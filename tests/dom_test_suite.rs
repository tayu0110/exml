#![allow(unused)]
#![allow(unused_variables)]
#![allow(unreachable_code)]
#[cfg(test)]
mod dom_test_suite {
    use exml::dom::{
        attlistdecl::*, character_data::*, document::*, document_type::*, elementdecl::*,
        entity::*, node::*, *,
    };

    mod level1 {
        use super::*;

        mod core {
            use exml::dom::{
                named_node_map::NamedNodeMap, node_list::NodeList, notation::NotationIdentifier,
            };

            use super::*;

            const STAFF_XML: &str = "resources/DOM-Test-Suite/tests/level1/core/files/staff.xml";
            const HC_STAFF_XML: &str =
                "resources/DOM-Test-Suite/tests/level1/core/files/hc_staff.xml";
            const HC_NODTDSTAFF_XML: &str =
                "resources/DOM-Test-Suite/tests/level1/core/files/hc_nodtdstaff.xml";

            #[rustfmt::skip]
            fn staff_xml(_doc: &str) -> Result<DocumentRef, DOMException> {
                let doctype = DocumentTypeRef::new("staff", None, Some("staff.dtd")).unwrap();
                let mut doc = DocumentRef::new(None, Some("staff"), Some(doctype)).unwrap();

                let mut doctype = doc.doctype().unwrap();
                // Internal Subset
                let mut ent = doctype.create_entity("ent1", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("es").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent2", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("1900 Dallas Road").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent3", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("Texas").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent4", EntityType::InternalGeneralEntity).unwrap();
                let mut ent_element = doc.create_element("entElement").unwrap();
                ent_element.set_attribute("domestic", "Yes").unwrap();
                ent_element.append_child(doc.create_text_node("Element data").into()).unwrap();
                ent.append_child(ent_element.into()).unwrap();
                ent.append_child(doc.create_processing_instruction("PItarget", Some("PIdata")).unwrap().into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent5", EntityType::ExternalGeneralUnparsedEntity).unwrap();
                ent.set_public_id(Some("entityURI"));
                ent.set_system_id(Some("entityFile"));
                ent.set_notation_name(Some("notation1"));
                doctype.add_entity::<false>(ent).unwrap();
                assert!(doctype.add_entity::<false>(doctype.create_entity("ent1", EntityType::InternalGeneralEntity).unwrap()).is_err());
                doctype.add_notation::<false>(doctype.create_notation("notation1",NotationIdentifier::PublicID { public_id: "notation1File".into() }).unwrap()).unwrap();
                doctype.add_notation::<false>(doctype.create_notation("notation2",NotationIdentifier::ExternalID { public_id: None, system_id: "notation2File".into() }).unwrap(),).unwrap();
                // External Subset
                doctype.add_element_decl::<true>(doctype.create_element_decl("employeeId",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("name",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("position",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("salary",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("address",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("entElement",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                let mut or = ElementContent::new_or(ElementContentOccur::Mult);
                or.set_first_child(Some(ElementContent::new_pcdata(ElementContentOccur::Once)));
                or.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"entElement")));
                doctype.add_element_decl::<true>(doctype.create_element_decl("gender", ContentSpec::Mixed(or)).unwrap()).unwrap();
                let mut seq1 = ElementContent::new_seq(ElementContentOccur::Once);
                seq1.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"employeeId")));
                let mut seq2 = ElementContent::new_seq(ElementContentOccur::Once);
                seq2.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"name")));
                let mut seq3 = ElementContent::new_seq(ElementContentOccur::Once);
                seq3.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"position")));
                let mut seq4 = ElementContent::new_seq(ElementContentOccur::Once);
                seq4.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"salary")));
                let mut seq5 = ElementContent::new_seq(ElementContentOccur::Once);
                seq5.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"gender")));
                seq5.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"address")));
                seq4.set_second_child(Some(seq5));
                seq3.set_second_child(Some(seq4));
                seq2.set_second_child(Some(seq3));
                seq1.set_second_child(Some(seq2));
                doctype.add_element_decl::<true>(doctype.create_element_decl("employee", ContentSpec::Children(seq1)).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("staff",ContentSpec::Children(ElementContent::new_element(ElementContentOccur::Plus,"employee"))).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("entElement","attr1",AttType::CDATA,DefaultDecl::None("Attr".into())).unwrap(),).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("address","domestic",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("address","street",AttType::CDATA,DefaultDecl::None("Yes".into())).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("entElement","domestic",AttType::CDATA,DefaultDecl::None("MALE".into())).unwrap()).unwrap();

                doc.insert_before(doc.create_processing_instruction("TEST-STYLE", Some("PIDATA")).unwrap().into(),Some(doctype.into())).unwrap();

                let mut root = doc.document_element().unwrap();
                assert!(root.parent_node().is_some());
                let comment = doc.create_comment(" This is comment number 1.").into();
                doc.insert_before(comment, Some(root.clone().into())).unwrap();

                let mut employee = root.append_child(doc.create_element("employee").unwrap().into()).unwrap();
                let mut employee_id = employee.append_child(doc.create_element("employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0001").into()).unwrap();
                let mut name = employee.append_child(doc.create_element("name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Margaret Martin").into()).unwrap();
                let mut position = employee.append_child(doc.create_element("position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Accountant").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element("salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("56,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element("gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("Female").into()).unwrap();
                let mut address = employee.append_child(doc.create_element("address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("1230 North Ave. Dallas, Texas 98551").into())?;
                address.set_attribute("domestic", "Yes").unwrap();

                let mut employee = root.append_child(doc.create_element("employee").unwrap().into()).unwrap();
                let mut employee_id = employee.append_child(doc.create_element("employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0002").into()).unwrap();
                let mut name = employee.append_child(doc.create_element("name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Martha Raynolds").into()).unwrap();
                name.append_child(doc.create_cdata_section("This is a CDATASection with EntityReference number 2 &ent2;").unwrap().into())?;
                name.append_child(doc.create_text_node("\n").into()).unwrap();
                name.append_child(doc.create_cdata_section("This is an adjacent CDATASection with a reference to a tab &tab;").unwrap().into())?;
                let mut position = employee.append_child(doc.create_element("position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Secretary").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element("salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("35,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element("gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("Female").into()).unwrap();
                let mut address = employee.append_child(doc.create_element("address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_entity_reference("ent2").unwrap().into()).unwrap();
                address.append_child(doc.create_text_node(" Dallas, ").into()).unwrap();
                address.append_child(doc.create_entity_reference("ent3").unwrap().into()).unwrap();
                address.append_child(doc.create_text_node("\n 98554").into()).unwrap();
                address.set_attribute("domestic", "Yes").unwrap();
                address.set_attribute("street", "Yes").unwrap();

                let mut employee = root.append_child(doc.create_element("employee").unwrap().into()).unwrap();
                let mut employee_id = employee.append_child(doc.create_element("employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0003").into()).unwrap();
                let mut name = employee.append_child(doc.create_element("name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Roger\n Jones").into()).unwrap();
                let mut position = employee.append_child(doc.create_element("position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Department Manager").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element("salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("100,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element("gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_entity_reference("ent4").unwrap().into()).unwrap();
                let mut address = employee.append_child(doc.create_element("address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("PO Box 27 Irving, texas 98553").into()).unwrap();
                address.set_attribute("domestic", "Yes").unwrap();
                address.set_attribute("street", "No").unwrap();

                let mut employee = root.append_child(doc.create_element("employee").unwrap().into()).unwrap();
                let mut employee_id = employee.append_child(doc.create_element("employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0004").into()).unwrap();
                let mut name = employee.append_child(doc.create_element("name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Jeny Oconnor").into()).unwrap();
                let mut position = employee.append_child(doc.create_element("position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Personnel Director").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element("salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("95,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element("gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("Female").into()).unwrap();
                let mut address = employee.append_child(doc.create_element("address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("PO Box 27 Irving, texas 98553").into()).unwrap();
                address.set_attribute("domestic", "Yes")?;
                address.set_attribute("street", "Y")?;
                let mut street = address.get_attribute_node("street").unwrap();
                street.append_child(doc.create_entity_reference("ent1").unwrap().into()).unwrap();

                let mut employee = root.append_child(doc.create_element("employee").unwrap().into()).unwrap();
                let mut employee_id = employee.append_child(doc.create_element("employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0005").into()).unwrap();
                let mut name = employee.append_child(doc.create_element("name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Robert Myers").into()).unwrap();
                let mut position = employee.append_child(doc.create_element("position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Computer Specialist").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element("salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("90,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element("gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("male").into()).unwrap();
                let mut address = employee.append_child(doc.create_element("address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("1821 Nordic. Road, Irving Texas 98558").into())?;
                address.set_attribute("street", "Yes").unwrap();

                doc.enable_read_only_check();
                Ok(doc)
                // Ok(load_xml::<false>(doc))
            }
            #[rustfmt::skip]
            fn hc_staff_xml(_doc: &str) -> Result<DocumentRef, DOMException> {
                let doctype = DocumentTypeRef::new("html",Some("-//W3C//DTD HTML 4.01//EN"),Some("http://www.w3.org/TR/html4/strict.dtd")).unwrap();
                let mut doc = DocumentRef::new(None, Some("html"), Some(doctype)).unwrap();
                let mut doctype = doc.doctype().unwrap();

                let mut ent = doctype.create_entity("alpha", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B1}").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("beta", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B2}").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("gamma", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B3}").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("delta", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B4}").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("epsilon", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B5}").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("alpha", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B6}").into()).unwrap();
                assert!(doctype.add_entity::<false>(ent).is_err());
                doctype.add_notation::<false>(doctype.create_notation("notation1",NotationIdentifier::PublicID { public_id: "notation1File".into() }).unwrap()).unwrap();
                doctype.add_notation::<false>(doctype.create_notation("notation2",NotationIdentifier::ExternalID { public_id: None, system_id: "notation2File".into() }).unwrap()).unwrap();

                // TODO: add external subset
                let mut seq = ElementContent::new_seq(ElementContentOccur::Once);
                seq.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"head")));
                seq.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"body")));
                doctype.add_element_decl::<true>(doctype.create_element_decl("html", ContentSpec::Children(seq)).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("html","xmlns",AttType::CDATA,DefaultDecl::Implied,).unwrap()).unwrap();
                let mut seq = ElementContent::new_seq(ElementContentOccur::Once);
                seq.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"meta")));
                let seq2 = ElementContent::new_seq(ElementContentOccur::Once);
                seq.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"title")));
                seq.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Mult,"script")));
                seq.set_second_child(Some(seq2));
                doctype.add_element_decl::<true>(doctype.create_element_decl("head", ContentSpec::Children(seq)).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("meta", ContentSpec::Empty).unwrap()).unwrap();
                doctype.create_attlist_decl("meta", "http-equiv", AttType::CDATA, DefaultDecl::Implied).unwrap();
                doctype.create_attlist_decl("meta", "content", AttType::CDATA, DefaultDecl::Implied).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("title",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("body",ContentSpec::Children(ElementContent::new_element(ElementContentOccur::Mult,"p"))).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("body","onload",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                let mut or = ElementContent::new_or(ElementContentOccur::Mult);
                or.set_first_child(Some(ElementContent::new_pcdata(ElementContentOccur::Once)));
                let mut or2 = ElementContent::new_or(ElementContentOccur::Once);
                or2.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"em")));
                let mut or3 = ElementContent::new_or(ElementContentOccur::Once);
                or3.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"strong")));
                let mut or4 = ElementContent::new_or(ElementContentOccur::Once);
                or4.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"code")));
                let mut or5 = ElementContent::new_or(ElementContentOccur::Once);
                or5.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"sup")));
                let mut or6 = ElementContent::new_or(ElementContentOccur::Once);
                or6.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"var")));
                let mut or7 = ElementContent::new_or(ElementContentOccur::Once);
                or7.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"acronym")));
                or7.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"abbr")));
                or6.set_second_child(Some(or7));
                or5.set_second_child(Some(or6));
                or4.set_second_child(Some(or5));
                or3.set_second_child(Some(or4));
                or2.set_second_child(Some(or3));
                or.set_second_child(Some(or2));
                doctype.add_element_decl::<true>(doctype.create_element_decl("p", ContentSpec::Mixed(or)).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("p","xmlns:dmstc",AttType::CDATA,DefaultDecl::Implied,).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("p","xmlns:nm",AttType::CDATA,DefaultDecl::Implied,).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("p","xmlns:emp2",AttType::CDATA,DefaultDecl::Implied,).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("p", "id", AttType::ID, DefaultDecl::Implied).unwrap()).unwrap();

                doctype.add_element_decl::<true>(doctype.create_element_decl("em",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("span",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("strong",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("code",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("sup",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                let mut or = ElementContent::new_or(ElementContentOccur::Mult);
                or.set_first_child(Some(ElementContent::new_pcdata(ElementContentOccur::Once)));
                or.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"span")));
                doctype.add_element_decl::<true>(doctype.create_element_decl("var", ContentSpec::Mixed(or)).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("acronym",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("acronym","title",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("acronym","class",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("acronym", "id", AttType::ID, DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("abbr",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("abbr","title",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("abbr","class",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("abbr", "id", AttType::ID, DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("script",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("script","type",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("script","src",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("script","charset",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();

                doc.insert_before(doc.create_processing_instruction("TEST-STYLE", Some("PIDATA")).unwrap().into(),Some(doctype.into())).unwrap();

                let mut root = doc.document_element().unwrap();
                assert!(root.parent_node().is_some());
                let comment = doc.create_comment(" This is comment number 1.").into();
                doc.insert_before(comment, Some(root.clone().into())).unwrap();

                let mut head = root.append_child(doc.create_element("head").unwrap().into()).unwrap();
                let mut meta = head.append_child(doc.create_element("meta").unwrap().into()).unwrap().as_element().unwrap();
                meta.set_attribute("http-equiv", "Content-Type").unwrap();
                meta.set_attribute("content", "text/html; charset=UTF-8").unwrap();
                let mut title = head.append_child(doc.create_element("title").unwrap().into()).unwrap();
                title.append_child(doc.create_text_node("hc_staff").into()).unwrap();
                let mut script = head.append_child(doc.create_element("script").unwrap().into()).unwrap().as_element().unwrap();
                script.set_attribute("type", "text/javascript").unwrap();
                script.set_attribute("src", "svgunit.js").unwrap();
                let mut script = head.append_child(doc.create_element("script").unwrap().into()).unwrap().as_element().unwrap();
                script.set_attribute("charset", "UTF-8").unwrap();
                script.set_attribute("type", "text/javascript").unwrap();
                script.set_attribute("src", "svgtest.js").unwrap();
                let mut script = head.append_child(doc.create_element("script").unwrap().into()).unwrap().as_element().unwrap();
                script.set_attribute("type", "text/javascript").unwrap();
                script.append_child(doc.create_text_node("function loadComplete() { startTest(); }").into(),).unwrap();

                let mut body = root.append_child(doc.create_element("body").unwrap().into()).unwrap().as_element().unwrap();
                body.set_attribute("onload", "parent.loadComplete()").unwrap();

                let mut p = body.append_child(doc.create_element("p").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut em = p.append_child(doc.create_element("em").unwrap().into()).unwrap();
                em.append_child(doc.create_text_node("EMP0001").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p.append_child(doc.create_element("strong").unwrap().into()).unwrap();
                strong.append_child(doc.create_text_node("Margaret Martin").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p.append_child(doc.create_element("code").unwrap().into()).unwrap();
                code.append_child(doc.create_text_node("Accountant").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p.append_child(doc.create_element("sup").unwrap().into()).unwrap();
                sup.append_child(doc.create_text_node("56,000").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p.append_child(doc.create_element("var").unwrap().into()).unwrap();
                var.append_child(doc.create_text_node("Female").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p.append_child(doc.create_element("acronym").unwrap().into()).unwrap().as_element().unwrap();
                acronym.append_child(doc.create_text_node("1230 North Ave. Dallas, Texas 98551").into())?;
                acronym.set_attribute("title", "Yes").unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();

                let mut p = body.append_child(doc.create_element("p").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut em = p.append_child(doc.create_element("em").unwrap().into()).unwrap();
                em.append_child(doc.create_text_node("EMP0002").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p.append_child(doc.create_element("strong").unwrap().into()).unwrap();
                strong.append_child(doc.create_text_node("Martha RaynoldsThis is a CDATASection with EntityReference number 2 &ent2;\nThis is an adjacent CDATASection with a reference to a tab &tab;").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p.append_child(doc.create_element("code").unwrap().into()).unwrap();
                code.append_child(doc.create_text_node("Secretary").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p.append_child(doc.create_element("sup").unwrap().into()).unwrap();
                sup.append_child(doc.create_text_node("35,000").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p.append_child(doc.create_element("var").unwrap().into()).unwrap();
                var.append_child(doc.create_text_node("Female").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p.append_child(doc.create_element("acronym").unwrap().into()).unwrap().as_element().unwrap();
                acronym.append_child(doc.create_entity_reference("beta").unwrap().into()).unwrap();
                acronym.append_child(doc.create_text_node(" Dallas, ").into()).unwrap();
                acronym.append_child(doc.create_entity_reference("gamma").unwrap().into()).unwrap();
                acronym.append_child(doc.create_text_node("\n 98554").into()).unwrap();
                acronym.set_attribute("title", "Yes").unwrap();
                acronym.set_attribute("class", "Yes").unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();

                let mut p = body.append_child(doc.create_element("p").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut em = p.append_child(doc.create_element("em").unwrap().into()).unwrap();
                em.append_child(doc.create_text_node("EMP0003").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p.append_child(doc.create_element("strong").unwrap().into()).unwrap();
                strong.append_child(doc.create_text_node("Roger\n Jones").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p.append_child(doc.create_element("code").unwrap().into()).unwrap();
                code.append_child(doc.create_text_node("Department Manager").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p.append_child(doc.create_element("sup").unwrap().into()).unwrap();
                sup.append_child(doc.create_text_node("100,000").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p.append_child(doc.create_element("var").unwrap().into()).unwrap();
                var.append_child(doc.create_entity_reference("delta").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p.append_child(doc.create_element("acronym").unwrap().into()).unwrap().as_element().unwrap();
                acronym.append_child(doc.create_text_node("PO Box 27 Irving, texas 98553").into()).unwrap();
                acronym.set_attribute("title", "Yes").unwrap();
                acronym.set_attribute("class", "No").unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();

                let mut p = body.append_child(doc.create_element("p").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut em = p.append_child(doc.create_element("em").unwrap().into()).unwrap();
                em.append_child(doc.create_text_node("EMP0004").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p.append_child(doc.create_element("strong").unwrap().into()).unwrap();
                strong.append_child(doc.create_text_node("Jeny Oconnor").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p.append_child(doc.create_element("code").unwrap().into()).unwrap();
                code.append_child(doc.create_text_node("Personnel Director").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p.append_child(doc.create_element("sup").unwrap().into()).unwrap();
                sup.append_child(doc.create_text_node("95,000").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p.append_child(doc.create_element("var").unwrap().into()).unwrap();
                var.append_child(doc.create_text_node("Female").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p.append_child(doc.create_element("acronym").unwrap().into()).unwrap().as_element().unwrap();
                acronym.append_child(doc.create_text_node("PO Box 27 Irving, texas 98553").into()).unwrap();
                acronym.set_attribute("title", "Yes")?;
                acronym.set_attribute("class", "Y")?;
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut class = acronym.get_attribute_node("class").unwrap();
                class.append_child(doc.create_entity_reference("alpha").unwrap().into()).unwrap();

                let mut p = body.append_child(doc.create_element("p").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut em = p.append_child(doc.create_element("em").unwrap().into()).unwrap();
                em.append_child(doc.create_text_node("EMP0005").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p.append_child(doc.create_element("strong").unwrap().into()).unwrap();
                strong.append_child(doc.create_text_node("Robert Myers").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p.append_child(doc.create_element("code").unwrap().into()).unwrap();
                code.append_child(doc.create_text_node("Computer Specialist").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p.append_child(doc.create_element("sup").unwrap().into()).unwrap();
                sup.append_child(doc.create_text_node("90,000").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p.append_child(doc.create_element("var").unwrap().into()).unwrap();
                var.append_child(doc.create_text_node("male").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p.append_child(doc.create_element("acronym").unwrap().into()).unwrap().as_element().unwrap();
                acronym.append_child(doc.create_text_node("1821 Nordic. Road, Irving Texas 98558").into(),)?;
                acronym.set_attribute("title", "Yes").unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();

                doc.enable_read_only_check();
                Ok(doc)
            }
            fn hc_nodtdstaff_xml(_doc: &str) -> Result<DocumentRef, DOMException> {
                let mut doc = DocumentRef::new(None, Some("html"), None).unwrap();
                let mut root = doc.document_element().unwrap();
                assert!(root.parent_node().is_some());

                let mut head = root
                    .append_child(doc.create_element("head").unwrap().into())
                    .unwrap();
                let mut meta = head
                    .append_child(doc.create_element("meta").unwrap().into())
                    .unwrap()
                    .as_element()
                    .unwrap();
                meta.set_attribute("http-equiv", "Content-Type").unwrap();
                meta.set_attribute("content", "text/html; charset=UTF-8")
                    .unwrap();
                let mut title = head
                    .append_child(doc.create_element("title").unwrap().into())
                    .unwrap();
                title
                    .append_child(doc.create_text_node("hc_nodtdstaff").into())
                    .unwrap();

                let mut body = root
                    .append_child(doc.create_element("body").unwrap().into())
                    .unwrap()
                    .as_element()
                    .unwrap();
                body.set_attribute("onload", "parent.loadComplete()")
                    .unwrap();

                let mut p = body
                    .append_child(doc.create_element("p").unwrap().into())
                    .unwrap();
                let mut em = p
                    .append_child(doc.create_element("em").unwrap().into())
                    .unwrap();
                em.append_child(doc.create_text_node("EMP0001").into())
                    .unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p
                    .append_child(doc.create_element("strong").unwrap().into())
                    .unwrap();
                strong
                    .append_child(doc.create_text_node("Margaret Martin").into())
                    .unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p
                    .append_child(doc.create_element("code").unwrap().into())
                    .unwrap();
                code.append_child(doc.create_text_node("Accountant").into())
                    .unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p
                    .append_child(doc.create_element("sup").unwrap().into())
                    .unwrap();
                sup.append_child(doc.create_text_node("56,000").into())
                    .unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p
                    .append_child(doc.create_element("var").unwrap().into())
                    .unwrap();
                var.append_child(doc.create_text_node("Female").into())
                    .unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p
                    .append_child(doc.create_element("acronym").unwrap().into())
                    .unwrap()
                    .as_element()
                    .unwrap();
                acronym.append_child(
                    doc.create_text_node("1230 North Ave. Dallas, Texas 98551")
                        .into(),
                )?;
                acronym.set_attribute("title", "Yes").unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();

                doc.enable_read_only_check();
                Ok(doc)
            }
            // hc_elementretrieveattrvalue.xml
            #[test]
            fn test_hc_elementretrieveattrvalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                let r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testAddress"/>
                let r#attr_value = r#test_address.get_attribute("class"); // <getAttribute obj="testAddress" var="attrValue" name="&quot;class&quot;"/>
                assert_eq!(r#attr_value, "No"); // <assertEquals actual="attrValue" expected="&quot;No&quot;" id="attrValue" ignoreCase="false"/>
            }
            // hc_nodevalue07.xml
            #[test]
            fn test_hc_nodevalue07() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // let mut r#new_value; // type: DOMString // <var name="newValue" type="DOMString"/>
                // let mut r#node_map; // type: NamedNodeMap // <var name="nodeMap" type="NamedNodeMap"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>

                // // unimplemented:
                // // <if><not><contentType type="text/html"/></not>
                // //      <assertNotNull actual="docType" id="docTypeNotNull"/>
                // //      <entities obj="docType" var="nodeMap"/>
                // //      <assertNotNull actual="nodeMap" id="entitiesNotNull"/>
                // //      <getNamedItem obj="nodeMap" name="&quot;alpha&quot;" var="newNode"/>
                // //      <assertNotNull actual="newNode" id="entityNotNull"/>
                // //      <nodeValue obj="newNode" var="newValue"/>
                // //      <assertNull actual="newValue" id="initiallyNull"/>
                // //      <!--   attempt to change the value and make sure that it stays null  -->
                // //      <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                // //      <nodeValue obj="newNode" var="newValue"/>
                // //      <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
                // // </if>
            }
            // hc_attrinsertbefore1.xml
            #[test]
            fn test_hc_attrinsertbefore1() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                let r#text_node = r#doc.create_text_node("terday"); // <createTextNode var="textNode" obj="doc" data="&quot;terday&quot;"/>
                let r#retval = r#title_attr.insert_before(text_node.into(), None).unwrap(); // <insertBefore var="retval" obj="titleAttr" newChild="textNode" refChild="refChild"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrNodeValue" ignoreCase="false"/>
                r#value = r#retval.node_value().unwrap().to_string(); // <nodeValue obj="retval" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="retvalValue" ignoreCase="false"/>
                let r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                r#value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="firstChildValue" ignoreCase="false"/>
                let r#last_child = r#title_attr.last_child().unwrap(); // <lastChild var="lastChild" obj="titleAttr" interface="Node"/>
                r#value = r#last_child.node_value().unwrap().to_string(); // <nodeValue obj="lastChild" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="lastChildValue" ignoreCase="false"/>
            }
            // hc_nodegetownerdocument.xml
            #[test]
            fn test_hc_nodegetownerdocument() {
                let mut r#element_name; // type: DOMString // <var name="elementName" type="DOMString"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#doc_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="docNode"/>
                let r#owner_document: DocumentRef = r#doc_node.owner_document().unwrap(); // <ownerDocument obj="docNode" var="ownerDocument"/>
                let r#doc_element = r#owner_document.document_element().unwrap(); // <documentElement obj="ownerDocument" var="docElement"/>
                r#element_name = r#doc_element.node_name().to_string(); // <nodeName obj="docElement" var="elementName"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //      <assertEquals actual="elementName" expected="&quot;svg&quot;" id="svgNodeName" ignoreCase="false"/>
                // <else>
                //      <assertEquals actual="elementName" expected="&quot;html&quot;" id="ownerDocElemTagName" ignoreCase="auto"/>
                // </else>
                // </if>
            }
            // nodeentitysetnodevalue.xml
            #[test]
            fn test_nodeentitysetnodevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                let mut r#entity_node; // type: Node // <var name="entityNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                entities = doc_type.entities(); // <entities obj="docType" var="entities"/>
                // unimplemented: // <assertNotNull actual="entities" id="entitiesNotNull"/>
                r#entity_node = r#entities.get_named_item("ent1").unwrap(); // <getNamedItem obj="entities" name="&quot;ent1&quot;" var="entityNode"/>
                // unimplemented: // <assertNotNull actual="entityNode" id="ent1NotNull"/>
                r#entity_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="entityNode" value="&quot;This should have no effect&quot;"/>
                let r#entity_value = r#entity_node.node_value(); // <nodeValue obj="entityNode" var="entityValue"/>
                assert!(entity_value.is_none()); // <assertNull actual="entityValue" id="nodeValueNull"/>
            }
            // hc_nodedocumentfragmentnodevalue.xml
            #[test]
            fn test_hc_nodedocumentfragmentnodevalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="docFragment"/>
                let r#attr_list = r#doc_fragment.attributes(); // <attributes obj="docFragment" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="attributesNull"/>
                let r#value = r#doc_fragment.node_value(); // <nodeValue obj="docFragment" var="value"/>
                assert!(value.is_none()); // <assertNull actual="value" id="initiallyNull"/>
            }
            // documentcreateattribute.xml
            #[test]
            fn test_documentcreateattribute() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#new_attr_node = r#doc.create_attribute("district".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttrNode" name="&quot;district&quot;"/>
                let r#attr_value = r#new_attr_node.node_value().unwrap().to_string(); // <nodeValue obj="newAttrNode" var="attrValue"/>
                assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" ignoreCase="false" id="value"/>
                let r#attr_name = r#new_attr_node.node_name().to_string(); // <nodeName obj="newAttrNode" var="attrName"/>
                assert_eq!(r#attr_name, "district"); // <assertEquals actual="attrName" expected="&quot;district&quot;" ignoreCase="false" id="name"/>
                let r#attr_type = r#new_attr_node.node_type(); // <nodeType obj="newAttrNode" var="attrType"/>
                assert_eq!(r#attr_type as i32, 2); // <assertEquals actual="attrType" expected="2" ignoreCase="false" id="type"/>
            }
            // hc_nodedocumentnodeattribute.xml
            #[test]
            fn test_hc_nodedocumentnodeattribute() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#attr_list = r#doc.attributes(); // <attributes obj="doc" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="doc_attributes_is_null"/>
            }
            // nodedocumentnodename.xml
            #[test]
            fn test_nodedocumentnodename() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#document_name = r#doc.node_name().to_string(); // <nodeName obj="doc" var="documentName"/>
                assert_eq!(r#document_name, "#document"); // <assertEquals actual="documentName" expected="&quot;#document&quot;" id="documentNodeName" ignoreCase="false"/>
            }
            // hc_elementwrongdocumenterr.xml
            #[test]
            fn test_hc_elementwrongdocumenterr() {
                let r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#address_element_list; // type: NodeList // <var name="addressElementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                r#doc1 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc1" href="hc_staff" willBeModified="true"/>
                r#doc2 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc2" href="hc_staff" willBeModified="false"/>
                r#new_attribute = r#doc2.create_attribute("newAttribute".to_string()).unwrap(); // <createAttribute obj="doc2" var="newAttribute" name="&quot;newAttribute&quot;"/>
                r#address_element_list = r#doc1.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc1" tagname="&quot;acronym&quot;" var="addressElementList"/>
                r#test_address = r#address_element_list.item(4).unwrap(); // <item interface="NodeList" obj="addressElementList" index="4" var="testAddress"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //      <WRONG_DOCUMENT_ERR>
                //          <setAttributeNode obj="testAddress" newAttr="newAttribute" var="attrAddress"/>
                //      </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                let r#attr_address = test_address.set_attribute_node(new_attribute);
                assert!(attr_address.is_err_and(|err| err == DOMException::WrongDocumentErr));
            }
            // elementgettagname.xml
            #[test]
            fn test_elementgettagname() {
                let mut r#tagname; // type: DOMString // <var name="tagname" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#root = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="root"/>
                r#tagname = r#root.tag_name().to_string(); // <tagName obj="root" var="tagname"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //      <assertEquals actual="tagname" expected="&quot;svg&quot;" id="svgTagName" ignoreCase="false"/>
                // <else>
                //      <assertEquals actual="tagname" expected="&quot;staff&quot;" id="elementGetTagNameAssert" ignoreCase="false"/>
                // </else>
                // </if>
            }
            // namednodemapsetnameditemwithnewvalue.xml
            #[test]
            fn test_namednodemapsetnameditemwithnewvalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                r#new_attribute = r#doc.create_attribute("district".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;district&quot;"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                let r#new_node = r#attributes.set_named_item(r#new_attribute).unwrap(); // <setNamedItem interface="NamedNodeMap" obj="attributes" var="newNode" arg="newAttribute"/>
                assert!(new_node.is_none()); // <assertNull actual="newNode" id="returnedNodeNull"/>
            }
            // hc_attrinsertbefore4.xml
            #[test]
            fn test_hc_attrinsertbefore4() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let r#ter_node; // type: Text // <var name="terNode" type="Text"/>
                let r#day_node; // type: Text // <var name="dayNode" type="Text"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                let r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                let r#last_child; // type: Node // <var name="lastChild" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#ter_node = r#doc.create_text_node("ter"); // <createTextNode var="terNode" obj="doc" data="&quot;ter&quot;"/>
                r#day_node = r#doc.create_text_node("day"); // <createTextNode var="dayNode" obj="doc" data="&quot;day&quot;"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#retval = r#doc_frag.append_child(ter_node.into()).unwrap(); // <appendChild var="retval" obj="docFrag" newChild="terNode"/>
                r#retval = r#doc_frag.append_child(day_node.into()).unwrap(); // <appendChild var="retval" obj="docFrag" newChild="dayNode"/>
                let r#ref_child = r#title_attr.first_child().unwrap(); // <firstChild var="refChild" obj="titleAttr" interface="Node"/>
                r#retval = r#title_attr
                    .insert_before(doc_frag.into(), ref_child.into())
                    .unwrap(); // <insertBefore var="retval" obj="titleAttr" newChild="docFrag" refChild="refChild"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "terdayYes"); // <assertEquals actual="value" expected="&quot;terdayYes&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "terdayYes"); // <assertEquals actual="value" expected="&quot;terdayYes&quot;" id="attrNodeValue" ignoreCase="false"/>
                let r#value = r#retval.node_value(); // <nodeValue obj="retval" var="value"/>
                assert!(value.is_none()); // <assertNull actual="value" id="retvalValue"/>
                r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                let r#value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="value"/>
                assert_eq!(r#value, "ter"); // <assertEquals actual="value" expected="&quot;ter&quot;" id="firstChildValue" ignoreCase="false"/>
                r#last_child = r#title_attr.last_child().unwrap(); // <lastChild var="lastChild" obj="titleAttr" interface="Node"/>
                let r#value = r#last_child.node_value().unwrap().to_string(); // <nodeValue obj="lastChild" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="lastChildValue" ignoreCase="false"/>
            }
            // hc_namednodemapwrongdocumenterr.xml
            #[test]
            fn test_hc_namednodemapwrongdocumenterr() {
                let r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc1 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc1" href="hc_staff" willBeModified="true"/>
                r#doc2 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc2" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc1.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc1" var="elementList" tagname="&quot;acronym&quot;"/>
                r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                let r#new_attribute = r#doc2.create_attribute("newAttribute".to_string()).unwrap(); // <createAttribute obj="doc2" var="newAttribute" name="&quot;newAttribute&quot;"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //      <WRONG_DOCUMENT_ERR>
                //          <setNamedItem var="setNode" obj="attributes" arg="newAttribute"/>
                //      </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                let r#set_node = attributes.set_named_item(new_attribute);
                assert!(set_node.is_err_and(|err| err == DOMException::WrongDocumentErr));
            }
            // characterdatareplacedatanomodificationallowederr.xml
            #[test]
            fn test_characterdatareplacedatanomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let r#ent_element; // type: Node // <var name="entElement" type="Node"/>
                let r#ent_element_content; // type: Node // <var name="entElementContent" type="Node"/>
                let mut r#ent_reference; // type: Node // <var name="entReference" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" index="2" var="genderNode"/>
                r#ent_reference = r#gender_node.first_child().unwrap(); // <firstChild interface="Node" var="entReference" obj="genderNode"/>
                // unimplemented: // <assertNotNull actual="entReference" id="entReferenceNotNull"/>
                let r#node_type = r#ent_reference.node_type(); // <nodeType var="nodeType" obj="entReference"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //      <createEntityReference var="entReference" obj="doc" name="&quot;ent4&quot;"/>
                //      <assertNotNull actual="entReference" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    ent_reference = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#ent_element = r#ent_reference.first_child().unwrap(); // <firstChild var="entElement" obj="entReference" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#ent_element_content = r#ent_element.first_child().unwrap(); // <firstChild var="entElementContent" obj="entElement" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElementContent" id="entElementContentNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //      <NO_MODIFICATION_ALLOWED_ERR>
                //          <replaceData obj="entElementContent" offset="1" count="3" arg="&quot;newArg&quot;"/>
                //      </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element_content
                        .as_text_node()
                        .unwrap()
                        .replace_data(1, 3, "newArg")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // elementinuseattributeerr.xml
            #[test]
            fn test_elementinuseattributeerr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#address_element_list; // type: NodeList // <var name="addressElementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                let mut r#new_element; // type: Element // <var name="newElement" type="Element"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#set_attr1; // type: Attr // <var name="setAttr1" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#address_element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="addressElementList"/>
                r#test_address = r#address_element_list.item(1).unwrap(); // <item interface="NodeList" obj="addressElementList" index="1" var="testAddress"/>
                r#new_element = r#doc.create_element("newElement".to_string()).unwrap(); // <createElement obj="doc" var="newElement" tagName="&quot;newElement&quot;"/>
                r#appended_child = r#test_address
                    .append_child(new_element.clone().into())
                    .unwrap(); // <appendChild var="appendedChild" obj="testAddress" newChild="newElement"/>
                r#new_attribute = r#doc.create_attribute("newAttribute".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;newAttribute&quot;"/>
                r#set_attr1 = r#new_element
                    .set_attribute_node(r#new_attribute.clone())
                    .unwrap(); // <setAttributeNode var="setAttr1" obj="newElement" newAttr="newAttribute"/>
                // <assertDOMException id="throw_INUSE_ATTRIBUTE_ERR">
                //      <INUSE_ATTRIBUTE_ERR>
                //          <setAttributeNode var="setAttr2" obj="testAddress" newAttr="newAttribute"/>
                //      </INUSE_ATTRIBUTE_ERR>
                // </assertDOMException>
                assert!(
                    test_address
                        .set_attribute_node(new_attribute)
                        .is_err_and(|err| { err == DOMException::InuseAttributeErr })
                );
            }
            // nodeelementnodename.xml
            #[test]
            fn test_nodeelementnodename() {
                let mut r#element_name; // type: DOMString // <var name="elementName" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="elementNode"/>
                r#element_name = r#element_node.node_name().to_string(); // <nodeName obj="elementNode" var="elementName"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //      <assertEquals actual="elementName" expected="&quot;svg&quot;" id="svgNodeName" ignoreCase="false"/>
                // <else>
                //      <assertEquals actual="elementName" expected="&quot;staff&quot;" id="nodeElementNodeNameAssert1" ignoreCase="false"/>
                // </else>
                // </if>
            }
            // hc_nodedocumentnodename.xml
            #[test]
            fn test_hc_nodedocumentnodename() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#document_name = r#doc.node_name().to_string(); // <nodeName obj="doc" var="documentName"/>
                assert_eq!(r#document_name, "#document"); // <assertEquals actual="documentName" expected="&quot;#document&quot;" id="documentNodeName" ignoreCase="false"/>
            }
            // nodedocumenttypenodevalue.xml
            #[test]
            fn test_nodedocumenttypenodevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#attr_list = r#doc_type.attributes(); // <attributes obj="docType" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="doctypeAttributesNull"/>
            }
            // hc_commentgetcomment.xml
            #[test]
            fn test_hc_commentgetcomment() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#child_value; // type: DOMString // <var name="childValue" type="DOMString"/>
                let mut r#comment_count = 0; // type: int // <var name="commentCount" type="int" value="0"/>
                let mut r#child_type; // type: int // <var name="childType" type="int"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#element_list = r#doc.child_nodes(); // <childNodes obj="doc" var="elementList"/>
                // <for-each collection="elementList" member="child">
                //      <nodeType obj="child" var="childType"/>
                //      <if><equals actual="childType" expected="8" ignoreCase="false"/>
                //          <nodeName obj="child" var="childName"/>
                //          <assertEquals actual="childName" expected="&quot;#comment&quot;" ignoreCase="false" id="nodeName"/>
                //          <nodeValue obj="child" var="childValue"/>
                //          <assertEquals actual="childValue" expected="&quot; This is comment number 1.&quot;" id="nodeValue" ignoreCase="false"/>
                //          <attributes var="attributes" obj="child"/>
                //          <assertNull actual="attributes" id="attributes"/>
                //          <increment var="commentCount" value="1"/>
                //      </if>
                // </for-each>
                let len = element_list.length();
                for i in 0..len {
                    child = element_list.item(i).unwrap();
                    child_type = child.node_type();
                    if child_type as i32 == 8 {
                        child_name = child.node_name();
                        assert_eq!(child_name.as_ref(), "#comment");
                        child_value = child.node_value().unwrap();
                        assert_eq!(child_value.as_ref(), " This is comment number 1.");
                        assert!(child.attributes().is_none());
                        comment_count += 1;
                    }
                }
                // <assertTrue id="atMostOneComment">
                //      <less actual="commentCount" expected="2"/>
                // </assertTrue>
                assert!(comment_count < 2);
            }
            // documenttypegetentitiestype.xml
            #[test]
            fn test_documenttypegetentitiestype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let r#entity_list; // type: NamedNodeMap // <var name="entityList" type="NamedNodeMap"/>
                let mut r#entity; // type: Node // <var name="entity" type="Node"/>
                let mut r#entity_type; // type: int // <var name="entityType" type="int"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                entity_list = doc_type.entities(); // <entities obj="docType" var="entityList"/>
                // unimplemented: // <assertNotNull actual="entityList" id="entitiesNotNull"/>
                // <for-each collection="entityList" member="entity">
                //  <nodeType obj="entity" var="entityType"/>
                //  <assertEquals actual="entityType" expected="6" id="documenttypeGetEntitiesTypeAssert" ignoreCase="false"/>
                // </for-each>
                for i in 0..entity_list.length() {
                    entity = entity_list.item(i).unwrap();
                    entity_type = entity.node_type();
                    assert_eq!(entity_type as i32, 6);
                }
            }
            // namednodemapsetnameditem.xml
            #[test]
            fn test_namednodemapsetnameditem() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let r#district_node; // type: Attr // <var name="districtNode" type="Attr"/>
                let mut r#set_node; // type: Node // <var name="setNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="1"/>
                r#new_attribute = r#doc.create_attribute("district".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;district&quot;"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                r#set_node = r#attributes.set_named_item(r#new_attribute).unwrap(); // <setNamedItem var="setNode" obj="attributes" arg="newAttribute"/>
                r#district_node = r#attributes.get_named_item("district").unwrap(); // <getNamedItem obj="attributes" var="districtNode" name="&quot;district&quot;"/>
                let r#attr_name = r#district_node.node_name().to_string(); // <nodeName obj="districtNode" var="attrName"/>
                assert_eq!(r#attr_name, "district"); // <assertEquals actual="attrName" expected="&quot;district&quot;" id="namednodemapSetNamedItemAssert" ignoreCase="false"/>
            }
            // nodereplacechildnodeancestor.xml
            #[test]
            fn test_nodereplacechildnodeancestor() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_child = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="newChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#old_child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="oldChild"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //      <HIERARCHY_REQUEST_ERR>
                //          <replaceChild var="replacedNode" obj="employeeNode" newChild="newChild" oldChild="oldChild"/>
                //      </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    employee_node
                        .replace_child(new_child.into(), old_child)
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // hc_nodereplacechildnewchildexists.xml
            #[test]
            fn test_hc_nodereplacechildnewchildexists() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node" isNull="true"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#actual = vec![]; // type: List // <var name="actual" type="List"/>
                let r#expected = vec!["strong", "code", "sup", "var", "em"]; // type: List // <var name="expected" type="List"><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"em"</member></var>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.get_elements_by_tag_name("*"); // <getElementsByTagName interface="Element" obj="employeeNode" var="childList" tagname="&quot;*&quot;"/>
                let r#new_child = r#child_list.item(0).unwrap(); // <item interface="NodeList" obj="childList" index="0" var="newChild"/>
                r#old_child = r#child_list.item(5).unwrap(); // <item interface="NodeList" obj="childList" index="5" var="oldChild"/>
                let r#replaced_child = r#employee_node
                    .replace_child(new_child.into(), old_child.clone().into())
                    .unwrap(); // <replaceChild var="replacedChild" obj="employeeNode" newChild="newChild" oldChild="oldChild"/>
                replaced_child.is_same_node(&old_child.into()); // <assertSame actual="replacedChild" expected="oldChild" id="return_value_same"/>
                // <for-each collection="childList" member="childNode">
                //      <nodeName var="childName" obj="childNode"/>
                //      <nodeType var="nodeType" obj="childNode"/>
                //      <if><equals actual="nodeType" expected="1"/>
                //          <append collection="actual" item="childName"/>
                //      <else>
                //          <assertEquals actual="nodeType" expected="3" id="textNodeType" ignoreCase="false"/>
                //          <assertEquals actual="childName" expected="&quot;#text&quot;" id="textNodeName" ignoreCase="false"/>
                //      </else>
                //      </if>
                // </for-each>
                for i in 0..child_list.length() {
                    let child_node = child_list.item(i).unwrap();
                    child_name = child_node.node_name();
                    node_type = child_node.node_type();
                    if node_type as i32 == 1 {
                        actual.push(child_name.to_string());
                    } else {
                        assert_eq!(node_type as i32, 3);
                        assert_eq!(child_name.as_ref(), "#text");
                    }
                }
                assert_eq!(actual.len(), expected.len());
                assert!(r#actual.into_iter().zip(expected).all(|(a, e)| a == e)); // <assertEquals actual="actual" expected="expected" id="childNames" ignoreCase="auto"/>
            }
            // characterdataindexsizeerrinsertdataoffsetnegative.xml
            #[test]
            fn test_characterdataindexsizeerrinsertdataoffsetnegative() {
                // unimplemented: // <implementationAttribute name="signed" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // unimplemented:
                // <assertDOMException id="throws_INDEX_SIZE_ERR">
                //      <INDEX_SIZE_ERR>
                //          <insertData obj="child" offset="-5" arg="&quot;ABC&quot;"/>
                //      </INDEX_SIZE_ERR>
                // </assertDOMException>
            }
            // hc_nodereplacechildnodeancestor.xml
            #[test]
            fn test_hc_nodereplacechildnodeancestor() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#new_child = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="newChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#old_child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="oldChild"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //      <HIERARCHY_REQUEST_ERR>
                //          <replaceChild var="replacedNode" obj="employeeNode" newChild="newChild" oldChild="oldChild"/>
                //      </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    employee_node
                        .replace_child(new_child.into(), old_child)
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // characterdataindexsizeerrdeletedataoffsetnegative.xml
            #[test]
            fn test_characterdataindexsizeerrdeletedataoffsetnegative() {
                // unimplemented: // <implementationAttribute name="signed" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                // unimplemented:
                // <assertDOMException id="throws_INDEX_SIZE_ERR">
                //      <INDEX_SIZE_ERR>
                //          <deleteData obj="child" offset="-5" count="3"/>
                //      </INDEX_SIZE_ERR>
                // </assertDOMException>
            }
            // hc_elementgetelementempty.xml
            #[test]
            fn test_hc_elementgetelementempty() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let mut r#domestic_attr; // type: Attr // <var name="domesticAttr" type="Attr"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#new_attribute = r#doc.create_attribute("lang".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;lang&quot;"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(3).unwrap(); // <item interface="NodeList" obj="elementList" index="3" var="testEmployee"/>
                r#domestic_attr = r#test_employee.set_attribute_node(r#new_attribute).unwrap(); // <setAttributeNode obj="testEmployee" var="domesticAttr" newAttr="newAttribute"/>
                let r#attr_value = r#test_employee.get_attribute("lang"); // <getAttribute obj="testEmployee" var="attrValue" name="&quot;lang&quot;"/>
                assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" id="elementGetElementEmptyAssert" ignoreCase="false"/>
            }
            // characterdatagetdata.xml
            #[test]
            fn test_characterdatagetdata() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                let r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Margaret Martin"); // <assertEquals actual="childData" expected="&quot;Margaret Martin&quot;" id="characterdataGetDataAssert" ignoreCase="false"/>
            }
            // characterdataindexsizeerrsubstringnegativeoffset.xml
            #[test]
            fn test_characterdataindexsizeerrsubstringnegativeoffset() {
                // unimplemented: // <implementationAttribute name="signed" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                // unimplemented:
                // <assertDOMException id="throws_INDEX_SIZE_ERR">
                //      <INDEX_SIZE_ERR>
                //          <substringData var="badString" obj="child" offset="-5" count="3"/>
                //      </INDEX_SIZE_ERR>
                // </assertDOMException>
            }
            // hc_nodeinsertbeforerefchildnull.xml
            #[test]
            fn test_hc_nodeinsertbeforerefchildnull() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#inserted_node; // type: Node // <var name="insertedNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#new_child = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="newChild"/>
                r#inserted_node = r#employee_node
                    .insert_before(new_child.into(), None)
                    .unwrap(); // <insertBefore var="insertedNode" obj="employeeNode" newChild="newChild" refChild="refChild"/>
                r#child = r#employee_node.last_child().unwrap(); // <lastChild interface="Node" obj="employeeNode" var="child"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                assert_eq!(r#child_name, "br"); // <assertEquals actual="childName" expected="&quot;br&quot;" id="nodeName" ignoreCase="auto"/>
            }
            // characterdataappenddatanomodificationallowederrEE.xml
            #[test]
            fn test_characterdataappenddatanomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let mut r#ent_text; // type: Node // <var name="entText" type="Node"/>
                let r#ent_reference; // type: EntityReference // <var name="entReference" type="EntityReference"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" index="2" var="genderNode"/>
                r#ent_reference = r#doc.create_entity_reference("ent3".to_string()).unwrap(); // <createEntityReference var="entReference" obj="doc" name="&quot;ent3&quot;"/>
                // unimplemented: // <assertNotNull actual="entReference" id="createdEntRefNotNull"/>
                r#appended_child = r#gender_node
                    .append_child(ent_reference.clone().into())
                    .unwrap(); // <appendChild obj="genderNode" newChild="entReference" var="appendedChild"/>
                r#ent_text = r#ent_reference
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild var="entText" obj="entReference" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entText" id="entTextNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //      <NO_MODIFICATION_ALLOWED_ERR>
                //          <appendData obj="entText" arg="&quot;newString&quot;"/>
                //      </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_text
                        .append_data("newString")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // entitygetpublicid.xml
            #[test]
            fn test_entitygetpublicid() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#entity_list = doc_type.entities(); // <entities obj="docType" var="entityList"/>
                // unimplemented: // <assertNotNull actual="entityList" id="entitiesNotNull"/>
                let r#entity_node = r#entity_list.get_named_item("ent5").unwrap(); // <getNamedItem obj="entityList" var="entityNode" name="&quot;ent5&quot;"/>
                let r#public_id = r#entity_node.public_id().unwrap().to_string(); // <publicId interface="Entity" obj="entityNode" var="publicId"/>
                assert_eq!(r#public_id, "entityURI"); // <assertEquals actual="publicId" expected="&quot;entityURI&quot;" id="publicId" ignoreCase="false"/>
                let r#system_id = r#entity_node.system_id().unwrap().to_string(); // <systemId interface="Entity" obj="entityNode" var="systemId"/>
                assert_eq!(system_id, "entityFile"); // <assertURIEquals actual="systemId" file="&quot;entityFile&quot;" id="systemId"/>
                let r#notation = r#entity_node.notation_name().unwrap().to_string(); // <notationName interface="Entity" obj="entityNode" var="notation"/>
                assert_eq!(r#notation, "notation1"); // <assertEquals actual="notation" expected="&quot;notation1&quot;" id="notation" ignoreCase="false"/>
            }
            // nodelistindexgetlengthofemptylist.xml
            #[test]
            fn test_nodelistindexgetlengthofemptylist() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#child_node = r#employee_list.item(1).unwrap().clone(); // <item interface="NodeList" obj="employeeList" var="childNode" index="1"/>
                let r#text_node = r#child_node.first_child().unwrap(); // <firstChild interface="Node" obj="childNode" var="textNode"/>
                let r#text_list = r#text_node.child_nodes(); // <childNodes obj="textNode" var="textList"/>
                assert_eq!(text_list.length(), 0); // <assertSize collection="textList" size="0" id="nodelistIndexGetLengthOfEmptyListAssert"/>
            }
            // nodedocumentfragmentnodevalue.xml
            #[test]
            fn test_nodedocumentfragmentnodevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="docFragment"/>
                let r#attr_list = r#doc_fragment.attributes(); // <attributes obj="docFragment" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="attributesNull"/>
                let r#value = r#doc_fragment.node_value(); // <nodeValue obj="docFragment" var="value"/>
                assert!(value.is_none()); // <assertNull actual="value" id="initiallyNull"/>
            }
            // hc_attrcreatetextnode2.xml
            #[test]
            fn test_hc_attrcreatetextnode2() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#address_list; // type: NodeList // <var name="addressList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#street_attr; // type: Attr // <var name="streetAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#address_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#address_list.item(3).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#street_attr = r#attributes.get_named_item("class").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;class&quot;"/>
                r#street_attr.set_node_value("Y&ent1;").unwrap(); // <nodeValue obj="streetAttr" value="&quot;Y&amp;ent1;&quot;"/>
                r#value = r#street_attr.value().to_string(); // <value interface="Attr" obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Y&ent1;"); // <assertEquals actual="value" expected="&quot;Y&amp;ent1;&quot;" id="value" ignoreCase="false"/>
                r#value = r#street_attr.node_value().unwrap().to_string(); // <nodeValue obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Y&ent1;"); // <assertEquals actual="value" expected="&quot;Y&amp;ent1;&quot;" id="nodeValue" ignoreCase="false"/>
            }
            // nodevalue03.xml
            #[test]
            fn test_nodevalue03() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_node = r#doc.create_entity_reference("ent1".to_string()).unwrap(); // <createEntityReference obj="doc" var="newNode" name="&quot;ent1&quot;"/>
                // unimplemented: // <assertNotNull actual="newNode" id="createdEntRefNotNull"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="initiallyNull"/>
                r#new_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
            }
            // nodereplacechildnewchilddiffdocument.xml
            #[test]
            fn test_nodereplacechildnewchilddiffdocument() {
                let r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc1 = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc1" href="staff" willBeModified="false"/>
                r#doc2 = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc2" href="staff" willBeModified="true"/>
                r#new_child = r#doc1.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc1" tagName="&quot;newChild&quot;" var="newChild"/>
                r#element_list = r#doc2.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc2" tagname="&quot;employee&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                r#old_child = r#element_node.first_child().unwrap(); // <firstChild obj="elementNode" var="oldChild" interface="Node"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //      <WRONG_DOCUMENT_ERR>
                //          <replaceChild var="replacedChild" obj="elementNode" newChild="newChild" oldChild="oldChild"/>
                //      </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .replace_child(new_child.into(), old_child)
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // hc_nodetextnodeattribute.xml
            #[test]
            fn test_hc_nodetextnodeattribute() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#text_node = r#test_addr.first_child().unwrap(); // <firstChild interface="Node" obj="testAddr" var="textNode"/>
                let r#attr_list = r#text_node.attributes(); // <attributes obj="textNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="text_attributes_is_null"/>
            }
            // nodeprocessinginstructionnodetype.xml
            #[test]
            fn test_nodeprocessinginstructionnodetype() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#test_list = r#doc.child_nodes(); // <childNodes obj="doc" var="testList"/>
                let r#pi_node = r#test_list
                    .item(0)
                    .unwrap()
                    .clone()
                    .as_processing_instruction()
                    .unwrap(); // <item interface="NodeList" obj="testList" var="piNode" index="0"/>
                let r#node_type = r#pi_node.node_type(); // <nodeType obj="piNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 7); // <assertEquals actual="nodeType" expected="7" id="nodeProcessingInstructionNodeTypeAssert1" ignoreCase="false"/>
            }
            // nodegetownerdocumentnull.xml
            #[test]
            fn test_nodegetownerdocumentnull() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#owner_document = r#doc.owner_document(); // <ownerDocument obj="doc" var="ownerDocument"/>
                assert!(owner_document.is_none()); // <assertNull actual="ownerDocument" id="documentOwnerDocumentNull"/>
            }
            // elementsetattributenodenomodificationallowederr.xml
            #[test]
            fn test_elementsetattributenodenomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender; // type: Node // <var name="gender" type="Node"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                let mut r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#ent_ref = r#gender.first_child().unwrap(); // <firstChild interface="Node" var="entRef" obj="gender"/>
                // unimplemented: // <assertNotNull actual="entRef" id="entRefNotNull"/>
                let r#node_type = r#ent_ref.node_type(); // <nodeType var="nodeType" obj="entRef"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //      <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                //      <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    ent_ref = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#ent_element = r#ent_ref.first_child().unwrap().as_element().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                let r#new_attr = r#doc.create_attribute("newAttr".to_string()).unwrap();
                // <createAttribute obj="doc" var="newAttr" name="&quot;newAttr&quot;"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //      <NO_MODIFICATION_ALLOWED_ERR>
                //          <setAttributeNode var="badAttr" obj="entElement" newAttr="newAttr"/>
                //      </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element
                        .set_attribute_node(new_attr)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodenotationnodevalue.xml
            #[test]
            fn test_nodenotationnodevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#notations = doc_type.notations(); // <notations obj="docType" var="notations"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                let r#notation_node = r#notations.get_named_item("notation1").unwrap(); // <getNamedItem obj="notations" name="&quot;notation1&quot;" var="notationNode"/>
                // unimplemented: // <assertNotNull actual="notationNode" id="notationNotNull"/>
                let r#notation_value = r#notation_node.node_value();
                // <nodeValue obj="notationNode" var="notationValue"/>
                assert!(notation_value.is_none()); // <assertNull actual="notationValue" id="nodeValue"/>
            }
            // textindexsizeerrnegativeoffset.xml
            #[test]
            fn test_textindexsizeerrnegativeoffset() {
                // unimplemented: // <implementationAttribute name="signed" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;name&quot;"/>
                r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                r#text_node = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="textNode"/>

                // unimplemented:
                // <assertDOMException id="throws_INDEX_SIZE_ERR">
                //      <INDEX_SIZE_ERR>
                //          <splitText obj="textNode" var="splitNode" offset="-69"/>
                //      </INDEX_SIZE_ERR>
                // </assertDOMException>
            }
            // documentcreatecomment.xml
            #[test]
            fn test_documentcreatecomment() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#new_comment_node = r#doc.create_comment("This is a new Comment node"); // <createComment obj="doc" var="newCommentNode" data="&quot;This is a new Comment node&quot;"/>
                let r#new_comment_value = r#new_comment_node.node_value().unwrap().to_string(); // <nodeValue obj="newCommentNode" var="newCommentValue"/>
                assert_eq!(r#new_comment_value, "This is a new Comment node"); // <assertEquals actual="newCommentValue" expected="&quot;This is a new Comment node&quot;" ignoreCase="false" id="value"/>
                let r#new_comment_name = r#new_comment_node.node_name().to_string(); // <nodeName obj="newCommentNode" var="newCommentName"/>
                assert_eq!(r#new_comment_name, "#comment"); // <assertEquals actual="newCommentName" expected="&quot;#comment&quot;" ignoreCase="false" id="name"/>
                let r#new_comment_type = r#new_comment_node.node_type(); // <nodeType obj="newCommentNode" var="newCommentType"/>
                assert_eq!(r#new_comment_type as i32, 8); // <assertEquals actual="newCommentType" expected="8" ignoreCase="false" id="type"/>
            }
            // characterdatainsertdatanomodificationallowederrEE.xml
            #[test]
            fn test_characterdatainsertdatanomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let mut r#ent_text; // type: CharacterData // <var name="entText" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" index="2" var="genderNode"/>
                let r#ent_reference = r#doc.create_entity_reference("ent3".to_string()).unwrap(); // <createEntityReference var="entReference" obj="doc" name="&quot;ent3&quot;"/>
                // unimplemented: // <assertNotNull actual="entReference" id="createdEntRefNotNull"/>
                r#ent_text = r#ent_reference
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild var="entText" obj="entReference" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entText" id="entTextNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //      <NO_MODIFICATION_ALLOWED_ERR>
                //          <insertData obj="entText" offset="1" arg="&quot;newArg&quot;"/>
                //      </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_text
                        .insert_data(1, "newArg")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodevalue01.xml
            #[test]
            fn test_nodevalue01() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_node; // type: Element // <var name="newNode" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_node = r#doc.create_element("address".to_string()).unwrap(); // <createElement obj="doc" var="newNode" tagName="&quot;address&quot;"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="initiallyNull"/>
                r#new_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
            }
            // hc_characterdataindexsizeerrreplacedataoffsetgreater.xml
            #[test]
            fn test_hc_characterdataindexsizeerrreplacedataoffsetgreater() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                // <assertDOMException id="throw_INDEX_SIZE_ERR">
                //      <INDEX_SIZE_ERR>
                //          <deleteData obj="child" offset="40" count="3"/>
                //      </INDEX_SIZE_ERR>
                // </assertDOMException>
                assert!(
                    child
                        .delete_data(40, 3)
                        .is_err_and(|err| err == DOMException::IndexSizeErr)
                );
            }
            // hc_documentinvalidcharacterexceptioncreateattribute1.xml
            #[test]
            fn test_hc_documentinvalidcharacterexceptioncreateattribute1() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //      <INVALID_CHARACTER_ERR>
                //          <createAttribute var="createdAttr" obj="doc" name="&quot;&quot;"/>
                //      </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_attribute("")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // hc_namednodemapsetnameditemreturnvalue.xml
            #[test]
            fn test_hc_namednodemapsetnameditemreturnvalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                r#new_attribute = r#doc.create_attribute("class".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;class&quot;"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                let r#new_node = r#attributes
                    .set_named_item(r#new_attribute)
                    .unwrap()
                    .unwrap(); // <setNamedItem interface="NamedNodeMap" obj="attributes" var="newNode" arg="newAttribute"/>
                // unimplemented: // <assertNotNull actual="newNode" id="previousAttrNotNull"/>
                let r#attr_value = r#new_node.node_value().unwrap().to_string(); // <nodeValue obj="newNode" var="attrValue"/>
                assert_eq!(r#attr_value, "No"); // <assertEquals actual="attrValue" expected="&quot;No&quot;" id="previousAttrValue" ignoreCase="false"/>
            }
            // hc_characterdatainsertdatamiddle.xml
            #[test]
            fn test_hc_characterdatainsertdatamiddle() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.insert_data(9, "Ann ").unwrap(); // <insertData obj="child" offset="9" arg="&quot;Ann &quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Margaret Ann Martin"); // <assertEquals actual="childData" expected="&quot;Margaret Ann Martin&quot;" id="characterdataInsertDataMiddleAssert" ignoreCase="false"/>
            }
            // characterdatareplacedatanomodificationallowederrEE.xml
            #[test]
            fn test_characterdatareplacedatanomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let mut r#ent_text; // type: CharacterData // <var name="entText" type="CharacterData"/>
                let r#ent_reference; // type: EntityReference // <var name="entReference" type="EntityReference"/>
                let mut r#appended_node; // type: Node // <var name="appendedNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" index="2" var="genderNode"/>
                r#ent_reference = r#doc.create_entity_reference("ent3".to_string()).unwrap(); // <createEntityReference var="entReference" obj="doc" name="&quot;ent3&quot;"/>
                // unimplemented: // <assertNotNull actual="entReference" id="createdEntRefNotNull"/>
                r#appended_node = r#gender_node
                    .append_child(ent_reference.clone().into())
                    .unwrap(); // <appendChild obj="genderNode" newChild="entReference" var="appendedNode"/>
                r#ent_text = r#ent_reference
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild var="entText" obj="entReference" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entText" id="entTextNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //      <NO_MODIFICATION_ALLOWED_ERR>
                //          <replaceData obj="entText" offset="1" count="3" arg="&quot;newArg&quot;"/>
                //      </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_text
                        .replace_data(1, 3, "newArg")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodetextnodetype.xml
            #[test]
            fn test_nodetextnodetype() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#text_node = r#test_addr.first_child().unwrap(); // <firstChild interface="Node" obj="testAddr" var="textNode"/>
                let r#node_type = r#text_node.node_type(); // <nodeType obj="textNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 3); // <assertEquals actual="nodeType" expected="3" id="nodeTextNodeTypeAssert1" ignoreCase="false"/>
            }
            // hc_nodedocumentnodetype.xml
            #[test]
            fn test_hc_nodedocumentnodetype() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#node_type = r#doc.node_type(); // <nodeType obj="doc" var="nodeType"/>
                assert_eq!(r#node_type as i32, 9); // <assertEquals actual="nodeType" expected="9" id="nodeDocumentNodeTypeAssert1" ignoreCase="false"/>
            }
            // notationgetpublicid.xml
            #[test]
            fn test_notationgetpublicid() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#notations = doc_type.notations(); // <notations obj="docType" var="notations"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                let r#notation_node = r#notations.get_named_item("notation1").unwrap(); // <getNamedItem obj="notations" var="notationNode" name="&quot;notation1&quot;"/>
                let r#public_id = r#notation_node.public_id().unwrap().to_string(); // <publicId interface="Notation" obj="notationNode" var="publicId"/>
                assert_eq!(r#public_id, "notation1File"); // <assertEquals actual="publicId" expected="&quot;notation1File&quot;" id="publicId" ignoreCase="false"/>
            }
            // hc_characterdatadeletedatabegining.xml
            #[test]
            fn test_hc_characterdatadeletedatabegining() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.delete_data(0, 16).unwrap(); // <deleteData obj="child" offset="0" count="16"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Dallas, Texas 98551"); // <assertEquals actual="childData" expected="&quot;Dallas, Texas 98551&quot;" id="data" ignoreCase="false"/>
            }
            // nodevalue04.xml
            #[test]
            fn test_nodevalue04() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_node = r#doc.doctype().unwrap(); // <doctype obj="doc" var="newNode"/>
                // unimplemented: // <assertNotNull actual="newNode" id="docTypeNotNull"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="initiallyNull"/>
                r#new_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
            }
            // nodegetfirstchild.xml
            #[test]
            fn test_nodegetfirstchild() {
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#fchild_node = r#employee_node.first_child().unwrap(); // <firstChild interface="Node" obj="employeeNode" var="fchildNode"/>
                r#child_name = r#fchild_node.node_name().to_string(); // <nodeName obj="fchildNode" var="childName"/>
                // <if><equals actual="childName" expected="&quot;#text&quot;" ignoreCase="false"/>
                //      <nextSibling var="fchildNode" obj="fchildNode" interface="Node"/>
                //      <nodeName obj="fchildNode" var="childName"/>
                // </if>
                if child_name == "#text" {
                    child_name = fchild_node.next_sibling().unwrap().node_name().to_string();
                }
                assert_eq!(r#child_name, "employeeId"); // <assertEquals actual="childName" expected="&quot;employeeId&quot;" id="nodeName" ignoreCase="false"/>
            }
            // hc_elementassociatedattribute.xml
            #[test]
            fn test_hc_elementassociatedattribute() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                let r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;title&quot;"/>
                let r#specified = r#domestic_attr.specified(); // <specified obj="domesticAttr" var="specified"/>
                assert!(r#specified); // <assertTrue actual="specified" id="acronymTitleSpecified"/>
            }
            // nodeelementnodevalue.xml
            #[test]
            fn test_nodeelementnodevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="elementNode"/>
                let r#element_value = r#element_node.node_value(); // <nodeValue obj="elementNode" var="elementValue"/>
                assert!(element_value.is_none()); // <assertNull actual="elementValue" id="elementNodeValueNull"/>
            }
            // textsplittextfour.xml
            #[test]
            fn test_textsplittextfour() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#address_node; // type: Node // <var name="addressNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#address_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="addressNode" index="0"/>
                r#text_node = r#address_node
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild interface="Node" obj="addressNode" var="textNode"/>
                let r#split_node = r#text_node.split_text(30).unwrap(); // <splitText obj="textNode" var="splitNode" offset="30"/>
                let r#value = r#split_node.node_value().unwrap().to_string(); // <nodeValue obj="splitNode" var="value"/>
                assert_eq!(r#value, "98551"); // <assertEquals actual="value" expected="&quot;98551&quot;" id="textSplitTextFourAssert" ignoreCase="false"/>
            }
            // hc_nodeappendchilddocfragment.xml
            #[test]
            fn test_hc_nodeappendchilddocfragment() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#newdoc_fragment; // type: DocumentFragment // <var name="newdocFragment" type="DocumentFragment"/>
                let r#new_child1; // type: Node // <var name="newChild1" type="Node"/>
                let r#new_child2; // type: Node // <var name="newChild2" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let r#expected = vec!["em", "strong", "code", "sup", "var", "acronym", "br", "b"]; // type: List // <var name="expected" type="List"><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member><member>"br"</member><member>"b"</member></var>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#newdoc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="newdocFragment"/>
                r#new_child1 = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="newChild1"/>
                r#new_child2 = r#doc.create_element("b".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;b&quot;" var="newChild2"/>
                r#appended_child = r#newdoc_fragment.append_child(new_child1.into()).unwrap(); // <appendChild var="appendedChild" obj="newdocFragment" newChild="newChild1"/>
                r#appended_child = r#newdoc_fragment.append_child(new_child2.into()).unwrap(); // <appendChild var="appendedChild" obj="newdocFragment" newChild="newChild2"/>
                r#appended_child = r#employee_node
                    .append_child(newdoc_fragment.into())
                    .unwrap(); // <appendChild var="appendedChild" obj="employeeNode" newChild="newdocFragment"/>
                // <for-each collection="childList" member="child">
                //      <nodeType var="nodeType" obj="child"/>
                //      <if><equals actual="nodeType" expected="1"/>
                //          <nodeName var="childName" obj="child"/>
                //          <append collection="result" item="childName"/>
                //      </if>
                // </for-each>
                let len = child_list.length();
                for i in 0..len {
                    let child = child_list.item(i).unwrap();
                    node_type = child.node_type();
                    if node_type as i32 == 1 {
                        child_name = child.node_name();
                        result.push(child_name.to_string());
                    }
                }
                assert_eq!(r#result, expected); // <assertEquals actual="result" expected="expected" ignoreCase="auto" id="nodeNames"/>
            }
            // attrreplacechild1.xml
            #[test]
            fn test_attrreplacechild1() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                let mut r#attr_node; // type: Node // <var name="attrNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference obj="doc" var="entRef" name="&quot;ent4&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                r#ent_element = r#ent_ref.first_child().unwrap().as_element().unwrap(); // <firstChild var="entElement" obj="entRef" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#attr_node = r#ent_element.get_attribute_node("domestic").unwrap(); // <getAttributeNode var="attrNode" obj="entElement" name="&quot;domestic&quot;"/>
                let r#text_node = r#attr_node.first_child().unwrap(); // <firstChild var="textNode" obj="attrNode" interface="Node"/>
                // unimplemented: // <assertNotNull actual="textNode" id="attrChildNotNull"/>
                let r#new_child = r#doc.create_text_node("Yesterday"); // <createTextNode var="newChild" obj="doc" data="&quot;Yesterday&quot;"/>
                // <assertDOMException id="setValue_throws_NO_MODIFICATION_ERR">
                //      <NO_MODIFICATION_ALLOWED_ERR>
                //          <replaceChild obj="attrNode" oldChild="textNode" var="removedNode" newChild="newChild"/>
                //      </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    attr_node
                        .replace_child(new_child.into(), text_node)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_elementinuseattributeerr.xml
            #[test]
            fn test_hc_elementinuseattributeerr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#address_element_list; // type: NodeList // <var name="addressElementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                let mut r#new_element; // type: Element // <var name="newElement" type="Element"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#set_attr1; // type: Attr // <var name="setAttr1" type="Attr"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#address_element_list = r#doc.get_elements_by_tag_name("body"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;body&quot;" var="addressElementList"/>
                r#test_address = r#address_element_list.item(0).unwrap(); // <item interface="NodeList" obj="addressElementList" index="0" var="testAddress"/>
                r#new_element = r#doc.create_element("p".to_string()).unwrap(); // <createElement obj="doc" var="newElement" tagName="&quot;p&quot;"/>
                r#appended_child = r#test_address
                    .append_child(new_element.clone().into())
                    .unwrap(); // <appendChild var="appendedChild" obj="testAddress" newChild="newElement"/>
                r#new_attribute = r#doc.create_attribute("title".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;title&quot;"/>
                r#set_attr1 = r#new_element
                    .set_attribute_node(r#new_attribute.clone())
                    .unwrap(); // <setAttributeNode var="setAttr1" obj="newElement" newAttr="newAttribute"/>
                // <assertDOMException id="throw_INUSE_ATTRIBUTE_ERR">
                //      <INUSE_ATTRIBUTE_ERR>
                //          <setAttributeNode var="setAttr2" obj="testAddress" newAttr="newAttribute"/>
                //      </INUSE_ATTRIBUTE_ERR>
                // </assertDOMException>
                assert!(
                    test_address
                        .set_attribute_node(new_attribute)
                        .is_err_and(|err| err == DOMException::InuseAttributeErr)
                );
            }
            // nodeappendchildnomodificationallowederrEE.xml
            #[test]
            fn test_nodeappendchildnomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                let r#created_node = r#doc.create_element("text3".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;text3&quot;" var="createdNode"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //      <NO_MODIFICATION_ALLOWED_ERR>
                //          <appendChild var="appendedNode" obj="entRef" newChild="createdNode"/>
                //      </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_ref
                        .append_child(created_node.into())
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodeappendchildnomodificationallowederr.xml
            #[test]
            fn test_nodeappendchildnomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                let mut r#ent_element; // type: Node // <var name="entElement" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item obj="genderList" index="2" var="genderNode" interface="NodeList"/>
                r#ent_ref = r#gender_node.first_child().unwrap(); // <firstChild interface="Node" var="entRef" obj="genderNode"/>
                // unimplemented: // <assertNotNull actual="entRef" id="entRefNotNull"/>
                let r#node_type = r#ent_ref.node_type(); // <nodeType var="nodeType" obj="entRef"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    ent_ref = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#ent_element = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                let r#created_node = r#doc.create_element("text3".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;text3&quot;" var="createdNode"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <appendChild var="appendedNode" obj="entElement" newChild="createdNode"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element
                        .append_child(created_node.into())
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // namednodemapreturnnull.xml
            #[test]
            fn test_namednodemapreturnnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="1"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#district_node = r#attributes.get_named_item("district"); // <getNamedItem obj="attributes" var="districtNode" name="&quot;district&quot;"/>
                assert!(district_node.is_none()); // <assertNull actual="districtNode" id="namednodemapReturnNullAssert"/>
            }
            // hc_nodegetownerdocumentnull.xml
            #[test]
            fn test_hc_nodegetownerdocumentnull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#owner_document = r#doc.owner_document(); // <ownerDocument obj="doc" var="ownerDocument"/>
                assert!(owner_document.is_none()); // <assertNull actual="ownerDocument" id="nodeGetOwnerDocumentNullAssert1"/>
            }
            // namednodemapchildnoderange.xml
            #[test]
            fn test_namednodemapchildnoderange() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="2"/>
                r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#length = r#attributes.length(); // <length var="length" obj="attributes" interface="NamedNodeMap"/>
                assert_eq!(r#length, 2); // <assertEquals actual="length" expected="2" id="length" ignoreCase="false"/>
                r#child = r#attributes.item(0).unwrap(); // <item var="child" index="0" obj="attributes" interface="NamedNodeMap"/>
                r#child = r#attributes.item(1).unwrap(); // <item var="child" index="1" obj="attributes" interface="NamedNodeMap"/>
            }
            // documenttypegetentitieslength.xml
            #[test]
            fn test_documenttypegetentitieslength() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#entity_list; // type: NamedNodeMap // <var name="entityList" type="NamedNodeMap"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                entity_list = doc_type.entities(); // <entities obj="docType" var="entityList"/>
                // unimplemented: // <assertNotNull actual="entityList" id="entitiesNotNull"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //  <assertSize collection="entityList" size="7" id="entitySizeSVG"/>
                // <else>
                //  <assertSize collection="entityList" size="5" id="entitySize"/>
                // </else>
                // </if>
            }
            // hc_noderemovechild.xml
            #[test]
            fn test_hc_noderemovechild() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Element // <var name="rootNode" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                let r#child_list = r#root_node.child_nodes(); // <childNodes obj="rootNode" var="childList"/>
                let r#child_to_remove = r#child_list.item(1).unwrap().clone(); // <item interface="NodeList" obj="childList" index="1" var="childToRemove"/>
                let r#removed_child = r#root_node.remove_child(child_to_remove).unwrap(); // <removeChild obj="rootNode" var="removedChild" oldChild="childToRemove"/>
                let r#parent_node = r#removed_child.parent_node(); // <parentNode interface="Node" obj="removedChild" var="parentNode"/>
                assert!(parent_node.is_none()); // <assertNull actual="parentNode" id="parentNodeNull"/>
            }
            // hc_attrname.xml
            #[test]
            fn test_hc_attrname() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;acronym&quot;"/>
                let r#test_node = r#address_list.item(1).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="1"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#street_attr = r#attributes.get_named_item("class").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;class&quot;"/>
                let r#strong1 = r#street_attr.node_name().to_string(); // <nodeName obj="streetAttr" var="strong1"/>
                let r#strong2 = r#street_attr.name().to_string(); // <name obj="streetAttr" var="strong2" interface="Attr"/>
                assert_eq!(r#strong1, "class"); // <assertEquals actual="strong1" expected="&quot;class&quot;" id="nodeName" ignoreCase="auto" context="attribute"/>
                assert_eq!(r#strong2, "class"); // <assertEquals actual="strong2" expected="&quot;class&quot;" id="name" ignoreCase="auto" context="attribute"/>
            }
            // hc_characterdataappenddata.xml
            #[test]
            fn test_hc_characterdataappenddata() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.append_data(", Esquire").unwrap(); // <appendData obj="child" arg="&quot;, Esquire&quot;"/>
                let r#child_value = r#child.data().to_string(); // <data obj="child" var="childValue" interface="CharacterData"/>
                let r#child_length = r#child_value.len(); // <length obj="childValue" var="childLength" interface="DOMString"/>
                assert_eq!(r#child_length, 24); // <assertEquals actual="childLength" expected="24" ignoreCase="false" id="characterdataAppendDataAssert"/>
            }
            // elementsetattributenomodificationallowederrEE.xml
            #[test]
            fn test_elementsetattributenomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender; // type: Node // <var name="gender" type="Node"/>
                let r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                r#appended_child = r#gender.append_child(ent_ref.clone().into()).unwrap(); // <appendChild obj="gender" newChild="entRef" var="appendedChild"/>
                r#ent_element = r#ent_ref.first_child().unwrap().as_element().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <setAttribute obj="entElement" name="&quot;newAttr&quot;" value="&quot;newValue&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element
                        .set_attribute("newAttr", "newValue")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_characterdatareplacedatamiddle.xml
            #[test]
            fn test_hc_characterdatareplacedatamiddle() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.replace_data(5, 5, "South").unwrap(); // <replaceData obj="child" offset="5" count="5" arg="&quot;South&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230 South Ave. Dallas, Texas 98551"); // <assertEquals actual="childData" expected="&quot;1230 South Ave. Dallas, Texas 98551&quot;" id="characterdataReplaceDataMiddleAssert" ignoreCase="false"/>
            }
            // hc_elementinvalidcharacterexception1.xml
            #[test]
            fn test_hc_elementinvalidcharacterexception1() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_address = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddress"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <setAttribute obj="testAddress" name="&quot;&quot;" value="&quot;value&quot;"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    test_address
                        .set_attribute("", "value")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // elementgetelementsbytagname.xml
            #[test]
            fn test_elementgetelementsbytagname() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                assert_eq!(element_list.length(), 5); // <assertSize collection="elementList" size="5" id="elementGetElementsByTagNameAssert"/>
            }
            // noderemovechildoldchildnonexistent.xml
            #[test]
            fn test_noderemovechildoldchildnonexistent() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#old_child = r#doc.create_element("oldChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;oldChild&quot;" var="oldChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <removeChild var="removedChild" obj="elementNode" oldChild="oldChild"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .remove_child(old_child.into())
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // noderemovechildnode.xml
            #[test]
            fn test_noderemovechildnode() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                let r#child; // type: Node // <var name="child" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#old_child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="oldChild"/>
                let r#removed_child = r#employee_node.remove_child(old_child).unwrap(); // <removeChild var="removedChild" obj="employeeNode" oldChild="oldChild"/>
                let r#removed_name = r#removed_child.node_name().to_string(); // <nodeName obj="removedChild" var="removedName"/>
                r#child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="child"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                let r#length = r#child_list.length(); // <length interface="NodeList" obj="childList" var="length"/>
                // <if><equals actual="length" expected="5" ignoreCase="false"/>
                //  <assertEquals actual="removedName" expected="&quot;employeeId&quot;" ignoreCase="false" id="removedNameNoWhitespace"/>
                //  <assertEquals actual="childName" expected="&quot;name&quot;" ignoreCase="false" id="childNameNoWhitespace"/>
                // <else>
                //  <assertEquals actual="removedName" expected="&quot;#text&quot;" ignoreCase="false" id="removedName"/>
                //  <assertEquals actual="childName" expected="&quot;employeeId&quot;" ignoreCase="false" id="childName"/>
                //  <assertEquals actual="length" expected="12" ignoreCase="false" id="length"/>
                // </else>
                // </if>
                if length == 5 {
                    assert_eq!(removed_name, "employeeId");
                    assert_eq!(child_name, "name");
                } else {
                    assert_eq!(removed_name, "#text");
                    assert_eq!(child_name, "employeeId");
                    assert_eq!(length, 12);
                }
            }
            // hc_characterdatareplacedataexceedslengthofdata.xml
            #[test]
            fn test_hc_characterdatareplacedataexceedslengthofdata() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.replace_data(0, 50, "2600").unwrap(); // <replaceData obj="child" offset="0" count="50" arg="&quot;2600&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "2600"); // <assertEquals actual="childData" expected="&quot;2600&quot;" id="characterdataReplaceDataExceedsLengthOfDataAssert" ignoreCase="false"/>
            }
            // nodeappendchild.xml
            #[test]
            fn test_nodeappendchild() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#created_node; // type: Node // <var name="createdNode" type="Node"/>
                let r#lchild; // type: Node // <var name="lchild" type="Node"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#created_node = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="createdNode"/>
                r#appended_child = r#employee_node.append_child(created_node.into()).unwrap(); // <appendChild var="appendedChild" obj="employeeNode" newChild="createdNode"/>
                r#lchild = r#employee_node.last_child().unwrap(); // <lastChild interface="Node" obj="employeeNode" var="lchild"/>
                let r#child_name = r#lchild.node_name().to_string(); // <nodeName obj="lchild" var="childName"/>
                assert_eq!(r#child_name, "newChild"); // <assertEquals actual="childName" expected="&quot;newChild&quot;" id="nodeAppendChildAssert1" ignoreCase="false"/>
            }
            // attrremovechild1.xml
            #[test]
            fn test_attrremovechild1() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                let mut r#attr_node; // type: Node // <var name="attrNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference obj="doc" var="entRef" name="&quot;ent4&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                r#ent_element = r#ent_ref.first_child().unwrap().as_element().unwrap(); // <firstChild var="entElement" obj="entRef" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#attr_node = r#ent_element.get_attribute_node("domestic").unwrap(); // <getAttributeNode var="attrNode" obj="entElement" name="&quot;domestic&quot;"/>
                let r#text_node = r#attr_node.first_child().unwrap(); // <firstChild var="textNode" obj="attrNode" interface="Node"/>
                // unimplemented: // <assertNotNull actual="textNode" id="attrChildNotNull"/>
                // <assertDOMException id="setValue_throws_NO_MODIFICATION_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <removeChild obj="attrNode" oldChild="textNode" var="removedNode"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    attr_node
                        .remove_child(text_node)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_namednodemapremovenameditem.xml
            #[test]
            fn test_hc_namednodemapremovenameditem() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let r#street_attr; // type: Attr // <var name="streetAttr" type="Attr"/>
                let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                r#removed_node = r#attributes.remove_named_item("class").unwrap(); // <removeNamedItem var="removedNode" interface="NamedNodeMap" obj="attributes" name="&quot;class&quot;"/>
                r#street_attr = r#attributes.get_named_item("class"); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;class&quot;"/>
                assert!(street_attr.is_none()); // <assertNull actual="streetAttr" id="isnull"/>
            }
            // domimplementationfeaturenull.xml
            #[test]
            fn test_domimplementationfeaturenull() {
                // unimplemented: // <implementationAttribute name="hasNullString" value="true"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                let r#state = dom_impl.has_feature("XML", None); // <hasFeature obj="domImpl" var="state" feature="&quot;XML&quot;" version="nullVersion"/>
                assert!(r#state); // <assertTrue actual="state" id="hasXMLnull"/>
            }
            // hc_elementgettagname.xml
            #[test]
            fn test_hc_elementgettagname() {
                let mut r#tagname; // type: DOMString // <var name="tagname" type="DOMString"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#root = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="root"/>
                r#tagname = r#root.tag_name().to_string(); // <tagName obj="root" var="tagname"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //  <assertEquals actual="tagname" expected="&quot;svg&quot;" id="svgTagname" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="tagname" expected="&quot;html&quot;" id="tagname" ignoreCase="auto"/>
                // </else>
                // </if>
            }
            // notationgetsystemidnull.xml
            #[test]
            fn test_notationgetsystemidnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#notations = doc_type.notations(); // <notations obj="docType" var="notations"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                let r#notation_node = r#notations.get_named_item("notation1").unwrap(); // <getNamedItem obj="notations" var="notationNode" name="&quot;notation1&quot;"/>
                let r#system_id = r#notation_node.system_id(); // <systemId interface="Notation" obj="notationNode" var="systemId"/>
                assert!(system_id.is_none()); // <assertNull actual="systemId" id="systemId"/>
            }
            // nodevalue08.xml
            #[test]
            fn test_nodevalue08() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                let mut r#new_value; // type: DOMString // <var name="newValue" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#node_map = doc_type.notations(); // <notations obj="docType" var="nodeMap"/>
                // unimplemented: // <assertNotNull actual="nodeMap" id="notationsNotNull"/>
                r#new_node = r#node_map.get_named_item("notation1").unwrap(); // <getNamedItem obj="nodeMap" name="&quot;notation1&quot;" var="newNode"/>
                // unimplemented: // <assertNotNull actual="newNode" id="notationNotNull"/>
                r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="initiallyNull"/>
                r#new_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
            }
            // documentcreatedocumentfragment.xml
            #[test]
            fn test_documentcreatedocumentfragment() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#new_doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="newDocFragment"/>
                let r#children = r#new_doc_fragment.child_nodes(); // <childNodes obj="newDocFragment" var="children"/>
                let r#length = r#children.length(); // <length interface="NodeList" obj="children" var="length"/>
                assert_eq!(r#length, 0); // <assertEquals actual="length" expected="0" ignoreCase="false" id="length"/>
                let r#new_doc_fragment_name = r#new_doc_fragment.node_name().to_string(); // <nodeName obj="newDocFragment" var="newDocFragmentName"/>
                assert_eq!(r#new_doc_fragment_name, "#document-fragment"); // <assertEquals actual="newDocFragmentName" expected="&quot;#document-fragment&quot;" ignoreCase="false" id="name"/>
                let r#new_doc_fragment_type = r#new_doc_fragment.node_type(); // <nodeType obj="newDocFragment" var="newDocFragmentType"/>
                assert_eq!(r#new_doc_fragment_type as i32, 11); // <assertEquals actual="newDocFragmentType" expected="11" ignoreCase="false" id="type"/>
                let r#new_doc_fragment_value = r#new_doc_fragment.node_value(); // <nodeValue obj="newDocFragment" var="newDocFragmentValue"/>
                assert!(new_doc_fragment_value.is_none()); // <assertNull actual="newDocFragmentValue" id="value"/>
            }
            // attrcreatedocumentfragment.xml
            #[test]
            fn test_attrcreatedocumentfragment() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_fragment; // type: DocumentFragment // <var name="docFragment" type="DocumentFragment"/>
                let mut r#new_one; // type: Element // <var name="newOne" type="Element"/>
                let r#domestic_node; // type: Node // <var name="domesticNode" type="Node"/>
                let r#domestic_attr; // type: NamedNodeMap // <var name="domesticAttr" type="NamedNodeMap"/>
                let r#attrs; // type: Attr // <var name="attrs" type="Attr"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="docFragment"/>
                r#new_one = r#doc.create_element("newElement".to_string()).unwrap(); // <createElement obj="doc" var="newOne" tagName="&quot;newElement&quot;"/>
                r#new_one.set_attribute("newdomestic", "Yes").unwrap(); // <setAttribute obj="newOne" name="&quot;newdomestic&quot;" value="&quot;Yes&quot;"/>
                r#appended_child = r#doc_fragment.append_child(new_one.into()).unwrap(); // <appendChild var="appendedChild" obj="docFragment" newChild="newOne"/>
                r#domestic_node = r#doc_fragment.first_child().unwrap(); // <firstChild interface="Node" obj="docFragment" var="domesticNode"/>
                r#domestic_attr = r#domestic_node.attributes().unwrap(); // <attributes obj="domesticNode" var="domesticAttr"/>
                r#attrs = r#domestic_attr.item(0).unwrap(); // <item interface="NamedNodeMap" obj="domesticAttr" var="attrs" index="0"/>
                let r#attr_name = r#attrs.name().to_string(); // <name interface="Attr" obj="attrs" var="attrName"/>
                assert_eq!(r#attr_name, "newdomestic"); // <assertEquals actual="attrName" expected="&quot;newdomestic&quot;" id="attrCreateDocumentFragmentAssert" ignoreCase="false"/>
            }
            // hc_elementnotfounderr.xml
            #[test]
            fn test_hc_elementnotfounderr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#old_attribute; // type: Attr // <var name="oldAttribute" type="Attr"/>
                let r#address_element_list; // type: NodeList // <var name="addressElementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#address_element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="addressElementList"/>
                r#test_address = r#address_element_list.item(4).unwrap(); // <item interface="NodeList" obj="addressElementList" index="4" var="testAddress"/>
                r#old_attribute = r#doc.create_attribute("title".to_string()).unwrap(); // <createAttribute obj="doc" var="oldAttribute" name="&quot;title&quot;"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <removeAttributeNode obj="testAddress" oldAttr="oldAttribute" var="attrAddress"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    test_address
                        .remove_attribute_node(old_attribute)
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // elementgetelementsbytagnameaccessnodelist.xml
            #[test]
            fn test_elementgetelementsbytagnameaccessnodelist() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(3).unwrap(); // <item interface="NodeList" obj="elementList" index="3" var="testEmployee"/>
                r#child = r#test_employee.first_child().unwrap(); // <firstChild interface="Node" obj="testEmployee" var="child"/>
                let r#child_type = r#child.node_type(); // <nodeType var="childType" obj="child"/>
                // <if><equals actual="childType" expected="3" ignoreCase="false"/>
                //  <nextSibling var="child" obj="child" interface="Node"/>
                // </if>
                if child_type as i32 == 3 {
                    child = child.next_sibling().unwrap();
                }
                let r#child_name = r#child.node_name().to_string(); // <nodeName var="childName" obj="child" interface="Node"/>
                assert_eq!(r#child_name, "employeeId"); // <assertEquals actual="childName" expected="&quot;employeeId&quot;" id="nodename" ignoreCase="false"/>
                r#child = r#child.first_child().unwrap(); // <firstChild var="child" obj="child" interface="Node"/>
                let r#child_value = r#child.node_value().unwrap().to_string(); // <nodeValue var="childValue" obj="child"/>
                assert_eq!(r#child_value, "EMP0004"); // <assertEquals actual="childValue" expected="&quot;EMP0004&quot;" ignoreCase="false" id="emp0004"/>
            }
            // hc_attrchildnodes2.xml
            #[test]
            fn test_hc_attrchildnodes2() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let r#text_node; // type: Text // <var name="textNode" type="Text"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                let r#child_nodes = r#title_attr.child_nodes(); // <childNodes var="childNodes" obj="titleAttr"/>
                r#text_node = r#doc.create_text_node("terday"); // <createTextNode var="textNode" obj="doc" data="&quot;terday&quot;"/>
                r#title_attr.append_child(text_node.into()).unwrap(); // <appendChild var="retval" obj="titleAttr" newChild="textNode"/>
                assert_eq!(child_nodes.length(), 2); // <assertSize size="2" collection="childNodes" id="childNodesSize"/>
                let r#text_node = r#child_nodes.item(0).unwrap().clone(); // <item var="textNode" obj="childNodes" index="0" interface="NodeList"/>
                r#value = r#text_node.node_value().unwrap().to_string(); // <nodeValue var="value" obj="textNode"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="child1IsYes" ignoreCase="false"/>
                let r#text_node = r#child_nodes.item(1).unwrap().clone(); // <item var="textNode" obj="childNodes" index="1" interface="NodeList"/>
                r#value = r#text_node.node_value().unwrap().to_string(); // <nodeValue var="value" obj="textNode"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="child2IsTerday" ignoreCase="false"/>
                let r#text_node = r#child_nodes.item(2); // <item var="textNode" obj="childNodes" index="2" interface="NodeList"/>
                assert!(text_node.is_none()); // <assertNull actual="textNode" id="thirdItemIsNull"/>
            }
            // hc_noderemovechildgetnodename.xml
            #[test]
            fn test_hc_noderemovechildgetnodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#old_child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="oldChild"/>
                let r#old_name = r#old_child.node_name().to_string(); // <nodeName obj="oldChild" var="oldName"/>
                let r#removed_child = r#employee_node.remove_child(old_child).unwrap(); // <removeChild obj="employeeNode" oldChild="oldChild" var="removedChild"/>
                // unimplemented: // <assertNotNull actual="removedChild" id="notnull"/>
                let r#child_name = r#removed_child.node_name().to_string(); // <nodeName obj="removedChild" var="childName"/>
                assert_eq!(r#child_name, old_name); // <assertEquals actual="childName" expected="oldName" id="nodeName" ignoreCase="false"/>
            }
            // hc_nodeinsertbeforenewchilddiffdocument.xml
            #[test]
            fn test_hc_nodeinsertbeforenewchilddiffdocument() {
                let r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc1 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc1" href="hc_staff" willBeModified="false"/>
                r#doc2 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc2" href="hc_staff" willBeModified="true"/>
                r#new_child = r#doc1.create_element("br".to_string()).unwrap(); // <createElement obj="doc1" tagName="&quot;br&quot;" var="newChild"/>
                r#element_list = r#doc2.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc2" tagname="&quot;p&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                r#ref_child = r#element_node.first_child().unwrap(); // <firstChild var="refChild" obj="elementNode" interface="Node"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <insertBefore var="insertedNode" obj="elementNode" newChild="newChild" refChild="refChild"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .insert_before(new_child.into(), Some(ref_child))
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // hc_characterdataindexsizeerrdeletedataoffsetnegative.xml
            #[test]
            fn test_hc_characterdataindexsizeerrdeletedataoffsetnegative() {
                // unimplemented: // <implementationAttribute name="signed" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // unimplemented:
                // <assertDOMException id="throws_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <deleteData obj="child" offset="-5" count="3"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
            }
            // hc_nodeelementnodename.xml
            #[test]
            fn test_hc_nodeelementnodename() {
                let mut r#element_name; // type: DOMString // <var name="elementName" type="DOMString"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="elementNode"/>
                r#element_name = r#element_node.node_name().to_string(); // <nodeName obj="elementNode" var="elementName"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //  <assertEquals actual="elementName" expected="&quot;svg&quot;" id="svgNodeName" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="elementName" expected="&quot;html&quot;" id="nodeName" ignoreCase="auto"/>
                // </else>
                // </if>
            }
            // nodeentityreferencenodetype.xml
            #[test]
            fn test_nodeentityreferencenodetype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#ent_ref_addr; // type: Element // <var name="entRefAddr" type="Element"/>
                let mut r#ent_ref_node; // type: Node // <var name="entRefNode" type="Node"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#ent_ref_addr = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="entRefAddr"/>
                r#ent_ref_node = r#ent_ref_addr.first_child().unwrap(); // <firstChild interface="Node" obj="entRefAddr" var="entRefNode"/>
                r#node_type = r#ent_ref_node.node_type(); // <nodeType obj="entRefNode" var="nodeType"/>
                // <if><equals actual="nodeType" expected="3" ignoreCase="false"/>
                //  <createEntityReference var="entRefNode" obj="doc" name="&quot;ent2&quot;"/>
                //  <assertNotNull actual="entRefNode" id="createdEntRefNotNull"/>
                //  <nodeType obj="entRefNode" var="nodeType"/>
                // </if>
                if node_type as i32 == 3 {
                    ent_ref_node = doc.create_entity_reference("ent2").unwrap().into();
                    node_type = ent_ref_node.node_type();
                }
                assert_eq!(r#node_type as i32, 5); // <assertEquals actual="nodeType" expected="5" id="entityNodeType" ignoreCase="false"/>
            }
            // hc_documentinvalidcharacterexceptioncreateelement1.xml
            #[test]
            fn test_hc_documentinvalidcharacterexceptioncreateelement1() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <createElement var="badElement" obj="doc" tagName="&quot;&quot;"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_element("")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // elementgetelementsbytagnamespecialvalue.xml
            #[test]
            fn test_elementgetelementsbytagnamespecialvalue() {
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let r#expected_result = vec![
                    "employeeId",
                    "name",
                    "position",
                    "salary",
                    "gender",
                    "address",
                ]; // type: List // <var name="expectedResult" type="List"><member>"employeeId"</member><member>"name"</member><member>"position"</member><member>"salary"</member><member>"gender"</member><member>"address"</member></var>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#last_employee = r#element_list.item(4).unwrap(); // <item interface="NodeList" obj="elementList" index="4" var="lastEmployee"/>
                let r#lastemp_list = r#last_employee.get_elements_by_tag_name("*"); // <getElementsByTagName interface="Element" obj="lastEmployee" var="lastempList" tagname="&quot;*&quot;"/>
                // <for-each collection="lastempList" member="child">
                //  <nodeName obj="child" var="childName"/>
                //  <append collection="result" item="childName"/>
                // </for-each>
                for i in 0..lastemp_list.length() {
                    let child = lastemp_list.item(i).unwrap();
                    child_name = child.node_name().to_string();
                    result.push(child_name);
                }
                assert_eq!(r#result, expected_result); // <assertEquals actual="result" expected="expectedResult" id="tagNames" ignoreCase="false"/>
            }
            // cdatasectionnormalize.xml
            #[test]
            fn test_cdatasectionnormalize() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#name_list; // type: NodeList // <var name="nameList" type="NodeList"/>
                let mut r#l_child; // type: Element // <var name="lChild" type="Element"/>
                let r#child_nodes; // type: NodeList // <var name="childNodes" type="NodeList"/>
                let mut r#cdata_n; // type: CDATASection // <var name="cdataN" type="CDATASection"/>
                let mut r#data; // type: DOMString // <var name="data" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#name_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="nameList" tagname="&quot;name&quot;"/>
                r#l_child = r#name_list.item(1).unwrap(); // <item interface="NodeList" obj="nameList" var="lChild" index="1"/>
                r#l_child.normalize(); // <normalize obj="lChild"/>
                r#child_nodes = r#l_child.child_nodes(); // <childNodes obj="lChild" var="childNodes"/>
                r#cdata_n = r#child_nodes
                    .item(1)
                    .unwrap()
                    .clone()
                    .as_cdata_section()
                    .unwrap(); // <item interface="NodeList" obj="childNodes" var="cdataN" index="1"/>
                // unimplemented: // <assertNotNull actual="cdataN" id="firstCDATASection"/>
                r#data = r#cdata_n.data().to_string(); // <data interface="CharacterData" obj="cdataN" var="data"/>
                assert_eq!(
                    r#data,
                    "This is a CDATASection with EntityReference number 2 &ent2;"
                ); // <assertEquals actual="data" expected="&quot;This is a CDATASection with EntityReference number 2 &amp;ent2;&quot;" ignoreCase="false" id="data1"/>
                r#cdata_n = r#child_nodes
                    .item(3)
                    .unwrap()
                    .clone()
                    .as_cdata_section()
                    .unwrap(); // <item interface="NodeList" obj="childNodes" var="cdataN" index="3"/>
                // unimplemented: // <assertNotNull actual="cdataN" id="secondCDATASection"/>
                r#data = r#cdata_n.data().to_string(); // <data interface="CharacterData" obj="cdataN" var="data"/>
                assert_eq!(
                    r#data,
                    "This is an adjacent CDATASection with a reference to a tab &tab;"
                ); // <assertEquals actual="data" expected="&quot;This is an adjacent CDATASection with a reference to a tab &amp;tab;&quot;" ignoreCase="false" id="data3"/>
            }
            // hc_documentcreateelementcasesensitive.xml
            #[test]
            fn test_hc_documentcreateelementcasesensitive() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_element1; // type: Element // <var name="newElement1" type="Element"/>
                let mut r#new_element2; // type: Element // <var name="newElement2" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#new_element1 = r#doc.create_element("ACRONYM".to_string()).unwrap(); // <createElement obj="doc" var="newElement1" tagName="&quot;ACRONYM&quot;"/>
                r#new_element2 = r#doc.create_element("acronym".to_string()).unwrap(); // <createElement obj="doc" var="newElement2" tagName="&quot;acronym&quot;"/>
                r#new_element1.set_attribute("lang", "EN").unwrap(); // <setAttribute obj="newElement1" name="&quot;lang&quot;" value="&quot;EN&quot;"/>
                r#new_element2.set_attribute("title", "Dallas").unwrap(); // <setAttribute obj="newElement2" name="&quot;title&quot;" value="&quot;Dallas&quot;"/>
                let r#attribute1 = r#new_element1.get_attribute("lang"); // <getAttribute obj="newElement1" var="attribute1" name="&quot;lang&quot;"/>
                let r#attribute2 = r#new_element2.get_attribute("title"); // <getAttribute obj="newElement2" var="attribute2" name="&quot;title&quot;"/>
                assert_eq!(r#attribute1, "EN"); // <assertEquals actual="attribute1" expected="&quot;EN&quot;" ignoreCase="false" id="attrib1"/>
                assert_eq!(r#attribute2, "Dallas"); // <assertEquals actual="attribute2" expected="&quot;Dallas&quot;" ignoreCase="false" id="attrib2"/>
                let r#node_name1 = r#new_element1.node_name().to_string(); // <nodeName var="nodeName1" obj="newElement1"/>
                let r#node_name2 = r#new_element2.node_name().to_string(); // <nodeName var="nodeName2" obj="newElement2"/>
                assert_eq!(r#node_name1, "ACRONYM"); // <assertEquals actual="nodeName1" expected="&quot;ACRONYM&quot;" ignoreCase="auto" id="nodeName1"/>
                assert_eq!(r#node_name2, "acronym"); // <assertEquals actual="nodeName2" expected="&quot;acronym&quot;" ignoreCase="auto" id="nodeName2"/>
            }
            // hc_elementretrievetagname.xml
            #[test]
            fn test_hc_elementretrievetagname() {
                let mut r#strong; // type: DOMString // <var name="strong" type="DOMString"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("code"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;code&quot;" var="elementList"/>
                let r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="testEmployee"/>
                r#strong = r#test_employee.node_name().to_string(); // <nodeName obj="testEmployee" var="strong"/>
                assert_eq!(r#strong, "code"); // <assertEquals actual="strong" expected="&quot;code&quot;" id="nodename" ignoreCase="auto"/>
                r#strong = r#test_employee.tag_name().to_string(); // <tagName obj="testEmployee" var="strong"/>
                assert_eq!(r#strong, "code"); // <assertEquals actual="strong" expected="&quot;code&quot;" id="tagname" ignoreCase="auto"/>
            }
            // hc_attrnormalize.xml
            #[test]
            fn test_hc_attrnormalize() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let mut r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#text_node = r#doc.create_text_node("terday"); // <createTextNode var="textNode" obj="doc" data="&quot;terday&quot;"/>
                r#retval = r#title_attr.append_child(text_node.into()).unwrap(); // <appendChild var="retval" obj="titleAttr" newChild="textNode"/>
                r#text_node = r#doc.create_text_node(""); // <createTextNode var="textNode" obj="doc" data="&quot;&quot;"/>
                r#retval = r#title_attr.append_child(text_node.into()).unwrap(); // <appendChild var="retval" obj="titleAttr" newChild="textNode"/>
                r#test_node.normalize(); // <normalize obj="testNode"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrNodeValue" ignoreCase="false"/>
                let r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                r#value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="firstChildValue" ignoreCase="false"/>
                let r#second_child = r#first_child.next_sibling(); // <nextSibling var="secondChild" obj="firstChild" interface="Node"/>
                assert!(second_child.is_none()); // <assertNull actual="secondChild" id="secondChildIsNull"/>
            }
            // hc_nodeappendchildchildexists.xml
            #[test]
            fn test_hc_nodeappendchildchildexists() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#child_node; // type: Node // <var name="childNode" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let mut r#member_name; // type: DOMString // <var name="memberName" type="DOMString"/>
                let mut r#refreshed_actual = vec![]; // type: List // <var name="refreshedActual" type="List"/>
                let mut r#actual = vec![]; // type: List // <var name="actual" type="List"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let r#expected = vec!["strong", "code", "sup", "var", "acronym", "em"]; // type: List // <var name="expected" type="List"><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member><member>"em"</member></var>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#child_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="childNode"/>
                r#child_list = r#child_node.get_elements_by_tag_name("*"); // <getElementsByTagName interface="Element" obj="childNode" var="childList" tagname="&quot;*&quot;"/>
                r#new_child = r#child_list.item(0).unwrap(); // <item interface="NodeList" obj="childList" index="0" var="newChild"/>
                r#appended_child = r#child_node.append_child(new_child.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="childNode" newChild="newChild"/>
                // <for-each collection="childList" member="memberNode">
                //  <nodeName var="memberName" obj="memberNode"/>
                //  <append collection="actual" item="memberName"/>
                // </for-each>
                for i in 0..child_list.length() {
                    let member_node = child_list.item(i).unwrap();
                    member_name = member_node.node_name().to_string();
                    actual.push(member_name);
                }
                assert_eq!(r#actual, expected); // <assertEquals id="liveByTagName" actual="actual" expected="expected" ignoreCase="auto"/>
                let r#child_list = r#child_node.child_nodes(); // <childNodes var="childList" obj="childNode"/>
                // <for-each collection="childList" member="memberNode">
                //  <nodeType var="nodeType" obj="memberNode"/>
                //  <if><equals actual="nodeType" expected="1"/>
                //      <nodeName var="memberName" obj="memberNode"/>
                //      <append collection="refreshedActual" item="memberName"/>
                //  </if>
                // </for-each>
                let len = child_list.length();
                for i in 0..len {
                    let member_node = child_list.item(i).unwrap();
                    node_type = member_node.node_type();
                    if node_type as i32 == 1 {
                        member_name = member_node.node_name().to_string();
                        refreshed_actual.push(member_name);
                    }
                }
                assert_eq!(r#refreshed_actual, expected); // <assertEquals id="refreshedChildNodes" actual="refreshedActual" expected="expected" ignoreCase="auto"/>
            }
            // namednodemapinuseattributeerr.xml
            #[test]
            fn test_namednodemapinuseattributeerr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#first_node; // type: Element // <var name="firstNode" type="Element"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#domestic_attr; // type: Attr // <var name="domesticAttr" type="Attr"/>
                let mut r#set_attr; // type: Attr // <var name="setAttr" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#first_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="firstNode" index="0"/>
                r#domestic_attr = r#doc.create_attribute("domestic".to_string()).unwrap(); // <createAttribute obj="doc" var="domesticAttr" name="&quot;domestic&quot;"/>
                r#domestic_attr.set_value("Yes").unwrap(); // <value interface="Attr" obj="domesticAttr" value="&quot;Yes&quot;"/>
                r#set_attr = r#first_node
                    .set_attribute_node(r#domestic_attr.clone())
                    .unwrap()
                    .unwrap(); // <setAttributeNode var="setAttr" obj="firstNode" newAttr="domesticAttr"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="2"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                // <assertDOMException id="throw_INUSE_ATTRIBUTE_ERR">
                //  <INUSE_ATTRIBUTE_ERR>
                //      <setNamedItem var="setNode" interface="NamedNodeMap" obj="attributes" arg="domesticAttr"/>
                //  </INUSE_ATTRIBUTE_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .set_named_item(domestic_attr)
                        .is_err_and(|err| err == DOMException::InuseAttributeErr)
                );
            }
            // nodehaschildnodes.xml
            #[test]
            fn test_nodehaschildnodes() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#state = r#employee_node.has_child_nodes(); // <hasChildNodes obj="employeeNode" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="nodeHasChildAssert1"/>
            }
            // processinginstructiongettarget.xml
            #[test]
            fn test_processinginstructiongettarget() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#child_nodes = r#doc.child_nodes(); // <childNodes obj="doc" var="childNodes"/>
                let r#pi_node = r#child_nodes
                    .item(0)
                    .unwrap()
                    .clone()
                    .as_processing_instruction()
                    .unwrap(); // <item interface="NodeList" obj="childNodes" var="piNode" index="0"/>
                let r#target = r#pi_node.target().to_string(); // <target obj="piNode" var="target" interface="ProcessingInstruction"/>
                assert_eq!(r#target, "TEST-STYLE"); // <assertEquals actual="target" expected="&quot;TEST-STYLE&quot;" id="processinginstructionGetTargetAssert" ignoreCase="false"/>
            }
            // nodecommentnodevalue.xml
            #[test]
            fn test_nodecommentnodevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#comment_node; // type: Node // <var name="commentNode" type="Node"/>
                let mut r#comment_name; // type: DOMString // <var name="commentName" type="DOMString"/>
                let mut r#comment_value; // type: DOMString // <var name="commentValue" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.child_nodes(); // <childNodes obj="doc" var="elementList"/>
                // <for-each collection="elementList" member="commentNode">
                //  <nodeName obj="commentNode" var="commentName"/>
                //  <if><equals actual="commentName" expected="&quot;#comment&quot;" ignoreCase="false"/>
                //      <nodeValue obj="commentNode" var="commentValue"/>
                //      <assertEquals actual="commentValue" expected="&quot; This is comment number 1.&quot;" id="value" ignoreCase="false"/>
                //  </if>
                // </for-each>
                let len = element_list.length();
                for i in 0..len {
                    comment_node = element_list.item(i).unwrap();
                    comment_name = comment_node.node_name().to_string();
                    if comment_name == "#comment" {
                        comment_value = comment_node.node_value().unwrap().to_string();
                        assert_eq!(comment_value, " This is comment number 1.");
                    }
                }
            }
            // characterdatadeletedataexceedslength.xml
            #[test]
            fn test_characterdatadeletedataexceedslength() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.delete_data(4, 50).unwrap(); // <deleteData obj="child" offset="4" count="50"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230"); // <assertEquals actual="childData" expected="&quot;1230&quot;" id="characterdataDeleteDataExceedsLengthAssert" ignoreCase="false"/>
            }
            // nodereplacechildnomodificationallowederrEE.xml
            #[test]
            fn test_nodereplacechildnomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                let r#ent_text = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" var="entText" obj="entRef"/>
                let r#created_node = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="createdNode"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <replaceChild var="replacedChild" obj="entRef" newChild="createdNode" oldChild="entText"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_ref
                        .replace_child(created_node.into(), ent_text)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // textsplittextnomodificationallowederr.xml
            #[test]
            fn test_textsplittextnomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender; // type: Node // <var name="gender" type="Node"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                let r#ent_element; // type: Node // <var name="entElement" type="Node"/>
                let mut r#ent_element_text; // type: Node // <var name="entElementText" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#ent_ref = r#gender.first_child().unwrap(); // <firstChild interface="Node" var="entRef" obj="gender"/>
                // unimplemented: // <assertNotNull actual="entRef" id="entRefNotNull"/>
                let r#node_type = r#ent_ref.node_type(); // <nodeType var="nodeType" obj="entRef"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    ent_ref = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#ent_element = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#ent_element_text = r#ent_element.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" var="entElementText" obj="entElement"/>
                // unimplemented: // <assertNotNull actual="entElementText" id="entElementTextNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <splitText var="splitNode" obj="entElementText" offset="2"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element_text
                        .split_text(2)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodelistreturnfirstitem.xml
            #[test]
            fn test_nodelistreturnfirstitem() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#child = r#employee_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="employeeList" var="child" index="0"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                let r#length = r#employee_list.length(); // <length var="length" obj="employeeList" interface="NodeList"/>
                // <if><equals actual="length" expected="6" ignoreCase="false"/>
                //  <assertEquals actual="childName" expected="&quot;employeeId&quot;" ignoreCase="true" id="firstChildNoWhitespace"/>
                // <else>
                //  <assertEquals actual="childName" expected="&quot;#text&quot;" ignoreCase="true" id="firstChildWithWhitespace"/>
                // </else>
                // </if>
                if length == 6 {
                    assert_eq!(child_name, "employeeId");
                } else {
                    assert_eq!(child_name, "#text");
                }
            }
            // hc_nodereplacechildnodename.xml
            #[test]
            fn test_hc_nodereplacechildnodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.get_elements_by_tag_name("em"); // <getElementsByTagName obj="employeeNode" var="childList" interface="Element" tagname="&quot;em&quot;"/>
                let r#old_child = r#child_list.item(0).unwrap(); // <item interface="NodeList" obj="childList" index="0" var="oldChild"/>
                let r#new_child = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="newChild"/>
                let r#replaced_node = r#employee_node
                    .replace_child(new_child.into(), old_child.into())
                    .unwrap(); // <replaceChild obj="employeeNode" newChild="newChild" oldChild="oldChild" var="replacedNode"/>
                let r#child_name = r#replaced_node.node_name().to_string(); // <nodeName obj="replacedNode" var="childName"/>
                assert_eq!(r#child_name, "em"); // <assertEquals actual="childName" expected="&quot;em&quot;" id="replacedNodeName" ignoreCase="auto"/>
            }
            // nodeclonegetparentnull.xml
            #[test]
            fn test_nodeclonegetparentnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#cloned_node = r#employee_node.clone_node(false); // <cloneNode obj="employeeNode" deep="false" var="clonedNode"/>
                let r#parent_node = r#cloned_node.parent_node(); // <parentNode interface="Node" obj="clonedNode" var="parentNode"/>
                assert!(parent_node.is_none()); // <assertNull actual="parentNode" id="nodeCloneGetParentNullAssert1"/>
            }
            // hc_nodecommentnodevalue.xml
            #[test]
            fn test_hc_nodecommentnodevalue() {
                let mut r#comment_name; // type: DOMString // <var name="commentName" type="DOMString"/>
                let mut r#comment_value; // type: DOMString // <var name="commentValue" type="DOMString"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.child_nodes(); // <childNodes obj="doc" var="elementList"/>
                // <for-each collection="elementList" member="commentNode">
                //  <nodeName obj="commentNode" var="commentName"/>
                //  <if><equals actual="commentName" expected="&quot;#comment&quot;" ignoreCase="false"/>
                //      <nodeValue obj="commentNode" var="commentValue"/>
                //      <assertEquals actual="commentValue" expected="&quot; This is comment number 1.&quot;" id="value" ignoreCase="false"/>
                //  </if>
                // </for-each>
                let len = element_list.length();
                for i in 0..len {
                    let comment_node = element_list.item(i).unwrap();
                    comment_name = comment_node.node_name().to_string();
                    if comment_name == "#comment" {
                        comment_value = comment_node.node_value().unwrap().to_string();
                        assert_eq!(comment_value, " This is comment number 1.");
                    }
                }
                let r#comment_node = r#doc.create_comment(" This is a comment"); // <createComment var="commentNode" obj="doc" data="&quot; This is a comment&quot;"/>
                r#comment_value = r#comment_node.node_value().unwrap().to_string(); // <nodeValue obj="commentNode" var="commentValue"/>
                assert_eq!(r#comment_value, " This is a comment"); // <assertEquals actual="commentValue" expected="&quot; This is a comment&quot;" id="createdCommentNodeValue" ignoreCase="false"/>
            }
            // textparseintolistofelements.xml
            #[test]
            fn test_textparseintolistofelements() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#address_node; // type: Node // <var name="addressNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let mut r#grand_child; // type: Node // <var name="grandChild" type="Node"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let r#expected_normal = vec!["1900 Dallas Road", " Dallas, ", "Texas", "\n 98554"]; // type: List // <var name="expectedNormal" type="List"><member>"1900 Dallas Road"</member><member>" Dallas, "</member><member>"Texas"</member><member>"\n 98554"</member></var>
                let r#expected_expanded = vec!["1900 Dallas Road Dallas, Texas\n 98554"]; // type: List // <var name="expectedExpanded" type="List"><member>"1900 Dallas Road Dallas, Texas\n 98554"</member></var>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#address_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="addressNode" index="1"/>
                r#child_list = r#address_node.child_nodes(); // <childNodes obj="addressNode" var="childList"/>
                let r#length = r#child_list.length(); // <length var="length" obj="childList" interface="NodeList"/>
                // <for-each collection="childList" member="child">
                //  <nodeValue obj="child" var="value"/>
                //  <if><isNull obj="value"/>
                //      <firstChild interface="Node" obj="child" var="grandChild"/>
                //      <assertNotNull actual="grandChild" id="grandChildNotNull"/>
                //      <nodeValue obj="grandChild" var="value"/>
                //      <append collection="result" item="value"/>
                //  <else>
                //      <append collection="result" item="value"/>
                //  </else>
                //  </if>
                // </for-each>
                for i in 0..length {
                    child = child_list.item(i).unwrap();
                    value = child.node_value();
                    if let Some(value) = value {
                        result.push(value.to_string());
                    } else {
                        grand_child = child.first_child().unwrap();
                        let value = grand_child.node_value().unwrap().to_string();
                        result.push(value);
                    }
                }
                // <if><equals actual="length" expected="4" ignoreCase="false"/>
                //  <assertEquals actual="result" expected="expectedNormal" ignoreCase="false" id="assertEqNormal"/>
                // <else>
                //  <assertEquals actual="result" expected="expectedExpanded" ignoreCase="false" id="assertEqCoalescing"/>
                // </else>
                // </if>
                if length == 4 {
                    assert_eq!(result, expected_normal);
                } else {
                    assert_eq!(result, expected_expanded);
                }
            }
            // hc_textparseintolistofelements.xml
            #[test]
            fn test_hc_textparseintolistofelements() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#address_node; // type: Node // <var name="addressNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let mut r#grand_child; // type: Node // <var name="grandChild" type="Node"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let r#expected_normal = vec!["β", " Dallas, ", "γ", "\n 98554"]; // type: List // <var name="expectedNormal" type="List"><member>"β"</member><member>" Dallas, "</member><member>"γ"</member><member>"\n 98554"</member></var>
                let r#expected_expanded = vec!["β Dallas, γ\n 98554"]; // type: List // <var name="expectedExpanded" type="List"><member>"β Dallas, γ\n 98554"</member></var>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                r#address_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="addressNode" index="1"/>
                r#child_list = r#address_node.child_nodes(); // <childNodes obj="addressNode" var="childList"/>
                let r#length = r#child_list.length(); // <length var="length" obj="childList" interface="NodeList"/>
                // <for-each collection="childList" member="child">
                //  <nodeValue obj="child" var="value"/>
                //  <if><isNull obj="value"/>
                //      <firstChild interface="Node" obj="child" var="grandChild"/>
                //      <assertNotNull actual="grandChild" id="grandChildNotNull"/>
                //      <nodeValue obj="grandChild" var="value"/>
                //      <append collection="result" item="value"/>
                //  <else>
                //      <append collection="result" item="value"/>
                //  </else>
                //  </if>
                // </for-each>
                for i in 0..length {
                    let child = child_list.item(i).unwrap();
                    value = child.node_value();
                    if let Some(value) = value {
                        result.push(value.to_string());
                    } else {
                        grand_child = child.first_child().unwrap();
                        result.push(grand_child.node_value().unwrap().to_string());
                    }
                }
                // <if><equals actual="length" expected="1" ignoreCase="false"/>
                //  <assertEquals actual="result" expected="expectedExpanded" ignoreCase="false" id="assertEqCoalescing"/>
                // <else>
                //  <assertEquals actual="result" expected="expectedNormal" ignoreCase="false" id="assertEqNormal"/>
                // </else>
                // </if>
                if length == 1 {
                    assert_eq!(result, expected_expanded);
                } else {
                    assert_eq!(result, expected_normal);
                }
            }
            // nodeinsertbeforenewchildexists.xml
            #[test]
            fn test_nodeinsertbeforenewchildexists() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#inserted_node; // type: Node // <var name="insertedNode" type="Node"/>
                let r#expected_whitespace = vec![
                    "#text",
                    "#text",
                    "name",
                    "#text",
                    "position",
                    "#text",
                    "salary",
                    "#text",
                    "gender",
                    "#text",
                    "employeeId",
                    "address",
                    "#text",
                ]; // type: List // <var name="expectedWhitespace" type="List"><member>"#text"</member><member>"#text"</member><member>"name"</member><member>"#text"</member><member>"position"</member><member>"#text"</member><member>"salary"</member><member>"#text"</member><member>"gender"</member><member>"#text"</member><member>"employeeId"</member><member>"address"</member><member>"#text"</member></var>
                let r#expected_no_whitespace = vec![
                    "name",
                    "position",
                    "salary",
                    "gender",
                    "employeeId",
                    "address",
                ]; // type: List // <var name="expectedNoWhitespace" type="List"><member>"name"</member><member>"position"</member><member>"salary"</member><member>"gender"</member><member>"employeeId"</member><member>"address"</member></var>
                let r#expected; // type: List // <var name="expected" type="List"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#length = r#child_list.length(); // <length var="length" obj="childList" interface="NodeList"/>
                // <if><equals actual="length" expected="6" ignoreCase="false"/>
                //  <assign var="expected" value="expectedNoWhitespace"/>
                //  <item interface="NodeList" obj="childList" index="5" var="refChild"/>
                //  <item interface="NodeList" obj="childList" index="0" var="newChild"/>
                // <else>
                //  <assign var="expected" value="expectedWhitespace"/>
                //  <item interface="NodeList" obj="childList" index="11" var="refChild"/>
                //  <item interface="NodeList" obj="childList" index="1" var="newChild"/>
                // </else>
                // </if>
                if length == 6 {
                    expected = expected_no_whitespace.clone();
                    ref_child = child_list.item(5).unwrap();
                    new_child = child_list.item(0).unwrap();
                } else {
                    expected = expected_whitespace.clone();
                    ref_child = child_list.item(11).unwrap();
                    new_child = child_list.item(1).unwrap();
                }
                r#inserted_node = r#employee_node
                    .insert_before(new_child, Some(ref_child))
                    .unwrap(); // <insertBefore var="insertedNode" obj="employeeNode" newChild="newChild" refChild="refChild"/>
                // <for-each collection="childList" member="child">
                //  <nodeName obj="child" var="childName"/>
                //  <append collection="result" item="childName"/>
                // </for-each>
                let len = child_list.length();
                for i in 0..len {
                    child = child_list.item(i).unwrap();
                    child_name = child.node_name().to_string();
                    result.push(child_name);
                }
                assert_eq!(r#result, expected); // <assertEquals id="childNames" actual="result" expected="expected" ignoreCase="false"/>
            }
            // characterdatasetdatanomodificationallowederr.xml
            #[test]
            fn test_characterdatasetdatanomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let r#ent_element; // type: Node // <var name="entElement" type="Node"/>
                let mut r#ent_element_content; // type: Node // <var name="entElementContent" type="Node"/>
                let mut r#ent_reference; // type: Node // <var name="entReference" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" index="2" var="genderNode"/>
                r#ent_reference = r#gender_node.first_child().unwrap(); // <firstChild var="entReference" obj="genderNode" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entReference" id="entReferenceNotNull"/>
                let r#node_type = r#ent_reference.node_type(); // <nodeType var="nodeType" obj="entReference"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="entReference" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="entReference" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    ent_reference = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#ent_element = r#ent_reference.first_child().unwrap(); // <firstChild var="entElement" obj="entReference" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#ent_element_content =
                    r#ent_element.first_child().unwrap().as_text_node().unwrap(); // <firstChild var="entElementContent" obj="entElement" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElementContent" id="entElementContentNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <data interface="CharacterData" obj="entElementContent" value="&quot;newData&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element_content
                        .set_data("newData")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // attrcreatetextnode2.xml
            #[test]
            fn test_attrcreatetextnode2() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#address_list; // type: NodeList // <var name="addressList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#street_attr; // type: Attr // <var name="streetAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                r#test_node = r#address_list.item(3).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                r#street_attr.set_node_value("Y&ent1;").unwrap(); // <nodeValue obj="streetAttr" value="&quot;Y&amp;ent1;&quot;"/>
                r#value = r#street_attr.value().to_string(); // <value interface="Attr" obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Y&ent1;"); // <assertEquals actual="value" expected="&quot;Y&amp;ent1;&quot;" id="value" ignoreCase="false"/>
                r#value = r#street_attr.node_value().unwrap().to_string(); // <nodeValue obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Y&ent1;"); // <assertEquals actual="value" expected="&quot;Y&amp;ent1;&quot;" id="nodeValue" ignoreCase="false"/>
            }
            // textsplittextthree.xml
            #[test]
            fn test_textsplittextthree() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;name&quot;"/>
                r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                r#text_node = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="textNode"/>
                let r#split_node = r#text_node.split_text(6).unwrap(); // <splitText obj="textNode" var="splitNode" offset="6"/>
                let r#value = r#split_node.node_value().unwrap().to_string(); // <nodeValue obj="splitNode" var="value"/>
                assert_eq!(r#value, " Jones"); // <assertEquals actual="value" expected="&quot; Jones&quot;" id="textSplitTextThreeAssert" ignoreCase="false"/>
            }
            // documentinvalidcharacterexceptioncreatepi1.xml
            #[test]
            fn test_documentinvalidcharacterexceptioncreatepi1() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#bad_pi; // type: ProcessingInstruction // <var name="badPI" type="ProcessingInstruction"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // unimplemented:
                // <if><contentType type="text/html"/>
                //  <assertDOMException id="throw_NOT_SUPPORTED_ERR">
                //      <NOT_SUPPORTED_ERR>
                //          <createProcessingInstruction var="badPI" obj="doc" target="&quot;foo&quot;" data="&quot;data&quot;"/>
                //      </NOT_SUPPORTED_ERR>
                //  </assertDOMException>
                // <else>
                //  <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //      <INVALID_CHARACTER_ERR>
                //          <createProcessingInstruction var="badPI" obj="doc" target="&quot;&quot;" data="&quot;data&quot;"/>
                //      </INVALID_CHARACTER_ERR>
                //  </assertDOMException>
                // </else>
                // </if>
            }
            // nodeappendchilddocfragment.xml
            #[test]
            fn test_nodeappendchilddocfragment() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#newdoc_fragment; // type: DocumentFragment // <var name="newdocFragment" type="DocumentFragment"/>
                let r#new_child1; // type: Node // <var name="newChild1" type="Node"/>
                let r#new_child2; // type: Node // <var name="newChild2" type="Node"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let r#expected = vec![
                    "employeeId",
                    "name",
                    "position",
                    "salary",
                    "gender",
                    "address",
                    "newChild1",
                    "newChild2",
                ]; // type: List // <var name="expected" type="List"><member>"employeeId"</member><member>"name"</member><member>"position"</member><member>"salary"</member><member>"gender"</member><member>"address"</member><member>"newChild1"</member><member>"newChild2"</member></var>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#newdoc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="newdocFragment"/>
                r#new_child1 = r#doc.create_element("newChild1".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild1&quot;" var="newChild1"/>
                r#new_child2 = r#doc.create_element("newChild2".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild2&quot;" var="newChild2"/>
                r#appended_child = r#newdoc_fragment.append_child(new_child1.into()).unwrap(); // <appendChild var="appendedChild" obj="newdocFragment" newChild="newChild1"/>
                r#appended_child = r#newdoc_fragment.append_child(new_child2.into()).unwrap(); // <appendChild var="appendedChild" obj="newdocFragment" newChild="newChild2"/>
                r#appended_child = r#employee_node
                    .append_child(newdoc_fragment.into())
                    .unwrap(); // <appendChild var="appendedChild" obj="employeeNode" newChild="newdocFragment"/>
                // <for-each collection="childList" member="child">
                //  <nodeType var="nodeType" obj="child"/>
                //  <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //      <nodeName var="childName" obj="child"/>
                //      <append collection="result" item="childName"/>
                //  </if>
                // </for-each>
                let len = child_list.length();
                for i in 0..len {
                    child = child_list.item(i).unwrap();
                    node_type = child.node_type();
                    if node_type as i32 == 1 {
                        child_name = child.node_name().to_string();
                        result.push(child_name);
                    }
                }
                assert_eq!(r#result, expected); // <assertEquals actual="result" expected="expected" ignoreCase="false" id="elementNames"/>
            }
            // characterdatareplacedataend.xml
            #[test]
            fn test_characterdatareplacedataend() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.replace_data(30, 5, "98665").unwrap(); // <replaceData obj="child" offset="30" count="5" arg="&quot;98665&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230 North Ave. Dallas, Texas 98665"); // <assertEquals actual="childData" expected="&quot;1230 North Ave. Dallas, Texas 98665&quot;" id="characterdataReplaceDataEndAssert" ignoreCase="false"/>
            }
            // hc_nodegetnextsibling.xml
            #[test]
            fn test_hc_nodegetnextsibling() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;em&quot;" var="elementList"/>
                let r#em_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="emNode"/>
                let r#ns_node = r#em_node.next_sibling().unwrap(); // <nextSibling interface="Node" obj="emNode" var="nsNode"/>
                let r#ns_name = r#ns_node.node_name().to_string(); // <nodeName obj="nsNode" var="nsName"/>
                assert_eq!(r#ns_name, "#text"); // <assertEquals actual="nsName" expected="&quot;#text&quot;" id="whitespace" ignoreCase="false"/>
            }
            // hc_nodeelementnodetype.xml
            #[test]
            fn test_hc_nodeelementnodetype() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                let r#node_type = r#root_node.node_type(); // <nodeType obj="rootNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 1); // <assertEquals actual="nodeType" expected="1" id="nodeElementNodeTypeAssert1" ignoreCase="false"/>
            }
            // textsplittextnomodificationallowederrEE.xml
            #[test]
            fn test_textsplittextnomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                let mut r#ent_text; // type: Node // <var name="entText" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#ent_ref = r#doc.create_entity_reference("ent3".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent3&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                r#ent_text = r#ent_ref.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" var="entText" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entText" id="entTextNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <splitText var="splitNode" obj="entText" offset="2"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_text
                        .split_text(2)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodenotationnodename.xml
            #[test]
            fn test_nodenotationnodename() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#notations = doc_type.notations(); // <notations obj="docType" var="notations"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                let r#notation_node = r#notations.get_named_item("notation1").unwrap(); // <getNamedItem obj="notations" name="&quot;notation1&quot;" var="notationNode"/>
                // unimplemented: // <assertNotNull actual="notationNode" id="notationNotNull"/>
                let r#notation_name = r#notation_node.node_name().to_string(); // <nodeName obj="notationNode" var="notationName"/>
                assert_eq!(r#notation_name, "notation1"); // <assertEquals actual="notationName" expected="&quot;notation1&quot;" id="nodeName" ignoreCase="false"/>
            }
            // hc_attrcreatedocumentfragment.xml
            #[test]
            fn test_hc_attrcreatedocumentfragment() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_fragment; // type: DocumentFragment // <var name="docFragment" type="DocumentFragment"/>
                let mut r#new_one; // type: Element // <var name="newOne" type="Element"/>
                let r#domestic_node; // type: Node // <var name="domesticNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#lang_attr_count = 0; // type: int // <var name="langAttrCount" type="int" value="0"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="docFragment"/>
                r#new_one = r#doc.create_element("html".to_string()).unwrap(); // <createElement obj="doc" var="newOne" tagName="&quot;html&quot;"/>
                r#new_one.set_attribute("lang", "EN").unwrap(); // <setAttribute obj="newOne" name="&quot;lang&quot;" value="&quot;EN&quot;"/>
                r#appended_child = r#doc_fragment.append_child(new_one.into()).unwrap(); // <appendChild var="appendedChild" obj="docFragment" newChild="newOne"/>
                r#domestic_node = r#doc_fragment.first_child().unwrap(); // <firstChild interface="Node" obj="docFragment" var="domesticNode"/>
                r#attributes = r#domestic_node.attributes().unwrap(); // <attributes obj="domesticNode" var="attributes"/>
                // <for-each collection="attributes" member="attribute">
                //  <nodeName var="attrName" obj="attribute"/>
                //  <if><equals expected="&quot;lang&quot;" actual="attrName" ignoreCase="auto" context="attribute"/>
                //      <increment var="langAttrCount" value="1"/>
                //  </if>
                // </for-each>
                for i in 0..attributes.length() {
                    attribute = attributes.item(i).unwrap();
                    attr_name = attribute.node_name().to_string();
                    if attr_name == "lang" {
                        lang_attr_count += 1;
                    }
                }
                assert_eq!(r#lang_attr_count, 1); // <assertEquals expected="1" actual="langAttrCount" id="hasLangAttr" ignoreCase="false"/>
            }
            // nodeattributenodevalue.xml
            #[test]
            fn test_nodeattributenodevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#addr_attr = r#test_addr.get_attribute_node("domestic").unwrap(); // <getAttributeNode obj="testAddr" name="&quot;domestic&quot;" var="addrAttr"/>
                let r#attr_value = r#addr_attr.node_value().unwrap().to_string(); // <nodeValue obj="addrAttr" var="attrValue"/>
                assert_eq!(r#attr_value, "Yes"); // <assertEquals actual="attrValue" expected="&quot;Yes&quot;" id="nodeAttributeNodeValueAssert1" ignoreCase="false"/>
            }
            // nodereplacechildoldchildnonexistent.xml
            #[test]
            fn test_nodereplacechildoldchildnonexistent() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_child = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="newChild"/>
                r#old_child = r#doc.create_element("oldChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;oldChild&quot;" var="oldChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <replaceChild var="replacedNode" obj="elementNode" newChild="newChild" oldChild="oldChild"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .replace_child(new_child.into(), old_child.into())
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // hc_elementgetattributenodenull.xml
            #[test]
            fn test_hc_elementgetattributenodenull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                let r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                let r#domestic_attr = r#test_employee.get_attribute_node("invalidAttribute"); // <getAttributeNode obj="testEmployee" var="domesticAttr" name="&quot;invalidAttribute&quot;"/>
                assert!(domestic_attr.is_none()); // <assertNull actual="domesticAttr" id="elementGetAttributeNodeNullAssert"/>
            }
            // namednodemapreturnlastitem.xml
            #[test]
            fn test_namednodemapreturnlastitem() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="1"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#child = r#attributes.item(1).unwrap(); // <item interface="NamedNodeMap" obj="attributes" var="child" index="1"/>
                let r#name = r#child.node_name().to_string(); // <nodeName obj="child" var="name"/>
                // <assertTrue id="namednodemapReturnLastItemAssert">
                //  <or>
                //      <equals actual="name" expected="&quot;domestic&quot;" ignoreCase="false"/>
                //      <equals actual="name" expected="&quot;street&quot;" ignoreCase="false"/>
                //  </or>
                // </assertTrue>
                assert!(name == "domestic" || name == "street")
            }
            // hc_attrremovechild1.xml
            #[test]
            fn test_hc_attrremovechild1() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                let r#text_node = r#title_attr.first_child().unwrap(); // <firstChild var="textNode" obj="titleAttr" interface="Node"/>
                // unimplemented: // <assertNotNull actual="textNode" id="attrChildNotNull"/>
                let r#retval = r#title_attr.remove_child(text_node).unwrap(); // <removeChild var="retval" obj="titleAttr" oldChild="textNode"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, ""); // <assertEquals actual="value" expected="&quot;&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, ""); // <assertEquals actual="value" expected="&quot;&quot;" id="attrNodeValue" ignoreCase="false"/>
                r#value = r#retval.node_value().unwrap().to_string(); // <nodeValue obj="retval" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="retvalValue" ignoreCase="false"/>
                let r#first_child = r#title_attr.first_child(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                assert!(first_child.is_none()); // <assertNull actual="firstChild" id="firstChildNull"/>
            }
            // hc_elementreplaceexistingattributegevalue.xml
            #[test]
            fn test_hc_elementreplaceexistingattributegevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                let r#new_attribute = r#doc.create_attribute("class".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;class&quot;"/>
                let r#street_attr = r#test_employee
                    .set_attribute_node(r#new_attribute)
                    .unwrap()
                    .unwrap(); // <setAttributeNode obj="testEmployee" var="streetAttr" newAttr="newAttribute"/>
                // unimplemented: // <assertNotNull actual="streetAttr" id="previousAttrNotNull"/>
                let r#value = r#street_attr.value().to_string(); // <value interface="Attr" obj="streetAttr" var="value"/>
                assert_eq!(r#value, "No"); // <assertEquals actual="value" expected="&quot;No&quot;" id="previousAttrValue" ignoreCase="false"/>
            }
            // nodeinsertbeforerefchildnonexistent.xml
            #[test]
            fn test_nodeinsertbeforerefchildnonexistent() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_child = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="newChild"/>
                r#ref_child = r#doc.create_element("refChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;refChild&quot;" var="refChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <insertBefore var="insertedNode" obj="elementNode" newChild="newChild" refChild="refChild"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .insert_before(new_child.into(), Some(ref_child.into()))
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // hc_entitiesremovenameditem1.xml
            #[test]
            fn test_hc_entitiesremovenameditem1() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented:
                // // <if><not><contentType type="text/html"/></not>
                // //  <assertNotNull actual="docType" id="docTypeNotNull"/>
                // //  <entities var="entities" obj="docType"/>
                // //  <assertNotNull actual="entities" id="entitiesNotNull"/>
                // //  <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                // //      <NO_MODIFICATION_ALLOWED_ERR>
                // //          <removeNamedItem var="retval" obj="entities" name="&quot;alpha&quot;"/>
                // //      </NO_MODIFICATION_ALLOWED_ERR>
                // //  </assertDOMException>
                // // </if>
            }
            // hc_namednodemapgetnameditem.xml
            #[test]
            fn test_hc_namednodemapgetnameditem() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                let r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="1"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;title&quot;"/>
                let r#attr_name = r#domestic_attr.node_name().to_string(); // <nodeName obj="domesticAttr" var="attrName"/>
                assert_eq!(r#attr_name, "title"); // <assertEquals actual="attrName" expected="&quot;title&quot;" id="nodeName" ignoreCase="auto" context="attribute"/>
            }
            // hc_nodeinsertbeforenewchildexists.xml
            #[test]
            fn test_hc_nodeinsertbeforenewchildexists() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#inserted_node; // type: Node // <var name="insertedNode" type="Node"/>
                let r#expected = vec!["strong", "code", "sup", "var", "em", "acronym"]; // type: List // <var name="expected" type="List"><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"em"</member><member>"acronym"</member></var>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.get_elements_by_tag_name("*"); // <getElementsByTagName interface="Element" obj="employeeNode" tagname="&quot;*&quot;" var="childList"/>
                r#ref_child = r#child_list.item(5).unwrap(); // <item interface="NodeList" obj="childList" index="5" var="refChild"/>
                r#new_child = r#child_list.item(0).unwrap(); // <item interface="NodeList" obj="childList" index="0" var="newChild"/>
                r#inserted_node = r#employee_node
                    .insert_before(new_child.into(), Some(ref_child.into()))
                    .unwrap(); // <insertBefore var="insertedNode" obj="employeeNode" newChild="newChild" refChild="refChild"/>
                // <for-each collection="childList" member="child">
                //  <nodeType obj="child" var="nodeType"/>
                //  <if><equals actual="nodeType" expected="1"/>
                //      <nodeName obj="child" var="childName"/>
                //      <append collection="result" item="childName"/>
                //  </if>
                // </for-each>
                for i in 0..child_list.length() {
                    let child = child_list.item(i).unwrap();
                    node_type = child.node_type();
                    if node_type as i32 == 1 {
                        child_name = child.node_name().to_string();
                        result.push(child_name);
                    }
                }
                assert_eq!(r#result, expected); // <assertEquals id="childNames" actual="result" expected="expected" ignoreCase="auto"/>
            }
            // hc_nodeattributenodeattribute.xml
            #[test]
            fn test_hc_nodeattributenodeattribute() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#addr_attr = r#test_addr.attributes(); // <attributes obj="testAddr" var="addrAttr"/>
                let r#attr_node = r#addr_attr.item(0).unwrap(); // <item interface="NamedNodeMap" obj="addrAttr" var="attrNode" index="0"/>
                let r#attr_list = r#attr_node.attributes(); // <attributes obj="attrNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="nodeAttributeNodeAttributeAssert1"/>
            }
            // hc_nodeclonenodefalse.xml
            #[test]
            fn test_hc_nodeclonenodefalse() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#cloned_node = r#employee_node.clone_node(false); // <cloneNode obj="employeeNode" deep="false" var="clonedNode"/>
                let r#clone_name = r#cloned_node.node_name().to_string(); // <nodeName obj="clonedNode" var="cloneName"/>
                assert_eq!(r#clone_name, "p"); // <assertEquals actual="cloneName" expected="&quot;p&quot;" ignoreCase="auto" id="strong"/>
                let r#clone_children = r#cloned_node.child_nodes(); // <childNodes obj="clonedNode" var="cloneChildren"/>
                let r#length = r#clone_children.length(); // <length interface="NodeList" obj="cloneChildren" var="length"/>
                assert_eq!(r#length, 0); // <assertEquals actual="length" expected="0" ignoreCase="false" id="length"/>
            }
            // nodeentitynodevalue.xml
            #[test]
            fn test_nodeentitynodevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#entities = doc_type.entities(); // <entities obj="docType" var="entities"/>
                // unimplemented: // <assertNotNull actual="entities" id="entitiesNotNull"/>
                let r#entity_node = r#entities.get_named_item("ent1").unwrap(); // <getNamedItem obj="entities" name="&quot;ent1&quot;" var="entityNode"/>
                // unimplemented: // <assertNotNull actual="entityNode" id="ent1NotNull"/>
                let r#entity_value = r#entity_node.node_value(); // <nodeValue obj="entityNode" var="entityValue"/>
                assert!(entity_value.is_none()); // <assertNull actual="entityValue" id="entityNodeValue"/>
            }
            // elementsetattributenodenull.xml
            #[test]
            fn test_elementsetattributenodenull() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                let r#new_attribute = r#doc.create_attribute("district".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;district&quot;"/>
                let r#district_attr = r#test_employee.set_attribute_node(r#new_attribute).unwrap(); // <setAttributeNode obj="testEmployee" var="districtAttr" newAttr="newAttribute"/>
                assert!(district_attr.is_none()); // <assertNull actual="districtAttr" id="elementSetAttributeNodeNullAssert"/>
            }
            // nodeentityreferencenodename.xml
            #[test]
            fn test_nodeentityreferencenodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#ent_ref_addr; // type: Element // <var name="entRefAddr" type="Element"/>
                let mut r#ent_ref_node; // type: Node // <var name="entRefNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#ent_ref_addr = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="entRefAddr"/>
                r#ent_ref_node = r#ent_ref_addr.first_child().unwrap(); // <firstChild interface="Node" obj="entRefAddr" var="entRefNode"/>
                let r#node_type = r#ent_ref_node.node_type(); // <nodeType var="nodeType" obj="entRefNode"/>
                // <if><notEquals actual="nodeType" expected="5" ignoreCase="false"/>
                //  <createEntityReference var="entRefNode" obj="doc" name="&quot;ent2&quot;"/>
                //  <assertNotNull actual="entRefNode" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 5 {
                    ent_ref_node = doc.create_entity_reference("ent2").unwrap().into();
                }
                let r#ent_ref_name = r#ent_ref_node.node_name().to_string(); // <nodeName obj="entRefNode" var="entRefName"/>
                assert_eq!(r#ent_ref_name, "ent2"); // <assertEquals actual="entRefName" expected="&quot;ent2&quot;" id="nodeEntityReferenceNodeNameAssert1" ignoreCase="false"/>
            }
            // nodeparentnode.xml
            #[test]
            fn test_nodeparentnode() {
                let mut r#parent_name; // type: DOMString // <var name="parentName" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#parent_node = r#employee_node.parent_node().unwrap(); // <parentNode interface="Node" obj="employeeNode" var="parentNode"/>
                r#parent_name = r#parent_node.node_name().to_string(); // <nodeName obj="parentNode" var="parentName"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //  <assertEquals actual="parentName" expected="&quot;svg&quot;" id="svgTagName" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="parentName" expected="&quot;staff&quot;" id="nodeParentNodeAssert1" ignoreCase="false"/>
                // </else>
                // </if>
            }
            // hc_documentgetimplementation.xml
            #[test]
            fn test_hc_documentgetimplementation() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_impl; // type: DOMImplementation // <var name="docImpl" type="DOMImplementation"/>
                // let mut r#xmlstate; // type: boolean // <var name="xmlstate" type="boolean"/>
                // let mut r#htmlstate; // type: boolean // <var name="htmlstate" type="boolean"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="docImpl"/>

                // // unimplemented: // <hasFeature obj="docImpl" var="xmlstate" feature="&quot;XML&quot;" version="&quot;1.0&quot;"/>

                // // unimplemented: // <hasFeature obj="docImpl" var="htmlstate" feature="&quot;HTML&quot;" version="&quot;1.0&quot;"/>

                // // unimplemented: // <if><contentType type="text/html"/><assertTrue actual="htmlstate" id="supports_HTML_1.0"/><else><assertTrue actual="xmlstate" id="supports_XML_1.0"/></else></if>
            }
            // documentcreateelementcasesensitive.xml
            #[test]
            fn test_documentcreateelementcasesensitive() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_element1; // type: Element // <var name="newElement1" type="Element"/>
                let mut r#new_element2; // type: Element // <var name="newElement2" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_element1 = r#doc.create_element("ADDRESS".to_string()).unwrap(); // <createElement obj="doc" var="newElement1" tagName="&quot;ADDRESS&quot;"/>
                r#new_element2 = r#doc.create_element("address".to_string()).unwrap(); // <createElement obj="doc" var="newElement2" tagName="&quot;address&quot;"/>
                r#new_element1
                    .set_attribute("district", "Fort Worth")
                    .unwrap(); // <setAttribute obj="newElement1" name="&quot;district&quot;" value="&quot;Fort Worth&quot;"/>
                r#new_element2.set_attribute("county", "Dallas").unwrap(); // <setAttribute obj="newElement2" name="&quot;county&quot;" value="&quot;Dallas&quot;"/>
                let r#attribute1 = r#new_element1.get_attribute("district"); // <getAttribute obj="newElement1" var="attribute1" name="&quot;district&quot;"/>
                let r#attribute2 = r#new_element2.get_attribute("county"); // <getAttribute obj="newElement2" var="attribute2" name="&quot;county&quot;"/>
                assert_eq!(r#attribute1, "Fort Worth"); // <assertEquals actual="attribute1" expected="&quot;Fort Worth&quot;" ignoreCase="false" id="attrib1"/>
                assert_eq!(r#attribute2, "Dallas"); // <assertEquals actual="attribute2" expected="&quot;Dallas&quot;" ignoreCase="false" id="attrib2"/>
            }
            // hc_nodetextnodevalue.xml
            #[test]
            fn test_hc_nodetextnodevalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#text_node = r#test_addr.first_child().unwrap(); // <firstChild interface="Node" obj="testAddr" var="textNode"/>
                let r#text_value = r#text_node.node_value().unwrap().to_string(); // <nodeValue obj="textNode" var="textValue"/>
                assert_eq!(r#text_value, "1230 North Ave. Dallas, Texas 98551"); // <assertEquals actual="textValue" expected="&quot;1230 North Ave. Dallas, Texas 98551&quot;" id="textNodeValue" ignoreCase="false"/>
            }
            // characterdatagetlength.xml
            #[test]
            fn test_characterdatagetlength() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                let r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                let r#child_value = r#child.data().to_string(); // <data var="childValue" obj="child" interface="CharacterData"/>
                let r#child_length = r#child_value.len(); // <length var="childLength" obj="childValue" interface="DOMString"/>
                assert_eq!(r#child_length, 15); // <assertEquals actual="childLength" expected="15" ignoreCase="false" id="characterdataGetLengthAssert"/>
            }
            // hc_nodeclonegetparentnull.xml
            #[test]
            fn test_hc_nodeclonegetparentnull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#cloned_node = r#employee_node.clone_node(false); // <cloneNode obj="employeeNode" deep="false" var="clonedNode"/>
                let r#parent_node = r#cloned_node.parent_node(); // <parentNode interface="Node" obj="clonedNode" var="parentNode"/>
                assert!(parent_node.is_none()); // <assertNull actual="parentNode" id="nodeCloneGetParentNullAssert1"/>
            }
            // nodeentitynodename.xml
            #[test]
            fn test_nodeentitynodename() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#entities = doc_type.entities(); // <entities obj="docType" var="entities"/>
                // unimplemented: // <assertNotNull actual="entities" id="entitiesNotNull"/>
                let r#entity_node = r#entities.get_named_item("ent1").unwrap(); // <getNamedItem obj="entities" name="&quot;ent1&quot;" var="entityNode"/>
                // unimplemented: // <assertNotNull actual="entityNode" id="entityNodeNotNull"/>
                let r#entity_name = r#entity_node.node_name().to_string(); // <nodeName obj="entityNode" var="entityName"/>
                assert_eq!(r#entity_name, "ent1"); // <assertEquals actual="entityName" expected="&quot;ent1&quot;" id="entityNodeName" ignoreCase="false"/>
            }
            // characterdatadeletedatanomodificationallowederr.xml
            #[test]
            fn test_characterdatadeletedatanomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let r#ent_element; // type: Node // <var name="entElement" type="Node"/>
                let mut r#ent_element_content; // type: Node // <var name="entElementContent" type="Node"/>
                let mut r#ent_reference; // type: Node // <var name="entReference" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" index="2" var="genderNode"/>
                r#ent_reference = r#gender_node.first_child().unwrap(); // <firstChild var="entReference" obj="genderNode" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entReference" id="entReferenceNotNull"/>
                let r#node_type = r#ent_reference.node_type(); // <nodeType var="nodeType" obj="entReference"/>
                // <if><equals actual="nodeType" expected="3"/>
                //  <createEntityReference var="entReference" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="entReference" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 3 {
                    ent_reference = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#ent_element = r#ent_reference.first_child().unwrap(); // <firstChild var="entElement" obj="entReference" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#ent_element_content =
                    r#ent_element.first_child().unwrap().as_text_node().unwrap(); // <firstChild var="entElementContent" obj="entElement" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElementContent" id="entElementContentNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <deleteData obj="entElementContent" offset="1" count="3"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element_content
                        .delete_data(1, 3)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodegetnextsiblingnull.xml
            #[test]
            fn test_nodegetnextsiblingnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#lc_node = r#employee_node.last_child().unwrap(); // <lastChild interface="Node" obj="employeeNode" var="lcNode"/>
                let r#ns_node = r#lc_node.next_sibling(); // <nextSibling interface="Node" obj="lcNode" var="nsNode"/>
                assert!(ns_node.is_none()); // <assertNull actual="nsNode" id="nodeGetNextSiblingNullAssert1"/>
            }
            // hc_domimplementationfeaturenoversion.xml
            #[test]
            fn test_hc_domimplementationfeaturenoversion() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <if><contentType type="text/html"/><hasFeature obj="domImpl" var="state" feature="&quot;HTML&quot;" version="&quot;&quot;"/><else><hasFeature obj="domImpl" var="state" feature="&quot;XML&quot;" version="&quot;&quot;"/></else></if>
                // assert!(r#state); // <assertTrue actual="state" id="hasFeatureBlank"/>
            }
            // elementaddnewattribute.xml
            #[test]
            fn test_elementaddnewattribute() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(4).unwrap(); // <item interface="NodeList" obj="elementList" index="4" var="testEmployee"/>
                r#test_employee.set_attribute("district", "dallas").unwrap(); // <setAttribute obj="testEmployee" name="&quot;district&quot;" value="&quot;dallas&quot;"/>
                let r#attr_value = r#test_employee.get_attribute("district"); // <getAttribute obj="testEmployee" var="attrValue" name="&quot;district&quot;"/>
                assert_eq!(r#attr_value, "dallas"); // <assertEquals actual="attrValue" expected="&quot;dallas&quot;" id="elementAddNewAttributeAssert" ignoreCase="false"/>
            }
            // hc_attrspecifiedvaluechanged.xml
            #[test]
            fn test_hc_attrspecifiedvaluechanged() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#address_list; // type: NodeList // <var name="addressList" type="NodeList"/>
                let mut r#test_node; // type: Node // <var name="testNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#address_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#address_list.item(2).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="2"/>
                r#test_node.set_attribute("class", "Yα").unwrap(); // <setAttribute obj="testNode" name="&quot;class&quot;" value="&quot;Yα&quot;"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#street_attr = r#attributes.get_named_item("class").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;class&quot;"/>
                let r#state = r#street_attr.specified(); // <specified obj="streetAttr" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="acronymClassSpecified"/>
            }
            // hc_characterdatareplacedataend.xml
            #[test]
            fn test_hc_characterdatareplacedataend() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.replace_data(30, 5, "98665").unwrap(); // <replaceData obj="child" offset="30" count="5" arg="&quot;98665&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230 North Ave. Dallas, Texas 98665"); // <assertEquals actual="childData" expected="&quot;1230 North Ave. Dallas, Texas 98665&quot;" id="characterdataReplaceDataEndAssert" ignoreCase="false"/>
            }
            // hc_characterdatadeletedatagetlengthanddata.xml
            #[test]
            fn test_hc_characterdatadeletedatagetlengthanddata() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.delete_data(30, 5).unwrap(); // <deleteData obj="child" offset="30" count="5"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230 North Ave. Dallas, Texas "); // <assertEquals actual="childData" expected="&quot;1230 North Ave. Dallas, Texas &quot;" ignoreCase="false" id="data"/>
                let r#child_length = r#child.length(); // <length interface="CharacterData" obj="child" var="childLength"/>
                assert_eq!(r#child_length, 30); // <assertEquals actual="childLength" expected="30" ignoreCase="false" id="length"/>
            }
            // attrsetvaluenomodificationallowederr.xml
            #[test]
            fn test_attrsetvaluenomodificationallowederr() {
                // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender; // type: Node // <var name="gender" type="Node"/>
                let r#gen_list; // type: NodeList // <var name="genList" type="NodeList"/>
                let r#gen; // type: Node // <var name="gen" type="Node"/>
                let r#g_list; // type: NodeList // <var name="gList" type="NodeList"/>
                let r#g; // type: Node // <var name="g" type="Node"/>
                let r#attr_list; // type: NamedNodeMap // <var name="attrList" type="NamedNodeMap"/>
                let mut r#attr_node; // type: Attr // <var name="attrNode" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                // unimplemented: // <assertNotNull actual="gender" id="genderNotNull"/>
                r#gen_list = r#gender.child_nodes(); // <childNodes obj="gender" var="genList"/>
                r#gen = r#gen_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="genList" var="gen" index="0"/>
                // unimplemented: // <assertNotNull actual="gen" id="genderFirstChildNotNull"/>
                r#g_list = r#gen.child_nodes(); // <childNodes obj="gen" var="gList"/>
                r#g = r#g_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="gList" var="g" index="0"/>
                // unimplemented: // <assertNotNull actual="g" id="genderFirstGrandchildNotNull"/>
                r#attr_list = r#g.attributes().unwrap(); // <attributes obj="g" var="attrList"/>
                // unimplemented: // <assertNotNull actual="attrList" id="attributesNotNull"/>
                r#attr_node = r#attr_list.get_named_item("domestic").unwrap(); // <getNamedItem obj="attrList" var="attrNode" name="&quot;domestic&quot;"/>
                // unimplemented: // <assertNotNull actual="attrNode" id="attrNotNull"/>
                // <assertDOMException id="setValue_throws_NO_MODIFICATION">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <value interface="Attr" obj="attrNode" value="&quot;newvalue&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    attr_node
                        .set_value("newValue")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
                // <assertDOMException id="setNodeValue_throws_NO_MODIFICATION">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <nodeValue interface="Node" obj="attrNode" value="&quot;newvalue2&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    attr_node
                        .set_node_value("newValue")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // textindexsizeerroffsetoutofbounds.xml
            #[test]
            fn test_textindexsizeerroffsetoutofbounds() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;name&quot;"/>
                r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                r#text_node = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="textNode"/>
                // <assertDOMException id="throw_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <splitText obj="textNode" var="splitNode" offset="300"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
                assert!(
                    text_node
                        .split_text(300)
                        .is_err_and(|err| err == DOMException::IndexSizeErr)
                );
            }
            // elementwrongdocumenterr.xml
            #[test]
            fn test_elementwrongdocumenterr() {
                let r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#address_element_list; // type: NodeList // <var name="addressElementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                r#doc1 = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc1" href="staff" willBeModified="true"/>
                r#doc2 = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc2" href="staff" willBeModified="false"/>
                r#new_attribute = r#doc2.create_attribute("newAttribute".to_string()).unwrap(); // <createAttribute obj="doc2" var="newAttribute" name="&quot;newAttribute&quot;"/>
                r#address_element_list = r#doc1.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc1" tagname="&quot;address&quot;" var="addressElementList"/>
                r#test_address = r#address_element_list.item(4).unwrap(); // <item interface="NodeList" obj="addressElementList" index="4" var="testAddress"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <setAttributeNode obj="testAddress" newAttr="newAttribute" var="attrAddress"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    test_address
                        .set_attribute_node(new_attribute)
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // documentcreateentityreference.xml
            #[test]
            fn test_documentcreateentityreference() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#new_ent_ref_node = r#doc.create_entity_reference("ent1".to_string()).unwrap(); // <createEntityReference obj="doc" var="newEntRefNode" name="&quot;ent1&quot;"/>
                // unimplemented: // <assertNotNull actual="newEntRefNode" id="createdEntRefNotNull"/>
                let r#ent_ref_value = r#new_ent_ref_node.node_value(); // <nodeValue obj="newEntRefNode" var="entRefValue"/>
                assert!(ent_ref_value.is_none()); // <assertNull actual="entRefValue" id="value"/>
                let r#ent_ref_name = r#new_ent_ref_node.node_name().to_string(); // <nodeName obj="newEntRefNode" var="entRefName"/>
                assert_eq!(r#ent_ref_name, "ent1"); // <assertEquals actual="entRefName" expected="&quot;ent1&quot;" ignoreCase="false" id="name"/>
                let r#ent_ref_type = r#new_ent_ref_node.node_type(); // <nodeType obj="newEntRefNode" var="entRefType"/>
                assert_eq!(r#ent_ref_type as i32, 5); // <assertEquals actual="entRefType" expected="5" ignoreCase="false" id="type"/>
            }
            // nodeinsertbeforeinvalidnodetype.xml
            #[test]
            fn test_nodeinsertbeforeinvalidnodetype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Element // <var name="rootNode" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                let r#new_child = r#doc.create_attribute("newAttribute".to_string()).unwrap(); // <createAttribute obj="doc" name="&quot;newAttribute&quot;" var="newChild"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#ref_child = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="refChild"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <insertBefore var="insertedNode" obj="rootNode" newChild="newChild" refChild="refChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    root_node
                        .insert_before(new_child.into(), Some(ref_child.into()))
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // elementsetattributenomodificationallowederr.xml
            #[test]
            fn test_elementsetattributenomodificationallowederr() {
                // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender; // type: Node // <var name="gender" type="Node"/>
                let r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                assert_eq!(gender.node_type(), NodeType::Element);
                assert_eq!(gender.node_name().as_ref(), "gender");
                r#ent_ref = r#gender.first_child().unwrap(); // <firstChild interface="Node" var="entRef" obj="gender"/>
                assert_eq!(gender.last_child().unwrap().node_name().as_ref(), "ent4");
                assert_eq!(ent_ref.node_name().as_ref(), "ent4");
                assert_eq!(ent_ref.node_type(), NodeType::EntityReference);
                // unimplemented: // <assertNotNull actual="entRef" id="entRefNotNull"/>
                r#ent_element = r#ent_ref.first_child().unwrap().as_element().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <setAttribute obj="entElement" name="&quot;newAttr&quot;" value="&quot;newValue&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element
                        .set_attribute("newAttr", "newValue")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_nodegetfirstchild.xml
            #[test]
            fn test_hc_nodegetfirstchild() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#fchild_node = r#employee_node.first_child().unwrap(); // <firstChild interface="Node" obj="employeeNode" var="fchildNode"/>
                let r#child_name = r#fchild_node.node_name().to_string(); // <nodeName obj="fchildNode" var="childName"/>
                // <if><equals expected="&quot;#text&quot;" actual="childName"/>
                //  <assertEquals actual="childName" expected="&quot;#text&quot;" id="firstChild_w_whitespace" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="childName" expected="&quot;em&quot;" id="firstChild_wo_whitespace" ignoreCase="auto"/>
                // </else>
                // </if>
                if child_name == "#text" {
                    assert_eq!(child_name, "#text");
                } else {
                    assert_eq!(child_name, "em");
                }
            }
            // documentcreatetextnode.xml
            #[test]
            fn test_documentcreatetextnode() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#new_text_node = r#doc.create_text_node("This is a new Text node"); // <createTextNode obj="doc" var="newTextNode" data="&quot;This is a new Text node&quot;"/>
                let r#new_text_value = r#new_text_node.node_value().unwrap().to_string(); // <nodeValue obj="newTextNode" var="newTextValue"/>
                assert_eq!(r#new_text_value, "This is a new Text node"); // <assertEquals actual="newTextValue" expected="&quot;This is a new Text node&quot;" ignoreCase="false" id="value"/>
                let r#new_text_name = r#new_text_node.node_name().to_string(); // <nodeName obj="newTextNode" var="newTextName"/>
                assert_eq!(r#new_text_name, "#text"); // <assertEquals actual="newTextName" expected="&quot;#text&quot;" ignoreCase="false" id="name"/>
                let r#new_text_type = r#new_text_node.node_type(); // <nodeType obj="newTextNode" var="newTextType"/>
                assert_eq!(r#new_text_type as i32, 3); // <assertEquals actual="newTextType" expected="3" ignoreCase="false" id="type"/>
            }
            // hc_nodereplacechildinvalidnodetype.xml
            #[test]
            fn test_hc_nodereplacechildinvalidnodetype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Element // <var name="rootNode" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#new_child = r#doc.create_attribute("lang".to_string()).unwrap(); // <createAttribute obj="doc" name="&quot;lang&quot;" var="newChild"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#old_child = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="oldChild"/>
                r#root_node = r#old_child.parent_node().unwrap(); // <parentNode var="rootNode" obj="oldChild" interface="Node"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <replaceChild var="replacedChild" obj="rootNode" newChild="newChild" oldChild="oldChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    root_node
                        .replace_child(new_child.into(), old_child.into())
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // nodeinsertbeforenomodificationallowederr.xml
            #[test]
            fn test_nodeinsertbeforenomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                let mut r#ent_element; // type: Node // <var name="entElement" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item obj="genderList" index="2" var="genderNode" interface="NodeList"/>
                r#ent_ref = r#gender_node.first_child().unwrap(); // <firstChild interface="Node" var="entRef" obj="genderNode"/>
                // unimplemented: // <assertNotNull actual="entRef" id="entRefNotNull"/>
                let r#node_type = r#ent_ref.node_type(); // <nodeType var="nodeType" obj="entRef"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    ent_ref = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#ent_element = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                let r#created_node = r#doc.create_element("text3".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;text3&quot;" var="createdNode"/>
                // <assertDOMException id="throw_NOT_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <insertBefore var="insertedNode" obj="entElement" newChild="createdNode" refChild="refChild"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element
                        .insert_before(created_node.into(), None)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_nodegetprevioussiblingnull.xml
            #[test]
            fn test_hc_nodegetprevioussiblingnull() {
                // <var name="doc" type="Document"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="employeeNode"/>
                let r#fc_node = r#employee_node.first_child().unwrap(); // <firstChild interface="Node" obj="employeeNode" var="fcNode"/>
                let r#ps_node = r#fc_node.previous_sibling(); // <previousSibling interface="Node" obj="fcNode" var="psNode"/>
                assert!(ps_node.is_none()); // <assertNull actual="psNode" id="nodeGetPreviousSiblingNullAssert1"/>
            }
            // nodeprocessinginstructionnodename.xml
            #[test]
            fn test_nodeprocessinginstructionnodename() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#test_list = r#doc.child_nodes(); // <childNodes obj="doc" var="testList"/>
                let r#pi_node = r#test_list
                    .item(0)
                    .unwrap()
                    .clone()
                    .as_processing_instruction()
                    .unwrap(); // <item interface="NodeList" obj="testList" index="0" var="piNode"/>
                let r#pi_name = r#pi_node.node_name().to_string(); // <nodeName obj="piNode" var="piName"/>
                assert_eq!(r#pi_name, "TEST-STYLE"); // <assertEquals actual="piName" expected="&quot;TEST-STYLE&quot;" id="nodeProcessingInstructionNodeNameAssert1" ignoreCase="false"/>
            }
            // nodelistreturnlastitem.xml
            #[test]
            fn test_nodelistreturnlastitem() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#employee_list; // type: NodeList // <var name="employeeList" type="NodeList"/>
                let r#child; // type: Node // <var name="child" type="Node"/>
                let r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#length = r#employee_list.length(); // <length var="length" obj="employeeList" interface="NodeList"/>
                // <if><equals actual="length" expected="6" ignoreCase="false"/>
                //  <item interface="NodeList" obj="employeeList" var="child" index="5"/>
                //  <nodeName obj="child" var="childName"/>
                //  <assertEquals actual="childName" expected="&quot;address&quot;" id="nodeName1" ignoreCase="false"/>
                // <else>
                //  <item interface="NodeList" obj="employeeList" var="child" index="12"/>
                //  <nodeName obj="child" var="childName"/>
                //  <assertEquals actual="childName" expected="&quot;#text&quot;" id="nodeName2" ignoreCase="false"/>
                // </else>
                // </if>
                if length == 6 {
                    child = employee_list.item(5).unwrap();
                    child_name = child.node_name().to_string();
                    assert_eq!(child_name, "address");
                } else {
                    child = employee_list.item(12).unwrap();
                    child_name = child.node_name().to_string();
                    assert_eq!(child_name, "#text");
                }
            }
            // hc_attrappendchild4.xml
            #[test]
            fn test_hc_attrappendchild4() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                // let mut r#test_node; // type: Node // <var name="testNode" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                // let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                // let mut r#text_node; // type: Node // <var name="textNode" type="Node"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#last_child; // type: Node // <var name="lastChild" type="Node"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                // r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                // r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                // r#title_attr = r#attributes.get_named_item("title").unwrap();
                // // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>

                // unimplemented:
                // <if><contentType type="text/html"/>
                //  <assertDOMException id="throw_NOT_SUPPORTED_ERR">
                //      <NOT_SUPPORTED_ERR>
                //          <createCDATASection var="textNode" obj="doc" data="&quot;terday&quot;"/>
                //      </NOT_SUPPORTED_ERR>
                //  </assertDOMException>
                // <else>
                //  <createCDATASection var="textNode" obj="doc" data="&quot;terday&quot;"/>
                //  <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //      <HIERARCHY_REQUEST_ERR>
                //          <appendChild var="retval" obj="titleAttr" newChild="textNode"/>
                //      </HIERARCHY_REQUEST_ERR>
                //  </assertDOMException>
                // </else>
                // </if>
            }
            // nodeinsertbeforenomodificationallowederrEE.xml
            #[test]
            fn test_nodeinsertbeforenomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                let r#created_node = r#doc.create_element("text3".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;text3&quot;" var="createdNode"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <insertBefore var="insertedNode" obj="entRef" newChild="createdNode" refChild="refChild"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_ref
                        .insert_before(created_node.into(), None)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_attrhaschildnodes.xml
            #[test]
            fn test_hc_attrhaschildnodes() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                let r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                let r#has_child_nodes = r#title_attr.has_child_nodes(); // <hasChildNodes var="hasChildNodes" obj="titleAttr"/>
                assert!(r#has_child_nodes); // <assertTrue actual="hasChildNodes" id="hasChildrenIsTrue"/>
            }
            // nodevalue02.xml
            #[test]
            fn test_nodevalue02() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                let mut r#new_value; // type: DOMString // <var name="newValue" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_node = r#doc.create_comment("This is a new Comment node"); // <createComment obj="doc" var="newNode" data="&quot;This is a new Comment node&quot;"/>
                r#new_value = r#new_node.node_value().unwrap().to_string(); // <nodeValue obj="newNode" var="newValue"/>
                assert_eq!(r#new_value, "This is a new Comment node"); // <assertEquals actual="newValue" expected="&quot;This is a new Comment node&quot;" ignoreCase="false" id="initial"/>
                r#new_node
                    .set_node_value("This should have an effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have an effect&quot;"/>
                r#new_value = r#new_node.node_value().unwrap().to_string(); // <nodeValue obj="newNode" var="newValue"/>
                assert_eq!(r#new_value, "This should have an effect"); // <assertEquals actual="newValue" expected="&quot;This should have an effect&quot;" id="afterChange" ignoreCase="false"/>
            }
            // hc_attrappendchild5.xml
            #[test]
            fn test_hc_attrappendchild5() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let r#text_node; // type: Node // <var name="textNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#other_doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="otherDoc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#text_node = r#other_doc.create_text_node("terday"); // <createTextNode var="textNode" obj="otherDoc" data="&quot;terday&quot;"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <appendChild var="retval" obj="titleAttr" newChild="textNode"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    title_attr
                        .append_child(text_node.into())
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // characterdataindexsizeerrreplacedataoffsetnegative.xml
            #[test]
            fn test_characterdataindexsizeerrreplacedataoffsetnegative() {
                // unimplemented: // <implementationAttribute name="signed" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // unimplemented:
                // <assertDOMException id="throws_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <replaceData obj="child" offset="-5" count="3" arg="&quot;ABC&quot;"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
            }
            // namednodemapremovenameditemreturnnodevalue.xml
            #[test]
            fn test_namednodemapremovenameditemreturnnodevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                let r#removed_node = r#attributes.remove_named_item("street").unwrap(); // <removeNamedItem interface="NamedNodeMap" obj="attributes" var="removedNode" name="&quot;street&quot;"/>
                let r#value = r#removed_node.node_value().unwrap().to_string(); // <nodeValue obj="removedNode" var="value"/>
                assert_eq!(r#value, "No"); // <assertEquals actual="value" expected="&quot;No&quot;" id="namednodemapRemoveNamedItemReturnNodeValueAssert" ignoreCase="false"/>
            }
            // hc_nodevalue08.xml
            #[test]
            fn test_hc_nodevalue08() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // let mut r#new_value; // type: DOMString // <var name="newValue" type="DOMString"/>
                // let mut r#node_map; // type: NamedNodeMap // <var name="nodeMap" type="NamedNodeMap"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>

                // unimplemented:
                // <if><not><contentType type="text/html"/></not>
                //  <assertNotNull actual="docType" id="docTypeNotNull"/>
                //  <notations obj="docType" var="nodeMap"/>
                //  <assertNotNull actual="nodeMap" id="notationsNotNull"/>
                //  <getNamedItem obj="nodeMap" name="&quot;notation1&quot;" var="newNode"/>
                //  <assertNotNull actual="newNode" id="notationNotNull"/>
                //  <nodeValue obj="newNode" var="newValue"/>
                //  <assertNull actual="newValue" id="initiallyNull"/>
                //  <!--   attempt to change the value and make sure that it stays null  -->
                //  <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                //  <nodeValue obj="newNode" var="newValue"/>
                //  <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
                // </if>
            }
            // nodeentitynodeattributes.xml
            #[test]
            fn test_nodeentitynodeattributes() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#entities = doc_type.entities(); // <entities obj="docType" var="entities"/>
                // unimplemented: // <assertNotNull actual="entities" id="entitiesNotNull"/>
                let r#entity_node = r#entities.get_named_item("ent1").unwrap(); // <getNamedItem obj="entities" name="&quot;ent1&quot;" var="entityNode"/>
                // unimplemented: // <assertNotNull actual="entityNode" id="ent1NotNull"/>
                let r#attr_list = r#entity_node.attributes(); // <attributes obj="entityNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="entityAttributesNull"/>
            }
            // elementassociatedattribute.xml
            #[test]
            fn test_elementassociatedattribute() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                let r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("domestic").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;domestic&quot;"/>
                let r#specified = r#domestic_attr.specified(); // <specified obj="domesticAttr" var="specified"/>
                assert!(r#specified); // <assertTrue actual="specified" id="domesticSpecified"/>
            }
            // hc_elementremoveattributenode.xml
            #[test]
            fn test_hc_elementremoveattributenode() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                let r#street_attr = r#test_employee.get_attribute_node("class").unwrap(); // <getAttributeNode obj="testEmployee" var="streetAttr" name="&quot;class&quot;"/>
                let r#removed_attr = r#test_employee
                    .remove_attribute_node(r#street_attr)
                    .unwrap(); // <removeAttributeNode obj="testEmployee" var="removedAttr" oldAttr="streetAttr"/>
                // unimplemented: // <assertNotNull actual="removedAttr" id="removedAttrNotNull"/>
                let r#removed_value = r#removed_attr.value().to_string(); // <value interface="Attr" obj="removedAttr" var="removedValue"/>
                assert_eq!(r#removed_value, "No"); // <assertEquals actual="removedValue" expected="&quot;No&quot;" id="elementRemoveAttributeNodeAssert" ignoreCase="false"/>
            }
            // hc_nodetextnodename.xml
            #[test]
            fn test_hc_nodetextnodename() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#text_node = r#test_addr.first_child().unwrap(); // <firstChild interface="Node" obj="testAddr" var="textNode"/>
                let r#text_name = r#text_node.node_name().to_string(); // <nodeName obj="textNode" var="textName"/>
                assert_eq!(r#text_name, "#text"); // <assertEquals actual="textName" expected="&quot;#text&quot;" id="textNodeName" ignoreCase="false"/>
            }
            // nodedocumenttypenodetype.xml
            #[test]
            fn test_nodedocumenttypenodetype() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#document_type_node = r#doc.doctype().unwrap(); // <doctype obj="doc" var="documentTypeNode"/>
                // unimplemented: // <assertNotNull actual="documentTypeNode" id="doctypeNotNull"/>
                let r#node_type = r#document_type_node.node_type(); // <nodeType obj="documentTypeNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 10); // <assertEquals actual="nodeType" expected="10" id="nodeType" ignoreCase="false"/>
            }
            // hc_textwithnomarkup.xml
            #[test]
            fn test_hc_textwithnomarkup() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;strong&quot;"/>
                let r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                let r#node_v = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="nodeV"/>
                let r#value = r#node_v.node_value().unwrap().to_string(); // <nodeValue obj="nodeV" var="value"/>
                assert_eq!(r#value, "Roger\n Jones"); // <assertEquals actual="value" expected="&quot;Roger\n Jones&quot;" id="textWithNoMarkupAssert" ignoreCase="false"/>
            }
            // elementremoveattributenomodificationallowederrEE.xml
            #[test]
            fn test_elementremoveattributenomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender; // type: Node // <var name="gender" type="Node"/>
                let r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference obj="doc" var="entRef" name="&quot;ent4&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                r#appended_child = r#gender.append_child(ent_ref.clone().into()).unwrap(); // <appendChild obj="gender" newChild="entRef" var="appendedChild"/>
                r#ent_element = r#ent_ref.first_child().unwrap().as_element().unwrap(); // <firstChild obj="entRef" var="entElement" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <removeAttribute obj="entElement" name="&quot;domestic&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element
                        .remove_attribute("domestic")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodecommentnodename.xml
            #[test]
            fn test_nodecommentnodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#comment_node; // type: Node // <var name="commentNode" type="Node"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#comment_node_name; // type: DOMString // <var name="commentNodeName" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.child_nodes(); // <childNodes obj="doc" var="elementList"/>
                // <for-each collection="elementList" member="commentNode">
                //  <nodeType obj="commentNode" var="nodeType"/>
                //  <if><equals actual="nodeType" expected="8" ignoreCase="false"/>
                //      <nodeName obj="commentNode" var="commentNodeName"/>
                //      <assertEquals actual="commentNodeName" expected="&quot;#comment&quot;" id="commentNodeName" ignoreCase="false"/>
                //  </if>
                // </for-each>
                for i in 0..element_list.length() {
                    comment_node = element_list.item(i).unwrap();
                    node_type = comment_node.node_type();
                    if node_type as i32 == 8 {
                        comment_node_name = comment_node.node_name().to_string();
                        assert_eq!(comment_node_name, "#comment");
                    }
                }
            }
            // namednodemapremovenameditem.xml
            #[test]
            fn test_namednodemapremovenameditem() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let r#street_attr; // type: Attr // <var name="streetAttr" type="Attr"/>
                let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                // unimplemented: // <assertNotNull actual="attributes" id="attributesNotNull"/>
                r#removed_node = r#attributes.remove_named_item("street").unwrap(); // <removeNamedItem var="removedNode" interface="NamedNodeMap" obj="attributes" name="&quot;street&quot;"/>
                r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                // unimplemented: // <assertNotNull actual="streetAttr" id="streetAttrNotNull"/>
                let r#specified = r#street_attr.specified(); // <specified obj="streetAttr" var="specified"/>
                assert!(!r#specified); // <assertFalse actual="specified" id="attrNotSpecified"/>
            }
            // noderemovechildnomodificationallowederrEE.xml
            #[test]
            fn test_noderemovechildnomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                let r#ent_text = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" var="entText" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entText" id="entTextNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <removeChild var="removedNode" obj="entRef" oldChild="entText"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_ref
                        .remove_child(ent_text)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // attreffectivevalue.xml
            #[test]
            fn test_attreffectivevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("domestic").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;domestic&quot;"/>
                let r#value = r#domestic_attr.node_value().unwrap().to_string(); // <nodeValue obj="domesticAttr" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="attrEffectiveValueAssert" ignoreCase="false"/>
            }
            // attrprevioussiblingnull.xml
            #[test]
            fn test_attrprevioussiblingnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("domestic").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;domestic&quot;"/>
                let r#s = r#domestic_attr.previous_sibling(); // <previousSibling interface="Node" obj="domesticAttr" var="s"/>
                assert!(s.is_none()); // <assertNull actual="s" id="attrPreviousSiblingNullAssert"/>
            }
            // hc_nodeparentnode.xml
            #[test]
            fn test_hc_nodeparentnode() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#parent_node = r#employee_node.parent_node().unwrap(); // <parentNode interface="Node" obj="employeeNode" var="parentNode"/>
                let r#parent_name = r#parent_node.node_name().to_string(); // <nodeName obj="parentNode" var="parentName"/>
                assert_eq!(r#parent_name, "body"); // <assertEquals actual="parentName" expected="&quot;body&quot;" id="parentNodeName" ignoreCase="auto"/>
            }
            // hc_characterdataindexsizeerrinsertdataoffsetgreater.xml
            #[test]
            fn test_hc_characterdataindexsizeerrinsertdataoffsetgreater() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                // <assertDOMException id="throw_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <deleteData obj="child" offset="40" count="3"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
                assert!(
                    child
                        .delete_data(40, 3)
                        .is_err_and(|err| err == DOMException::IndexSizeErr)
                );
            }
            // nodeclonetruecopytext.xml
            #[test]
            fn test_nodeclonetruecopytext() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("salary"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;salary&quot;" var="elementList"/>
                let r#child_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="childNode"/>
                let r#cloned_node = r#child_node.clone_node(true); // <cloneNode obj="childNode" deep="true" var="clonedNode"/>
                let r#last_child_node = r#cloned_node.last_child().unwrap(); // <lastChild interface="Node" obj="clonedNode" var="lastChildNode"/>
                let r#child_value = r#last_child_node.node_value().unwrap().to_string(); // <nodeValue obj="lastChildNode" var="childValue"/>
                assert_eq!(r#child_value, "35,000"); // <assertEquals actual="childValue" expected="&quot;35,000&quot;" id="nodeCloneTrueCopyTextAssert1" ignoreCase="false"/>
            }
            // hc_namednodemapreturnlastitem.xml
            #[test]
            fn test_hc_namednodemapreturnlastitem() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#html_expected; // type: Collection // <var name="htmlExpected" type="Collection">    <member>"title"</member>    <member>"class"</member></var>
                // let mut r#expected; // type: Collection // <var name="expected" type="Collection">    <member>"title"</member>    <member>"class"</member>    <member>"dir"</member></var>
                // let mut r#actual; // type: Collection // <var name="actual" type="Collection"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                // r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="1"/>
                // r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>

                // // unimplemented: // <for-each collection="attributes" member="child"><nodeName obj="child" var="nodeName"/><append collection="actual" item="nodeName"/></for-each>

                // // unimplemented: // <if><contentType type="text/html"/><assertEquals id="attrName_html" actual="actual" expected="htmlExpected" ignoreCase="true"/><else><assertEquals id="attrName" actual="actual" expected="expected" ignoreCase="false"/></else></if>
            }
            // nodeinsertbeforenewchilddiffdocument.xml
            #[test]
            fn test_nodeinsertbeforenewchilddiffdocument() {
                let r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc1 = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc1" href="staff" willBeModified="false"/>
                r#doc2 = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc2" href="staff" willBeModified="true"/>
                r#new_child = r#doc1.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc1" tagName="&quot;newChild&quot;" var="newChild"/>
                r#element_list = r#doc2.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc2" tagname="&quot;employee&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                r#ref_child = r#element_node.first_child().unwrap(); // <firstChild var="refChild" obj="elementNode" interface="Node"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <insertBefore var="insertedNode" obj="elementNode" newChild="newChild" refChild="refChild"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .insert_before(new_child.into(), Some(ref_child))
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // hc_nodedocumentfragmentnodetype.xml
            #[test]
            fn test_hc_nodedocumentfragmentnodetype() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#document_fragment_node = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="documentFragmentNode"/>
                let r#node_type = r#document_fragment_node.node_type(); // <nodeType obj="documentFragmentNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 11); // <assertEquals actual="nodeType" expected="11" id="nodeDocumentFragmentNodeTypeAssert1" ignoreCase="false"/>
            }
            // elementremoveattributerestoredefaultvalue.xml
            #[test]
            fn test_elementremoveattributerestoredefaultvalue() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let r#street_attr; // type: Attr // <var name="streetAttr" type="Attr"/>
                let mut r#removed_attr; // type: Attr // <var name="removedAttr" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                r#street_attr = r#test_employee.get_attribute_node("street").unwrap(); // <getAttributeNode obj="testEmployee" var="streetAttr" name="&quot;street&quot;"/>
                r#removed_attr = r#test_employee
                    .remove_attribute_node(r#street_attr)
                    .unwrap(); // <removeAttributeNode var="removedAttr" obj="testEmployee" oldAttr="streetAttr"/>
                let r#attribute = r#test_employee.get_attribute("street"); // <getAttribute obj="testEmployee" var="attribute" name="&quot;street&quot;"/>
                assert_eq!(r#attribute, "Yes"); // <assertEquals actual="attribute" expected="&quot;Yes&quot;" id="streetYes" ignoreCase="false"/>
            }
            // attrcreatetextnode.xml
            #[test]
            fn test_attrcreatetextnode() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#address_list; // type: NodeList // <var name="addressList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#street_attr; // type: Attr // <var name="streetAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                r#test_node = r#address_list.item(3).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                r#street_attr.set_value("Y&ent1;").unwrap(); // <value interface="Attr" obj="streetAttr" value="&quot;Y&amp;ent1;&quot;"/>
                r#value = r#street_attr.value().to_string(); // <value interface="Attr" obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Y&ent1;"); // <assertEquals actual="value" expected="&quot;Y&amp;ent1;&quot;" id="value" ignoreCase="false"/>
                r#value = r#street_attr.node_value().unwrap().to_string(); // <nodeValue obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Y&ent1;"); // <assertEquals actual="value" expected="&quot;Y&amp;ent1;&quot;" id="nodeValue" ignoreCase="false"/>
            }
            // elementgetattributenodenull.xml
            #[test]
            fn test_elementgetattributenodenull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                let r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                let r#domestic_attr = r#test_employee.get_attribute_node("invalidAttribute"); // <getAttributeNode obj="testEmployee" var="domesticAttr" name="&quot;invalidAttribute&quot;"/>
                assert!(domestic_attr.is_none()); // <assertNull actual="domesticAttr" id="elementGetAttributeNodeNullAssert"/>
            }
            // hc_textsplittextthree.xml
            #[test]
            fn test_hc_textsplittextthree() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;strong&quot;"/>
                r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                r#text_node = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="textNode"/>
                let r#split_node = r#text_node.split_text(6).unwrap(); // <splitText obj="textNode" var="splitNode" offset="6"/>
                let r#value = r#split_node.node_value().unwrap().to_string(); // <nodeValue obj="splitNode" var="value"/>
                assert_eq!(r#value, " Jones"); // <assertEquals actual="value" expected="&quot; Jones&quot;" id="textSplitTextThreeAssert" ignoreCase="false"/>
            }
            // elementretrieveattrvalue.xml
            #[test]
            fn test_elementretrieveattrvalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                let r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testAddress"/>
                let r#attr_value = r#test_address.get_attribute("street"); // <getAttribute obj="testAddress" var="attrValue" name="&quot;street&quot;"/>
                assert_eq!(r#attr_value, "No"); // <assertEquals actual="attrValue" expected="&quot;No&quot;" id="attrValue" ignoreCase="false"/>
            }
            // hc_elementremoveattribute.xml
            #[test]
            fn test_hc_elementremoveattribute() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(3).unwrap(); // <item interface="NodeList" obj="elementList" index="3" var="testEmployee"/>
                r#test_employee.remove_attribute("class").unwrap(); // <removeAttribute obj="testEmployee" name="&quot;class&quot;"/>
                let r#attr_value = r#test_employee.get_attribute("class"); // <getAttribute obj="testEmployee" var="attrValue" name="&quot;class&quot;"/>
                assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" id="attrValue" ignoreCase="false"/>
            }
            // hc_attrappendchild1.xml
            #[test]
            fn test_hc_attrappendchild1() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                let r#text_node = r#doc.create_text_node("terday"); // <createTextNode var="textNode" obj="doc" data="&quot;terday&quot;"/>
                let r#retval = r#title_attr.append_child(text_node.into()).unwrap(); // <appendChild var="retval" obj="titleAttr" newChild="textNode"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrNodeValue" ignoreCase="false"/>
                r#value = r#retval.node_value().unwrap().to_string(); // <nodeValue obj="retval" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="retvalValue" ignoreCase="false"/>
                let r#last_child = r#title_attr.last_child().unwrap(); // <lastChild var="lastChild" obj="titleAttr" interface="Node"/>
                r#value = r#last_child.node_value().unwrap().to_string(); // <nodeValue obj="lastChild" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="lastChildValue" ignoreCase="false"/>
            }
            // documenttypegetentities.xml
            #[test]
            fn test_documenttypegetentities() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entity_list; // type: NamedNodeMap // <var name="entityList" type="NamedNodeMap"/>
                // let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                // let mut r#expected_result; // type: Collection // <var name="expectedResult" type="Collection"><member>"ent1"</member><member>"ent2"</member><member>"ent3"</member><member>"ent4"</member><member>"ent5"</member></var>
                // let mut r#expected_result_svg; // type: Collection // <var name="expectedResultSVG" type="Collection"><member>"ent1"</member><member>"ent2"</member><member>"ent3"</member><member>"ent4"</member><member>"ent5"</member><member>"svgunit"</member><member>"svgtest"</member></var>
                // let mut r#name_list; // type: Collection // <var name="nameList" type="Collection"/>
                // let mut r#entity; // type: Node // <var name="entity" type="Node"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>

                // // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>

                // entity_list = doc_type.entities(); // <entities obj="docType" var="entityList"/>

                // // unimplemented: // <assertNotNull actual="entityList" id="entitiesNotNull"/>

                // // unimplemented: // <for-each collection="entityList" member="entity">	<nodeName obj="entity" var="name"/>	<append collection="nameList" item="name"/></for-each>

                // // unimplemented: // <if><contentType type="image/svg+xml"/>	<assertEquals actual="nameList" expected="expectedResultSVG" id="entityNamesSVG" ignoreCase="false"/>	<else>		<assertEquals actual="nameList" expected="expectedResult" id="entityNames" ignoreCase="false"/>	</else></if>
            }
            // characterdataappenddata.xml
            #[test]
            fn test_characterdataappenddata() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.append_data(", Esquire").unwrap(); // <appendData obj="child" arg="&quot;, Esquire&quot;"/>
                let r#child_value = r#child.data().to_string(); // <data obj="child" var="childValue" interface="CharacterData"/>
                let r#child_length = r#child_value.len(); // <length obj="childValue" var="childLength" interface="DOMString"/>
                assert_eq!(r#child_length, 24); // <assertEquals actual="childLength" expected="24" ignoreCase="false" id="characterdataAppendDataAssert"/>
            }
            // characterdatasubstringexceedsvalue.xml
            #[test]
            fn test_characterdatasubstringexceedsvalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                let r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                let r#substring = child.substring_data(9, 10).unwrap(); // <substringData obj="child" var="substring" offset="9" count="10"/>
                assert_eq!(r#substring, "Martin"); // <assertEquals actual="substring" expected="&quot;Martin&quot;" id="characterdataSubStringExceedsValueAssert" ignoreCase="false"/>
            }
            // documentgetelementsbytagnamevalue.xml
            #[test]
            fn test_documentgetelementsbytagnamevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#name_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="nameList" tagname="&quot;name&quot;"/>
                let r#name_node = r#name_list.item(3).unwrap(); // <item interface="NodeList" obj="nameList" var="nameNode" index="3"/>
                let r#first_child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="firstChild"/>
                let r#child_value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="childValue"/>
                assert_eq!(r#child_value, "Jeny Oconnor"); // <assertEquals actual="childValue" expected="&quot;Jeny Oconnor&quot;" id="documentGetElementsByTagNameValueAssert" ignoreCase="false"/>
            }
            // characterdatainsertdatamiddle.xml
            #[test]
            fn test_characterdatainsertdatamiddle() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.insert_data(9, "Ann ").unwrap(); // <insertData obj="child" offset="9" arg="&quot;Ann &quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Margaret Ann Martin"); // <assertEquals actual="childData" expected="&quot;Margaret Ann Martin&quot;" id="characterdataInsertDataMiddleAssert" ignoreCase="false"/>
            }
            // namednodemapnotfounderr.xml
            #[test]
            fn test_namednodemapnotfounderr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="2"/>
                r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <removeNamedItem var="removedNode" interface="NamedNodeMap" obj="attributes" name="&quot;district&quot;"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .remove_named_item("district")
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // nodeinsertbefore.xml
            #[test]
            fn test_nodeinsertbefore() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#inserted_node; // type: Node // <var name="insertedNode" type="Node"/>
                let mut r#actual = vec![]; // type: List // <var name="actual" type="List"/>
                let r#expected_with_whitespace = vec![
                    "#text",
                    "employeeId",
                    "#text",
                    "name",
                    "#text",
                    "position",
                    "#text",
                    "newChild",
                    "salary",
                    "#text",
                    "gender",
                    "#text",
                    "address",
                    "#text",
                ]; // type: List // <var name="expectedWithWhitespace" type="List"><member>"#text"</member><member>"employeeId"</member><member>"#text"</member><member>"name"</member><member>"#text"</member><member>"position"</member><member>"#text"</member><member>"newChild"</member><member>"salary"</member><member>"#text"</member><member>"gender"</member><member>"#text"</member><member>"address"</member><member>"#text"</member></var>
                let r#expected_without_whitespace = vec![
                    "employeeId",
                    "name",
                    "position",
                    "newChild",
                    "salary",
                    "gender",
                    "address",
                ]; // type: List // <var name="expectedWithoutWhitespace" type="List"><member>"employeeId"</member><member>"name"</member><member>"position"</member><member>"newChild"</member><member>"salary"</member><member>"gender"</member><member>"address"</member></var>
                let r#expected; // type: List // <var name="expected" type="List"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#length = r#child_list.length(); // <length var="length" obj="childList" interface="NodeList"/>
                // <if><equals actual="length" expected="6" ignoreCase="false"/>
                //  <item interface="NodeList" obj="childList" index="3" var="refChild"/>
                //  <assign var="expected" value="expectedWithoutWhitespace"/>
                // <else>
                //  <item interface="NodeList" obj="childList" index="7" var="refChild"/>
                //  <assign var="expected" value="expectedWithWhitespace"/>
                // </else>
                // </if>
                if length == 6 {
                    ref_child = child_list.item(3).unwrap();
                    expected = expected_without_whitespace;
                } else {
                    ref_child = child_list.item(7).unwrap();
                    expected = expected_with_whitespace;
                }
                r#new_child = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="newChild"/>
                r#inserted_node = r#employee_node
                    .insert_before(new_child.into(), Some(ref_child))
                    .unwrap(); // <insertBefore var="insertedNode" obj="employeeNode" newChild="newChild" refChild="refChild"/>
                // <for-each collection="childList" member="child">
                //  <nodeName obj="child" var="childName"/>
                //  <append collection="actual" item="childName"/>
                // </for-each>
                for i in 0..child_list.length() {
                    child = child_list.item(i).unwrap();
                    child_name = child.node_name().to_string();
                    actual.push(child_name);
                }
                assert_eq!(r#actual, expected); // <assertEquals actual="actual" expected="expected" id="nodeNames" ignoreCase="false"/>
            }
            // characterdataappenddatagetdata.xml
            #[test]
            fn test_characterdataappenddatagetdata() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.append_data(", Esquire").unwrap(); // <appendData obj="child" arg="&quot;, Esquire&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Margaret Martin, Esquire"); // <assertEquals actual="childData" expected="&quot;Margaret Martin, Esquire&quot;" id="characterdataAppendDataGetDataAssert" ignoreCase="false"/>
            }
            // hc_nodeappendchildnewchilddiffdocument.xml
            #[test]
            fn test_hc_nodeappendchildnewchilddiffdocument() {
                let r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc1 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc1" href="hc_staff" willBeModified="false"/>
                r#doc2 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc2" href="hc_staff" willBeModified="true"/>
                r#new_child = r#doc1.create_element("br".to_string()).unwrap(); // <createElement obj="doc1" tagName="&quot;br&quot;" var="newChild"/>
                r#element_list = r#doc2.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc2" tagname="&quot;p&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <appendChild var="appendedChild" obj="elementNode" newChild="newChild"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .append_child(new_child.into())
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // documentgetimplementation.xml
            #[test]
            fn test_documentgetimplementation() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_impl = doc.implementation(); // <implementation obj="doc" var="docImpl"/>
                let r#state = doc_impl.has_feature("XML", Some("1.0")); // <hasFeature obj="docImpl" var="state" feature="&quot;XML&quot;" version="&quot;1.0&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="documentGetImplementationAssert"/>
            }
            // hc_nodeinsertbeforedocfragment.xml
            #[test]
            fn test_hc_nodeinsertbeforedocfragment() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                let mut r#newdoc_fragment; // type: DocumentFragment // <var name="newdocFragment" type="DocumentFragment"/>
                let r#new_child1; // type: Node // <var name="newChild1" type="Node"/>
                let r#new_child2; // type: Node // <var name="newChild2" type="Node"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#inserted_node; // type: Node // <var name="insertedNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#ref_child = r#child_list.item(3).unwrap().clone(); // <item interface="NodeList" obj="childList" index="3" var="refChild"/>
                r#newdoc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="newdocFragment"/>
                r#new_child1 = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="newChild1"/>
                r#new_child2 = r#doc.create_element("b".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;b&quot;" var="newChild2"/>
                r#appended_child = r#newdoc_fragment.append_child(new_child1.into()).unwrap(); // <appendChild var="appendedChild" obj="newdocFragment" newChild="newChild1"/>
                r#appended_child = r#newdoc_fragment.append_child(new_child2.into()).unwrap(); // <appendChild var="appendedChild" obj="newdocFragment" newChild="newChild2"/>
                r#inserted_node = r#employee_node
                    .insert_before(newdoc_fragment.into(), ref_child.into())
                    .unwrap(); // <insertBefore var="insertedNode" obj="employeeNode" newChild="newdocFragment" refChild="refChild"/>
                r#child = r#child_list.item(3).unwrap().clone(); // <item interface="NodeList" obj="childList" index="3" var="child"/>
                r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                assert_eq!(r#child_name, "br"); // <assertEquals actual="childName" expected="&quot;br&quot;" ignoreCase="auto" id="childName3"/>
                r#child = r#child_list.item(4).unwrap().clone(); // <item interface="NodeList" obj="childList" index="4" var="child"/>
                r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                assert_eq!(r#child_name, "b"); // <assertEquals actual="childName" expected="&quot;b&quot;" ignoreCase="auto" id="childName4"/>
            }
            // hc_elementreplaceexistingattribute.xml
            #[test]
            fn test_hc_elementreplaceexistingattribute() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#set_attr; // type: Attr // <var name="setAttr" type="Attr"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                r#new_attribute = r#doc.create_attribute("class".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;class&quot;"/>
                r#set_attr = r#test_employee
                    .set_attribute_node(r#new_attribute)
                    .unwrap()
                    .unwrap(); // <setAttributeNode var="setAttr" obj="testEmployee" newAttr="newAttribute"/>
                let r#strong = r#test_employee.get_attribute("class"); // <getAttribute obj="testEmployee" var="strong" name="&quot;class&quot;"/>
                assert_eq!(r#strong, ""); // <assertEquals actual="strong" expected="&quot;&quot;" id="replacedValue" ignoreCase="false"/>
            }
            // hc_namednodemapsetnameditemwithnewvalue.xml
            #[test]
            fn test_hc_namednodemapsetnameditemwithnewvalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                r#new_attribute = r#doc.create_attribute("lang".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;lang&quot;"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                let r#new_node = r#attributes.set_named_item(r#new_attribute).unwrap(); // <setNamedItem interface="NamedNodeMap" obj="attributes" var="newNode" arg="newAttribute"/>
                assert!(new_node.is_none()); // <assertNull actual="newNode" id="prevValueNull"/>
            }
            // nodeclonenodetrue.xml
            #[test]
            fn test_nodeclonenodetrue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#cloned_node; // type: Node // <var name="clonedNode" type="Node"/>
                let r#cloned_list; // type: NodeList // <var name="clonedList" type="NodeList"/>
                let mut r#cloned_child; // type: Node // <var name="clonedChild" type="Node"/>
                let mut r#cloned_child_name; // type: DOMString // <var name="clonedChildName" type="DOMString"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let mut r#expected_whitespace = vec![
                    "#text",
                    "employeeId",
                    "#text",
                    "name",
                    "#text",
                    "position",
                    "#text",
                    "salary",
                    "#text",
                    "gender",
                    "#text",
                    "address",
                    "#text",
                ]; // type: List // <var name="expectedWhitespace" type="List"><member>"#text"</member><member>"employeeId"</member><member>"#text"</member><member>"name"</member><member>"#text"</member><member>"position"</member><member>"#text"</member><member>"salary"</member><member>"#text"</member><member>"gender"</member><member>"#text"</member><member>"address"</member><member>"#text"</member></var>
                let r#expected_no_whitespace = vec![
                    "employeeId",
                    "name",
                    "position",
                    "salary",
                    "gender",
                    "address",
                ]; // type: List // <var name="expectedNoWhitespace" type="List"><member>"employeeId"</member><member>"name"</member><member>"position"</member><member>"salary"</member><member>"gender"</member><member>"address"</member></var>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes var="childList" obj="employeeNode"/>
                let r#length = r#child_list.length(); // <length var="length" obj="childList" interface="NodeList"/>
                r#cloned_node = r#employee_node.clone_node(true); // <cloneNode obj="employeeNode" deep="true" var="clonedNode"/>
                r#cloned_list = r#cloned_node.child_nodes(); // <childNodes obj="clonedNode" var="clonedList"/>
                // <for-each collection="clonedList" member="clonedChild">
                //  <nodeName obj="clonedChild" var="clonedChildName"/>
                //  <append collection="result" item="clonedChildName"/>
                // </for-each>
                for i in 0..cloned_list.length() {
                    cloned_child = cloned_list.item(i).unwrap();
                    cloned_child_name = cloned_child.node_name().to_string();
                    result.push(cloned_child_name);
                }
                // <if><equals actual="length" expected="6" ignoreCase="false"/>
                //  <assertEquals actual="result" expected="expectedNoWhitespace" id="nowhitespace" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="result" expected="expectedWhitespace" id="whitespace" ignoreCase="false"/>
                // </else>
                // </if>
                if length == 6 {
                    assert_eq!(result, expected_no_whitespace);
                } else {
                    assert_eq!(result, expected_whitespace);
                }
            }
            // hc_characterdataindexsizeerrdeletedatacountnegative.xml
            #[test]
            fn test_hc_characterdataindexsizeerrdeletedatacountnegative() {
                // // unimplemented: // <implementationAttribute name="signed" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                // let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                // let mut r#child_substring; // type: DOMString // <var name="childSubstring" type="DOMString"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                // r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                // r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // // unimplemented:
                // // <assertDOMException id="throws_INDEX_SIZE_ERR">
                // //  <INDEX_SIZE_ERR>
                // //      <substringData var="childSubstring" obj="child" offset="10" count="-3"/>
                // //  </INDEX_SIZE_ERR>
                // // </assertDOMException>
            }
            // nodeentityreferencenodevalue.xml
            #[test]
            fn test_nodeentityreferencenodevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#ent_ref_addr; // type: Element // <var name="entRefAddr" type="Element"/>
                let mut r#ent_ref_node; // type: Node // <var name="entRefNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#ent_ref_addr = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="entRefAddr"/>
                r#ent_ref_node = r#ent_ref_addr.first_child().unwrap(); // <firstChild interface="Node" obj="entRefAddr" var="entRefNode"/>
                let r#node_type = r#ent_ref_node.node_type(); // <nodeType var="nodeType" obj="entRefNode"/>
                // <if><equals actual="nodeType" expected="3" ignoreCase="false"/>
                //  <createEntityReference var="entRefNode" obj="doc" name="&quot;ent2&quot;"/>
                //  <assertNotNull actual="entRefNode" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 3 {
                    ent_ref_node = doc.create_entity_reference("ent2").unwrap().into();
                }
                let r#ent_ref_value = r#ent_ref_node.node_value(); // <nodeValue obj="entRefNode" var="entRefValue"/>
                assert!(ent_ref_value.is_none()) // <assertNull actual="entRefValue" id="entRefNodeValue"/>
            }
            // elementgetelementsbytagnamenomatch.xml
            #[test]
            fn test_elementgetelementsbytagnamenomatch() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("noMatch"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;noMatch&quot;" var="elementList"/>
                assert_eq!(element_list.length(), 0) // <assertSize collection="elementList" size="0" id="elementGetElementsByTagNameNoMatchNoMatchAssert"/>
            }
            // nodeinsertbeforenodeancestor.xml
            #[test]
            fn test_nodeinsertbeforenodeancestor() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_child = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="newChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#ref_child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="refChild"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <insertBefore var="insertedNode" obj="employeeNode" newChild="newChild" refChild="refChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    employee_node
                        .insert_before(new_child.into(), Some(ref_child))
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // hc_characterdataindexsizeerrsubstringcountnegative.xml
            #[test]
            fn test_hc_characterdataindexsizeerrsubstringcountnegative() {
                // // unimplemented: // <implementationAttribute name="signed" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                // let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                // let mut r#bad_substring; // type: DOMString // <var name="badSubstring" type="DOMString"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                // r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                // r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // // unimplemented:
                // // <assertDOMException id="throws_INDEX_SIZE_ERR">
                // //  <INDEX_SIZE_ERR>
                // //      <substringData var="badSubstring" obj="child" offset="10" count="-3"/>
                // //  </INDEX_SIZE_ERR>
                // // </assertDOMException>
            }
            // hc_nodecommentnodeattributes.xml
            #[test]
            fn test_hc_nodecommentnodeattributes() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#comment_node; // type: Node // <var name="commentNode" type="Node"/>
                let r#node_list; // type: NodeList // <var name="nodeList" type="NodeList"/>
                let mut r#attr_list; // type: NamedNodeMap // <var name="attrList" type="NamedNodeMap"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#node_list = r#doc.child_nodes(); // <childNodes obj="doc" var="nodeList"/>
                // <for-each collection="nodeList" member="commentNode">
                //  <nodeType obj="commentNode" var="nodeType"/>
                //  <if><equals actual="nodeType" expected="8" ignoreCase="false"/>
                //      <attributes obj="commentNode" var="attrList"/>
                //      <assertNull actual="attrList" id="existingCommentAttributesNull"/>
                //  </if>
                // </for-each>
                for i in 0..node_list.length() {
                    comment_node = node_list.item(i).unwrap();
                    node_type = comment_node.node_type();
                    if node_type as i32 == 8 {
                        attr_list = comment_node.attributes();
                        assert!(attr_list.is_none());
                    }
                }
                let r#comment_node = r#doc.create_comment("This is a comment"); // <createComment var="commentNode" obj="doc" data="&quot;This is a comment&quot;"/>
                r#attr_list = r#comment_node.attributes(); // <attributes obj="commentNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="createdCommentAttributesNull"/>
            }
            // hc_elementgetelementsbytagnamespecialvalue.xml
            #[test]
            fn test_hc_elementgetelementsbytagnamespecialvalue() {
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let r#expected_result = vec!["em", "strong", "code", "sup", "var", "acronym"]; // type: List // <var name="expectedResult" type="List"><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member></var>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#last_employee = r#element_list.item(4).unwrap(); // <item interface="NodeList" obj="elementList" index="4" var="lastEmployee"/>
                let r#lastemp_list = r#last_employee.get_elements_by_tag_name("*"); // <getElementsByTagName interface="Element" obj="lastEmployee" var="lastempList" tagname="&quot;*&quot;"/>
                // <for-each collection="lastempList" member="child">
                //  <nodeName obj="child" var="childName"/>
                //  <append collection="result" item="childName"/>
                // </for-each>
                for i in 0..lastemp_list.length() {
                    let child = lastemp_list.item(i).unwrap();
                    child_name = child.node_name().to_string();
                    result.push(child_name);
                }
                assert_eq!(r#result, expected_result); // <assertEquals actual="result" expected="expectedResult" id="tagNames" ignoreCase="auto"/>
            }
            // nodelistindexgetlength.xml
            #[test]
            fn test_nodelistindexgetlength() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#length = r#employee_list.length(); // <length var="length" obj="employeeList" interface="NodeList"/>
                // <assertTrue id="lengthIs6or13">
                //  <or>
                //      <equals actual="length" expected="6" ignoreCase="false"/>
                //      <equals actual="length" expected="13" ignoreCase="false"/>
                //  </or>
                // </assertTrue>
                assert!(length == 6 || length == 13);
            }
            // nodeinsertbeforerefchildnull.xml
            #[test]
            fn test_nodeinsertbeforerefchildnull() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#inserted_node; // type: Node // <var name="insertedNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#new_child = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="newChild"/>
                r#inserted_node = r#employee_node
                    .insert_before(new_child.into(), None)
                    .unwrap(); // <insertBefore var="insertedNode" obj="employeeNode" newChild="newChild" refChild="refChild"/>
                r#child = r#employee_node.last_child().unwrap(); // <lastChild interface="Node" obj="employeeNode" var="child"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                assert_eq!(r#child_name, "newChild"); // <assertEquals actual="childName" expected="&quot;newChild&quot;" id="nodeInsertBeforeRefChildNullAssert1" ignoreCase="false"/>
            }
            // hc_nodevalue01.xml
            #[test]
            fn test_hc_nodevalue01() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_node; // type: Element // <var name="newNode" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#new_node = r#doc.create_element("acronym".to_string()).unwrap(); // <createElement obj="doc" var="newNode" tagName="&quot;acronym&quot;"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="initiallyNull"/>
                r#new_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
            }
            // namednodemapwrongdocumenterr.xml
            #[test]
            fn test_namednodemapwrongdocumenterr() {
                let r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc1 = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc1" href="staff" willBeModified="true"/>
                r#doc2 = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc2" href="staff" willBeModified="true"/>
                r#element_list = r#doc1.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc1" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                let r#new_attribute = r#doc2.create_attribute("newAttribute".to_string()).unwrap(); // <createAttribute obj="doc2" var="newAttribute" name="&quot;newAttribute&quot;"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <setNamedItem var="setNode" obj="attributes" arg="newAttribute"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .set_named_item(new_attribute)
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // hc_nodetextnodetype.xml
            #[test]
            fn test_hc_nodetextnodetype() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#text_node = r#test_addr.first_child().unwrap(); // <firstChild interface="Node" obj="testAddr" var="textNode"/>
                let r#node_type = r#text_node.node_type(); // <nodeType obj="textNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 3); // <assertEquals actual="nodeType" expected="3" id="nodeTextNodeTypeAssert1" ignoreCase="false"/>
            }
            // characterdatareplacedataexceedslengthofarg.xml
            #[test]
            fn test_characterdatareplacedataexceedslengthofarg() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.replace_data(0, 4, "260030").unwrap(); // <replaceData obj="child" offset="0" count="4" arg="&quot;260030&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "260030 North Ave. Dallas, Texas 98551"); // <assertEquals actual="childData" expected="&quot;260030 North Ave. Dallas, Texas 98551&quot;" id="characterdataReplaceDataExceedsLengthOfArgAssert" ignoreCase="false"/>
            }
            // nodeclonenodefalse.xml
            #[test]
            fn test_nodeclonenodefalse() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#cloned_node = r#employee_node.clone_node(false); // <cloneNode obj="employeeNode" deep="false" var="clonedNode"/>
                let r#clone_name = r#cloned_node.node_name().to_string(); // <nodeName obj="clonedNode" var="cloneName"/>
                assert_eq!(r#clone_name, "employee"); // <assertEquals actual="cloneName" expected="&quot;employee&quot;" ignoreCase="false" id="name"/>
                let r#clone_children = r#cloned_node.child_nodes(); // <childNodes obj="clonedNode" var="cloneChildren"/>
                let r#length = r#clone_children.length(); // <length interface="NodeList" obj="cloneChildren" var="length"/>
                assert_eq!(r#length, 0); // <assertEquals actual="length" expected="0" ignoreCase="false" id="length"/>
            }
            // documenttypegetnotations.xml
            #[test]
            fn test_documenttypegetnotations() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let r#notation_list; // type: NamedNodeMap // <var name="notationList" type="NamedNodeMap"/>
                let mut r#notation; // type: Node // <var name="notation" type="Node"/>
                let mut r#notation_name; // type: DOMString // <var name="notationName" type="DOMString"/>
                let mut r#actual = vec![]; // type: Collection // <var name="actual" type="Collection"/>
                let r#expected = vec!["notation1", "notation2"]; // type: Collection // <var name="expected" type="Collection"><member>"notation1"</member><member>"notation2"</member></var>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                notation_list = doc_type.notations(); // <notations obj="docType" var="notationList"/>
                // unimplemented: // <assertNotNull actual="notationList" id="notationsNotNull"/>
                // <for-each collection="notationList" member="notation">
                //  <nodeName obj="notation" var="notationName"/>
                //  <append collection="actual" item="notationName"/>
                // </for-each>
                for i in 0..notation_list.length() {
                    notation = notation_list.item(i).unwrap();
                    notation_name = notation.node_name().to_string();
                    actual.push(notation_name);
                }
                assert_eq!(r#actual, expected); // <assertEquals actual="actual" expected="expected" id="names" ignoreCase="false"/>
            }
            // nodevalue06.xml
            #[test]
            fn test_nodevalue06() {
                let mut r#new_node: DocumentRef; // <var name="newNode" type="Document"/>
                r#new_node = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="newNode" href="staff" willBeModified="true"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="initiallyNull"/>
                r#new_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
            }
            // hc_notationsremovenameditem1.xml
            #[test]
            fn test_hc_notationsremovenameditem1() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // unimplemented:
                // <if><not><contentType type="text/html"/></not>
                //  <assertNotNull actual="docType" id="docTypeNotNull"/>
                //  <notations var="notations" obj="docType"/>
                //  <assertNotNull actual="notations" id="notationsNotNull"/>
                //  <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //      <NO_MODIFICATION_ALLOWED_ERR>
                //          <removeNamedItem var="retval" obj="notations" name="&quot;notation1&quot;"/>
                //      </NO_MODIFICATION_ALLOWED_ERR>
                //  </assertDOMException>
                // </if>
            }
            // nodeattributenodeattribute.xml
            #[test]
            fn test_nodeattributenodeattribute() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#addr_attr = r#test_addr.attributes(); // <attributes obj="testAddr" var="addrAttr"/>
                let r#attr_node = r#addr_attr.item(0).unwrap(); // <item interface="NamedNodeMap" obj="addrAttr" var="attrNode" index="0"/>
                let r#attr_list = r#attr_node.attributes(); // <attributes obj="attrNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="nodeAttributeNodeAttributeAssert1"/>
            }
            // hc_characterdataindexsizeerrsubstringoffsetgreater.xml
            #[test]
            fn test_hc_characterdataindexsizeerrsubstringoffsetgreater() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                let r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                // <assertDOMException id="throw_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <substringData var="badString" obj="child" offset="40" count="3"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
                assert!(
                    child
                        .substring_data(40, 3)
                        .is_err_and(|err| err == DOMException::IndexSizeErr)
                );
            }
            // hc_attrappendchild6.xml
            #[test]
            fn test_hc_attrappendchild6() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#title_attr = r#doc.create_attribute("title".to_string()).unwrap(); // <createAttribute var="titleAttr" obj="doc" name="&quot;title&quot;"/>
                let r#text_node = r#doc.create_text_node("Yesterday"); // <createTextNode var="textNode" obj="doc" data="&quot;Yesterday&quot;"/>
                let r#retval = r#title_attr.append_child(text_node.into()).unwrap(); // <appendChild var="retval" obj="titleAttr" newChild="textNode"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrNodeValue" ignoreCase="false"/>
                r#value = r#retval.node_value().unwrap().to_string(); // <nodeValue obj="retval" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="retvalValue" ignoreCase="false"/>
                let r#last_child = r#title_attr.last_child().unwrap(); // <lastChild var="lastChild" obj="titleAttr" interface="Node"/>
                r#value = r#last_child.node_value().unwrap().to_string(); // <nodeValue obj="lastChild" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="lastChildValue" ignoreCase="false"/>
            }
            // namednodemapnumberofnodes.xml
            #[test]
            fn test_namednodemapnumberofnodes() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="2"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#length = r#attributes.length(); // <length var="length" obj="attributes" interface="NamedNodeMap"/>
                assert_eq!(r#length, 2); // <assertEquals actual="length" expected="2" id="length" ignoreCase="false"/>
            }
            // hc_attrprevioussiblingnull.xml
            #[test]
            fn test_hc_attrprevioussiblingnull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;acronym&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;title&quot;"/>
                let r#s = r#domestic_attr.previous_sibling(); // <previousSibling interface="Node" obj="domesticAttr" var="s"/>
                assert!(s.is_none()); // <assertNull actual="s" id="attrPreviousSiblingNullAssert"/>
            }
            // documentinvalidcharacterexceptioncreateentref.xml
            #[test]
            fn test_documentinvalidcharacterexceptioncreateentref() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#bad_entity_ref; // type: EntityReference // <var name="badEntityRef" type="EntityReference"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // unimplemented:
                // <if><contentType type="text/html"/>
                //  <assertDOMException id="throw_NOT_SUPPORTED_ERR">
                //      <NOT_SUPPORTED_ERR>
                //          <createEntityReference var="badEntityRef" obj="doc" name="&quot;foo&quot;"/>
                //      </NOT_SUPPORTED_ERR>
                //  </assertDOMException>
                // <else>
                //  <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //      <INVALID_CHARACTER_ERR>
                //          <createEntityReference var="badEntityRef" obj="doc" name="&quot;invalid^Name&quot;"/>
                //      </INVALID_CHARACTER_ERR>
                //  </assertDOMException>
                // </else>
                // </if>
            }
            // hc_attrclonenode1.xml
            #[test]
            fn test_hc_attrclonenode1() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                let r#last_child; // type: Node // <var name="lastChild" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#text_node = r#doc.create_text_node("terday"); // <createTextNode var="textNode" obj="doc" data="&quot;terday&quot;"/>
                r#retval = r#title_attr.append_child(text_node.clone().into()).unwrap(); // <appendChild var="retval" obj="titleAttr" newChild="textNode"/>
                let r#cloned_title = r#title_attr.clone_node(false).as_attribute().unwrap(); // <cloneNode var="clonedTitle" obj="titleAttr" deep="false"/>
                r#text_node.set_node_value("text_node_not_cloned").unwrap(); // <nodeValue obj="textNode" value="&quot;text_node_not_cloned&quot;"/>
                r#value = r#cloned_title.value().to_string(); // <value interface="Attr" obj="clonedTitle" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#cloned_title.node_value().unwrap().to_string(); // <nodeValue obj="clonedTitle" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrNodeValue" ignoreCase="false"/>
                r#last_child = r#cloned_title.last_child().unwrap(); // <lastChild var="lastChild" obj="clonedTitle" interface="Node"/>
                r#value = r#last_child.node_value().unwrap().to_string(); // <nodeValue obj="lastChild" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="lastChildValue" ignoreCase="false"/>
            }
            // documentgetrootnode.xml
            #[test]
            fn test_documentgetrootnode() {
                let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#root = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="root"/>
                r#root_name = r#root.node_name().to_string(); // <nodeName obj="root" var="rootName"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //  <assertEquals actual="rootName" expected="&quot;svg&quot;" id="svgRootNode" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="rootName" expected="&quot;staff&quot;" id="documentGetRootNodeAssert" ignoreCase="false"/>
                // </else>
                // </if>
            }
            // hc_nodeinsertbefore.xml
            #[test]
            fn test_hc_nodeinsertbefore() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#inserted_node; // type: Node // <var name="insertedNode" type="Node"/>
                let mut r#actual = vec![]; // type: List // <var name="actual" type="List"/>
                let r#expected = vec!["em", "strong", "code", "br", "sup", "var", "acronym"]; // type: List // <var name="expected" type="List"><member>"em"</member><member>"strong"</member><member>"code"</member><member>"br"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member></var>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("sup"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;sup&quot;" var="elementList"/>
                r#ref_child = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="refChild"/>
                r#employee_node = r#ref_child.parent_node().unwrap(); // <parentNode interface="Node" var="employeeNode" obj="refChild"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes var="childList" obj="employeeNode"/>
                r#new_child = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="newChild"/>
                r#inserted_node = r#employee_node
                    .insert_before(new_child.into(), Some(ref_child.into()))
                    .unwrap(); // <insertBefore var="insertedNode" obj="employeeNode" newChild="newChild" refChild="refChild"/>
                // <for-each collection="childList" member="child">
                //  <nodeType var="nodeType" obj="child"/>
                //  <if><equals actual="nodeType" expected="1"/>
                //      <nodeName obj="child" var="childName"/>
                //      <append collection="actual" item="childName"/>
                //  </if>
                // </for-each>
                for i in 0..child_list.length() {
                    child = child_list.item(i).unwrap();
                    node_type = child.node_type();
                    if node_type as i32 == 1 {
                        child_name = child.node_name().to_string();
                        actual.push(child_name);
                    }
                }
                assert_eq!(r#actual, expected); // <assertEquals actual="actual" expected="expected" id="nodeNames" ignoreCase="auto"/>
            }
            // documentinvalidcharacterexceptioncreateattribute.xml
            #[test]
            fn test_documentinvalidcharacterexceptioncreateattribute() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <createAttribute var="createdAttr" obj="doc" name="&quot;invalid^Name&quot;"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_attribute("invalid^Name")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // hc_textsplittextfour.xml
            #[test]
            fn test_hc_textsplittextfour() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#address_node; // type: Node // <var name="addressNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                r#address_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="addressNode" index="0"/>
                r#text_node = r#address_node
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild interface="Node" obj="addressNode" var="textNode"/>
                let r#split_node = r#text_node.split_text(30).unwrap(); // <splitText obj="textNode" var="splitNode" offset="30"/>
                let r#value = r#split_node.node_value().unwrap().to_string(); // <nodeValue obj="splitNode" var="value"/>
                assert_eq!(r#value, "98551"); // <assertEquals actual="value" expected="&quot;98551&quot;" id="textSplitTextFourAssert" ignoreCase="false"/>
            }
            // hc_characterdataindexsizeerrinsertdataoffsetnegative.xml
            #[test]
            fn test_hc_characterdataindexsizeerrinsertdataoffsetnegative() {
                // unimplemented: // <implementationAttribute name="signed" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // unimplemented:
                // <assertDOMException id="throws_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <replaceData obj="child" offset="-5" arg="&quot;ABC&quot;" count="3"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
            }
            // documentgetelementsbytagnametotallength.xml
            #[test]
            fn test_documentgetelementsbytagnametotallength() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#name_list; // type: NodeList // <var name="nameList" type="NodeList"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#name_list = r#doc.get_elements_by_tag_name("*"); // <getElementsByTagName interface="Document" obj="doc" var="nameList" tagname="&quot;*&quot;"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //  <assertSize collection="nameList" size="39" id="elementCountSVG"/>
                // <else>
                //  <assertSize collection="nameList" size="37" id="documentGetElementsByTagNameTotalLengthAssert"/>
                // </else>
                // </if>
            }
            // nodetextnodevalue.xml
            #[test]
            fn test_nodetextnodevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#text_node = r#test_addr.first_child().unwrap(); // <firstChild interface="Node" obj="testAddr" var="textNode"/>
                let r#text_value = r#text_node.node_value().unwrap().to_string(); // <nodeValue obj="textNode" var="textValue"/>
                assert_eq!(r#text_value, "1230 North Ave. Dallas, Texas 98551"); // <assertEquals actual="textValue" expected="&quot;1230 North Ave. Dallas, Texas 98551&quot;" id="nodeTextNodeValueAssert1" ignoreCase="false"/>
            }
            // hc_characterdatadeletedatamiddle.xml
            #[test]
            fn test_hc_characterdatadeletedatamiddle() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.delete_data(16, 8).unwrap(); // <deleteData obj="child" offset="16" count="8"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230 North Ave. Texas 98551"); // <assertEquals actual="childData" expected="&quot;1230 North Ave. Texas 98551&quot;" id="characterdataDeleteDataMiddleAssert" ignoreCase="false"/>
            }
            // hc_attrgetvalue2.xml
            #[test]
            fn test_hc_attrgetvalue2() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                // let mut r#test_node; // type: Node // <var name="testNode" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                // let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                // let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                // let mut r#alpha_ref; // type: EntityReference // <var name="alphaRef" type="EntityReference"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                // r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                // r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                // r#title_attr = r#attributes.get_named_item("class").unwrap();
                // // <getNamedItem obj="attributes" var="titleAttr" name="&quot;class&quot;"/>

                // unimplemented:
                // <if><contentType type="text/html"/>
                //  <assertDOMException id="throw_NOT_SUPPORTED_ERR">
                //      <NOT_SUPPORTED_ERR>
                //          <createEntityReference var="alphaRef" obj="doc" name="&quot;alpha&quot;"/>
                //      </NOT_SUPPORTED_ERR>
                //  </assertDOMException>
                // <else>
                //  <!--  create an alpha entity reference and place it first -->
                //  <createEntityReference var="alphaRef" obj="doc" name="&quot;alpha&quot;"/>
                //  <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                //  <insertBefore var="retval" obj="titleAttr" newChild="alphaRef" refChild="firstChild"/>
                //  <!--  check that Attr.value gives expected result   -->
                //  <value interface="Attr" obj="titleAttr" var="value"/>
                //  <assertEquals actual="value" expected="&quot;αYα&quot;" id="attrValue1" ignoreCase="false"/>
                // </else>
                // </if>
            }
            // characterdatasetnodevalue.xml
            #[test]
            fn test_characterdatasetnodevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.set_node_value("Marilyn Martin").unwrap(); // <nodeValue obj="child" value="&quot;Marilyn Martin&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Marilyn Martin"); // <assertEquals actual="childData" expected="&quot;Marilyn Martin&quot;" id="data" ignoreCase="false"/>
                let r#child_value = r#child.node_value().unwrap().to_string(); // <nodeValue obj="child" var="childValue"/>
                assert_eq!(r#child_value, "Marilyn Martin"); // <assertEquals actual="childValue" expected="&quot;Marilyn Martin&quot;" id="value" ignoreCase="false"/>
            }
            // nodecommentnodetype.xml
            #[test]
            fn test_nodecommentnodetype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#test_list; // type: NodeList // <var name="testList" type="NodeList"/>
                let mut r#comment_node; // type: Node // <var name="commentNode" type="Node"/>
                let mut r#comment_node_name; // type: DOMString // <var name="commentNodeName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#test_list = r#doc.child_nodes(); // <childNodes obj="doc" var="testList"/>
                // <for-each collection="testList" member="commentNode">
                //  <nodeName obj="commentNode" var="commentNodeName"/>
                //  <if><equals actual="commentNodeName" expected="&quot;#comment&quot;" ignoreCase="false"/>
                //      <nodeType obj="commentNode" var="nodeType"/>
                //      <assertEquals actual="nodeType" expected="8" id="nodeCommentNodeTypeAssert1" ignoreCase="false"/>
                //  </if>
                // </for-each>
                for i in 0..test_list.length() {
                    comment_node = test_list.item(i).unwrap();
                    comment_node_name = comment_node.node_name().to_string();
                    if comment_node_name == "#comment" {
                        node_type = comment_node.node_type();
                        assert_eq!(node_type as i32, 8);
                    }
                }
            }
            // hc_documentcreateelement.xml
            #[test]
            fn test_hc_documentcreateelement() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#new_element = r#doc.create_element("acronym".to_string()).unwrap(); // <createElement obj="doc" var="newElement" tagName="&quot;acronym&quot;"/>
                let r#new_element_name = r#new_element.node_name().to_string(); // <nodeName obj="newElement" var="newElementName"/>
                assert_eq!(r#new_element_name, "acronym"); // <assertEquals actual="newElementName" expected="&quot;acronym&quot;" ignoreCase="auto" id="strong"/>
                let r#new_element_type = r#new_element.node_type(); // <nodeType obj="newElement" var="newElementType"/>
                assert_eq!(r#new_element_type as i32, 1); // <assertEquals actual="newElementType" expected="1" ignoreCase="false" id="type"/>
                let r#new_element_value = r#new_element.node_value(); // <nodeValue obj="newElement" var="newElementValue"/>
                assert!(new_element_value.is_none()); // <assertNull actual="newElementValue" id="valueInitiallyNull"/>
            }
            // namednodemapreturnfirstitem.xml
            #[test]
            fn test_namednodemapreturnfirstitem() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_address = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="1"/>
                let r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                let r#child = r#attributes.item(0).unwrap(); // <item interface="NamedNodeMap" obj="attributes" var="child" index="0"/>
                let r#name = r#child.node_name().to_string(); // <nodeName obj="child" var="name"/>
                // <assertTrue id="namednodemapReturnFirstItemAssert">
                //  <or>
                //      <equals actual="name" expected="&quot;domestic&quot;" ignoreCase="false"/>
                //      <equals actual="name" expected="&quot;street&quot;" ignoreCase="false"/>
                //  </or>
                // </assertTrue>
                assert!(name == "domestic" || name == "street");
            }
            // characterdatainsertdatabeginning.xml
            #[test]
            fn test_characterdatainsertdatabeginning() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.insert_data(0, "Mss. ").unwrap(); // <insertData obj="child" offset="0" arg="&quot;Mss. &quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Mss. Margaret Martin"); // <assertEquals actual="childData" expected="&quot;Mss. Margaret Martin&quot;" id="characterdataInsertDataBeginningAssert" ignoreCase="false"/>
            }
            // nodereplacechildnewchildexists.xml
            #[test]
            fn test_nodereplacechildnewchildexists() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node" isNull="true"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node" isNull="true"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#child_node; // type: Node // <var name="childNode" type="Node"/>
                let mut r#actual = vec![]; // type: List // <var name="actual" type="List"/>
                let r#expected; // type: List // <var name="expected" type="List"/>
                let r#expected_without_whitespace =
                    vec!["name", "position", "salary", "gender", "employeeId"]; // type: List // <var name="expectedWithoutWhitespace" type="List"><member>"name"</member><member>"position"</member><member>"salary"</member><member>"gender"</member><member>"employeeId"</member></var>
                let mut r#expected_with_whitespace = vec![
                    "#text",
                    "#text",
                    "name",
                    "#text",
                    "position",
                    "#text",
                    "salary",
                    "#text",
                    "gender",
                    "#text",
                    "employeeId",
                    "#text",
                ]; // type: List // <var name="expectedWithWhitespace" type="List"><member>"#text"</member><member>"#text"</member><member>"name"</member><member>"#text"</member><member>"position"</member><member>"#text"</member><member>"salary"</member><member>"#text"</member><member>"gender"</member><member>"#text"</member><member>"employeeId"</member><member>"#text"</member></var>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#length = r#child_list.length(); // <length var="length" obj="childList" interface="NodeList"/>
                // <if><equals actual="length" expected="13" ignoreCase="false"/>
                //  <item interface="NodeList" obj="childList" index="1" var="newChild"/>
                //  <item interface="NodeList" obj="childList" index="11" var="oldChild"/>
                //  <assign var="expected" value="expectedWithWhitespace"/>
                // <else>
                //  <item interface="NodeList" obj="childList" index="0" var="newChild"/>
                //  <item interface="NodeList" obj="childList" index="5" var="oldChild"/>
                //  <assign var="expected" value="expectedWithoutWhitespace"/>
                // </else>
                // </if>
                if length == 13 {
                    new_child = child_list.item(1).unwrap();
                    old_child = child_list.item(11).unwrap();
                    expected = expected_with_whitespace;
                } else {
                    new_child = child_list.item(0).unwrap();
                    old_child = child_list.item(5).unwrap();
                    expected = expected_without_whitespace;
                }
                let r#replaced_child = r#employee_node
                    .replace_child(new_child, old_child.clone())
                    .unwrap(); // <replaceChild var="replacedChild" obj="employeeNode" newChild="newChild" oldChild="oldChild"/>

                assert!(replaced_child.is_same_node(&old_child)); // <assertSame actual="replacedChild" expected="oldChild" id="return_value_same"/>
                // <for-each collection="childList" member="childNode">
                //  <nodeName var="childName" obj="childNode"/>
                //  <append collection="actual" item="childName"/>
                // </for-each>
                for i in 0..child_list.length() {
                    child_node = child_list.item(i).unwrap();
                    child_name = child_node.node_name().to_string();
                    actual.push(child_name);
                }
                assert_eq!(r#actual, expected); // <assertEquals actual="actual" expected="expected" id="childNames" ignoreCase="false"/>
            }
            // characterdatasetdatanomodificationallowederrEE.xml
            #[test]
            fn test_characterdatasetdatanomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let mut r#ent_text; // type: Node // <var name="entText" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(4).unwrap(); // <item interface="NodeList" obj="genderList" index="4" var="genderNode"/>
                let r#ent_reference = r#doc.create_entity_reference("ent3".to_string()).unwrap(); // <createEntityReference var="entReference" obj="doc" name="&quot;ent3&quot;"/>
                // unimplemented: // <assertNotNull actual="entReference" id="createdEntRefNotNull"/>
                r#ent_text = r#ent_reference
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild var="entText" obj="entReference" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entText" id="entTextNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <data interface="CharacterData" obj="entText" value="&quot;newData&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_text
                        .set_data("newData")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_nodeinsertbeforeinvalidnodetype.xml
            #[test]
            fn test_hc_nodeinsertbeforeinvalidnodetype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Element // <var name="rootNode" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#new_child = r#doc.create_attribute("title".to_string()).unwrap(); // <createAttribute obj="doc" name="&quot;title&quot;" var="newChild"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#ref_child = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="refChild"/>
                r#root_node = r#ref_child.parent_node().unwrap(); // <parentNode var="rootNode" obj="refChild" interface="Node"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <insertBefore var="insertedNode" obj="rootNode" newChild="newChild" refChild="refChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    root_node
                        .insert_before(new_child.into(), Some(ref_child.into()))
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // elementremoveattributenodenomodificationallowederr.xml
            #[test]
            fn test_elementremoveattributenodenomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender; // type: Node // <var name="gender" type="Node"/>
                let r#gen_list; // type: NodeList // <var name="genList" type="NodeList"/>
                let mut r#gen; // type: Node // <var name="gen" type="Node"/>
                let r#g_list; // type: NodeList // <var name="gList" type="NodeList"/>
                let mut r#gen_element; // type: Element // <var name="genElement" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#gen_list = r#gender.child_nodes(); // <childNodes obj="gender" var="genList"/>
                r#gen = r#gen_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="genList" var="gen" index="0"/>
                // unimplemented: // <assertNotNull actual="gen" id="genNotNull"/>
                let r#node_type = r#gen.node_type(); // <nodeType var="nodeType" obj="gen"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="gen" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="gen" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    r#gen = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#g_list = r#gen.child_nodes(); // <childNodes obj="gen" var="gList"/>
                r#gen_element = r#g_list.item(0).unwrap().clone().as_element().unwrap(); // <item interface="NodeList" obj="gList" var="genElement" index="0"/>
                // unimplemented: // <assertNotNull actual="genElement" id="genElementNotNull"/>
                let r#attr_list = r#gen_element.attributes(); // <attributes obj="genElement" var="attrList"/>
                let r#attr_node = r#attr_list.get_named_item("domestic").unwrap(); // <getNamedItem obj="attrList" var="attrNode" name="&quot;domestic&quot;"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <removeAttributeNode var="removedAttr" obj="genElement" oldAttr="attrNode"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    gen_element
                        .remove_attribute_node(attr_node)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_documentgetelementsbytagnametotallength.xml
            #[test]
            fn test_hc_documentgetelementsbytagnametotallength() {
                let mut r#expected_names = vec![
                    "html", "head", "meta", "title", "script", "script", "script", "body", "p",
                    "em", "strong", "code", "sup", "var", "acronym", "p", "em", "strong", "code",
                    "sup", "var", "acronym", "p", "em", "strong", "code", "sup", "var", "acronym",
                    "p", "em", "strong", "code", "sup", "var", "acronym", "p", "em", "strong",
                    "code", "sup", "var", "acronym",
                ]; // type: List // <var name="expectedNames" type="List"><member>"html"</member><member>"head"</member><member>"meta"</member><member>"title"</member><member>"script"</member><member>"script"</member><member>"script"</member><member>"body"</member><member>"p"</member><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member><member>"p"</member><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member> <member>"var"</member><member>"acronym"</member><member>"p"</member> <member>"em"</member> <member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member><member>"p"</member><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member><member>"p"</member><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member></var>
                let mut r#svg_expected_names = vec![
                    "svg", "rect", "script", "head", "meta", "title", "body", "p", "em", "strong",
                    "code", "sup", "var", "acronym", "p", "em", "strong", "code", "sup", "var",
                    "acronym", "p", "em", "strong", "code", "sup", "var", "acronym", "p", "em",
                    "strong", "code", "sup", "var", "acronym", "p", "em", "strong", "code", "sup",
                    "var", "acronym",
                ]; // type: List // <var name="svgExpectedNames" type="List"><member>"svg"</member><member>"rect"</member><member>"script"</member><member>"head"</member><member>"meta"</member><member>"title"</member><member>"body"</member><member>"p"</member><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member><member>"p"</member><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member><member>"p"</member><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member><member>"p"</member> <member>"em"</member> <member>"strong"</member> <member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member><member>"p"</member><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member></var>
                let mut r#actual_names = vec![]; // type: List // <var name="actualNames" type="List"/>
                let mut r#this_tag; // type: DOMString // <var name="thisTag" type="DOMString"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#name_list = r#doc.get_elements_by_tag_name("*"); // <getElementsByTagName interface="Document" obj="doc" var="nameList" tagname="&quot;*&quot;"/>
                // <for-each collection="nameList" member="thisElement">
                //  <tagName var="thisTag" obj="thisElement"/>
                //  <append collection="actualNames" item="thisTag"/>
                // </for-each>
                for i in 0..name_list.length() {
                    let this_element = name_list.item(i).unwrap();
                    this_tag = this_element.tag_name().to_string();
                    actual_names.push(this_tag);
                }

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //  <assertEquals expected="svgExpectedNames" actual="actualNames" ignoreCase="auto" id="svgTagNames"/>
                // <else>
                //  <assertEquals expected="expectedNames" actual="actualNames" ignoreCase="auto" id="tagNames"/>
                // </else>
                // </if>
            }
            // nodesetnodevaluenomodificationallowederrEE.xml
            #[test]
            fn test_nodesetnodevaluenomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#ent_text; // type: CharacterData // <var name="entText" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#ent_ref = r#doc.create_entity_reference("ent3".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent3&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                r#ent_text = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" var="entText" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entText" id="entTextNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <nodeValue obj="entText" value="&quot;newValue&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_text
                        .set_node_value("newValue")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // characterdatadeletedatanomodificationallowederrEE.xml
            #[test]
            fn test_characterdatadeletedatanomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let mut r#ent_text; // type: Node // <var name="entText" type="Node"/>
                let r#ent_reference; // type: EntityReference // <var name="entReference" type="EntityReference"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" index="2" var="genderNode"/>
                r#ent_reference = r#doc.create_entity_reference("ent3".to_string()).unwrap(); // <createEntityReference obj="doc" var="entReference" name="&quot;ent3&quot;"/>
                // unimplemented: // <assertNotNull actual="entReference" id="createdEntRefNotNull"/>
                r#appended_child = r#gender_node
                    .append_child(ent_reference.clone().into())
                    .unwrap(); // <appendChild obj="genderNode" newChild="entReference" var="appendedChild"/>
                r#ent_text = r#ent_reference
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild var="entText" obj="entReference" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entText" id="entTextNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <deleteData obj="entText" offset="1" count="3"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_text
                        .delete_data(1, 3)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodelistindexnotzero.xml
            #[test]
            fn test_nodelistindexnotzero() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#length = r#employee_list.length(); // <length var="length" obj="employeeList" interface="NodeList"/>
                // <if><equals actual="length" expected="6" ignoreCase="false"/>
                //  <item interface="NodeList" obj="employeeList" var="child" index="1"/>
                // <else>
                //  <item interface="NodeList" obj="employeeList" var="child" index="3"/>
                // </else>
                // </if>
                let child = if length == 6 {
                    employee_list.item(1).unwrap()
                } else {
                    employee_list.item(3).unwrap()
                };
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                assert_eq!(r#child_name, "name"); // <assertEquals actual="childName" expected="&quot;name&quot;" id="nodeName" ignoreCase="false"/>
            }
            // hc_characterdataindexsizeerrreplacedataoffsetnegative.xml
            #[test]
            fn test_hc_characterdataindexsizeerrreplacedataoffsetnegative() {
                // unimplemented: // <implementationAttribute name="signed" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // unimplemented:
                // <assertDOMException id="throws_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <replaceData obj="child" offset="-5" count="3" arg="&quot;ABC&quot;"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
            }
            // nodeentitynodetype.xml
            #[test]
            fn test_nodeentitynodetype() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#entities = doc_type.entities(); // <entities obj="docType" var="entities"/>
                // unimplemented: // <assertNotNull actual="entities" id="entitiesNotNull"/>
                let r#entity_node = r#entities.get_named_item("ent1").unwrap(); // <getNamedItem obj="entities" var="entityNode" name="&quot;ent1&quot;"/>
                // unimplemented: // <assertNotNull actual="entityNode" id="ent1NotNull"/>
                let r#node_type = r#entity_node.node_type(); // <nodeType obj="entityNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 6); // <assertEquals actual="nodeType" expected="6" id="entityNodeType" ignoreCase="false"/>
            }
            // hc_nodehaschildnodesfalse.xml
            #[test]
            fn test_hc_nodehaschildnodesfalse() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#em_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;em&quot;" var="emList"/>
                let r#em_node = r#em_list.item(0).unwrap(); // <item interface="NodeList" obj="emList" index="0" var="emNode"/>
                let r#em_text = r#em_node.first_child().unwrap(); // <firstChild var="emText" obj="emNode" interface="Node"/>
                let r#has_child = r#em_text.has_child_nodes(); // <hasChildNodes var="hasChild" obj="emText" interface="Node"/>
                assert!(!r#has_child); // <assertFalse actual="hasChild" id="hasChild"/>
            }
            // hc_characterdatasetnodevalue.xml
            #[test]
            fn test_hc_characterdatasetnodevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.set_node_value("Marilyn Martin").unwrap(); // <nodeValue obj="child" value="&quot;Marilyn Martin&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Marilyn Martin"); // <assertEquals actual="childData" expected="&quot;Marilyn Martin&quot;" id="data" ignoreCase="false"/>
                let r#child_value = r#child.node_value().unwrap().to_string(); // <nodeValue obj="child" var="childValue"/>
                assert_eq!(r#child_value, "Marilyn Martin"); // <assertEquals actual="childValue" expected="&quot;Marilyn Martin&quot;" id="value" ignoreCase="false"/>
            }
            // characterdataindexsizeerrdeletedataoffsetgreater.xml
            #[test]
            fn test_characterdataindexsizeerrdeletedataoffsetgreater() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                // <assertDOMException id="throw_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <deleteData obj="child" offset="40" count="3"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
                assert!(
                    child
                        .delete_data(40, 3)
                        .is_err_and(|err| err == DOMException::IndexSizeErr)
                );
            }
            // nodeattributenodetype.xml
            #[test]
            fn test_nodeattributenodetype() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#addr_attr = r#test_addr.get_attribute_node("domestic").unwrap(); // <getAttributeNode obj="testAddr" name="&quot;domestic&quot;" var="addrAttr"/>
                let r#node_type = r#addr_attr.node_type(); // <nodeType obj="addrAttr" var="nodeType"/>
                assert_eq!(r#node_type as i32, 2); // <assertEquals actual="nodeType" expected="2" id="nodeAttrNodeTypeAssert1" ignoreCase="false"/>
            }
            // hc_attrchildnodes1.xml
            #[test]
            fn test_hc_attrchildnodes1() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let r#text_node; // type: Text // <var name="textNode" type="Text"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                let r#child_nodes = r#title_attr.child_nodes(); // <childNodes var="childNodes" obj="titleAttr"/>
                assert_eq!(child_nodes.length(), 1); // <assertSize size="1" collection="childNodes" id="childNodesSize"/>
                r#text_node = r#child_nodes.item(0).unwrap().clone(); // <item var="textNode" obj="childNodes" index="0" interface="NodeList"/>
                let r#value = r#text_node.node_value().unwrap().to_string(); // <nodeValue var="value" obj="textNode"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="child1IsYes" ignoreCase="false"/>
                let r#text_node = r#child_nodes.item(1); // <item var="textNode" obj="childNodes" index="1" interface="NodeList"/>
                assert!(text_node.is_none()); // <assertNull actual="textNode" id="secondItemIsNull"/>
            }
            // elementreplaceexistingattribute.xml
            #[test]
            fn test_elementreplaceexistingattribute() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#set_attr; // type: Attr // <var name="setAttr" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                r#new_attribute = r#doc.create_attribute("street".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;street&quot;"/>
                r#set_attr = r#test_employee
                    .set_attribute_node(r#new_attribute)
                    .unwrap()
                    .unwrap(); // <setAttributeNode var="setAttr" obj="testEmployee" newAttr="newAttribute"/>
                let r#name = r#test_employee.get_attribute("street"); // <getAttribute obj="testEmployee" var="name" name="&quot;street&quot;"/>
                assert_eq!(r#name, ""); // <assertEquals actual="name" expected="&quot;&quot;" id="elementReplaceExistingAttributeAssert" ignoreCase="false"/>
            }
            // hc_elementcreatenewattribute.xml
            #[test]
            fn test_hc_elementcreatenewattribute() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#district_attr; // type: Attr // <var name="districtAttr" type="Attr"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_address = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddress"/>
                r#new_attribute = r#doc.create_attribute("lang".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;lang&quot;"/>
                let r#old_attr = r#test_address.set_attribute_node(r#new_attribute).unwrap(); // <setAttributeNode obj="testAddress" var="oldAttr" newAttr="newAttribute"/>
                assert!(old_attr.is_none()); // <assertNull actual="oldAttr" id="old_attr_doesnt_exist"/>
                r#district_attr = r#test_address.get_attribute_node("lang").unwrap(); // <getAttributeNode obj="testAddress" var="districtAttr" name="&quot;lang&quot;"/>
                // unimplemented: // <assertNotNull actual="districtAttr" id="new_district_accessible"/>
                let r#attr_val = r#test_address.get_attribute("lang"); // <getAttribute var="attrVal" obj="testAddress" name="&quot;lang&quot;"/>
                assert_eq!(r#attr_val, ""); // <assertEquals actual="attrVal" expected="&quot;&quot;" id="attr_value" ignoreCase="false"/>
            }
            // namednodemapremovenameditemgetvalue.xml
            #[test]
            fn test_namednodemapremovenameditemgetvalue() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let r#street_attr; // type: Attr // <var name="streetAttr" type="Attr"/>
                let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="2"/>
                r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                // unimplemented: // <assertNotNull actual="attributes" id="attributesNotNull"/>
                r#removed_node = r#attributes.remove_named_item("street").unwrap(); // <removeNamedItem var="removedNode" obj="attributes" name="&quot;street&quot;"/>
                r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                // unimplemented: // <assertNotNull actual="streetAttr" id="streetAttrNotNull"/>
                let r#value = r#street_attr.value().to_string(); // <value interface="Attr" obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="namednodemapRemoveNamedItemGetValueAssert" ignoreCase="false"/>
            }
            // elementsetattributenodenomodificationallowederrEE.xml
            #[test]
            fn test_elementsetattributenodenomodificationallowederr_ee() {
                // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender; // type: Node // <var name="gender" type="Node"/>
                let r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                let r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                r#appended_child = r#gender.append_child(ent_ref.clone().into()).unwrap(); // <appendChild obj="gender" newChild="entRef" var="appendedChild"/>
                r#ent_element = r#ent_ref.first_child().unwrap().as_element().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#new_attr = r#doc.create_attribute("newAttr".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttr" name="&quot;newAttr&quot;"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <setAttributeNode var="badAttr" obj="entElement" newAttr="newAttr"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element
                        .set_attribute_node(new_attr)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_nodechildnodes.xml
            #[test]
            fn test_hc_nodechildnodes() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let mut r#child_node; // type: Node // <var name="childNode" type="Node"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#actual = vec![]; // type: List // <var name="actual" type="List"/>
                let r#expected = vec!["em", "strong", "code", "sup", "var", "acronym"]; // type: List // <var name="expected" type="List"><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member></var>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_nodes = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childNodes"/>
                // <for-each collection="childNodes" member="childNode">
                //  <nodeType var="nodeType" obj="childNode"/>
                //  <nodeName var="childName" obj="childNode"/>
                //  <if><equals actual="nodeType" expected="1"/>
                //      <append collection="actual" item="childName"/>
                //  <else>
                //      <assertEquals actual="nodeType" expected="3" ignoreCase="false" id="textNodeType"/>
                //  </else>
                //  </if>
                // </for-each>
                for i in 0..child_nodes.length() {
                    child_node = child_nodes.item(i).unwrap();
                    node_type = child_node.node_type();
                    child_name = child_node.node_name().to_string();
                    if node_type as i32 == 1 {
                        actual.push(child_name);
                    } else {
                        assert_eq!(node_type as i32, 3);
                    }
                }
                assert_eq!(r#actual, expected); // <assertEquals actual="actual" expected="expected" id="elementNames" ignoreCase="auto"/>
            }
            // nodecdatasectionnodevalue.xml
            #[test]
            fn test_nodecdatasectionnodevalue() {
                // unimplemented: // <implementationAttribute name="coalescing" value="false"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;name&quot;"/>
                let r#cdata_name = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="cdataName"/>
                let r#child_list = r#cdata_name.child_nodes(); // <childNodes obj="cdataName" var="childList"/>
                let r#child = r#child_list.item(1).unwrap().clone(); // <item interface="NodeList" obj="childList" index="1" var="child"/>
                // <if><isNull obj="child"/>
                //  <createCDATASection var="child" obj="doc" data="&quot;This is a CDATASection with EntityReference number 2 &amp;ent2;&quot;"/>
                // </if>
                let r#cdata_node_value = r#child.node_value().unwrap().to_string(); // <nodeValue obj="child" var="cdataNodeValue"/>
                assert_eq!(
                    r#cdata_node_value,
                    "This is a CDATASection with EntityReference number 2 &ent2;"
                ); // <assertEquals actual="cdataNodeValue" expected="&quot;This is a CDATASection with EntityReference number 2 &amp;ent2;&quot;" id="value" ignoreCase="false"/>
            }
            // characterdataindexsizeerrreplacedatacountnegative.xml
            #[test]
            fn test_characterdataindexsizeerrreplacedatacountnegative() {
                // unimplemented: // <implementationAttribute name="signed" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // unimplemented:
                // <assertDOMException id="throws_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <replaceData obj="child" offset="10" count="-3" arg="&quot;ABC&quot;"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
            }
            // documenttypegetnotationstype.xml
            #[test]
            fn test_documenttypegetnotationstype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let r#notation_list; // type: NamedNodeMap // <var name="notationList" type="NamedNodeMap"/>
                let mut r#notation; // type: Node // <var name="notation" type="Node"/>
                let mut r#notation_type; // type: int // <var name="notationType" type="int"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                notation_list = doc_type.notations(); // <notations obj="docType" var="notationList"/>
                // unimplemented: // <assertNotNull actual="notationList" id="notationsNotNull"/>
                // <for-each collection="notationList" member="notation">
                //  <nodeType obj="notation" var="notationType"/>
                //  <assertEquals actual="notationType" expected="12" id="documenttypeGetNotationsTypeAssert" ignoreCase="false"/>
                // </for-each>
                for i in 0..notation_list.length() {
                    notation = notation_list.item(i).unwrap();
                    notation_type = notation.node_type();
                    assert_eq!(notation_type as i32, 12);
                }
            }
            // hc_characterdatainsertdataend.xml
            #[test]
            fn test_hc_characterdatainsertdataend() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.insert_data(15, ", Esquire").unwrap(); // <insertData obj="child" offset="15" arg="&quot;, Esquire&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Margaret Martin, Esquire"); // <assertEquals actual="childData" expected="&quot;Margaret Martin, Esquire&quot;" id="characterdataInsertDataEndAssert" ignoreCase="false"/>
            }
            // hc_nodevalue06.xml
            #[test]
            fn test_hc_nodevalue06() {
                let mut r#new_node: DocumentRef; // <var name="newNode" type="Document"/>
                r#new_node = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="newNode" href="hc_staff" willBeModified="true"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="initiallyNull"/>
                r#new_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
            }
            // hc_documentcreatetextnode.xml
            #[test]
            fn test_hc_documentcreatetextnode() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#new_text_node = r#doc.create_text_node("This is a new Text node"); // <createTextNode obj="doc" var="newTextNode" data="&quot;This is a new Text node&quot;"/>
                let r#new_text_value = r#new_text_node.node_value().unwrap().to_string(); // <nodeValue obj="newTextNode" var="newTextValue"/>
                assert_eq!(r#new_text_value, "This is a new Text node"); // <assertEquals actual="newTextValue" expected="&quot;This is a new Text node&quot;" ignoreCase="false" id="value"/>
                let r#new_text_name = r#new_text_node.node_name().to_string(); // <nodeName obj="newTextNode" var="newTextName"/>
                assert_eq!(r#new_text_name, "#text"); // <assertEquals actual="newTextName" expected="&quot;#text&quot;" ignoreCase="false" id="strong"/>
                let r#new_text_type = r#new_text_node.node_type(); // <nodeType obj="newTextNode" var="newTextType"/>
                assert_eq!(r#new_text_type as i32, 3); // <assertEquals actual="newTextType" expected="3" ignoreCase="false" id="type"/>
            }
            // hc_nodelistindexnotzero.xml
            #[test]
            fn test_hc_nodelistindexnotzero() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;p&quot;"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#child = r#employee_list.item(3).unwrap().clone(); // <item interface="NodeList" obj="employeeList" var="child" index="3"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                // <if><equals expected="&quot;#text&quot;" actual="childName"/>
                //  <assertEquals id="childName_space" actual="childName" expected="&quot;#text&quot;" ignoreCase="false"/>
                // <else>
                //  <assertEquals id="childName_strong" actual="childName" expected="&quot;strong&quot;" ignoreCase="auto"/>
                // </else>
                // </if>
                if child_name == "#text" {
                    assert_eq!(child_name, "#text");
                } else {
                    assert_eq!(child_name, "strong");
                }
            }
            // elementremoveattributeaftercreate.xml
            #[test]
            fn test_elementremoveattributeaftercreate() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#district_attr; // type: Attr // <var name="districtAttr" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                r#new_attribute = r#doc.create_attribute("district".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;district&quot;"/>
                r#district_attr = r#test_employee
                    .set_attribute_node(r#new_attribute.clone())
                    .unwrap(); // <setAttributeNode obj="testEmployee" var="districtAttr" newAttr="newAttribute"/>
                let r#district_attr = r#test_employee
                    .remove_attribute_node(r#new_attribute)
                    .unwrap(); // <removeAttributeNode obj="testEmployee" var="districtAttr" oldAttr="newAttribute"/>
                r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#district_attr = r#attributes.get_named_item("district"); // <getNamedItem obj="attributes" var="districtAttr" name="&quot;district&quot;"/>
                assert!(district_attr.is_none()); // <assertNull actual="districtAttr" id="elementRemoveAttributeAfterCreateAssert"/>
            }
            // hc_nodechildnodesappendchild.xml
            #[test]
            fn test_hc_nodechildnodesappendchild() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#created_node; // type: Node // <var name="createdNode" type="Node"/>
                let mut r#child_node; // type: Node // <var name="childNode" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#child_type; // type: int // <var name="childType" type="int"/>
                let mut r#actual = vec![]; // type: List // <var name="actual" type="List"/>
                let r#expected = vec!["em", "strong", "code", "sup", "var", "acronym", "br"]; // type: List // <var name="expected" type="List"><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member><member>"br"</member></var>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#created_node = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" var="createdNode" tagName="&quot;br&quot;"/>
                r#employee_node = r#employee_node
                    .append_child(created_node.into())
                    .unwrap()
                    .as_element()
                    .unwrap(); // <appendChild obj="employeeNode" newChild="createdNode" var="employeeNode"/>
                // <for-each collection="childList" member="childNode">
                //  <nodeName var="childName" obj="childNode"/>
                //  <nodeType var="childType" obj="childNode"/>
                //  <if><equals actual="childType" expected="1"/>
                //      <append collection="actual" item="childName"/>
                //  <else>
                //      <assertEquals id="textNodeType" actual="childType" expected="3" ignoreCase="false"/>
                //  </else>
                //  </if>
                // </for-each>
                for i in 0..child_list.length() {
                    child_node = child_list.item(i).unwrap();
                    child_name = child_node.node_name().to_string();
                    child_type = child_node.node_type();
                    if child_type as i32 == 1 {
                        actual.push(child_name);
                    } else {
                        assert_eq!(child_type as i32, 3);
                    }
                }
                assert_eq!(r#actual, expected); // <assertEquals actual="actual" expected="expected" id="childElements" ignoreCase="auto"/>
            }
            // nodeelementnodeattributes.xml
            #[test]
            fn test_nodeelementnodeattributes() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                let r#addr_attr; // type: NamedNodeMap // <var name="addrAttr" type="NamedNodeMap"/>
                let mut r#attr_node; // type: Node // <var name="attrNode" type="Node"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                let mut r#attr_list = vec![]; // type: Collection // <var name="attrList" type="Collection"/>
                let r#expected = vec!["domestic", "street"]; // type: Collection // <var name="expected" type="Collection"><member>"domestic"</member><member>"street"</member></var>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_addr = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testAddr"/>
                r#addr_attr = r#test_addr.attributes(); // <attributes obj="testAddr" var="addrAttr"/>
                // <for-each collection="addrAttr" member="attrNode">
                //  <nodeName obj="attrNode" var="attrName"/>
                //  <append collection="attrList" item="attrName"/>
                // </for-each>
                for i in 0..addr_attr.length() {
                    attr_node = addr_attr.item(i).unwrap();
                    attr_name = attr_node.node_name().to_string();
                    attr_list.push(attr_name);
                }
                attr_list.sort();
                assert_eq!(r#attr_list, expected); // <assertEquals actual="attrList" expected="expected" id="nodeElementNodeValueAssert1" ignoreCase="false"/>
            }
            // nodeappendchildchildexists.xml
            #[test]
            fn test_nodeappendchildchildexists() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#child_node; // type: Node // <var name="childNode" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#lchild; // type: Node // <var name="lchild" type="Node"/>
                let r#fchild; // type: Node // <var name="fchild" type="Node"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#child_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="childNode"/>
                r#new_child = r#child_node.first_child().unwrap(); // <firstChild interface="Node" obj="childNode" var="newChild"/>
                let r#initial_name = r#new_child.node_name().to_string(); // <nodeName var="initialName" obj="newChild"/>
                r#appended_child = r#child_node.append_child(new_child).unwrap(); // <appendChild var="appendedChild" obj="childNode" newChild="newChild"/>
                r#fchild = r#child_node.first_child().unwrap(); // <firstChild interface="Node" obj="childNode" var="fchild"/>
                let r#fchild_name = r#fchild.node_name().to_string(); // <nodeName obj="fchild" var="fchildName"/>
                r#lchild = r#child_node.last_child().unwrap(); // <lastChild interface="Node" obj="childNode" var="lchild"/>
                let r#lchild_name = r#lchild.node_name().to_string(); // <nodeName obj="lchild" var="lchildName"/>
                // <if><equals actual="initialName" expected="&quot;employeeId&quot;" ignoreCase="false"/>
                //  <assertEquals id="assert1_nowhitespace" actual="fchildName" expected="&quot;name&quot;" ignoreCase="false"/>
                //  <assertEquals id="assert2_nowhitespace" actual="lchildName" expected="&quot;employeeId&quot;" ignoreCase="false"/>
                // <else>
                //  <assertEquals id="assert1" actual="fchildName" expected="&quot;employeeId&quot;" ignoreCase="false"/>
                //  <assertEquals id="assert2" actual="lchildName" expected="&quot;#text&quot;" ignoreCase="false"/>
                // </else>
                // </if>
                if initial_name == "employeeId" {
                    assert_eq!(fchild_name, "name");
                    assert_eq!(lchild_name, "employeeId");
                } else {
                    assert_eq!(fchild_name, "employeeId");
                    assert_eq!(lchild_name, "#text");
                }
            }
            // attrsetvaluenomodificationallowederrEE.xml
            #[test]
            fn test_attrsetvaluenomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                let r#attr_list; // type: NamedNodeMap // <var name="attrList" type="NamedNodeMap"/>
                let mut r#attr_node; // type: Node // <var name="attrNode" type="Node"/>
                let mut r#gender; // type: Node // <var name="gender" type="Node"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                // unimplemented: // <assertNotNull actual="gender" id="genderNotNull"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference obj="doc" var="entRef" name="&quot;ent4&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="entRefNotNull"/>
                r#appended_child = r#gender.append_child(ent_ref.clone().into()).unwrap(); // <appendChild obj="gender" newChild="entRef" var="appendedChild"/>
                r#ent_element = r#ent_ref.first_child().unwrap(); // <firstChild obj="entRef" var="entElement" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#attr_list = r#ent_element.attributes().unwrap(); // <attributes obj="entElement" var="attrList"/>
                r#attr_node = r#attr_list.get_named_item("domestic").unwrap(); // <getNamedItem obj="attrList" var="attrNode" name="&quot;domestic&quot;"/>
                // <assertDOMException id="setValue_throws_NO_MODIFICATION">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <value interface="Attr" obj="attrNode" value="&quot;newvalue&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    attr_node
                        .set_value("newvalue")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
                // <assertDOMException id="setNodeValue_throws_NO_MODIFICATION">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <nodeValue interface="Node" obj="attrNode" value="&quot;newvalue2&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    attr_node
                        .set_node_value("newvalue2")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_nodecommentnodetype.xml
            #[test]
            fn test_hc_nodecommentnodetype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#test_list; // type: NodeList // <var name="testList" type="NodeList"/>
                let mut r#comment_node; // type: Node // <var name="commentNode" type="Node"/>
                let mut r#comment_node_name; // type: DOMString // <var name="commentNodeName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#test_list = r#doc.child_nodes(); // <childNodes obj="doc" var="testList"/>
                // <for-each collection="testList" member="commentNode">
                //  <nodeName obj="commentNode" var="commentNodeName"/>
                //  <if><equals actual="commentNodeName" expected="&quot;#comment&quot;" ignoreCase="false"/>
                //      <nodeType obj="commentNode" var="nodeType"/>
                //      <assertEquals actual="nodeType" expected="8" id="existingCommentNodeType" ignoreCase="false"/>
                //  </if>
                // </for-each>
                for i in 0..test_list.length() {
                    comment_node = test_list.item(i).unwrap();
                    comment_node_name = comment_node.node_name().to_string();
                    if comment_node_name == "#comment" {
                        node_type = comment_node.node_type();
                        assert_eq!(node_type as i32, 8);
                    }
                }
                let r#comment_node = r#doc.create_comment("This is a comment"); // <createComment var="commentNode" obj="doc" data="&quot;This is a comment&quot;"/>
                r#node_type = r#comment_node.node_type(); // <nodeType obj="commentNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 8); // <assertEquals actual="nodeType" expected="8" id="createdCommentNodeType" ignoreCase="false"/>
            }
            // hc_characterdataindexsizeerrreplacedatacountnegative.xml
            #[test]
            fn test_hc_characterdataindexsizeerrreplacedatacountnegative() {
                // // unimplemented: // <implementationAttribute name="signed" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                // let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                // let mut r#bad_string; // type: DOMString // <var name="badString" type="DOMString"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                // r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                // r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // // unimplemented:
                // // <assertDOMException id="throws_INDEX_SIZE_ERR">
                // //  <INDEX_SIZE_ERR>
                // //      <substringData var="badString" obj="child" offset="10" count="-3"/>
                // //  </INDEX_SIZE_ERR>
                // // </assertDOMException>
            }
            // hc_domimplementationfeaturexml.xml
            #[test]
            fn test_hc_domimplementationfeaturexml() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>

                // unimplemented:
                // <if><contentType type="text/html"/>
                //  <hasFeature obj="domImpl" var="state" feature="&quot;html&quot;" version="&quot;1.0&quot;"/>
                //  <assertTrue actual="state" id="supports_html_1.0"/>
                // <else>
                //  <hasFeature obj="domImpl" var="state" feature="&quot;xml&quot;" version="&quot;1.0&quot;"/>
                //  <assertTrue actual="state" id="supports_xml_1.0"/>
                // </else>
                // </if>
            }
            // nodeattributenodename.xml
            #[test]
            fn test_nodeattributenodename() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#addr_attr = r#test_addr.get_attribute_node("domestic").unwrap(); // <getAttributeNode obj="testAddr" name="&quot;domestic&quot;" var="addrAttr"/>
                let r#attr_name = r#addr_attr.node_name().to_string(); // <nodeName obj="addrAttr" var="attrName"/>
                assert_eq!(r#attr_name, "domestic"); // <assertEquals actual="attrName" expected="&quot;domestic&quot;" id="nodeAttributeNodeNameAssert1" ignoreCase="false"/>
            }
            // noderemovechild.xml
            #[test]
            fn test_noderemovechild() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Element // <var name="rootNode" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                let r#child_list = r#root_node.child_nodes(); // <childNodes obj="rootNode" var="childList"/>
                let r#child_to_remove = r#child_list.item(1).unwrap().clone(); // <item interface="NodeList" obj="childList" index="1" var="childToRemove"/>
                let r#removed_child = r#root_node.remove_child(child_to_remove).unwrap(); // <removeChild obj="rootNode" var="removedChild" oldChild="childToRemove"/>
                let r#parent_node = r#removed_child.parent_node(); // <parentNode interface="Node" obj="removedChild" var="parentNode"/>
                assert!(parent_node.is_none()); // <assertNull actual="parentNode" id="nodeRemoveChildAssert1"/>
            }
            // nodedocumentfragmentnodetype.xml
            #[test]
            fn test_nodedocumentfragmentnodetype() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#document_fragment_node = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="documentFragmentNode"/>
                let r#node_type = r#document_fragment_node.node_type(); // <nodeType obj="documentFragmentNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 11); // <assertEquals actual="nodeType" expected="11" id="nodeDocumentFragmentNodeTypeAssert1" ignoreCase="false"/>
            }
            // attrname.xml
            #[test]
            fn test_attrname() {
                let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                let r#test_node = r#address_list.item(1).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="1"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                r#name = r#street_attr.node_name().to_string(); // <nodeName obj="streetAttr" var="name"/>
                assert_eq!(r#name, "street"); // <assertEquals actual="name" expected="&quot;street&quot;" id="nodeName" ignoreCase="false"/>
                r#name = r#street_attr.name().to_string(); // <name obj="streetAttr" var="name" interface="Attr"/>
                assert_eq!(r#name, "street"); // <assertEquals actual="name" expected="&quot;street&quot;" id="name" ignoreCase="false"/>
            }
            // nodesetnodevaluenomodificationallowederr.xml
            #[test]
            fn test_nodesetnodevaluenomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                let mut r#ent_element_text; // type: CharacterData // <var name="entElementText" type="CharacterData"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item obj="genderList" index="2" var="genderNode" interface="NodeList"/>
                r#ent_ref = r#gender_node.first_child().unwrap(); // <firstChild interface="Node" var="entRef" obj="genderNode"/>
                // unimplemented: // <assertNotNull actual="entRef" id="entRefNotNull"/>
                r#node_type = r#ent_ref.node_type(); // <nodeType var="nodeType" obj="entRef"/>
                // unimplemented: // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>	<createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>	<assertNotNull actual="entRef" id="createdEntRefNotNull"/></if>
                r#ent_element = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#ent_element_text = r#ent_element.first_child().unwrap(); // <firstChild interface="Node" var="entElementText" obj="entElement"/>
                // unimplemented: // <assertNotNull actual="entElementText" id="entElementTextNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <nodeValue obj="entElementText" value="&quot;newValue&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element_text
                        .set_node_value("newValue")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_documentinvalidcharacterexceptioncreateelement.xml
            #[test]
            fn test_hc_documentinvalidcharacterexceptioncreateelement() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <createElement var="badElement" obj="doc" tagName="&quot;invalid^Name&quot;"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_element("invalid^Name")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // documentcreateentityreferenceknown.xml
            #[test]
            fn test_documentcreateentityreferenceknown() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_ent_ref_node; // type: EntityReference // <var name="newEntRefNode" type="EntityReference"/>
                let mut r#new_ent_ref_list; // type: NodeList // <var name="newEntRefList" type="NodeList"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_ent_ref_node = r#doc.create_entity_reference("ent3".to_string()).unwrap(); // <createEntityReference obj="doc" var="newEntRefNode" name="&quot;ent3&quot;"/>
                // unimplemented: // <assertNotNull actual="newEntRefNode" id="createdEntRefNotNull"/>
                r#new_ent_ref_list = r#new_ent_ref_node.child_nodes(); // <childNodes obj="newEntRefNode" var="newEntRefList"/>
                // unimplemented: // <assertSize collection="newEntRefList" size="1" id="size"/>
                let r#child = r#new_ent_ref_node.first_child().unwrap(); // <firstChild interface="Node" obj="newEntRefNode" var="child"/>
                let r#name = r#child.node_name().to_string(); // <nodeName obj="child" var="name"/>
                assert_eq!(r#name, "#text"); // <assertEquals actual="name" expected="&quot;#text&quot;" ignoreCase="false" id="name"/>
                let r#value = r#child.node_value().unwrap().to_string(); // <nodeValue obj="child" var="value"/>
                assert_eq!(r#value, "Texas"); // <assertEquals actual="value" expected="&quot;Texas&quot;" ignoreCase="false" id="value"/>
            }
            // hc_documentgetelementsbytagnamevalue.xml
            #[test]
            fn test_hc_documentgetelementsbytagnamevalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#name_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" var="nameList" tagname="&quot;strong&quot;"/>
                let r#name_node = r#name_list.item(3).unwrap(); // <item interface="NodeList" obj="nameList" var="nameNode" index="3"/>
                let r#first_child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="firstChild"/>
                let r#child_value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="childValue"/>
                assert_eq!(r#child_value, "Jeny Oconnor"); // <assertEquals actual="childValue" expected="&quot;Jeny Oconnor&quot;" id="documentGetElementsByTagNameValueAssert" ignoreCase="false"/>
            }
            // nodevalue07.xml
            #[test]
            fn test_nodevalue07() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                let mut r#new_value; // type: DOMString // <var name="newValue" type="DOMString"/>
                let r#node_map; // type: NamedNodeMap // <var name="nodeMap" type="NamedNodeMap"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                node_map = doc_type.entities(); // <entities obj="docType" var="nodeMap"/>
                // unimplemented: // <assertNotNull actual="nodeMap" id="entitiesNotNull"/>
                r#new_node = r#node_map.get_named_item("ent1").unwrap(); // <getNamedItem obj="nodeMap" name="&quot;ent1&quot;" var="newNode"/>
                // unimplemented: // <assertNotNull actual="newNode" id="entityNotNull"/>
                r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="initiallyNull"/>
                r#new_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
            }
            // hc_characterdataappenddatagetdata.xml
            #[test]
            fn test_hc_characterdataappenddatagetdata() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.append_data(", Esquire").unwrap(); // <appendData obj="child" arg="&quot;, Esquire&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Margaret Martin, Esquire"); // <assertEquals actual="childData" expected="&quot;Margaret Martin, Esquire&quot;" id="characterdataAppendDataGetDataAssert" ignoreCase="false"/>
            }
            // hc_nodeattributenodename.xml
            #[test]
            fn test_hc_nodeattributenodename() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#addr_attr = r#test_addr.get_attribute_node("title").unwrap(); // <getAttributeNode obj="testAddr" name="&quot;title&quot;" var="addrAttr"/>
                let r#attr_name = r#addr_attr.node_name().to_string(); // <nodeName obj="addrAttr" var="attrName"/>
                assert_eq!(r#attr_name, "title"); // <assertEquals actual="attrName" expected="&quot;title&quot;" id="nodeName" ignoreCase="auto" context="attribute"/>
            }
            // namednodemapsetnameditemreturnvalue.xml
            #[test]
            fn test_namednodemapsetnameditemreturnvalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                r#new_attribute = r#doc.create_attribute("street".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;street&quot;"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                let r#new_node = r#attributes
                    .set_named_item(r#new_attribute)
                    .unwrap()
                    .unwrap(); // <setNamedItem interface="NamedNodeMap" obj="attributes" var="newNode" arg="newAttribute"/>
                let r#attr_value = r#new_node.node_value().unwrap().to_string(); // <nodeValue obj="newNode" var="attrValue"/>
                assert_eq!(r#attr_value, "No"); // <assertEquals actual="attrValue" expected="&quot;No&quot;" id="returnedNodeValue" ignoreCase="false"/>
            }
            // attrnextsiblingnull.xml
            #[test]
            fn test_attrnextsiblingnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("domestic").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;domestic&quot;"/>
                let r#s = r#domestic_attr.next_sibling(); // <nextSibling interface="Node" obj="domesticAttr" var="s"/>
                assert!(s.is_none()); // <assertNull actual="s" id="attrNextSiblingNullAssert"/>
            }
            // hc_characterdatainsertdatabeginning.xml
            #[test]
            fn test_hc_characterdatainsertdatabeginning() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.insert_data(0, "Mss. ").unwrap(); // <insertData obj="child" offset="0" arg="&quot;Mss. &quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Mss. Margaret Martin"); // <assertEquals actual="childData" expected="&quot;Mss. Margaret Martin&quot;" id="characterdataInsertDataBeginningAssert" ignoreCase="false"/>
            }
            // hc_documentgetdoctype.xml
            #[test]
            fn test_hc_documentgetdoctype() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#doc_type_name; // type: DOMString // <var name="docTypeName" type="DOMString"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>

                // // unimplemented: // <if><not><contentType type="text/html"/></not>	<assertNotNull actual="docType" id="docTypeNotNull"/></if>

                // // unimplemented: // <if><notNull obj="docType"/>		<name interface="DocumentType" obj="docType" var="docTypeName"/>		<if><contentType type="image/svg+xml"/>			<assertEquals actual="docTypeName" expected="&quot;svg&quot;" id="nodeNameSVG" ignoreCase="false"/>			<else>				<assertEquals actual="docTypeName" expected="&quot;html&quot;" id="nodeName" ignoreCase="false"/>			</else>		</if>		<nodeValue obj="docType" var="nodeValue"/>		<assertNull actual="nodeValue" id="nodeValue"/>		<attributes var="attributes" obj="docType"/>		<assertNull actual="attributes" id="attributes"/></if>
            }
            // hc_attrgetvalue1.xml
            #[test]
            fn test_hc_attrgetvalue1() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                let r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#title_attr = r#attributes.get_named_item("class").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;class&quot;"/>
                let r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yα"); // <assertEquals actual="value" expected="&quot;Yα&quot;" id="attrValue1" ignoreCase="false"/>
            }
            // characterdataindexsizeerrdeletedatacountnegative.xml
            #[test]
            fn test_characterdataindexsizeerrdeletedatacountnegative() {
                // unimplemented: // <implementationAttribute name="signed" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // unimplemented:
                // <assertDOMException id="throws_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <deleteData obj="child" offset="10" count="-3"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
            }
            // hc_elementreplaceattributewithself.xml
            #[test]
            fn test_hc_elementreplaceattributewithself() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                let r#street_attr = r#test_employee.get_attribute_node("class").unwrap(); // <getAttributeNode var="streetAttr" obj="testEmployee" name="&quot;class&quot;"/>
                let r#replaced_attr = r#test_employee
                    .set_attribute_node(r#street_attr.clone())
                    .unwrap()
                    .unwrap(); // <setAttributeNode obj="testEmployee" var="replacedAttr" newAttr="streetAttr"/>

                assert!(replaced_attr.is_same_node(&street_attr.into())); // <assertSame actual="replacedAttr" expected="streetAttr" id="replacedAttr"/>
            }
            // nodeprocessinginstructionnodeattributes.xml
            #[test]
            fn test_nodeprocessinginstructionnodeattributes() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#test_list = r#doc.child_nodes(); // <childNodes obj="doc" var="testList"/>
                let r#pi_node = r#test_list
                    .item(0)
                    .unwrap()
                    .clone()
                    .as_processing_instruction()
                    .unwrap(); // <item interface="NodeList" obj="testList" index="0" var="piNode"/>
                let r#attr_list = r#pi_node.attributes(); // <attributes obj="piNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="nodeProcessingInstructionNodeAttrAssert1"/>
            }
            // elementreplaceexistingattributegevalue.xml
            #[test]
            fn test_elementreplaceexistingattributegevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                let r#new_attribute = r#doc.create_attribute("street".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;street&quot;"/>
                let r#street_attr = r#test_employee
                    .set_attribute_node(r#new_attribute)
                    .unwrap()
                    .unwrap(); // <setAttributeNode obj="testEmployee" var="streetAttr" newAttr="newAttribute"/>
                let r#value = r#street_attr.value().to_string(); // <value interface="Attr" obj="streetAttr" var="value"/>
                assert_eq!(r#value, "No"); // <assertEquals actual="value" expected="&quot;No&quot;" id="streetNo" ignoreCase="false"/>
            }
            // nodeinsertbeforenodename.xml
            #[test]
            fn test_nodeinsertbeforenodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#ref_child = r#child_list.item(3).unwrap().clone(); // <item interface="NodeList" obj="childList" index="3" var="refChild"/>
                let r#new_child = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="newChild"/>
                let r#inserted_node = r#employee_node
                    .insert_before(new_child.into(), Some(ref_child))
                    .unwrap(); // <insertBefore obj="employeeNode" newChild="newChild" refChild="refChild" var="insertedNode"/>
                let r#child_name = r#inserted_node.node_name().to_string(); // <nodeName obj="insertedNode" var="childName"/>
                assert_eq!(r#child_name, "newChild"); // <assertEquals actual="childName" expected="&quot;newChild&quot;" id="nodeInsertBeforeNodeNameAssert1" ignoreCase="false"/>
            }
            // hc_nodevalue03.xml
            #[test]
            fn test_hc_nodevalue03() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // let mut r#new_value; // type: DOMString // <var name="newValue" type="DOMString"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // // unimplemented: // <if><contentType type="text/html"/>	<assertDOMException id="throw_NOT_SUPPORTED_ERR">		<NOT_SUPPORTED_ERR>			<createEntityReference obj="doc" var="newNode" name="&quot;ent1&quot;"/>		</NOT_SUPPORTED_ERR>	</assertDOMException><else><createEntityReference obj="doc" var="newNode" name="&quot;ent1&quot;"/><assertNotNull actual="newNode" id="createdEntRefNotNull"/>	<nodeValue obj="newNode" var="newValue"/><assertNull actual="newValue" id="initiallyNull"/><!--   attempt to change the value and make sure that it stays null  --><nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/><nodeValue obj="newNode" var="newValue"/><assertNull actual="newValue" id="nullAfterAttemptedChange"/></else></if>
            }
            // nodeparentnodenull.xml
            #[test]
            fn test_nodeparentnodenull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#created_node = r#doc.create_element("employee".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;employee&quot;" var="createdNode"/>
                let r#parent_node = r#created_node.parent_node(); // <parentNode interface="Node" obj="createdNode" var="parentNode"/>
                assert!(parent_node.is_none()); // <assertNull actual="parentNode" id="parentNode"/>
            }
            // hc_nodeclonefalsenocopytext.xml
            #[test]
            fn test_hc_nodeclonefalsenocopytext() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#child_node = r#child_list.item(3).unwrap().clone(); // <item interface="NodeList" obj="childList" index="3" var="childNode"/>
                let r#cloned_node = r#child_node.clone_node(false); // <cloneNode obj="childNode" deep="false" var="clonedNode"/>
                let r#last_child_node = r#cloned_node.last_child(); // <lastChild interface="Node" obj="clonedNode" var="lastChildNode"/>
                assert!(last_child_node.is_none()); // <assertNull actual="lastChildNode" id="nodeCloneFalseNoCopyTextAssert1"/>
            }
            // hc_noderemovechildnode.xml
            #[test]
            fn test_hc_noderemovechildnode() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#em_list; // type: NodeList // <var name="emList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let r#expected = vec!["strong", "code", "sup", "var", "acronym"]; // type: List // <var name="expected" type="List"><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member></var>
                let mut r#actual = vec![]; // type: List // <var name="actual" type="List"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#em_list = r#employee_node.get_elements_by_tag_name("em"); // <getElementsByTagName interface="Element" var="emList" obj="employeeNode" tagname="&quot;em&quot;"/>
                r#old_child = r#em_list.item(0).unwrap(); // <item interface="NodeList" obj="emList" index="0" var="oldChild"/>
                let r#removed_child = r#employee_node.remove_child(old_child.into()).unwrap(); // <removeChild var="removedChild" obj="employeeNode" oldChild="oldChild"/>
                let r#removed_name = r#removed_child.node_name().to_string(); // <nodeName obj="removedChild" var="removedName"/>
                assert_eq!(r#removed_name, "em"); // <assertEquals actual="removedName" expected="&quot;em&quot;" ignoreCase="auto" id="removedName"/>
                // <for-each collection="childList" member="child">
                //  <nodeType var="nodeType" obj="child"/>
                //  <nodeName var="childName" obj="child"/>
                //  <if><equals expected="1" actual="nodeType"/>
                //      <append collection="actual" item="childName"/>
                //  <else>
                //      <assertEquals expected="3" actual="nodeType" id="textNodeType" ignoreCase="false"/>
                //      <assertEquals expected="&quot;#text&quot;" actual="childName" id="textNodeName" ignoreCase="false"/>
                //  </else>
                //  </if>
                // </for-each>
                for i in 0..child_list.length() {
                    child = child_list.item(i).unwrap();
                    node_type = child.node_type();
                    child_name = child.node_name().to_string();
                    if node_type as i32 == 1 {
                        actual.push(child_name);
                    } else {
                        assert_eq!(node_type as i32, 3);
                        assert_eq!(child_name, "#text");
                    }
                }
                assert_eq!(r#actual, expected); // <assertEquals actual="actual" expected="expected" ignoreCase="auto" id="childNames"/>
            }
            // hc_nodeattributenodetype.xml
            #[test]
            fn test_hc_nodeattributenodetype() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#addr_attr = r#test_addr.get_attribute_node("title").unwrap(); // <getAttributeNode obj="testAddr" name="&quot;title&quot;" var="addrAttr"/>
                let r#node_type = r#addr_attr.node_type(); // <nodeType obj="addrAttr" var="nodeType"/>
                assert_eq!(r#node_type as i32, 2); // <assertEquals actual="nodeType" expected="2" id="nodeAttrNodeTypeAssert1" ignoreCase="false"/>
            }
            // attrspecifiedvalue.xml
            #[test]
            fn test_attrspecifiedvalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("domestic").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;domestic&quot;"/>
                let r#state = r#domestic_attr.specified(); // <specified obj="domesticAttr" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="domesticSpecified"/>
            }
            // noderemovechildnomodificationallowederr.xml
            #[test]
            fn test_noderemovechildnomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item obj="genderList" index="2" var="genderNode" interface="NodeList"/>
                r#ent_ref = r#gender_node.first_child().unwrap(); // <firstChild interface="Node" var="entRef" obj="genderNode"/>
                // unimplemented: // <assertNotNull actual="entRef" id="entRefNotNull"/>
                let r#node_type = r#ent_ref.node_type(); // <nodeType var="nodeType" obj="entRef"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    ent_ref = doc.create_entity_reference("ent4").unwrap().into();
                }
                let r#ent_element = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <removeChild var="removedNode" obj="entRef" oldChild="entElement"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_ref
                        .remove_child(ent_element)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_attrcreatetextnode.xml
            #[test]
            fn test_hc_attrcreatetextnode() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#address_list; // type: NodeList // <var name="addressList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#street_attr; // type: Attr // <var name="streetAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#address_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#address_list.item(3).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#street_attr = r#attributes.get_named_item("class").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;class&quot;"/>
                r#street_attr.set_value("Y&ent1;").unwrap(); // <value interface="Attr" obj="streetAttr" value="&quot;Y&amp;ent1;&quot;"/>
                r#value = r#street_attr.value().to_string(); // <value interface="Attr" obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Y&ent1;"); // <assertEquals actual="value" expected="&quot;Y&amp;ent1;&quot;" id="value" ignoreCase="false"/>
                r#value = r#street_attr.node_value().unwrap().to_string(); // <nodeValue obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Y&ent1;"); // <assertEquals actual="value" expected="&quot;Y&amp;ent1;&quot;" id="nodeValue" ignoreCase="false"/>
            }
            // elementretrieveallattributes.xml
            #[test]
            fn test_elementretrieveallattributes() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="addressList"/>
                let r#test_address = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" index="0" var="testAddress"/>
                let r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                assert_eq!(attributes.length(), 2); // <assertSize collection="attributes" size="2" id="elementRetrieveAllAttributesAssert"/>
            }
            // documentgetdoctypenodtd.xml
            #[test]
            fn test_documentgetdoctypenodtd() {
                // unimplemented: // <implementationAttribute name="validating" value="false"/>
                let r#doc: DocumentRef = hc_nodtdstaff_xml(HC_NODTDSTAFF_XML).unwrap(); // hc_nodtdstaff.xml // <load var="doc" href="hc_nodtdstaff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype(); // <doctype obj="doc" var="docType"/>
                assert!(doc_type.is_none()); // <assertNull actual="docType" id="documentGetDocTypeNoDTDAssert"/>
            }
            // hc_attrappendchild3.xml
            #[test]
            fn test_hc_attrappendchild3() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let r#ter_node; // type: Text // <var name="terNode" type="Text"/>
                let r#day_node; // type: Text // <var name="dayNode" type="Text"/>
                let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                let r#last_child; // type: Node // <var name="lastChild" type="Node"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#ter_node = r#doc.create_text_node("ter"); // <createTextNode var="terNode" obj="doc" data="&quot;ter&quot;"/>
                r#day_node = r#doc.create_text_node("day"); // <createTextNode var="dayNode" obj="doc" data="&quot;day&quot;"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#retval = r#doc_frag.append_child(ter_node.into()).unwrap(); // <appendChild var="retval" obj="docFrag" newChild="terNode"/>
                r#retval = r#doc_frag.append_child(day_node.into()).unwrap(); // <appendChild var="retval" obj="docFrag" newChild="dayNode"/>
                r#retval = r#title_attr.append_child(doc_frag.into()).unwrap(); // <appendChild var="retval" obj="titleAttr" newChild="docFrag"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrNodeValue" ignoreCase="false"/>
                let r#value = r#retval.node_value(); // <nodeValue obj="retval" var="value"/>
                assert!(value.is_none()); // <assertNull actual="value" id="retvalValue"/>
                r#last_child = r#title_attr.last_child().unwrap(); // <lastChild var="lastChild" obj="titleAttr" interface="Node"/>
                let r#value = r#last_child.node_value().unwrap().to_string(); // <nodeValue obj="lastChild" var="value"/>
                assert_eq!(r#value, "day"); // <assertEquals actual="value" expected="&quot;day&quot;" id="lastChildValue" ignoreCase="false"/>
            }
            // characterdatadeletedatamiddle.xml
            #[test]
            fn test_characterdatadeletedatamiddle() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.delete_data(16, 8).unwrap(); // <deleteData obj="child" offset="16" count="8"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230 North Ave. Texas 98551"); // <assertEquals actual="childData" expected="&quot;1230 North Ave. Texas 98551&quot;" id="characterdataDeleteDataMiddleAssert" ignoreCase="false"/>
            }
            // nodegetnextsibling.xml
            #[test]
            fn test_nodegetnextsibling() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#employee_id_node; // type: Node // <var name="employeeIdNode" type="Node"/>
                let mut r#ns_node; // type: Node // <var name="nsNode" type="Node"/>
                let mut r#ns_name; // type: DOMString // <var name="nsName" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employeeId"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employeeId&quot;" var="elementList"/>
                r#employee_id_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeIdNode"/>
                r#ns_node = r#employee_id_node.next_sibling().unwrap(); // <nextSibling interface="Node" obj="employeeIdNode" var="nsNode"/>
                r#ns_name = r#ns_node.node_name().to_string(); // <nodeName obj="nsNode" var="nsName"/>
                // <if><equals actual="nsName" expected="&quot;#text&quot;" ignoreCase="false"/>
                //  <nextSibling interface="Node" obj="nsNode" var="nsNode"/>
                //  <nodeName obj="nsNode" var="nsName"/>
                // </if>
                if ns_name == "#text" {
                    ns_node = ns_node.next_sibling().unwrap();
                    ns_name = ns_node.node_name().to_string();
                }
                assert_eq!(r#ns_name, "name"); // <assertEquals actual="nsName" expected="&quot;name&quot;" id="nodeName" ignoreCase="false"/>
            }
            // hc_elementgetelementsbytagnameaccessnodelist.xml
            #[test]
            fn test_hc_elementgetelementsbytagnameaccessnodelist() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let mut r#first_c; // type: Node // <var name="firstC" type="Node"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(3).unwrap(); // <item interface="NodeList" obj="elementList" index="3" var="testEmployee"/>
                r#first_c = r#test_employee.first_child().unwrap(); // <firstChild interface="Node" obj="testEmployee" var="firstC"/>
                r#node_type = r#first_c.node_type(); // <nodeType var="nodeType" obj="firstC"/>
                // <while><equals actual="nodeType" expected="3"/>
                //  <nextSibling interface="Node" var="firstC" obj="firstC"/>
                //  <nodeType var="nodeType" obj="firstC"/>
                // </while>
                while node_type as i32 == 3 {
                    first_c = first_c.next_sibling().unwrap();
                    node_type = first_c.node_type();
                }
                let r#child_name = r#first_c.node_name().to_string(); // <nodeName obj="firstC" var="childName"/>
                assert_eq!(r#child_name, "em"); // <assertEquals actual="childName" expected="&quot;em&quot;" id="childName" ignoreCase="auto"/>
                let r#employee_id_node = r#first_c.first_child().unwrap(); // <firstChild interface="Node" var="employeeIDNode" obj="firstC"/>
                let r#employee_id = r#employee_id_node.node_value().unwrap().to_string(); // <nodeValue var="employeeID" obj="employeeIDNode"/>
                assert_eq!(r#employee_id, "EMP0004"); // <assertEquals actual="employeeID" expected="&quot;EMP0004&quot;" ignoreCase="false" id="employeeID"/>
            }
            // nodeentityreferencenodeattributes.xml
            #[test]
            fn test_nodeentityreferencenodeattributes() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#ent_ref_addr; // type: Element // <var name="entRefAddr" type="Element"/>
                let mut r#ent_ref_node; // type: Node // <var name="entRefNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#ent_ref_addr = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="entRefAddr"/>
                r#ent_ref_node = r#ent_ref_addr.first_child().unwrap(); // <firstChild interface="Node" obj="entRefAddr" var="entRefNode"/>
                let r#node_type = r#ent_ref_node.node_type(); // <nodeType var="nodeType" obj="entRefNode"/>
                // <if><notEquals actual="nodeType" expected="5" ignoreCase="false"/>
                //  <createEntityReference var="entRefNode" obj="doc" name="&quot;ent2&quot;"/>
                //  <assertNotNull actual="entRefNode" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 5 {
                    ent_ref_node = doc.create_entity_reference("ent2").unwrap().into();
                }
                let r#attr_list = r#ent_ref_node.attributes(); // <attributes obj="entRefNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="attrList"/>
            }
            // nodeelementnodetype.xml
            #[test]
            fn test_nodeelementnodetype() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                let r#node_type = r#root_node.node_type(); // <nodeType obj="rootNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 1); // <assertEquals actual="nodeType" expected="1" id="nodeElementNodeTypeAssert1" ignoreCase="false"/>
            }
            // documentcreateelement.xml
            #[test]
            fn test_documentcreateelement() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#new_element = r#doc.create_element("address".to_string()).unwrap(); // <createElement obj="doc" var="newElement" tagName="&quot;address&quot;"/>
                let r#new_element_name = r#new_element.node_name().to_string(); // <nodeName obj="newElement" var="newElementName"/>
                assert_eq!(r#new_element_name, "address"); // <assertEquals actual="newElementName" expected="&quot;address&quot;" ignoreCase="false" id="name"/>
                let r#new_element_type = r#new_element.node_type(); // <nodeType obj="newElement" var="newElementType"/>
                assert_eq!(r#new_element_type as i32, 1); // <assertEquals actual="newElementType" expected="1" ignoreCase="false" id="type"/>
                let r#new_element_value = r#new_element.node_value(); // <nodeValue obj="newElement" var="newElementValue"/>
                assert!(new_element_value.is_none()); // <assertNull actual="newElementValue" id="valueInitiallyNull"/>
            }
            // hc_entitiessetnameditem1.xml
            #[test]
            fn test_hc_entitiessetnameditem1() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <if><not><contentType type="text/html"/></not><assertNotNull actual="docType" id="docTypeNotNull"/><entities var="entities" obj="docType"/><assertNotNull actual="entities" id="entitiesNotNull"/><createElement var="elem" obj="doc" tagName="&quot;br&quot;"/><try>	<setNamedItem var="retval" obj="entities" arg="elem"/>	<fail id="throw_HIER_OR_NO_MOD_ERR"/>	<catch>		<DOMException code="HIERARCHY_REQUEST_ERR"/>		<DOMException code="NO_MODIFICATION_ALLOWED_ERR"/>	</catch></try> </if>
            }
            // textsplittextone.xml
            #[test]
            fn test_textsplittextone() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#split_node; // type: Text // <var name="splitNode" type="Text"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;name&quot;"/>
                r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                r#text_node = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="textNode"/>
                r#split_node = r#text_node.split_text(7).unwrap(); // <splitText obj="textNode" var="splitNode" offset="7"/>
                let r#second_part = r#text_node.next_sibling().unwrap(); // <nextSibling interface="Node" obj="textNode" var="secondPart"/>
                let r#value = r#second_part.node_value().unwrap().to_string(); // <nodeValue obj="secondPart" var="value"/>
                assert_eq!(r#value, "Jones"); // <assertEquals actual="value" expected="&quot;Jones&quot;" id="textSplitTextOneAssert" ignoreCase="false"/>
            }
            // attrspecifiedvaluechanged.xml
            #[test]
            fn test_attrspecifiedvaluechanged() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#address_list; // type: NodeList // <var name="addressList" type="NodeList"/>
                let mut r#test_node; // type: Node // <var name="testNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                r#test_node = r#address_list.item(2).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="2"/>
                r#test_node.set_attribute("street", "Yes").unwrap(); // <setAttribute obj="testNode" name="&quot;street&quot;" value="&quot;Yes&quot;"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                let r#state = r#street_attr.specified(); // <specified obj="streetAttr" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="streetSpecified"/>
            }
            // hc_nodegetfirstchildnull.xml
            #[test]
            fn test_hc_nodegetfirstchildnull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#em_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;em&quot;" var="emList"/>
                let r#em_node = r#em_list.item(0).unwrap(); // <item interface="NodeList" obj="emList" index="0" var="emNode"/>
                let r#em_text = r#em_node.first_child().unwrap(); // <firstChild var="emText" obj="emNode" interface="Node"/>
                let r#null_child = r#em_text.first_child(); // <firstChild var="nullChild" obj="emText" interface="Node"/>
                assert!(null_child.is_none()); // <assertNull actual="nullChild" id="nullChild"/>
            }
            // characterdatadeletedatabegining.xml
            #[test]
            fn test_characterdatadeletedatabegining() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.delete_data(0, 16).unwrap(); // <deleteData obj="child" offset="0" count="16"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Dallas, Texas 98551"); // <assertEquals actual="childData" expected="&quot;Dallas, Texas 98551&quot;" id="characterdataDeleteDataBeginingAssert" ignoreCase="false"/>
            }
            // hc_attrreplacechild2.xml
            #[test]
            fn test_hc_attrreplacechild2() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let r#ter_node; // type: Text // <var name="terNode" type="Text"/>
                let r#day_node; // type: Text // <var name="dayNode" type="Text"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                let mut r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#ter_node = r#doc.create_text_node("ter"); // <createTextNode var="terNode" obj="doc" data="&quot;ter&quot;"/>
                r#day_node = r#doc.create_text_node("day"); // <createTextNode var="dayNode" obj="doc" data="&quot;day&quot;"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#retval = r#doc_frag.append_child(ter_node.into()).unwrap(); // <appendChild var="retval" obj="docFrag" newChild="terNode"/>
                r#retval = r#doc_frag.append_child(day_node.into()).unwrap(); // <appendChild var="retval" obj="docFrag" newChild="dayNode"/>
                r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                // unimplemented: // <assertNotNull actual="firstChild" id="attrChildNotNull"/>
                r#retval = r#title_attr
                    .replace_child(doc_frag.into(), first_child)
                    .unwrap(); // <replaceChild var="retval" obj="titleAttr" newChild="docFrag" oldChild="firstChild"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="attrNodeValue" ignoreCase="false"/>
                r#value = r#retval.node_value().unwrap().to_string(); // <nodeValue obj="retval" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="retvalValue" ignoreCase="false"/>
                r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                r#value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="value"/>
                assert_eq!(r#value, "ter"); // <assertEquals actual="value" expected="&quot;ter&quot;" id="firstChildValue" ignoreCase="false"/>
            }
            // hc_documentcreatedocumentfragment.xml
            #[test]
            fn test_hc_documentcreatedocumentfragment() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#new_doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="newDocFragment"/>
                let r#children = r#new_doc_fragment.child_nodes(); // <childNodes obj="newDocFragment" var="children"/>
                let r#length = r#children.length(); // <length interface="NodeList" obj="children" var="length"/>
                assert_eq!(r#length, 0); // <assertEquals actual="length" expected="0" ignoreCase="false" id="length"/>
                let r#new_doc_fragment_name = r#new_doc_fragment.node_name().to_string(); // <nodeName obj="newDocFragment" var="newDocFragmentName"/>
                assert_eq!(r#new_doc_fragment_name, "#document-fragment"); // <assertEquals actual="newDocFragmentName" expected="&quot;#document-fragment&quot;" ignoreCase="false" id="strong"/>
                let r#new_doc_fragment_type = r#new_doc_fragment.node_type(); // <nodeType obj="newDocFragment" var="newDocFragmentType"/>
                assert_eq!(r#new_doc_fragment_type as i32, 11); // <assertEquals actual="newDocFragmentType" expected="11" ignoreCase="false" id="type"/>
                let r#new_doc_fragment_value = r#new_doc_fragment.node_value(); // <nodeValue obj="newDocFragment" var="newDocFragmentValue"/>
                assert!(new_doc_fragment_value.is_none()); // <assertNull actual="newDocFragmentValue" id="value"/>
            }
            // hc_attrspecifiedvalue.xml
            #[test]
            fn test_hc_attrspecifiedvalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;acronym&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;title&quot;"/>
                let r#state = r#domestic_attr.specified(); // <specified obj="domesticAttr" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="acronymTitleSpecified"/>
            }
            // elementgetelementempty.xml
            #[test]
            fn test_elementgetelementempty() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let mut r#domestic_attr; // type: Attr // <var name="domesticAttr" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_attribute = r#doc.create_attribute("district".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;district&quot;"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(3).unwrap(); // <item interface="NodeList" obj="elementList" index="3" var="testEmployee"/>
                r#domestic_attr = r#test_employee.set_attribute_node(r#new_attribute).unwrap(); // <setAttributeNode obj="testEmployee" var="domesticAttr" newAttr="newAttribute"/>
                let r#attr_value = r#test_employee.get_attribute("district"); // <getAttribute obj="testEmployee" var="attrValue" name="&quot;district&quot;"/>
                assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" id="elementGetElementEmptyAssert" ignoreCase="false"/>
            }
            // elementchangeattributevalue.xml
            #[test]
            fn test_elementchangeattributevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(3).unwrap(); // <item interface="NodeList" obj="elementList" index="3" var="testEmployee"/>
                r#test_employee.set_attribute("street", "Neither").unwrap(); // <setAttribute obj="testEmployee" name="&quot;street&quot;" value="&quot;Neither&quot;"/>
                let r#attr_value = r#test_employee.get_attribute("street"); // <getAttribute obj="testEmployee" var="attrValue" name="&quot;street&quot;"/>
                assert_eq!(r#attr_value, "Neither"); // <assertEquals actual="attrValue" expected="&quot;Neither&quot;" id="elementChangeAttributeValueAssert" ignoreCase="false"/>
            }
            // hc_nodedocumentnodevalue.xml
            #[test]
            fn test_hc_nodedocumentnodevalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#document_value = r#doc.node_value(); // <nodeValue obj="doc" var="documentValue"/>
                assert!(document_value.is_none()); // <assertNull actual="documentValue" id="documentNodeValue"/>
            }
            // hc_elementgetelementsbytagnamenomatch.xml
            #[test]
            fn test_hc_elementgetelementsbytagnamenomatch() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("noMatch"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;noMatch&quot;" var="elementList"/>
                assert_eq!(element_list.length(), 0); // <assertSize collection="elementList" size="0" id="elementGetElementsByTagNameNoMatchNoMatchAssert"/>
            }
            // elementinvalidcharacterexception.xml
            #[test]
            fn test_elementinvalidcharacterexception() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_address = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddress"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <setAttribute obj="testAddress" name="&quot;invalid^Name&quot;" value="&quot;value&quot;"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    test_address
                        .set_attribute("invalid^Name", "value")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // processinginstructionsetdatanomodificationallowederrEE.xml
            #[test]
            fn test_processinginstructionsetdatanomodificationallowederr_ee() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender; // type: Node // <var name="gender" type="Node"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                let mut r#pi_node; // type: ProcessingInstruction // <var name="piNode" type="ProcessingInstruction"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                r#appended_child = r#gender.append_child(ent_ref.into()).unwrap(); // <appendChild var="appendedChild" obj="gender" newChild="entRef"/>
                r#ent_ref = r#gender
                    .last_child()
                    .unwrap()
                    .as_entity_reference()
                    .unwrap(); // <lastChild interface="Node" var="entRef" obj="gender"/>
                // unimplemented: // <assertNotNull actual="entRef" id="entRefNotNull"/>
                r#pi_node = r#ent_ref
                    .last_child()
                    .unwrap()
                    .as_processing_instruction()
                    .unwrap(); // <lastChild interface="Node" var="piNode" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="piNode" id="piNodeNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR"
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <data interface="ProcessingInstruction" obj="piNode" value="&quot;newData&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    pi_node
                        .set_data("newData")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // domimplementationfeaturenoversion.xml
            #[test]
            fn test_domimplementationfeaturenoversion() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                let r#state = dom_impl.has_feature("XML", Some("")); // <hasFeature obj="domImpl" var="state" feature="&quot;XML&quot;" version="&quot;&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="hasXMLEmpty"/>
            }
            // hc_attrlastchild.xml
            #[test]
            fn test_hc_attrlastchild() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                let r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                let r#text_node = r#title_attr.first_child().unwrap(); // <firstChild var="textNode" obj="titleAttr" interface="Node"/>
                // unimplemented: // <assertNotNull actual="textNode" id="textNodeNotNull"/>
                let r#value = r#text_node.node_value().unwrap().to_string(); // <nodeValue var="value" obj="textNode"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="child1IsYes" ignoreCase="false"/>
                let r#other_child = r#text_node.next_sibling(); // <nextSibling var="otherChild" obj="textNode" interface="Node"/>
                assert!(other_child.is_none()); // <assertNull actual="otherChild" id="nextSiblingIsNull"/>
                let r#other_child = r#text_node.previous_sibling(); // <previousSibling var="otherChild" obj="textNode" interface="Node"/>
                assert!(other_child.is_none()); // <assertNull actual="otherChild" id="previousSiblingIsNull"/>
            }
            // nodereplacechildnodename.xml
            #[test]
            fn test_nodereplacechildnodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#length = r#child_list.length(); // <length var="length" obj="childList" interface="NodeList"/>
                let r#old_child = r#child_list.item(1).unwrap().clone(); // <item interface="NodeList" obj="childList" index="1" var="oldChild"/>
                let r#new_child = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="newChild"/>
                let r#replaced_node = r#employee_node
                    .replace_child(new_child.into(), old_child)
                    .unwrap(); // <replaceChild obj="employeeNode" newChild="newChild" oldChild="oldChild" var="replacedNode"/>
                let r#child_name = r#replaced_node.node_name().to_string(); // <nodeName obj="replacedNode" var="childName"/>
                // <if><equals actual="length" expected="6" ignoreCase="false"/>
                //  <assertEquals actual="childName" expected="&quot;name&quot;" id="nowhitespace" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="childName" expected="&quot;employeeId&quot;" id="whitespace" ignoreCase="false"/>
                // </else>
                // </if>
                if length == 6 {
                    assert_eq!(child_name, "name");
                } else {
                    assert_eq!(child_name, "employeeId");
                }
            }
            // nodecloneattributescopied.xml
            #[test]
            fn test_nodecloneattributescopied() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#address_node; // type: Node // <var name="addressNode" type="Node"/>
                let r#cloned_node; // type: Node // <var name="clonedNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#attribute_node; // type: Node // <var name="attributeNode" type="Node"/>
                let mut r#attribute_name; // type: DOMString // <var name="attributeName" type="DOMString"/>
                let mut r#result = vec![]; // type: Collection // <var name="result" type="Collection"/>
                let r#expected_result = vec!["domestic", "street"]; // type: Collection // <var name="expectedResult" type="Collection"><member>"domestic"</member><member>"street"</member></var>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#address_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="addressNode"/>
                r#cloned_node = r#address_node.clone_node(false); // <cloneNode obj="addressNode" deep="false" var="clonedNode"/>
                r#attributes = r#cloned_node.attributes().unwrap(); // <attributes obj="clonedNode" var="attributes"/>
                // <for-each collection="attributes" member="attributeNode">
                //  <nodeName obj="attributeNode" var="attributeName"/>
                //  <append collection="result" item="attributeName"/>
                // </for-each>
                for i in 0..attributes.length() {
                    attribute_node = attributes.item(i).unwrap();
                    attribute_name = attribute_node.node_name().to_string();
                    result.push(attribute_name);
                }
                result.sort();
                assert_eq!(r#result, expected_result); // <assertEquals actual="result" expected="expectedResult" id="nodeCloneAttributesCopiedAssert1" ignoreCase="false"/>
            }
            // attrdefaultvalue.xml
            #[test]
            fn test_attrdefaultvalue() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                let r#value = r#street_attr.node_value().unwrap().to_string(); // <nodeValue obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="attrDefaultValueAssert" ignoreCase="false"/>
            }
            // hc_attrremovechild2.xml
            #[test]
            fn test_hc_attrremovechild2() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                let r#text_node = r#doc.create_text_node("Yesterday"); // <createTextNode var="textNode" obj="doc" data="&quot;Yesterday&quot;"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <removeChild var="retval" obj="titleAttr" oldChild="textNode"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    title_attr
                        .remove_child(text_node.into())
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // nodeappendchildnewchilddiffdocument.xml
            #[test]
            fn test_nodeappendchildnewchilddiffdocument() {
                let r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc1 = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc1" href="staff" willBeModified="false"/>
                r#doc2 = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc2" href="staff" willBeModified="true"/>
                r#new_child = r#doc1.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc1" tagName="&quot;newChild&quot;" var="newChild"/>
                r#element_list = r#doc2.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc2" tagname="&quot;employee&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <appendChild var="appendedChild" obj="elementNode" newChild="newChild"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .append_child(new_child.into())
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // nodedocumentnodetype.xml
            #[test]
            fn test_nodedocumentnodetype() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#node_type = r#doc.node_type(); // <nodeType obj="doc" var="nodeType"/>
                assert_eq!(r#node_type as i32, 9); // <assertEquals actual="nodeType" expected="9" id="nodeDocumentNodeTypeAssert1" ignoreCase="false"/>
            }
            // nodereplacechildnomodificationallowederr.xml
            #[test]
            fn test_nodereplacechildnomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item obj="genderList" index="2" var="genderNode" interface="NodeList"/>
                r#ent_ref = r#gender_node.first_child().unwrap(); // <firstChild interface="Node" var="entRef" obj="genderNode"/>
                let r#node_type = r#ent_ref.node_type(); // <nodeType var="nodeType" obj="entRef"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    ent_ref = doc.create_entity_reference("ent4").unwrap().into();
                }
                let r#ent_element = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                let r#created_node = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="createdNode"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <replaceChild var="replacedChild" obj="entRef" newChild="createdNode" oldChild="entElement"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_ref
                        .replace_child(created_node.into(), ent_element)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_elementremoveattributeaftercreate.xml
            #[test]
            fn test_hc_elementremoveattributeaftercreate() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                r#new_attribute = r#doc.create_attribute("lang".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;lang&quot;"/>
                let r#district_attr = r#test_employee
                    .set_attribute_node(r#new_attribute.clone())
                    .unwrap(); // <setAttributeNode obj="testEmployee" var="districtAttr" newAttr="newAttribute"/>
                let r#district_attr = r#test_employee
                    .remove_attribute_node(r#new_attribute)
                    .unwrap(); // <removeAttributeNode obj="testEmployee" var="districtAttr" oldAttr="newAttribute"/>
                r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#district_attr = r#attributes.get_named_item("lang"); // <getNamedItem obj="attributes" var="districtAttr" name="&quot;lang&quot;"/>
                assert!(district_attr.is_none()); // <assertNull actual="districtAttr" id="removed_item_null"/>
            }
            // hc_nodeattributenodevalue.xml
            #[test]
            fn test_hc_nodeattributenodevalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#addr_attr = r#test_addr.get_attribute_node("title").unwrap(); // <getAttributeNode obj="testAddr" name="&quot;title&quot;" var="addrAttr"/>
                let r#attr_value = r#addr_attr.node_value().unwrap().to_string(); // <nodeValue obj="addrAttr" var="attrValue"/>
                assert_eq!(r#attr_value, "Yes"); // <assertEquals actual="attrValue" expected="&quot;Yes&quot;" id="nodeValue" ignoreCase="false"/>
            }
            // documentinvalidcharacterexceptioncreatepi.xml
            #[test]
            fn test_documentinvalidcharacterexceptioncreatepi() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#bad_pi; // type: ProcessingInstruction // <var name="badPI" type="ProcessingInstruction"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // // unimplemented: // <if><contentType type="text/html"/><assertDOMException id="throw_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><createProcessingInstruction var="badPI" obj="doc" target="&quot;foo&quot;" data="&quot;data&quot;"/></NOT_SUPPORTED_ERR></assertDOMException><else><assertDOMException id="throw_INVALID_CHARACTER_ERR"><INVALID_CHARACTER_ERR><createProcessingInstruction var="badPI" obj="doc" target="&quot;invalid^Name&quot;" data="&quot;data&quot;"/></INVALID_CHARACTER_ERR></assertDOMException></else></if>
            }
            // elementnormalize.xml
            #[test]
            fn test_elementnormalize() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root; // type: Element // <var name="root" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#root = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="root"/>
                r#root.normalize(); // <normalize obj="root"/>
                let r#element_list = r#root.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Element" obj="root" tagname="&quot;name&quot;" var="elementList"/>
                let r#test_name = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testName"/>
                let r#first_child = r#test_name.first_child().unwrap(); // <firstChild interface="Node" obj="testName" var="firstChild"/>
                let r#child_value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="childValue"/>
                assert_eq!(r#child_value, "Roger\n Jones"); // <assertEquals actual="childValue" expected="&quot;Roger\n Jones&quot;" id="elementNormalizeAssert" ignoreCase="false"/>
            }
            // hc_namednodemapchildnoderange.xml
            #[test]
            fn test_hc_namednodemapchildnoderange() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#strong; // type: DOMString // <var name="strong" type="DOMString"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                // r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="2"/>
                // r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                // r#length = r#attributes.len(); // <length var="length" obj="attributes" interface="NamedNodeMap"/>

                // // unimplemented: // <if><contentType type="text/html"/><assertEquals actual="length" expected="2" id="htmlLength" ignoreCase="false"/><else><assertEquals actual="length" expected="3" id="length" ignoreCase="false"/><item var="child" index="2" obj="attributes" interface="NamedNodeMap"/><assertNotNull actual="child" id="attr2"/></else></if>
                // r#child = r#attributes.item(0).unwrap(); // <item var="child" index="0" obj="attributes" interface="NamedNodeMap"/>

                // // unimplemented: // <assertNotNull actual="child" id="attr0"/>
                // r#child = r#attributes.item(1).unwrap(); // <item var="child" index="1" obj="attributes" interface="NamedNodeMap"/>

                // // unimplemented: // <assertNotNull actual="child" id="attr1"/>
                // r#child = r#attributes.item(3).unwrap(); // <item var="child" index="3" obj="attributes" interface="NamedNodeMap"/>

                // // unimplemented: // <assertNull actual="child" id="attr3"/>
            }
            // characterdatainsertdatanomodificationallowederr.xml
            #[test]
            fn test_characterdatainsertdatanomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let r#ent_element; // type: Node // <var name="entElement" type="Node"/>
                let mut r#ent_element_content; // type: Node // <var name="entElementContent" type="Node"/>
                let mut r#ent_reference; // type: Node // <var name="entReference" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" index="2" var="genderNode"/>
                r#ent_reference = r#gender_node.first_child().unwrap(); // <firstChild var="entReference" obj="genderNode" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entReference" id="entReferenceNotNull"/>
                let r#node_type = r#ent_reference.node_type(); // <nodeType var="nodeType" obj="entReference"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="entReference" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="entReference" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    ent_reference = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#ent_element = r#ent_reference.first_child().unwrap(); // <firstChild var="entElement" obj="entReference" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#ent_element_content =
                    r#ent_element.first_child().unwrap().as_text_node().unwrap(); // <firstChild var="entElementContent" obj="entElement" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElementContent" id="entElementContentNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <insertData obj="entElementContent" offset="1" arg="&quot;newArg&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element_content
                        .insert_data(1, "newArg")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodeappendchildinvalidnodetype.xml
            #[test]
            fn test_nodeappendchildinvalidnodetype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Element // <var name="rootNode" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                let r#new_child = r#doc.create_attribute("newAttribute".to_string()).unwrap(); // <createAttribute obj="doc" name="&quot;newAttribute&quot;" var="newChild"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <appendChild var="appendedChild" obj="rootNode" newChild="newChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    root_node
                        .append_child(new_child.into())
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // elementremoveattributenodenomodificationallowederrEE.xml
            #[test]
            fn test_elementremoveattributenodenomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender; // type: Node // <var name="gender" type="Node"/>
                let r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                let r#attr_list; // type: NamedNodeMap // <var name="attrList" type="NamedNodeMap"/>
                let r#attr_node; // type: Attr // <var name="attrNode" type="Attr"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                r#appended_child = r#gender.append_child(ent_ref.clone().into()).unwrap(); // <appendChild obj="gender" newChild="entRef" var="appendedChild"/>
                r#ent_element = r#ent_ref.first_child().unwrap().as_element().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#attr_list = r#ent_element.attributes(); // <attributes obj="entElement" var="attrList"/>
                r#attr_node = r#attr_list.get_named_item("domestic").unwrap(); // <getNamedItem obj="attrList" var="attrNode" name="&quot;domestic&quot;"/>
                // unimplemented: // <assertNotNull actual="attrNode" id="attrNodeNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <removeAttributeNode var="removedAttr" obj="entElement" oldAttr="attrNode"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element
                        .remove_attribute_node(attr_node)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // elementremoveattributenomodificationallowederr.xml
            #[test]
            fn test_elementremoveattributenomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender; // type: Node // <var name="gender" type="Node"/>
                let r#gen_list; // type: NodeList // <var name="genList" type="NodeList"/>
                let mut r#gen; // type: Node // <var name="gen" type="Node"/>
                let r#g_list; // type: NodeList // <var name="gList" type="NodeList"/>
                let mut r#gen_element; // type: Element // <var name="genElement" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#gen_list = r#gender.child_nodes(); // <childNodes obj="gender" var="genList"/>
                r#gen = r#gen_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="genList" var="gen" index="0"/>
                // unimplemented: // <assertNotNull actual="gen" id="genNotNull"/>
                let r#node_type = r#gen.node_type(); // <nodeType var="nodeType" obj="gen"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="gen" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="gen" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    r#gen = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#g_list = r#gen.child_nodes(); // <childNodes obj="gen" var="gList"/>
                r#gen_element = r#g_list.item(0).unwrap().as_element().unwrap(); // <item interface="NodeList" obj="gList" var="genElement" index="0"/>
                // unimplemented: // <assertNotNull actual="genElement" id="genElementNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <removeAttribute obj="genElement" name="&quot;domestic&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    gen_element
                        .remove_attribute("domestic")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_characterdatasubstringexceedsvalue.xml
            #[test]
            fn test_hc_characterdatasubstringexceedsvalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                let r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                let r#substring = child.substring_data(9, 10).unwrap(); // <substringData obj="child" var="substring" offset="9" count="10"/>
                assert_eq!(r#substring, "Martin"); // <assertEquals actual="substring" expected="&quot;Martin&quot;" id="characterdataSubStringExceedsValueAssert" ignoreCase="false"/>
            }
            // hc_textsplittexttwo.xml
            #[test]
            fn test_hc_textsplittexttwo() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#split_node; // type: Text // <var name="splitNode" type="Text"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;strong&quot;"/>
                r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                r#text_node = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="textNode"/>
                r#split_node = r#text_node.split_text(5).unwrap(); // <splitText obj="textNode" var="splitNode" offset="5"/>
                let r#value = r#text_node.node_value().unwrap().to_string(); // <nodeValue obj="textNode" var="value"/>
                assert_eq!(r#value, "Roger"); // <assertEquals actual="value" expected="&quot;Roger&quot;" id="textSplitTextTwoAssert" ignoreCase="false"/>
            }
            // documentinvalidcharacterexceptioncreateelement.xml
            #[test]
            fn test_documentinvalidcharacterexceptioncreateelement() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <createElement var="badElement" obj="doc" tagName="&quot;invalid^Name&quot;"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_element("invalid^Name")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // hc_attrsetvalue1.xml
            #[test]
            fn test_hc_attrsetvalue1() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let mut r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                // unimplemented: // <assertNotNull actual="firstChild" id="attrChildNotNull"/>
                r#title_attr.set_value("Tomorrow").unwrap(); // <value obj="titleAttr" value="&quot;Tomorrow&quot;" interface="Attr"/>
                r#first_child.set_node_value("impl reused node").unwrap(); // <nodeValue obj="firstChild" value="&quot;impl reused node&quot;"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Tomorrow"); // <assertEquals actual="value" expected="&quot;Tomorrow&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Tomorrow"); // <assertEquals actual="value" expected="&quot;Tomorrow&quot;" id="attrNodeValue" ignoreCase="false"/>
                r#first_child = r#title_attr.last_child().unwrap(); // <lastChild var="firstChild" obj="titleAttr" interface="Node"/>
                r#value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="value"/>
                assert_eq!(r#value, "Tomorrow"); // <assertEquals actual="value" expected="&quot;Tomorrow&quot;" id="firstChildValue" ignoreCase="false"/>
                let r#other_child = r#first_child.next_sibling(); // <nextSibling var="otherChild" obj="firstChild" interface="Node"/>
                assert!(other_child.is_none()); // <assertNull actual="otherChild" id="nextSiblingIsNull"/>
            }
            // hc_namednodemapsetnameditemthatexists.xml
            #[test]
            fn test_hc_namednodemapsetnameditemthatexists() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let r#district_node; // type: Attr // <var name="districtNode" type="Attr"/>
                let mut r#set_node; // type: Node // <var name="setNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                r#test_address = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="1"/>
                r#new_attribute = r#doc.create_attribute("class".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;class&quot;"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                r#set_node = r#attributes
                    .set_named_item(r#new_attribute)
                    .unwrap()
                    .unwrap(); // <setNamedItem var="setNode" obj="attributes" arg="newAttribute"/>
                r#district_node = r#attributes.get_named_item("class").unwrap(); // <getNamedItem obj="attributes" var="districtNode" name="&quot;class&quot;"/>
                let r#attr_value = r#district_node.node_value().unwrap().to_string(); // <nodeValue obj="districtNode" var="attrValue"/>
                assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" id="namednodemapSetNamedItemThatExistsAssert" ignoreCase="false"/>
            }
            // characterdataindexsizeerrinsertdataoffsetgreater.xml
            #[test]
            fn test_characterdataindexsizeerrinsertdataoffsetgreater() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                // <assertDOMException id="throw_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <insertData obj="child" offset="40" arg="&quot;ABC&quot;"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
                assert!(
                    child
                        .insert_data(40, "ABC")
                        .is_err_and(|err| err == DOMException::IndexSizeErr)
                );
            }
            // hc_attrinsertbefore2.xml
            #[test]
            fn test_hc_attrinsertbefore2() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let r#retval; // type: Node // <var name="retval" type="Node"/>
                let r#last_child; // type: Node // <var name="lastChild" type="Node"/>
                let r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#text_node = r#doc.create_text_node("terday"); // <createTextNode var="textNode" obj="doc" data="&quot;terday&quot;"/>
                let r#ref_child = r#title_attr.first_child().unwrap(); // <firstChild var="refChild" obj="titleAttr" interface="Node"/>
                r#retval = r#title_attr
                    .insert_before(text_node.into(), ref_child.into())
                    .unwrap(); // <insertBefore var="retval" obj="titleAttr" newChild="textNode" refChild="refChild"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "terdayYes"); // <assertEquals actual="value" expected="&quot;terdayYes&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "terdayYes"); // <assertEquals actual="value" expected="&quot;terdayYes&quot;" id="attrNodeValue" ignoreCase="false"/>
                r#value = r#retval.node_value().unwrap().to_string(); // <nodeValue obj="retval" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="retvalValue" ignoreCase="false"/>
                r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                r#value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="firstChildValue" ignoreCase="false"/>
                r#last_child = r#title_attr.last_child().unwrap(); // <lastChild var="lastChild" obj="titleAttr" interface="Node"/>
                r#value = r#last_child.node_value().unwrap().to_string(); // <nodeValue obj="lastChild" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="lastChildValue" ignoreCase="false"/>
            }
            // documentcreatecdatasection.xml
            #[test]
            fn test_documentcreatecdatasection() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#new_cdata_section_node = r#doc
                    .create_cdata_section("This is a new CDATASection node")
                    .unwrap(); // <createCDATASection obj="doc" var="newCDATASectionNode" data="&quot;This is a new CDATASection node&quot;"/>
                let r#new_cdata_section_value =
                    r#new_cdata_section_node.node_value().unwrap().to_string(); // <nodeValue obj="newCDATASectionNode" var="newCDATASectionValue"/>
                assert_eq!(r#new_cdata_section_value, "This is a new CDATASection node"); // <assertEquals id="nodeValue" actual="newCDATASectionValue" expected="&quot;This is a new CDATASection node&quot;" ignoreCase="false"/>
                let r#new_cdata_section_name = r#new_cdata_section_node.node_name().to_string(); // <nodeName obj="newCDATASectionNode" var="newCDATASectionName"/>
                assert_eq!(r#new_cdata_section_name, "#cdata-section"); // <assertEquals id="nodeName" actual="newCDATASectionName" expected="&quot;#cdata-section&quot;" ignoreCase="false"/>
                let r#new_cdata_section_type = r#new_cdata_section_node.node_type(); // <nodeType obj="newCDATASectionNode" var="newCDATASectionType"/>
                assert_eq!(r#new_cdata_section_type as i32, 4); // <assertEquals id="nodeType" actual="newCDATASectionType" expected="4" ignoreCase="false"/>
            }
            // hc_attrparentnodenull.xml
            #[test]
            fn test_hc_attrparentnodenull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;acronym&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;title&quot;"/>
                let r#s = r#domestic_attr.parent_node(); // <parentNode interface="Node" obj="domesticAttr" var="s"/>
                assert!(s.is_none()); // <assertNull actual="s" id="attrParentNodeNullAssert"/>
            }
            // hc_attrreplacechild1.xml
            #[test]
            fn test_hc_attrreplacechild1() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let r#retval; // type: Node // <var name="retval" type="Node"/>
                let mut r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#text_node = r#doc.create_text_node("terday"); // <createTextNode var="textNode" obj="doc" data="&quot;terday&quot;"/>
                r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                // unimplemented: // <assertNotNull actual="firstChild" id="attrChildNotNull"/>
                r#retval = r#title_attr
                    .replace_child(text_node.into(), first_child)
                    .unwrap(); // <replaceChild var="retval" obj="titleAttr" newChild="textNode" oldChild="firstChild"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="attrNodeValue" ignoreCase="false"/>
                r#value = r#retval.node_value().unwrap().to_string(); // <nodeValue obj="retval" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="retvalValue" ignoreCase="false"/>
                r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                r#value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="firstChildValue" ignoreCase="false"/>
            }
            // hc_nodeappendchild.xml
            #[test]
            fn test_hc_nodeappendchild() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#created_node; // type: Node // <var name="createdNode" type="Node"/>
                let r#lchild; // type: Node // <var name="lchild" type="Node"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#created_node = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="createdNode"/>
                r#appended_child = r#employee_node.append_child(created_node.into()).unwrap(); // <appendChild var="appendedChild" obj="employeeNode" newChild="createdNode"/>
                r#lchild = r#employee_node.last_child().unwrap(); // <lastChild interface="Node" obj="employeeNode" var="lchild"/>
                let r#child_name = r#lchild.node_name().to_string(); // <nodeName obj="lchild" var="childName"/>
                assert_eq!(r#child_name, "br"); // <assertEquals actual="childName" expected="&quot;br&quot;" id="nodeName" ignoreCase="auto"/>
            }
            // hc_nodeappendchildgetnodename.xml
            #[test]
            fn test_hc_nodeappendchildgetnodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#new_child = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="newChild"/>
                let r#append_node = r#employee_node.append_child(new_child.into()).unwrap(); // <appendChild obj="employeeNode" newChild="newChild" var="appendNode"/>
                let r#child_name = r#append_node.node_name().to_string(); // <nodeName obj="appendNode" var="childName"/>
                assert_eq!(r#child_name, "br"); // <assertEquals actual="childName" expected="&quot;br&quot;" id="nodeName" ignoreCase="auto"/>
            }
            // hc_documentinvalidcharacterexceptioncreateattribute.xml
            #[test]
            fn test_hc_documentinvalidcharacterexceptioncreateattribute() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <createAttribute var="createdAttr" obj="doc" name="&quot;invalid^Name&quot;"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_attribute("invalid^Name")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // nodeprocessinginstructionsetnodevalue.xml
            #[test]
            fn test_nodeprocessinginstructionsetnodevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#test_list; // type: NodeList // <var name="testList" type="NodeList"/>
                let mut r#pi_node; // type: Node // <var name="piNode" type="Node"/>
                let mut r#pi_value; // type: DOMString // <var name="piValue" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#test_list = r#doc.child_nodes(); // <childNodes obj="doc" var="testList"/>
                r#pi_node = r#test_list
                    .item(0)
                    .unwrap()
                    .clone()
                    .as_processing_instruction()
                    .unwrap(); // <item interface="NodeList" obj="testList" index="0" var="piNode"/>
                r#pi_node.set_node_value("Something different").unwrap(); // <nodeValue obj="piNode" value="&quot;Something different&quot;"/>
                r#pi_value = r#pi_node.node_value().unwrap().to_string(); // <nodeValue obj="piNode" var="piValue"/>
                assert_eq!(r#pi_value, "Something different"); // <assertEquals actual="piValue" expected="&quot;Something different&quot;" id="nodeValue" ignoreCase="false"/>
                r#pi_value = r#pi_node.data().unwrap().to_string(); // <data interface="ProcessingInstruction" obj="piNode" var="piValue"/>
                assert_eq!(r#pi_value, "Something different"); // <assertEquals actual="piValue" expected="&quot;Something different&quot;" id="data" ignoreCase="false"/>
            }
            // hc_elementchangeattributevalue.xml
            #[test]
            fn test_hc_elementchangeattributevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(3).unwrap(); // <item interface="NodeList" obj="elementList" index="3" var="testEmployee"/>
                r#test_employee.set_attribute("class", "Neither").unwrap(); // <setAttribute obj="testEmployee" name="&quot;class&quot;" value="&quot;Neither&quot;"/>
                let r#attr_value = r#test_employee.get_attribute("class"); // <getAttribute obj="testEmployee" var="attrValue" name="&quot;class&quot;"/>
                assert_eq!(r#attr_value, "Neither"); // <assertEquals actual="attrValue" expected="&quot;Neither&quot;" id="elementChangeAttributeValueAssert" ignoreCase="false"/>
            }
            // hc_attrappendchild2.xml
            #[test]
            fn test_hc_attrappendchild2() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                let r#new_child = r#doc.create_element("terday".to_string()).unwrap(); // <createElement var="newChild" obj="doc" tagName="&quot;terday&quot;"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <appendChild var="retval" obj="titleAttr" newChild="newChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    title_attr
                        .append_child(new_child.into())
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // hc_characterdataindexsizeerrsubstringnegativeoffset.xml
            #[test]
            fn test_hc_characterdataindexsizeerrsubstringnegativeoffset() {
                // // unimplemented: // <implementationAttribute name="signed" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                // let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                // let mut r#bad_string; // type: DOMString // <var name="badString" type="DOMString"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                // r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                // r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // // unimplemented:
                // // <assertDOMException id="throws_INDEX_SIZE_ERR">
                // //  <INDEX_SIZE_ERR>
                // //      <substringData var="badString" obj="child" offset="-5" count="3"/>
                // //  </INDEX_SIZE_ERR>
                // // </assertDOMException>
            }
            // characterdatareplacedataexceedslengthofdata.xml
            #[test]
            fn test_characterdatareplacedataexceedslengthofdata() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.replace_data(0, 50, "2600").unwrap(); // <replaceData obj="child" offset="0" count="50" arg="&quot;2600&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "2600"); // <assertEquals actual="childData" expected="&quot;2600&quot;" id="characterdataReplaceDataExceedsLengthOfDataAssert" ignoreCase="false"/>
            }
            // nodenotationnodetype.xml
            #[test]
            fn test_nodenotationnodetype() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#notations = doc_type.notations(); // <notations obj="docType" var="notations"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                let r#notation_node = r#notations.get_named_item("notation1").unwrap(); // <getNamedItem obj="notations" var="notationNode" name="&quot;notation1&quot;"/>
                // unimplemented: // <assertNotNull actual="notationNode" id="notationNotNull"/>
                let r#node_type = r#notation_node.node_type(); // <nodeType obj="notationNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 12); // <assertEquals actual="nodeType" expected="12" id="nodeNotationNodeTypeAssert1" ignoreCase="false"/>
            }
            // characterdatainsertdataend.xml
            #[test]
            fn test_characterdatainsertdataend() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.insert_data(15, ", Esquire").unwrap(); // <insertData obj="child" offset="15" arg="&quot;, Esquire&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Margaret Martin, Esquire"); // <assertEquals actual="childData" expected="&quot;Margaret Martin, Esquire&quot;" id="characterdataInsertDataEndAssert" ignoreCase="false"/>
            }
            // elementnotfounderr.xml
            #[test]
            fn test_elementnotfounderr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#old_attribute; // type: Attr // <var name="oldAttribute" type="Attr"/>
                let r#address_element_list; // type: NodeList // <var name="addressElementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#address_element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="addressElementList"/>
                r#test_address = r#address_element_list.item(4).unwrap(); // <item interface="NodeList" obj="addressElementList" index="4" var="testAddress"/>
                r#old_attribute = r#doc.create_attribute("oldAttribute".to_string()).unwrap(); // <createAttribute obj="doc" var="oldAttribute" name="&quot;oldAttribute&quot;"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <removeAttributeNode obj="testAddress" oldAttr="oldAttribute" var="attrAddress"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    test_address
                        .remove_attribute_node(old_attribute)
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // noderemovechildgetnodename.xml
            #[test]
            fn test_noderemovechildgetnodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#length = r#child_list.length(); // <length var="length" obj="childList" interface="NodeList"/>
                let r#old_child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="oldChild"/>
                let r#removed_child = r#employee_node.remove_child(old_child).unwrap(); // <removeChild obj="employeeNode" oldChild="oldChild" var="removedChild"/>
                let r#child_name = r#removed_child.node_name().to_string(); // <nodeName obj="removedChild" var="childName"/>
                // <if><equals actual="length" expected="6" ignoreCase="false"/>
                //  <assertEquals actual="childName" expected="&quot;employeeId&quot;" id="nowhitespace" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="childName" expected="&quot;#text&quot;" id="whitespace" ignoreCase="false"/>
                // </else>
                // </if>
                if length == 6 {
                    assert_eq!(child_name, "employeeId");
                } else {
                    assert_eq!(child_name, "#text");
                }
            }
            // nodevalue05.xml
            #[test]
            fn test_nodevalue05() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_node = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="newNode"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="initiallyNull"/>
                r#new_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
            }
            // hc_attrinsertbefore6.xml
            #[test]
            fn test_hc_attrinsertbefore6() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let r#text_node; // type: Node // <var name="textNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#other_doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="otherDoc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#text_node = r#other_doc.create_text_node("terday"); // <createTextNode var="textNode" obj="otherDoc" data="&quot;terday&quot;"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <insertBefore var="retval" obj="titleAttr" newChild="textNode" refChild="refChild"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    title_attr
                        .insert_before(text_node.into(), None)
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // nodetextnodeattribute.xml
            #[test]
            fn test_nodetextnodeattribute() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#text_node = r#test_addr.first_child().unwrap(); // <firstChild interface="Node" obj="testAddr" var="textNode"/>
                let r#attr_list = r#text_node.attributes(); // <attributes obj="textNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="nodeTextNodeAttributesAssert1"/>
            }
            // textsplittexttwo.xml
            #[test]
            fn test_textsplittexttwo() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#split_node; // type: Text // <var name="splitNode" type="Text"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;name&quot;"/>
                r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                r#text_node = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="textNode"/>
                r#split_node = r#text_node.split_text(5).unwrap(); // <splitText obj="textNode" var="splitNode" offset="5"/>
                let r#value = r#text_node.node_value().unwrap().to_string(); // <nodeValue obj="textNode" var="value"/>
                assert_eq!(r#value, "Roger"); // <assertEquals actual="value" expected="&quot;Roger&quot;" id="textSplitTextTwoAssert" ignoreCase="false"/>
            }
            // nodereplacechild.xml
            #[test]
            fn test_nodereplacechild() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#replaced_node; // type: Node // <var name="replacedNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#old_child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="oldChild"/>
                r#new_child = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="newChild"/>
                r#replaced_node = r#employee_node
                    .replace_child(new_child.into(), old_child)
                    .unwrap(); // <replaceChild var="replacedNode" obj="employeeNode" newChild="newChild" oldChild="oldChild"/>
                r#child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="child"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                assert_eq!(r#child_name, "newChild"); // <assertEquals actual="childName" expected="&quot;newChild&quot;" id="nodeReplaceChildAssert1" ignoreCase="false"/>
            }
            // hc_elementgetelementsbytagname.xml
            #[test]
            fn test_hc_elementgetelementsbytagname() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                assert_eq!(element_list.length(), 5); // <assertSize collection="elementList" size="5" id="elementGetElementsByTagNameAssert"/>
            }
            // hc_namednodemapsetnameditem.xml
            #[test]
            fn test_hc_namednodemapsetnameditem() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let r#district_node; // type: Attr // <var name="districtNode" type="Attr"/>
                let mut r#set_node; // type: Node // <var name="setNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                r#test_address = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="1"/>
                r#new_attribute = r#doc.create_attribute("lang".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;lang&quot;"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                r#set_node = r#attributes.set_named_item(r#new_attribute).unwrap(); // <setNamedItem var="setNode" obj="attributes" arg="newAttribute"/>
                r#district_node = r#attributes.get_named_item("lang").unwrap(); // <getNamedItem obj="attributes" var="districtNode" name="&quot;lang&quot;"/>
                let r#attr_name = r#district_node.node_name().to_string(); // <nodeName obj="districtNode" var="attrName"/>
                assert_eq!(r#attr_name, "lang"); // <assertEquals actual="attrName" expected="&quot;lang&quot;" id="nodeName" ignoreCase="auto" context="attribute"/>
            }
            // hc_elementnormalize2.xml
            #[test]
            fn test_hc_elementnormalize2() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#root; // type: Element // <var name="root" type="Element"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                let r#empty_text; // type: Text // <var name="emptyText" type="Text"/>
                let mut r#attr_node; // type: Attr // <var name="attrNode" type="Attr"/>
                let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#root = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="root"/>
                r#empty_text = r#doc.create_text_node(""); // <createTextNode var="emptyText" obj="doc" data="&quot;&quot;"/>
                r#element_list = r#root.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Element" obj="root" tagname="&quot;acronym&quot;" var="elementList"/>
                r#element = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="element"/>
                r#attr_node = r#element.get_attribute_node("title").unwrap(); // <getAttributeNode var="attrNode" obj="element" name="&quot;title&quot;"/>
                r#retval = r#attr_node.append_child(empty_text.into()).unwrap(); // <appendChild var="retval" obj="attrNode" newChild="emptyText"/>
                r#element.normalize(); // <normalize obj="element"/>
                r#attr_node = r#element.get_attribute_node("title").unwrap(); // <getAttributeNode var="attrNode" obj="element" name="&quot;title&quot;"/>
                r#first_child = r#attr_node.first_child().unwrap(); // <firstChild interface="Node" obj="attrNode" var="firstChild"/>
                let r#child_value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="childValue"/>
                assert_eq!(r#child_value, "Yes"); // <assertEquals actual="childValue" expected="&quot;Yes&quot;" id="firstChild" ignoreCase="false"/>
                let r#second_child = r#first_child.next_sibling(); // <nextSibling var="secondChild" obj="firstChild" interface="Node"/>
                assert!(second_child.is_none()); // <assertNull actual="secondChild" id="secondChildNull"/>
            }
            // hc_nodeinsertbeforenodeancestor.xml
            #[test]
            fn test_hc_nodeinsertbeforenodeancestor() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#new_child = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="newChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#ref_child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="refChild"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <insertBefore var="insertedNode" obj="employeeNode" newChild="newChild" refChild="refChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    employee_node
                        .insert_before(new_child.into(), Some(ref_child))
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // hc_nodechildnodesempty.xml
            #[test]
            fn test_hc_nodechildnodesempty() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;em&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#text_node = r#employee_node.first_child().unwrap(); // <firstChild var="textNode" obj="employeeNode"/>
                r#child_list = r#text_node.child_nodes(); // <childNodes var="childList" obj="textNode"/>
                let r#length = r#child_list.length(); // <length var="length" obj="childList" interface="NodeList"/>
                assert_eq!(r#length, 0); // <assertEquals expected="0" actual="length" id="length_zero" ignoreCase="false"/>
            }
            // nodenotationnodeattributes.xml
            #[test]
            fn test_nodenotationnodeattributes() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#notations = doc_type.notations(); // <notations obj="docType" var="notations"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                let r#notation_node = r#notations.get_named_item("notation1").unwrap(); // <getNamedItem obj="notations" name="&quot;notation1&quot;" var="notationNode"/>
                // unimplemented: // <assertNotNull actual="notationNode" id="notationNotNull"/>
                let r#attr_list = r#notation_node.attributes(); // <attributes obj="notationNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="nodeNotationNodeAttributesAssert1"/>
            }
            // characterdataindexsizeerrreplacedataoffsetgreater.xml
            #[test]
            fn test_characterdataindexsizeerrreplacedataoffsetgreater() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                // <assertDOMException id="throw_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <replaceData obj="child" offset="40" count="3" arg="&quot;ABC&quot;"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
                assert!(
                    child
                        .replace_data(40, 3, "ABC")
                        .is_err_and(|err| err == DOMException::IndexSizeErr)
                );
            }
            // hc_nodegetnextsiblingnull.xml
            #[test]
            fn test_hc_nodegetnextsiblingnull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#lc_node = r#employee_node.last_child().unwrap(); // <lastChild interface="Node" obj="employeeNode" var="lcNode"/>
                let r#ns_node = r#lc_node.next_sibling(); // <nextSibling interface="Node" obj="lcNode" var="nsNode"/>
                assert!(ns_node.is_none()); // <assertNull actual="nsNode" id="nodeGetNextSiblingNullAssert1"/>
            }
            // hc_nodehaschildnodes.xml
            #[test]
            fn test_hc_nodehaschildnodes() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#state = r#employee_node.has_child_nodes(); // <hasChildNodes obj="employeeNode" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="nodeHasChildAssert1"/>
            }
            // hc_documentgetelementsbytagnamelength.xml
            #[test]
            fn test_hc_documentgetelementsbytagnamelength() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#name_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" var="nameList" tagname="&quot;strong&quot;"/>
                assert_eq!(name_list.length(), 5); // <assertSize collection="nameList" size="5" id="documentGetElementsByTagNameLengthAssert"/>
            }
            // elementreplaceattributewithself.xml
            #[test]
            fn test_elementreplaceattributewithself() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                let r#street_attr = r#test_employee.get_attribute_node("street").unwrap(); // <getAttributeNode var="streetAttr" obj="testEmployee" name="&quot;street&quot;"/>
                let r#replaced_attr = r#test_employee
                    .set_attribute_node(r#street_attr.clone())
                    .unwrap()
                    .unwrap(); // <setAttributeNode obj="testEmployee" var="replacedAttr" newAttr="streetAttr"/>
                assert!(replaced_attr.is_same_node(&street_attr.into())); // <assertSame actual="replacedAttr" expected="streetAttr" id="replacedAttr"/>
            }
            // nodecdatasectionnodename.xml
            #[test]
            fn test_nodecdatasectionnodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#cdata_name; // type: Element // <var name="cdataName" type="Element"/>
                let mut r#cdata_node; // type: Node // <var name="cdataNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;name&quot;"/>
                r#cdata_name = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="cdataName"/>
                r#cdata_node = r#cdata_name.last_child().unwrap(); // <lastChild interface="Node" obj="cdataName" var="cdataNode"/>
                let r#node_type = r#cdata_node.node_type(); // <nodeType var="nodeType" obj="cdataNode"/>
                // <if><notEquals actual="nodeType" expected="4" ignoreCase="false"/>
                //  <createCDATASection var="cdataNode" obj="doc" data="&quot;&quot;"/>
                // </if>
                if node_type as i32 != 4 {
                    cdata_node = doc.create_cdata_section("").unwrap().into();
                }
                let r#cdata_node_name = r#cdata_node.node_name().to_string(); // <nodeName obj="cdataNode" var="cdataNodeName"/>
                assert_eq!(r#cdata_node_name, "#cdata-section"); // <assertEquals actual="cdataNodeName" expected="&quot;#cdata-section&quot;" id="cdataNodeName" ignoreCase="false"/>
            }
            // hc_nodelisttraverselist.xml
            #[test]
            fn test_hc_nodelisttraverselist() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#employee_list; // type: NodeList // <var name="employeeList" type="NodeList"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let r#expected = vec!["em", "strong", "code", "sup", "var", "acronym"]; // type: List // <var name="expected" type="List"><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member></var>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;p&quot;"/>
                r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                // <for-each collection="employeeList" member="child">
                //  <nodeType var="nodeType" obj="child"/>
                //  <nodeName obj="child" var="childName"/>
                //  <if><equals actual="nodeType" expected="1"/>
                //      <append collection="result" item="childName"/>
                //  <else>
                //      <assertEquals actual="nodeType" expected="3" id="textNodeType" ignoreCase="false"/>
                //      <assertEquals actual="childName" expected="&quot;#text&quot;" id="textNodeName" ignoreCase="false"/>
                //  </else>
                //  </if>
                // </for-each>
                for i in 0..employee_list.length() {
                    child = employee_list.item(i).unwrap();
                    node_type = child.node_type();
                    child_name = child.node_name().to_string();
                    if node_type as i32 == 1 {
                        result.push(child_name);
                    } else {
                        assert_eq!(node_type as i32, 3);
                        assert_eq!(child_name, "#text");
                    }
                }
                assert_eq!(r#result, expected); // <assertEquals actual="result" expected="expected" id="nodeNames" ignoreCase="auto"/>
            }
            // hc_nodevalue04.xml
            #[test]
            fn test_hc_nodevalue04() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // let mut r#new_value; // type: DOMString // <var name="newValue" type="DOMString"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#new_node = r#doc.doctype().unwrap(); // <doctype obj="doc" var="newNode"/>

                // // unimplemented:
                // // <assertTrue id="docTypeNotNullOrDocIsHTML">
                // //  <or>
                // //      <notNull obj="newNode"/>
                // //      <contentType type="text/html"/>
                // //  </or>
                // // </assertTrue>

                // // unimplemented: // <if><notNull obj="newNode"/><assertNotNull actual="newNode" id="docTypeNotNull"/><nodeValue obj="newNode" var="newValue"/><assertNull actual="newValue" id="initiallyNull"/><!--   attempt to change the value and make sure that it stays null  --><nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/><nodeValue obj="newNode" var="newValue"/><assertNull actual="newValue" id="nullAfterAttemptedChange"/></if>
            }
            // hc_nodeelementnodevalue.xml
            #[test]
            fn test_hc_nodeelementnodevalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="elementNode"/>
                let r#element_value = r#element_node.node_value(); // <nodeValue obj="elementNode" var="elementValue"/>
                assert!(element_value.is_none()); // <assertNull actual="elementValue" id="elementNodeValue"/>
            }
            // cdatasectiongetdata.xml
            #[test]
            fn test_cdatasectiongetdata() {
                // unimplemented: // <implementationAttribute name="coalescing" value="false"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#name_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="nameList" tagname="&quot;name&quot;"/>
                let r#child = r#name_list.item(1).unwrap(); // <item interface="NodeList" obj="nameList" var="child" index="1"/>
                let r#last_child = r#child.last_child().unwrap().as_cdata_section().unwrap(); // <lastChild interface="Node" obj="child" var="lastChild"/>
                let r#node_type = r#last_child.node_type(); // <nodeType var="nodeType" obj="lastChild"/>
                assert_eq!(r#node_type as i32, 4); // <assertEquals actual="nodeType" expected="4" id="isCDATA" ignoreCase="false"/>
                let r#data = r#last_child.data().to_string(); // <data interface="CharacterData" obj="lastChild" var="data"/>
                assert_eq!(
                    r#data,
                    "This is an adjacent CDATASection with a reference to a tab &tab;"
                ); // <assertEquals actual="data" expected="&quot;This is an adjacent CDATASection with a reference to a tab &amp;tab;&quot;" id="data" ignoreCase="false"/>
            }
            // characterdataindexsizeerrsubstringcountnegative.xml
            #[test]
            fn test_characterdataindexsizeerrsubstringcountnegative() {
                // // unimplemented: // <implementationAttribute name="signed" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                // let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                // let mut r#bad_substring; // type: DOMString // <var name="badSubstring" type="DOMString"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                // r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                // r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                // r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // // unimplemented:
                // // <assertDOMException id="throws_INDEX_SIZE_ERR">
                // //  <INDEX_SIZE_ERR>
                // //      <substringData var="badSubstring" obj="child" offset="10" count="-3"/>
                // //  </INDEX_SIZE_ERR>
                // // </assertDOMException>
            }
            // nodehaschildnodesfalse.xml
            #[test]
            fn test_nodehaschildnodesfalse() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#child = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="child"/>
                let r#employee_id_list = r#child.child_nodes(); // <childNodes obj="child" var="employeeIdList"/>
                let r#employee_node = r#employee_id_list.item(1).unwrap().clone(); // <item interface="NodeList" obj="employeeIdList" index="1" var="employeeNode"/>
                let r#text_node = r#employee_node.first_child().unwrap(); // <firstChild interface="Node" obj="employeeNode" var="textNode"/>
                let r#state = r#text_node.has_child_nodes(); // <hasChildNodes obj="textNode" var="state"/>
                assert!(!r#state); // <assertFalse actual="state" id="nodeHasChildFalseAssert1"/>
            }
            // nodelisttraverselist.xml
            #[test]
            fn test_nodelisttraverselist() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#employee_list; // type: NodeList // <var name="employeeList" type="NodeList"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let r#expected_whitespace = vec![
                    "#text",
                    "employeeId",
                    "#text",
                    "name",
                    "#text",
                    "position",
                    "#text",
                    "salary",
                    "#text",
                    "gender",
                    "#text",
                    "address",
                    "#text",
                ]; // type: List // <var name="expectedWhitespace" type="List"><member>"#text"</member><member>"employeeId"</member><member>"#text"</member><member>"name"</member><member>"#text"</member><member>"position"</member><member>"#text"</member><member>"salary"</member><member>"#text"</member><member>"gender"</member><member>"#text"</member><member>"address"</member><member>"#text"</member></var>
                let r#expected_no_whitespace = vec![
                    "employeeId",
                    "name",
                    "position",
                    "salary",
                    "gender",
                    "address",
                ]; // type: List // <var name="expectedNoWhitespace" type="List"><member>"employeeId"</member><member>"name"</member><member>"position"</member><member>"salary"</member><member>"gender"</member><member>"address"</member></var>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#length = r#employee_list.length(); // <length var="length" obj="employeeList" interface="NodeList"/>
                // <for-each collection="employeeList" member="child">
                //  <nodeName obj="child" var="childName"/>
                //  <append collection="result" item="childName"/>
                // </for-each>
                for i in 0..employee_list.length() {
                    child = employee_list.item(i).unwrap();
                    child_name = child.node_name().to_string();
                    result.push(child_name);
                }
                // <if><equals actual="length" expected="6" ignoreCase="false"/>
                //  <assertEquals actual="result" expected="expectedNoWhitespace" id="nowhitespace" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="result" expected="expectedWhitespace" id="whitespace" ignoreCase="false"/>
                // </else>
                // </if>
                if length == 6 {
                    assert_eq!(result, expected_no_whitespace);
                } else {
                    assert_eq!(result, expected_whitespace);
                }
            }
            // documentgetdoctype.xml
            #[test]
            fn test_documentgetdoctype() {
                let mut r#doc_type_name; // type: DOMString // <var name="docTypeName" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                r#doc_type_name = r#doc_type.name().to_string(); // <name interface="DocumentType" obj="docType" var="docTypeName"/>

                // unimplemented: // <if><contentType type="image/svg+xml"/>	<assertEquals actual="docTypeName" expected="&quot;svg&quot;" id="doctypeNameSVG" ignoreCase="false"/>	<else>		<assertEquals actual="docTypeName" expected="&quot;staff&quot;" id="doctypeName" ignoreCase="false"/>	</else></if>
                let r#node_value = r#doc_type.node_value(); // <nodeValue obj="docType" var="nodeValue"/>
                assert!(node_value.is_none()); // <assertNull actual="nodeValue" id="initiallyNull"/>
            }
            // hc_characterdatasubstringvalue.xml
            #[test]
            fn test_hc_characterdatasubstringvalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                let r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                let r#substring = child.substring_data(0, 8).unwrap(); // <substringData obj="child" var="substring" offset="0" count="8"/>
                assert_eq!(r#substring, "Margaret"); // <assertEquals actual="substring" expected="&quot;Margaret&quot;" id="characterdataSubStringValueAssert" ignoreCase="false"/>
            }
            // hc_nodelistindexgetlength.xml
            #[test]
            fn test_hc_nodelistindexgetlength() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;p&quot;"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#length = r#employee_list.length(); // <length var="length" obj="employeeList" interface="NodeList"/>
                // <if><equals actual="length" expected="6"/>
                //  <assertEquals actual="length" expected="6" ignoreCase="false" id="length_wo_space"/>
                // <else>
                //  <assertEquals actual="length" expected="13" ignoreCase="false" id="length_w_space"/>
                // </else>
                // </if>
                if length == 6 {
                    assert_eq!(length, 6);
                } else {
                    assert_eq!(length, 13);
                }
            }
            // nodegetownerdocument.xml
            #[test]
            fn test_nodegetownerdocument() {
                let mut r#element_name; // type: DOMString // <var name="elementName" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#doc_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="docNode"/>
                let r#owner_document: DocumentRef = r#doc_node.owner_document().unwrap(); // <ownerDocument obj="docNode" var="ownerDocument"/>
                let r#doc_element = r#owner_document.document_element().unwrap(); // <documentElement obj="ownerDocument" var="docElement"/>
                r#element_name = r#doc_element.node_name().to_string(); // <nodeName obj="docElement" var="elementName"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //  <assertEquals actual="elementName" expected="&quot;svg&quot;" id="svgTagName" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="elementName" expected="&quot;staff&quot;" id="nodeGetOwnerDocumentAssert1" ignoreCase="false"/>
                // </else>
                // </if>
            }
            // hc_attrinsertbefore7.xml
            #[test]
            fn test_hc_attrinsertbefore7() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                // let mut r#test_node; // type: Node // <var name="testNode" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                // let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                // let mut r#ter_node; // type: Text // <var name="terNode" type="Text"/>
                // let mut r#day_node; // type: Node // <var name="dayNode" type="Node"/>
                // let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                // let mut r#last_child; // type: Node // <var name="lastChild" type="Node"/>
                // let mut r#ref_child; // type: Node // <var name="refChild" type="Node" isNull="true"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                // r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                // r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                // r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                // r#ter_node = r#doc.create_text_node("ter"); // <createTextNode var="terNode" obj="doc" data="&quot;ter&quot;"/>

                // // unimplemented: // <if><contentType type="text/html"/>	<assertDOMException id="throw_NOT_SUPPORTED_ERR">		<NOT_SUPPORTED_ERR>			<createCDATASection var="dayNode" obj="doc" data="&quot;day&quot;"/>		</NOT_SUPPORTED_ERR>	</assertDOMException><else><createCDATASection var="dayNode" obj="doc" data="&quot;day&quot;"/><createDocumentFragment var="docFrag" obj="doc"/><appendChild var="retval" obj="docFrag" newChild="terNode"/><appendChild var="retval" obj="docFrag" newChild="dayNode"/><assertDOMException id="throw_HIERARCHY_REQUEST_ERR">	<HIERARCHY_REQUEST_ERR>		<insertBefore var="retval" obj="titleAttr" newChild="docFrag" refChild="refChild"/>	</HIERARCHY_REQUEST_ERR></assertDOMException></else></if>
            }
            // namednodemapgetnameditem.xml
            #[test]
            fn test_namednodemapgetnameditem() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="1"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("domestic").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;domestic&quot;"/>
                let r#attr_name = r#domestic_attr.node_name().to_string(); // <nodeName obj="domesticAttr" var="attrName"/>
                assert_eq!(r#attr_name, "domestic"); // <assertEquals actual="attrName" expected="&quot;domestic&quot;" id="namednodemapGetNamedItemAssert" ignoreCase="false"/>
            }
            // nodegetprevioussiblingnull.xml
            #[test]
            fn test_nodegetprevioussiblingnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="employeeNode"/>
                let r#fc_node = r#employee_node.first_child().unwrap(); // <firstChild interface="Node" obj="employeeNode" var="fcNode"/>
                let r#ps_node = r#fc_node.previous_sibling(); // <previousSibling interface="Node" obj="fcNode" var="psNode"/>
                assert!(ps_node.is_none()); // <assertNull actual="psNode" id="nodeGetPreviousSiblingNullAssert1"/>
            }
            // hc_notationssetnameditem1.xml
            #[test]
            fn test_hc_notationssetnameditem1() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <if><not><contentType type="text/html"/></not><assertNotNull actual="docType" id="docTypeNotNull"/><notations var="notations" obj="docType"/><assertNotNull actual="notations" id="notationsNotNull"/><createElement var="elem" obj="doc" tagName="&quot;br&quot;"/><try>	<setNamedItem var="retval" obj="notations" arg="elem"/>	<fail id="throw_HIER_OR_NO_MOD_ERR"/>	<catch>		<DOMException code="HIERARCHY_REQUEST_ERR"/>		<DOMException code="NO_MODIFICATION_ALLOWED_ERR"/>	</catch></try> </if>
            }
            // processinginstructionsetdatanomodificationallowederr.xml
            #[test]
            fn test_processinginstructionsetdatanomodificationallowederr() {
                // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender; // type: Node // <var name="gender" type="Node"/>
                let r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                let mut r#pi_node; // type: ProcessingInstruction // <var name="piNode" type="ProcessingInstruction"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#ent_ref = r#gender.first_child().unwrap(); // <firstChild interface="Node" var="entRef" obj="gender"/>
                // unimplemented: // <assertNotNull actual="entRef" id="entRefNotNull"/>
                r#pi_node = r#ent_ref
                    .last_child()
                    .unwrap()
                    .as_processing_instruction()
                    .unwrap(); // <lastChild interface="Node" var="piNode" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="piNode" id="piNodeNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <data interface="ProcessingInstruction" obj="piNode" value="&quot;newData&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    pi_node
                        .set_data("newData")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // elementcreatenewattribute.xml
            #[test]
            fn test_elementcreatenewattribute() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#district_attr; // type: Attr // <var name="districtAttr" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_address = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddress"/>
                r#new_attribute = r#doc.create_attribute("district".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;district&quot;"/>
                let r#old_attr = r#test_address.set_attribute_node(r#new_attribute).unwrap(); // <setAttributeNode obj="testAddress" var="oldAttr" newAttr="newAttribute"/>
                assert!(old_attr.is_none()); // <assertNull actual="oldAttr" id="old_attr_doesnt_exist"/>
                r#district_attr = r#test_address.get_attribute_node("district").unwrap(); // <getAttributeNode obj="testAddress" var="districtAttr" name="&quot;district&quot;"/>
                // unimplemented: // <assertNotNull actual="districtAttr" id="new_district_accessible"/>
                let r#attr_val = r#test_address.get_attribute("district"); // <getAttribute var="attrVal" obj="testAddress" name="&quot;district&quot;"/>
                assert_eq!(r#attr_val, ""); // <assertEquals actual="attrVal" expected="&quot;&quot;" id="attr_value" ignoreCase="false"/>
            }
            // nodedocumenttypenodename.xml
            #[test]
            fn test_nodedocumenttypenodename() {
                let mut r#document_type_name; // type: DOMString // <var name="documentTypeName" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                r#document_type_name = r#doc_type.node_name().to_string(); // <nodeName obj="docType" var="documentTypeName"/>

                // unimplemented: // <if><contentType type="image/svg+xml"/><assertEquals actual="documentTypeName" expected="&quot;svg&quot;" id="doctypeNameSVG" ignoreCase="false"/><else><assertEquals actual="documentTypeName" expected="&quot;staff&quot;" id="documentName" ignoreCase="false"/></else></if>
            }
            // hc_elementaddnewattribute.xml
            #[test]
            fn test_hc_elementaddnewattribute() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(4).unwrap(); // <item interface="NodeList" obj="elementList" index="4" var="testEmployee"/>
                r#test_employee.set_attribute("lang", "EN-us").unwrap(); // <setAttribute obj="testEmployee" name="&quot;lang&quot;" value="&quot;EN-us&quot;"/>
                let r#attr_value = r#test_employee.get_attribute("lang"); // <getAttribute obj="testEmployee" var="attrValue" name="&quot;lang&quot;"/>
                assert_eq!(r#attr_value, "EN-us"); // <assertEquals actual="attrValue" expected="&quot;EN-us&quot;" id="attrValue" ignoreCase="false"/>
            }
            // hc_elementinvalidcharacterexception.xml
            #[test]
            fn test_hc_elementinvalidcharacterexception() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_address = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddress"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <setAttribute obj="testAddress" name="&quot;invalid^Name&quot;" value="&quot;value&quot;"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    test_address
                        .set_attribute("invalid^Name", "value")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // notationgetpublicidnull.xml
            #[test]
            fn test_notationgetpublicidnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#notations = doc_type.notations(); // <notations obj="docType" var="notations"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                let r#notation_node = r#notations.get_named_item("notation2").unwrap(); // <getNamedItem obj="notations" var="notationNode" name="&quot;notation2&quot;"/>
                let r#public_id = r#notation_node.public_id(); // <publicId interface="Notation" obj="notationNode" var="publicId"/>
                assert!(public_id.is_none()); // <assertNull actual="publicId" id="publicId"/>
            }
            // notationgetsystemid.xml
            #[test]
            fn test_notationgetsystemid() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#notations = doc_type.notations(); // <notations obj="docType" var="notations"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                let r#notation_node = r#notations.get_named_item("notation2").unwrap(); // <getNamedItem obj="notations" var="notationNode" name="&quot;notation2&quot;"/>
                let r#system_id = r#notation_node.system_id().unwrap().to_string(); // <systemId interface="Notation" obj="notationNode" var="systemId"/>
                assert_eq!(system_id, "notation2File"); // <assertURIEquals actual="systemId" file="&quot;notation2File&quot;" id="uriEquals"/>
            }
            // nodegetfirstchildnull.xml
            #[test]
            fn test_nodegetfirstchildnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="employeeNode"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#second_child_node = r#employee_list.item(1).unwrap().clone(); // <item interface="NodeList" obj="employeeList" index="1" var="secondChildNode"/>
                let r#text_node = r#second_child_node.first_child().unwrap(); // <firstChild interface="Node" obj="secondChildNode" var="textNode"/>
                let r#no_child_node = r#text_node.first_child(); // <firstChild interface="Node" obj="textNode" var="noChildNode"/>
                assert!(no_child_node.is_none()); // <assertNull actual="noChildNode" id="nodeGetFirstChildNullAssert1"/>
            }
            // hc_elementretrieveallattributes.xml
            #[test]
            fn test_hc_elementretrieveallattributes() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#address_list; // type: NodeList // <var name="addressList" type="NodeList"/>
                // let mut r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                // let mut r#attribute_name; // type: DOMString // <var name="attributeName" type="DOMString"/>
                // let mut r#actual; // type: Collection // <var name="actual" type="Collection"/>
                // let mut r#html_expected; // type: Collection // <var name="htmlExpected" type="Collection">    <member>"title"</member></var>
                // let mut r#expected; // type: Collection // <var name="expected" type="Collection">    <member>"title"</member>    <member>"dir"</member></var>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#address_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="addressList"/>
                // r#test_address = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" index="0" var="testAddress"/>
                // r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>

                // // unimplemented: // <for-each collection="attributes" member="attribute">    <nodeName var="attributeName" obj="attribute"/>    <append collection="actual" item="attributeName"/></for-each>

                // // unimplemented: // <if><contentType type="text/html"/>    <assertEquals id="htmlAttributeNames" actual="actual" expected="htmlExpected" ignoreCase="true"/>    <else>        <assertEquals id="attributeNames" actual="actual" expected="expected" ignoreCase="true"/>    </else></if>
            }
            // characterdataappenddatanomodificationallowederr.xml
            #[test]
            fn test_characterdataappenddatanomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let r#ent_element; // type: Node // <var name="entElement" type="Node"/>
                let mut r#ent_element_content; // type: Node // <var name="entElementContent" type="Node"/>
                let mut r#ent_reference; // type: Node // <var name="entReference" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" index="2" var="genderNode"/>
                r#ent_reference = r#gender_node.first_child().unwrap(); // <firstChild var="entReference" obj="genderNode" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entReference" id="entReferenceNotNull"/>
                let r#node_type = r#ent_reference.node_type(); // <nodeType var="nodeType" obj="entReference"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="entReference" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="entReference" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    ent_reference = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#ent_element = r#ent_reference.first_child().unwrap(); // <firstChild var="entElement" obj="entReference" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#ent_element_content =
                    r#ent_element.first_child().unwrap().as_text_node().unwrap(); // <firstChild var="entElementContent" obj="entElement" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElementContent" id="entElementContentNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <appendData obj="entElementContent" arg="&quot;newString&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element_content
                        .append_data("newString")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_characterdatagetlength.xml
            #[test]
            fn test_hc_characterdatagetlength() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                let r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                let r#child_value = r#child.data().to_string(); // <data var="childValue" obj="child" interface="CharacterData"/>
                let r#child_length = r#child_value.len(); // <length var="childLength" obj="childValue" interface="DOMString"/>
                assert_eq!(r#child_length, 15); // <assertEquals actual="childLength" expected="15" ignoreCase="false" id="characterdataGetLengthAssert"/>
            }
            // hc_attrnextsiblingnull.xml
            #[test]
            fn test_hc_attrnextsiblingnull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;acronym&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;title&quot;"/>
                let r#s = r#domestic_attr.next_sibling(); // <nextSibling interface="Node" obj="domesticAttr" var="s"/>
                assert!(s.is_none()); // <assertNull actual="s" id="attrNextSiblingNullAssert"/>
            }
            // hc_textindexsizeerrnegativeoffset.xml
            #[test]
            fn test_hc_textindexsizeerrnegativeoffset() {
                // // unimplemented: // <implementationAttribute name="signed" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                // let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                // let mut r#split_node; // type: Text // <var name="splitNode" type="Text"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;strong&quot;"/>
                // r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                // r#text_node = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="textNode"/>

                // // unimplemented:
                // // <assertDOMException id="throws_INDEX_SIZE_ERR">
                // //  <INDEX_SIZE_ERR>
                // //      <splitText obj="textNode" var="splitNode" offset="-69"/>
                // //  </INDEX_SIZE_ERR>
                // // </assertDOMException>
            }
            // hc_nodedocumentfragmentnodename.xml
            #[test]
            fn test_hc_nodedocumentfragmentnodename() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="docFragment"/>
                let r#document_fragment_name = r#doc_fragment.node_name().to_string(); // <nodeName obj="docFragment" var="documentFragmentName"/>
                assert_eq!(r#document_fragment_name, "#document-fragment"); // <assertEquals actual="documentFragmentName" expected="&quot;#document-fragment&quot;" id="nodeDocumentFragmentNodeNameAssert1" ignoreCase="false"/>
            }
            // hc_nodelistindexgetlengthofemptylist.xml
            #[test]
            fn test_hc_nodelistindexgetlengthofemptylist() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#em_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName interface="Document" obj="doc" var="emList" tagname="&quot;em&quot;"/>
                let r#em_node = r#em_list.item(2).unwrap(); // <item interface="NodeList" obj="emList" var="emNode" index="2"/>
                let r#text_node = r#em_node.first_child().unwrap(); // <firstChild var="textNode" obj="emNode"/>
                let r#text_list = r#text_node.child_nodes(); // <childNodes var="textList" obj="textNode"/>
                let r#length = r#text_list.length(); // <length var="length" obj="textList" interface="NodeList"/>
                assert_eq!(r#length, 0); // <assertEquals actual="length" expected="0" id="length" ignoreCase="false"/>
            }
            // nodegetlastchild.xml
            #[test]
            fn test_nodegetlastchild() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let mut r#lchild_node; // type: Node // <var name="lchildNode" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#lchild_node = r#employee_node.last_child().unwrap(); // <lastChild interface="Node" obj="employeeNode" var="lchildNode"/>
                r#child_name = r#lchild_node.node_name().to_string(); // <nodeName obj="lchildNode" var="childName"/>
                // <if><equals actual="childName" expected="&quot;#text&quot;" ignoreCase="false"/>
                //  <previousSibling interface="Node" obj="lchildNode" var="lchildNode"/>
                //  <nodeName obj="lchildNode" var="childName"/>
                // </if>
                if child_name == "#text" {
                    lchild_node = lchild_node.previous_sibling().unwrap();
                    child_name = lchild_node.node_name().to_string();
                }
                assert_eq!(r#child_name, "address"); // <assertEquals actual="childName" expected="&quot;address&quot;" id="nodeName" ignoreCase="false"/>
            }
            // hc_nodecloneattributescopied.xml
            #[test]
            fn test_hc_nodecloneattributescopied() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#address_node; // type: Node // <var name="addressNode" type="Node"/>
                // let mut r#cloned_node; // type: Node // <var name="clonedNode" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#attribute_node; // type: Node // <var name="attributeNode" type="Node"/>
                // let mut r#attribute_name; // type: DOMString // <var name="attributeName" type="DOMString"/>
                // let mut r#result; // type: Collection // <var name="result" type="Collection"/>
                // let mut r#html_expected; // type: Collection // <var name="htmlExpected" type="Collection"><member>"class"</member><member>"title"</member></var>
                // let mut r#expected; // type: Collection // <var name="expected" type="Collection"><member>"class"</member><member>"title"</member><member>"dir"</member></var>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                // r#address_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="addressNode"/>
                // r#cloned_node = r#address_node.clone_node(false); // <cloneNode obj="addressNode" deep="false" var="clonedNode"/>
                // r#attributes = r#cloned_node.attributes(); // <attributes obj="clonedNode" var="attributes"/>

                // // unimplemented: // <for-each collection="attributes" member="attributeNode"><nodeName obj="attributeNode" var="attributeName"/><append collection="result" item="attributeName"/></for-each>

                // // unimplemented: // <if><contentType type="text/html"/><assertEquals actual="result" expected="htmlExpected" id="nodeNames_html" ignoreCase="true"/><else><assertEquals actual="result" expected="expected" id="nodeNames" ignoreCase="false"/></else></if>
            }
            // nodegetprevioussibling.xml
            #[test]
            fn test_nodegetprevioussibling() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#ps_node; // type: Node // <var name="psNode" type="Node"/>
                let mut r#ps_name; // type: DOMString // <var name="psName" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                r#name_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="nameNode"/>
                r#ps_node = r#name_node.previous_sibling().unwrap(); // <previousSibling interface="Node" obj="nameNode" var="psNode"/>
                r#ps_name = r#ps_node.node_name().to_string(); // <nodeName obj="psNode" var="psName"/>
                // <if><equals actual="psName" expected="&quot;#text&quot;" ignoreCase="false"/>
                //  <previousSibling interface="Node" obj="psNode" var="psNode"/>
                //  <nodeName obj="psNode" var="psName"/>
                // </if>
                if ps_name == "#text" {
                    ps_node = ps_node.previous_sibling().unwrap();
                    ps_name = ps_node.node_name().to_string();
                }
                assert_eq!(r#ps_name, "employeeId"); // <assertEquals actual="psName" expected="&quot;employeeId&quot;" id="nodeName" ignoreCase="false"/>
            }
            // hc_characterdatagetdata.xml
            #[test]
            fn test_hc_characterdatagetdata() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                let r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Margaret Martin"); // <assertEquals actual="childData" expected="&quot;Margaret Martin&quot;" id="characterdataGetDataAssert" ignoreCase="false"/>
            }
            // hc_attrsetvalue2.xml
            #[test]
            fn test_hc_attrsetvalue2() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                let mut r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#text_node = r#doc.create_text_node("terday"); // <createTextNode var="textNode" obj="doc" data="&quot;terday&quot;"/>
                r#retval = r#title_attr.append_child(text_node.into()).unwrap(); // <appendChild var="retval" obj="titleAttr" newChild="textNode"/>
                r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                // unimplemented: // <assertNotNull actual="firstChild" id="attrChildNotNull"/>
                r#title_attr.set_value("Tomorrow").unwrap(); // <value obj="titleAttr" value="&quot;Tomorrow&quot;" interface="Attr"/>
                r#first_child.set_node_value("impl reused node").unwrap(); // <nodeValue obj="firstChild" value="&quot;impl reused node&quot;"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Tomorrow"); // <assertEquals actual="value" expected="&quot;Tomorrow&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Tomorrow"); // <assertEquals actual="value" expected="&quot;Tomorrow&quot;" id="attrNodeValue" ignoreCase="false"/>
                r#first_child = r#title_attr.last_child().unwrap(); // <lastChild var="firstChild" obj="titleAttr" interface="Node"/>
                r#value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="value"/>
                assert_eq!(r#value, "Tomorrow"); // <assertEquals actual="value" expected="&quot;Tomorrow&quot;" id="firstChildValue" ignoreCase="false"/>
                let r#other_child = r#first_child.next_sibling(); // <nextSibling var="otherChild" obj="firstChild" interface="Node"/>
                assert!(other_child.is_none()); // <assertNull actual="otherChild" id="nextSiblingIsNull"/>
            }
            // hc_attrinsertbefore5.xml
            #[test]
            fn test_hc_attrinsertbefore5() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                // let mut r#test_node; // type: Node // <var name="testNode" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                // let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                // let mut r#text_node; // type: Node // <var name="textNode" type="Node"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#ref_child; // type: Node // <var name="refChild" type="Node" isNull="true"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                // r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                // r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                // r#title_attr = r#attributes.get_named_item("title").unwrap();
                // // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>

                // // unimplemented: // <if><contentType type="text/html"/>	<assertDOMException id="throw_NOT_SUPPORTED_ERR">		<NOT_SUPPORTED_ERR>			<createCDATASection var="textNode" obj="doc" data="&quot;terday&quot;"/>		</NOT_SUPPORTED_ERR>	</assertDOMException><else><createCDATASection var="textNode" obj="doc" data="&quot;terday&quot;"/><assertDOMException id="throw_HIERARCHY_REQUEST_ERR">	<HIERARCHY_REQUEST_ERR>		<insertBefore var="retval" obj="titleAttr" newChild="textNode" refChild="refChild"/>	</HIERARCHY_REQUEST_ERR></assertDOMException></else></if>
            }
            // elementretrievetagname.xml
            #[test]
            fn test_elementretrievetagname() {
                let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("position"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;position&quot;" var="elementList"/>
                let r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="testEmployee"/>
                r#name = r#test_employee.node_name().to_string(); // <nodeName obj="testEmployee" var="name"/>
                assert_eq!(r#name, "position"); // <assertEquals actual="name" expected="&quot;position&quot;" id="nodename" ignoreCase="false"/>
                r#name = r#test_employee.tag_name().to_string(); // <tagName obj="testEmployee" var="name"/>
                assert_eq!(r#name, "position"); // <assertEquals actual="name" expected="&quot;position&quot;" id="tagname" ignoreCase="false"/>
            }
            // nodereplacechildinvalidnodetype.xml
            #[test]
            fn test_nodereplacechildinvalidnodetype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Element // <var name="rootNode" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                let r#new_child = r#doc.create_attribute("newAttribute".to_string()).unwrap(); // <createAttribute obj="doc" name="&quot;newAttribute&quot;" var="newChild"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#old_child = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="oldChild"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <replaceChild var="replacedChild" obj="rootNode" newChild="newChild" oldChild="oldChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    root_node
                        .replace_child(new_child.into(), old_child.into())
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // nodedocumentnodeattribute.xml
            #[test]
            fn test_nodedocumentnodeattribute() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#attr_list = r#doc.attributes(); // <attributes obj="doc" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="documentAttributesNull"/>
            }
            // nodeclonefalsenocopytext.xml
            #[test]
            fn test_nodeclonefalsenocopytext() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#child_node = r#child_list.item(3).unwrap().clone(); // <item interface="NodeList" obj="childList" index="3" var="childNode"/>
                let r#cloned_node = r#child_node.clone_node(false); // <cloneNode obj="childNode" deep="false" var="clonedNode"/>
                let r#last_child_node = r#cloned_node.last_child(); // <lastChild interface="Node" obj="clonedNode" var="lastChildNode"/>
                assert!(last_child_node.is_none()); // <assertNull actual="lastChildNode" id="noTextNodes"/>
            }
            // hc_characterdatadeletedataexceedslength.xml
            #[test]
            fn test_hc_characterdatadeletedataexceedslength() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.delete_data(4, 50).unwrap(); // <deleteData obj="child" offset="4" count="50"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230"); // <assertEquals actual="childData" expected="&quot;1230&quot;" id="characterdataDeleteDataExceedsLengthAssert" ignoreCase="false"/>
            }
            // hc_documentcreatecomment.xml
            #[test]
            fn test_hc_documentcreatecomment() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#new_comment_node = r#doc.create_comment("This is a new Comment node"); // <createComment obj="doc" var="newCommentNode" data="&quot;This is a new Comment node&quot;"/>
                let r#new_comment_value = r#new_comment_node.node_value().unwrap().to_string(); // <nodeValue obj="newCommentNode" var="newCommentValue"/>
                assert_eq!(r#new_comment_value, "This is a new Comment node"); // <assertEquals actual="newCommentValue" expected="&quot;This is a new Comment node&quot;" ignoreCase="false" id="value"/>
                let r#new_comment_name = r#new_comment_node.node_name().to_string(); // <nodeName obj="newCommentNode" var="newCommentName"/>
                assert_eq!(r#new_comment_name, "#comment"); // <assertEquals actual="newCommentName" expected="&quot;#comment&quot;" ignoreCase="false" id="strong"/>
                let r#new_comment_type = r#new_comment_node.node_type(); // <nodeType obj="newCommentNode" var="newCommentType"/>
                assert_eq!(r#new_comment_type as i32, 8); // <assertEquals actual="newCommentType" expected="8" ignoreCase="false" id="type"/>
            }
            // characterdatadeletedataend.xml
            #[test]
            fn test_characterdatadeletedataend() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.delete_data(30, 5).unwrap(); // <deleteData obj="child" offset="30" count="5"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230 North Ave. Dallas, Texas "); // <assertEquals actual="childData" expected="&quot;1230 North Ave. Dallas, Texas &quot;" id="characterdataDeleteDataEndAssert" ignoreCase="false"/>
            }
            // hc_noderemovechildoldchildnonexistent.xml
            #[test]
            fn test_hc_noderemovechildoldchildnonexistent() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#old_child = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="oldChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <removeChild var="removedChild" obj="elementNode" oldChild="oldChild"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .remove_child(old_child.into())
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // documentcreateelementdefaultattr.xml
            #[test]
            fn test_documentcreateelementdefaultattr() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#new_element = r#doc.create_element("address".to_string()).unwrap(); // <createElement obj="doc" var="newElement" tagName="&quot;address&quot;"/>
                let r#default_attr = r#new_element.attributes(); // <attributes obj="newElement" var="defaultAttr"/>
                let r#child = r#default_attr.item(0).unwrap(); // <item obj="defaultAttr" var="child" index="0" interface="NamedNodeMap"/>
                // unimplemented: // <assertNotNull actual="child" id="defaultAttrNotNull"/>
                let r#name = r#child.node_name().to_string(); // <nodeName obj="child" var="name"/>
                assert_eq!(r#name, "street"); // <assertEquals actual="name" expected="&quot;street&quot;" id="attrName" ignoreCase="false"/>
                let r#value = r#child.node_value().unwrap().to_string(); // <nodeValue obj="child" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="attrValue" ignoreCase="false"/>
                assert_eq!(default_attr.length(), 1); // <assertSize collection="defaultAttr" size="1" id="attrCount"/>
            }
            // commentgetcomment.xml
            #[test]
            fn test_commentgetcomment() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#child_value; // type: DOMString // <var name="childValue" type="DOMString"/>
                let mut r#comment_count = 0; // type: int // <var name="commentCount" type="int" value="0"/>
                let mut r#child_type; // type: int // <var name="childType" type="int"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.child_nodes(); // <childNodes obj="doc" var="elementList"/>
                // <for-each collection="elementList" member="child">
                //  <nodeType obj="child" var="childType"/>
                //  <if><equals actual="childType" expected="8" ignoreCase="false"/>
                //      <nodeName obj="child" var="childName"/>
                //      <assertEquals actual="childName" expected="&quot;#comment&quot;" ignoreCase="false" id="nodeName"/>
                //      <nodeValue obj="child" var="childValue"/>
                //      <assertEquals actual="childValue" expected="&quot; This is comment number 1.&quot;" id="nodeValue" ignoreCase="false"/>
                //      <plus var="commentCount" op1="commentCount" op2="1"/>
                //  </if>
                // </for-each>
                for i in 0..element_list.length() {
                    child = element_list.item(i).unwrap();
                    child_type = child.node_type();
                    if child_type as i32 == 8 {
                        child_name = child.node_name().to_string();
                        assert_eq!(child_name, "#comment");
                        child_value = child.node_value().unwrap().to_string();
                        assert_eq!(child_value, " This is comment number 1.");
                        comment_count += 1;
                    }
                }
                assert_eq!(r#comment_count, 1); // <assertEquals actual="commentCount" expected="1" ignoreCase="false" id="commentCount"/>
            }
            // hc_documentgetrootnode.xml
            #[test]
            fn test_hc_documentgetrootnode() {
                let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#root = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="root"/>
                r#root_name = r#root.node_name().to_string(); // <nodeName obj="root" var="rootName"/>

                // unimplemented: // <if><contentType type="image/svg+xml"/><assertEquals actual="rootName" expected="&quot;svg&quot;" id="svgTagName" ignoreCase="false"/><else><assertEquals actual="rootName" expected="&quot;html&quot;" id="docElemName" ignoreCase="auto"/></else></if>
            }
            // hc_textindexsizeerroffsetoutofbounds.xml
            #[test]
            fn test_hc_textindexsizeerroffsetoutofbounds() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;strong&quot;"/>
                r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                r#text_node = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="textNode"/>
                // <assertDOMException id="throw_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <splitText obj="textNode" var="splitNode" offset="300"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
                assert!(
                    text_node
                        .split_text(300)
                        .is_err_and(|err| err == DOMException::IndexSizeErr)
                );
            }
            // attrnotspecifiedvalue.xml
            #[test]
            fn test_attrnotspecifiedvalue() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                let r#state = r#street_attr.specified(); // <specified obj="streetAttr" var="state"/>
                assert!(!r#state); // <assertFalse actual="state" id="streetNotSpecified"/>
            }
            // characterdatareplacedatabegining.xml
            #[test]
            fn test_characterdatareplacedatabegining() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.replace_data(0, 4, "2500").unwrap(); // <replaceData obj="child" offset="0" count="4" arg="&quot;2500&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "2500 North Ave. Dallas, Texas 98551"); // <assertEquals actual="childData" expected="&quot;2500 North Ave. Dallas, Texas 98551&quot;" id="characterdataReplaceDataBeginingAssert" ignoreCase="false"/>
            }
            // nodelistindexequalzero.xml
            #[test]
            fn test_nodelistindexequalzero() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#child = r#employee_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="employeeList" var="child" index="0"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                // <if><notEquals actual="childName" expected="&quot;#text&quot;" ignoreCase="false"/>
                //  <assertEquals actual="childName" expected="&quot;employeeId&quot;" id="childName" ignoreCase="false"/>
                // </if>
                if child_name != "#text" {
                    assert_eq!(child_name, "employeeId");
                }
            }
            // hc_namednodemapnotfounderr.xml
            #[test]
            fn test_hc_namednodemapnotfounderr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="2"/>
                r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <removeNamedItem var="removedNode" interface="NamedNodeMap" obj="attributes" name="&quot;lang&quot;"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .remove_named_item("lang")
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // hc_elementnormalize.xml
            #[test]
            fn test_hc_elementnormalize() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root; // type: Element // <var name="root" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_name; // type: Element // <var name="testName" type="Element"/>
                let r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#ret_node; // type: Node // <var name="retNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("sup"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;sup&quot;" var="elementList"/>
                r#test_name = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testName"/>
                r#text_node = r#doc.create_text_node(""); // <createTextNode var="textNode" obj="doc" data="&quot;&quot;"/>
                r#ret_node = r#test_name.append_child(text_node.into()).unwrap(); // <appendChild var="retNode" obj="testName" newChild="textNode"/>
                r#text_node = r#doc.create_text_node(",000"); // <createTextNode var="textNode" obj="doc" data="&quot;,000&quot;"/>
                r#ret_node = r#test_name.append_child(text_node.into()).unwrap(); // <appendChild var="retNode" obj="testName" newChild="textNode"/>
                r#root = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="root"/>
                r#root.normalize(); // <normalize obj="root"/>
                r#element_list = r#doc.get_elements_by_tag_name("sup"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;sup&quot;" var="elementList"/>
                r#test_name = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testName"/>
                r#first_child = r#test_name.first_child().unwrap(); // <firstChild interface="Node" obj="testName" var="firstChild"/>
                let r#child_value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="childValue"/>
                assert_eq!(r#child_value, "56,000,000"); // <assertEquals actual="childValue" expected="&quot;56,000,000&quot;" id="elementNormalizeAssert" ignoreCase="false"/>
            }
            // notationgetnotationname.xml
            #[test]
            fn test_notationgetnotationname() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#notations = doc_type.notations(); // <notations obj="docType" var="notations"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                let r#notation_node = r#notations.get_named_item("notation1").unwrap(); // <getNamedItem obj="notations" var="notationNode" name="&quot;notation1&quot;"/>
                let r#notation_name = r#notation_node.node_name().to_string(); // <nodeName obj="notationNode" var="notationName"/>
                assert_eq!(r#notation_name, "notation1"); // <assertEquals actual="notationName" expected="&quot;notation1&quot;" id="notationGetNotationNameAssert" ignoreCase="false"/>
            }
            // nodechildnodesempty.xml
            #[test]
            fn test_nodechildnodesempty() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#second_c_node = r#child_list.item(1).unwrap().clone(); // <item interface="NodeList" obj="childList" index="1" var="secondCNode"/>
                let r#text_node = r#second_c_node.first_child().unwrap(); // <firstChild interface="Node" obj="secondCNode" var="textNode"/>
                let r#child_nodes_list = r#text_node.child_nodes(); // <childNodes obj="textNode" var="childNodesList"/>
                assert_eq!(child_nodes_list.length(), 0); // <assertSize collection="childNodesList" size="0" id="nodeChildNodesEmptyAssert1"/>
            }
            // hc_nodevalue05.xml
            #[test]
            fn test_hc_nodevalue05() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#new_node = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="newNode"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="initiallyNull"/>
                r#new_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
            }
            // hc_nodegetlastchild.xml
            #[test]
            fn test_hc_nodegetlastchild() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#lchild_node = r#employee_node.last_child().unwrap(); // <lastChild interface="Node" obj="employeeNode" var="lchildNode"/>
                let r#child_name = r#lchild_node.node_name().to_string(); // <nodeName obj="lchildNode" var="childName"/>
                assert_eq!(r#child_name, "#text"); // <assertEquals actual="childName" expected="&quot;#text&quot;" id="whitespace" ignoreCase="false"/>
            }
            // attrspecifiedvalueremove.xml
            #[test]
            fn test_attrspecifiedvalueremove() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#address_list; // type: NodeList // <var name="addressList" type="NodeList"/>
                let mut r#test_node; // type: Node // <var name="testNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                r#test_node = r#address_list.item(2).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="2"/>
                r#test_node.remove_attribute("street").unwrap(); // <removeAttribute obj="testNode" name="&quot;street&quot;"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                // unimplemented: // <assertNotNull actual="streetAttr" id="streetAttrNotNull"/>
                let r#state = r#street_attr.specified(); // <specified obj="streetAttr" var="state"/>
                assert!(!r#state); // <assertFalse actual="state" id="attrSpecifiedValueRemoveAssert"/>
            }
            // hc_nodereplacechildoldchildnonexistent.xml
            #[test]
            fn test_hc_nodereplacechildoldchildnonexistent() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#new_child = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="newChild"/>
                r#old_child = r#doc.create_element("b".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;b&quot;" var="oldChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <replaceChild var="replacedNode" obj="elementNode" newChild="newChild" oldChild="oldChild"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .replace_child(new_child.into(), old_child.into())
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // hc_attreffectivevalue.xml
            #[test]
            fn test_hc_attreffectivevalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;acronym&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;title&quot;"/>
                let r#value = r#domestic_attr.node_value().unwrap().to_string(); // <nodeValue obj="domesticAttr" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="attrEffectiveValueAssert" ignoreCase="false"/>
            }
            // hc_characterdatadeletedataend.xml
            #[test]
            fn test_hc_characterdatadeletedataend() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.delete_data(30, 5).unwrap(); // <deleteData obj="child" offset="30" count="5"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230 North Ave. Dallas, Texas "); // <assertEquals actual="childData" expected="&quot;1230 North Ave. Dallas, Texas &quot;" id="characterdataDeleteDataEndAssert" ignoreCase="false"/>
            }
            // nodecdatasectionnodeattribute.xml
            #[test]
            fn test_nodecdatasectionnodeattribute() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#cdata_name; // type: Element // <var name="cdataName" type="Element"/>
                let mut r#cdata_node; // type: Node // <var name="cdataNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;name&quot;"/>
                r#cdata_name = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="cdataName"/>
                r#cdata_node = r#cdata_name.last_child().unwrap(); // <lastChild interface="Node" obj="cdataName" var="cdataNode"/>
                let r#node_type = r#cdata_node.node_type(); // <nodeType var="nodeType" obj="cdataNode"/>
                // <if><notEquals actual="nodeType" expected="4" ignoreCase="false"/>
                //  <createCDATASection var="cdataNode" obj="doc" data="&quot;&quot;"/>
                // </if>
                if node_type as i32 == 4 {
                    cdata_node = doc.create_cdata_section("").unwrap().into();
                }
                let r#attr_list = r#cdata_node.attributes(); // <attributes obj="cdataNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="cdataSection"/>
            }
            // hc_namednodemapinuseattributeerr.xml
            #[test]
            fn test_hc_namednodemapinuseattributeerr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#first_node; // type: Element // <var name="firstNode" type="Element"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#domestic_attr; // type: Attr // <var name="domesticAttr" type="Attr"/>
                let mut r#set_attr; // type: Attr // <var name="setAttr" type="Attr"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                r#first_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="firstNode" index="0"/>
                r#domestic_attr = r#doc.create_attribute("title".to_string()).unwrap(); // <createAttribute obj="doc" var="domesticAttr" name="&quot;title&quot;"/>
                r#domestic_attr.set_value("Yα").unwrap(); // <value interface="Attr" obj="domesticAttr" value="&quot;Yα&quot;"/>
                r#set_attr = r#first_node
                    .set_attribute_node(r#domestic_attr.clone())
                    .unwrap()
                    .unwrap(); // <setAttributeNode var="setAttr" obj="firstNode" newAttr="domesticAttr"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="2"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                // <assertDOMException id="throw_INUSE_ATTRIBUTE_ERR">
                //  <INUSE_ATTRIBUTE_ERR>
                //      <setNamedItem var="setNode" interface="NamedNodeMap" obj="attributes" arg="domesticAttr"/>
                //  </INUSE_ATTRIBUTE_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .set_named_item(domestic_attr)
                        .is_err_and(|err| err == DOMException::InuseAttributeErr)
                );
            }
            // hc_namednodemapreturnnull.xml
            #[test]
            fn test_hc_namednodemapreturnnull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                let r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="1"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#district_node = r#attributes.get_named_item("lang"); // <getNamedItem obj="attributes" var="districtNode" name="&quot;lang&quot;"/>
                assert!(district_node.is_none()); // <assertNull actual="districtNode" id="langAttrNull"/>
            }
            // hc_documentcreateattribute.xml
            #[test]
            fn test_hc_documentcreateattribute() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#new_attr_node = r#doc.create_attribute("title".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttrNode" name="&quot;title&quot;"/>
                let r#attr_value = r#new_attr_node.node_value().unwrap().to_string(); // <nodeValue obj="newAttrNode" var="attrValue"/>
                assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" ignoreCase="false" id="value"/>
                let r#attr_name = r#new_attr_node.node_name().to_string(); // <nodeName obj="newAttrNode" var="attrName"/>
                assert_eq!(r#attr_name, "title"); // <assertEquals actual="attrName" expected="&quot;title&quot;" ignoreCase="auto" context="attribute" id="name"/>
                let r#attr_type = r#new_attr_node.node_type(); // <nodeType obj="newAttrNode" var="attrType"/>
                assert_eq!(r#attr_type as i32, 2); // <assertEquals actual="attrType" expected="2" ignoreCase="false" id="type"/>
            }
            // nodecommentnodeattributes.xml
            #[test]
            fn test_nodecommentnodeattributes() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#child_node; // type: Node // <var name="childNode" type="Node"/>
                let mut r#attr_list; // type: NamedNodeMap // <var name="attrList" type="NamedNodeMap"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#child_list = r#doc.child_nodes(); // <childNodes obj="doc" var="childList"/>
                // <for-each collection="childList" member="childNode">
                //  <nodeType var="nodeType" obj="childNode"/>
                //  <if><equals actual="nodeType" expected="8"/>
                //      <attributes obj="childNode" var="attrList"/>
                //      <assertNull actual="attrList" id="attributesNull"/>
                //  </if>
                // </for-each>
                for i in 0..child_list.length() {
                    child_node = child_list.item(i).unwrap();
                    node_type = child_node.node_type();
                    if node_type as i32 == 8 {
                        attr_list = child_node.attributes();
                        assert!(attr_list.is_none());
                    }
                }
                let r#child_node = r#doc.create_comment("This is a comment"); // <createComment var="childNode" obj="doc" data="&quot;This is a comment&quot;"/>
                r#attr_list = r#child_node.attributes(); // <attributes obj="childNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="createdAttributesNull"/>
            }
            // elementremoveattributenode.xml
            #[test]
            fn test_elementremoveattributenode() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                let r#street_attr = r#test_employee.get_attribute_node("street").unwrap(); // <getAttributeNode obj="testEmployee" var="streetAttr" name="&quot;street&quot;"/>
                let r#removed_attr = r#test_employee
                    .remove_attribute_node(r#street_attr)
                    .unwrap(); // <removeAttributeNode obj="testEmployee" var="removedAttr" oldAttr="streetAttr"/>
                let r#removed_value = r#removed_attr.value().to_string(); // <value interface="Attr" obj="removedAttr" var="removedValue"/>
                assert_eq!(r#removed_value, "No"); // <assertEquals actual="removedValue" expected="&quot;No&quot;" id="elementRemoveAttributeNodeAssert" ignoreCase="false"/>
            }
            // attrparentnodenull.xml
            #[test]
            fn test_attrparentnodenull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("domestic").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;domestic&quot;"/>
                let r#s = r#domestic_attr.parent_node(); // <parentNode interface="Node" obj="domesticAttr" var="s"/>
                assert!(s.is_none()); // <assertNull actual="s" id="attrParentNodeNullAssert"/>
            }
            // hc_namednodemapreturnattrnode.xml
            #[test]
            fn test_hc_namednodemapreturnattrnode() {
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                let r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="1"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#street_attr = r#attributes.get_named_item("class").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;class&quot;"/>
                // unimplemented: // <assertInstanceOf obj="streetAttr" type="Attr" id="typeAssert"/>
                r#attr_name = r#street_attr.node_name().to_string(); // <nodeName obj="streetAttr" var="attrName"/>
                assert_eq!(r#attr_name, "class"); // <assertEquals actual="attrName" expected="&quot;class&quot;" id="nodeName" ignoreCase="auto" context="attribute"/>
                r#attr_name = r#street_attr.name().to_string(); // <name obj="streetAttr" var="attrName" interface="Attr"/>
                assert_eq!(r#attr_name, "class"); // <assertEquals actual="attrName" expected="&quot;class&quot;" id="name" ignoreCase="auto" context="attribute"/>
            }
            // documentcreateprocessinginstruction.xml
            #[test]
            fn test_documentcreateprocessinginstruction() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#new_pi_node = r#doc
                    .create_processing_instruction("TESTPI", Some("This is a new PI node"))
                    .unwrap(); // <createProcessingInstruction obj="doc" var="newPINode" target="&quot;TESTPI&quot;" data="&quot;This is a new PI node&quot;"/>
                // unimplemented: // <assertNotNull actual="newPINode" id="createdPINotNull"/>
                let r#pi_name = r#new_pi_node.node_name().to_string(); // <nodeName obj="newPINode" var="piName"/>
                assert_eq!(r#pi_name, "TESTPI"); // <assertEquals actual="piName" expected="&quot;TESTPI&quot;" ignoreCase="false" id="name"/>
                let r#pi_value = r#new_pi_node.node_value().unwrap().to_string(); // <nodeValue obj="newPINode" var="piValue"/>
                assert_eq!(r#pi_value, "This is a new PI node"); // <assertEquals actual="piValue" expected="&quot;This is a new PI node&quot;" ignoreCase="false" id="value"/>
                let r#pi_type = r#new_pi_node.node_type(); // <nodeType obj="newPINode" var="piType"/>
                assert_eq!(r#pi_type as i32, 7); // <assertEquals actual="piType" expected="7" ignoreCase="false" id="type"/>
            }
            // entitygetpublicidnull.xml
            #[test]
            fn test_entitygetpublicidnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#entity_list = doc_type.entities(); // <entities obj="docType" var="entityList"/>
                // unimplemented: // <assertNotNull actual="entityList" id="entitiesNotNull"/>
                let r#entity_node = r#entity_list.get_named_item("ent1").unwrap(); // <getNamedItem obj="entityList" var="entityNode" name="&quot;ent1&quot;"/>
                let r#public_id = r#entity_node.public_id(); // <publicId interface="Entity" obj="entityNode" var="publicId"/>
                assert!(public_id.is_none()); // <assertNull actual="publicId" id="entityGetPublicIdNullAssert"/>
            }
            // nodechildnodes.xml
            #[test]
            fn test_nodechildnodes() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_nodes; // type: NodeList // <var name="childNodes" type="NodeList"/>
                let mut r#child_node; // type: Node // <var name="childNode" type="Node"/>
                let mut r#child_type; // type: int // <var name="childType" type="int"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#element_names = vec![]; // type: List // <var name="elementNames" type="List"/>
                let mut r#expected_element_names = vec![
                    "employeeId",
                    "name",
                    "position",
                    "salary",
                    "gender",
                    "address",
                ]; // type: List // <var name="expectedElementNames" type="List"><member>"employeeId"</member>  <member>"name"</member>  <member>"position"</member>  <member>"salary"</member>  <member>"gender"</member>  <member>"address"</member></var>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_nodes = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childNodes"/>
                // <for-each collection="childNodes" member="childNode">
                //  <nodeType var="childType" obj="childNode"/>
                //  <if><equals actual="childType" expected="1" ignoreCase="false"/>
                //      <nodeName var="childName" obj="childNode"/>
                //      <append collection="elementNames" item="childName"/>
                //  </if>
                // </for-each>
                for i in 0..child_nodes.length() {
                    child_node = child_nodes.item(i).unwrap();
                    child_type = child_node.node_type();
                    if child_type as i32 == 1 {
                        child_name = child_node.node_name().to_string();
                        element_names.push(child_name);
                    }
                }
                assert_eq!(r#element_names, expected_element_names); // <assertEquals actual="elementNames" expected="expectedElementNames" id="elementNames" ignoreCase="false"/>
            }
            // textwithnomarkup.xml
            #[test]
            fn test_textwithnomarkup() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;name&quot;"/>
                let r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                let r#node_v = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="nodeV"/>
                let r#value = r#node_v.node_value().unwrap().to_string(); // <nodeValue obj="nodeV" var="value"/>
                assert_eq!(r#value, "Roger\n Jones"); // <assertEquals actual="value" expected="&quot;Roger\n Jones&quot;" id="textNodeValue" ignoreCase="false"/>
            }
            // nodecdatasectionnodetype.xml
            #[test]
            fn test_nodecdatasectionnodetype() {
                // unimplemented: // <implementationAttribute name="coalescing" value="false"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_name; // type: Element // <var name="testName" type="Element"/>
                let mut r#cdata_node; // type: Node // <var name="cdataNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                r#test_name = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="testName"/>
                r#cdata_node = r#test_name.last_child().unwrap(); // <lastChild interface="Node" obj="testName" var="cdataNode"/>
                let r#node_type = r#cdata_node.node_type(); // <nodeType obj="cdataNode" var="nodeType"/>
                // <if><equals actual="nodeType" expected="3" ignoreCase="false"/>
                //  <createCDATASection var="cdataNode" obj="doc" data="&quot;&quot;"/>
                //  <nodeType obj="cdataNode" var="nodeType"/>
                // </if>
                if node_type as i32 == 3 {
                    cdata_node = doc.create_cdata_section("").unwrap().into();
                }
                assert_eq!(r#node_type as i32, 4); // <assertEquals actual="nodeType" expected="4" id="nodeTypeCDATA" ignoreCase="false"/>
            }
            // documentgetelementsbytagnamelength.xml
            #[test]
            fn test_documentgetelementsbytagnamelength() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#name_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="nameList" tagname="&quot;name&quot;"/>
                assert_eq!(name_list.length(), 5); // <assertSize collection="nameList" size="5" id="documentGetElementsByTagNameLengthAssert"/>
            }
            // hc_nodelistreturnfirstitem.xml
            #[test]
            fn test_hc_nodelistreturnfirstitem() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;p&quot;"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#child = r#employee_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="employeeList" var="child" index="0"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                // <if><equals actual="childName" expected="&quot;#text&quot;"/>
                //  <assertEquals actual="childName" expected="&quot;#text&quot;" ignoreCase="false" id="nodeName_w_space"/>
                // <else>
                //  <assertEquals actual="childName" expected="&quot;em&quot;" ignoreCase="auto" id="nodeName_wo_space"/>
                // </else>
                // </if>
                if child_name == "#text" {
                    assert_eq!(child_name, "#text");
                } else {
                    assert_eq!(child_name, "em");
                }
            }
            // nodedocumentnodevalue.xml
            #[test]
            fn test_nodedocumentnodevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#document_value = r#doc.node_value(); // <nodeValue obj="doc" var="documentValue"/>
                assert!(document_value.is_none()); // <assertNull actual="documentValue" id="documentNodeValueNull"/>
            }
            // characterdataindexsizeerrsubstringoffsetgreater.xml
            #[test]
            fn test_characterdataindexsizeerrsubstringoffsetgreater() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                let r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                // <assertDOMException id="throw_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <substringData var="badString" obj="child" offset="40" count="3"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
                assert!(
                    child
                        .substring_data(40, 3)
                        .is_err_and(|err| err == DOMException::IndexSizeErr)
                );
            }
            // hc_elementgetattributenode.xml
            #[test]
            fn test_hc_elementgetattributenode() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                let r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                let r#domestic_attr = r#test_employee.get_attribute_node("title").unwrap(); // <getAttributeNode obj="testEmployee" var="domesticAttr" name="&quot;title&quot;"/>
                let r#node_name = r#domestic_attr.node_name().to_string(); // <nodeName obj="domesticAttr" var="nodeName"/>
                assert_eq!(r#node_name, "title"); // <assertEquals actual="nodeName" expected="&quot;title&quot;" id="nodeName" ignoreCase="auto" context="attribute"/>
            }
            // hc_namednodemapreturnfirstitem.xml
            #[test]
            fn test_hc_namednodemapreturnfirstitem() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#html_expected; // type: Collection // <var name="htmlExpected" type="Collection">    <member>"title"</member>    <member>"class"</member></var>
                // let mut r#expected; // type: Collection // <var name="expected" type="Collection">    <member>"title"</member>    <member>"class"</member>    <member>"dir"</member></var>
                // let mut r#actual; // type: Collection // <var name="actual" type="Collection"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                // r#test_address = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="1"/>
                // r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>

                // // unimplemented: // <for-each collection="attributes" member="child"><nodeName obj="child" var="nodeName"/><append collection="actual" item="nodeName"/></for-each>

                // // unimplemented: // <if><contentType type="text/html"/><assertEquals id="attrName_html" actual="actual" expected="htmlExpected" ignoreCase="true"/><else><assertEquals id="attrName" actual="actual" expected="expected" ignoreCase="false"/></else></if>
            }
            // processinginstructiongetdata.xml
            #[test]
            fn test_processinginstructiongetdata() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#child_nodes = r#doc.child_nodes(); // <childNodes obj="doc" var="childNodes"/>
                let r#pi_node = r#child_nodes
                    .item(0)
                    .unwrap()
                    .clone()
                    .as_processing_instruction()
                    .unwrap(); // <item interface="NodeList" obj="childNodes" var="piNode" index="0"/>
                let r#data = r#pi_node.data().unwrap().to_string(); // <data interface="ProcessingInstruction" obj="piNode" var="data"/>
                assert_eq!(r#data, "PIDATA"); // <assertEquals actual="data" expected="&quot;PIDATA&quot;" id="processinginstructionGetTargetAssert" ignoreCase="false"/>
            }
            // characterdatareplacedatamiddle.xml
            #[test]
            fn test_characterdatareplacedatamiddle() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.replace_data(5, 5, "South").unwrap(); // <replaceData obj="child" offset="5" count="5" arg="&quot;South&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230 South Ave. Dallas, Texas 98551"); // <assertEquals actual="childData" expected="&quot;1230 South Ave. Dallas, Texas 98551&quot;" id="characterdataReplaceDataMiddleAssert" ignoreCase="false"/>
            }
            // nodegetlastchildnull.xml
            #[test]
            fn test_nodegetlastchildnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="employeeNode"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#second_child_node = r#employee_list.item(1).unwrap().clone(); // <item interface="NodeList" obj="employeeList" index="1" var="secondChildNode"/>
                let r#text_node = r#second_child_node.first_child().unwrap(); // <firstChild interface="Node" obj="secondChildNode" var="textNode"/>
                let r#no_child_node = r#text_node.last_child(); // <lastChild interface="Node" obj="textNode" var="noChildNode"/>
                assert!(no_child_node.is_none()); // <assertNull actual="noChildNode" id="nodeGetLastChildNullAssert1"/>
            }
            // hc_nodeparentnodenull.xml
            #[test]
            fn test_hc_nodeparentnodenull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#created_node = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="createdNode"/>
                let r#parent_node = r#created_node.parent_node(); // <parentNode interface="Node" obj="createdNode" var="parentNode"/>
                assert!(parent_node.is_none()); // <assertNull actual="parentNode" id="parentNode"/>
            }
            // nodechildnodesappendchild.xml
            #[test]
            fn test_nodechildnodesappendchild() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let mut r#expected_length; // type: int // <var name="expectedLength" type="int"/>
                let mut r#length; // type: int // <var name="length" type="int"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#expected_length = r#child_list.length(); // <length var="expectedLength" obj="childList" interface="NodeList"/>
                r#expected_length += 1; // <increment var="expectedLength" value="1"/>
                let r#created_node = r#doc.create_element("text3".to_string()).unwrap(); // <createElement obj="doc" var="createdNode" tagName="&quot;text3&quot;"/>
                r#employee_node = r#employee_node
                    .append_child(created_node.into())
                    .unwrap()
                    .as_element()
                    .unwrap(); // <appendChild obj="employeeNode" newChild="createdNode" var="employeeNode"/>
                r#length = r#child_list.length(); // <length var="length" obj="childList" interface="NodeList"/>
                assert_eq!(r#length, expected_length); // <assertEquals actual="length" expected="expectedLength" ignoreCase="false" id="childNodeLength"/>
            }
            // hc_nodeappendchildnodeancestor.xml
            #[test]
            fn test_hc_nodeappendchildnodeancestor() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#new_child = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="newChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <appendChild var="appendedChild" obj="employeeNode" newChild="newChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    employee_node
                        .append_child(new_child.into())
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // hc_nodegetlastchildnull.xml
            #[test]
            fn test_hc_nodegetlastchildnull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#em_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;em&quot;" var="emList"/>
                let r#em_node = r#em_list.item(0).unwrap(); // <item interface="NodeList" obj="emList" index="0" var="emNode"/>
                let r#em_text = r#em_node.first_child().unwrap(); // <firstChild var="emText" obj="emNode" interface="Node"/>
                let r#null_child = r#em_text.last_child(); // <lastChild var="nullChild" obj="emText" interface="Node"/>
                assert!(null_child.is_none()); // <assertNull actual="nullChild" id="nullChild"/>
            }
            // hc_domimplementationfeaturenull.xml
            #[test]
            fn test_hc_domimplementationfeaturenull() {
                // // unimplemented: // <implementationAttribute name="hasNullString" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <if><contentType type="text/html"/><hasFeature obj="domImpl" var="state" feature="&quot;HTML&quot;"/><assertTrue actual="state" id="supports_HTML_null"/><else><hasFeature obj="domImpl" var="state" feature="&quot;XML&quot;"/><assertTrue actual="state" id="supports_XML_null"/></else></if>
            }
            // characterdatasubstringvalue.xml
            #[test]
            fn test_characterdatasubstringvalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                let r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                let r#substring = child.substring_data(0, 8).unwrap(); // <substringData obj="child" var="substring" offset="0" count="8"/>
                assert_eq!(r#substring, "Margaret"); // <assertEquals actual="substring" expected="&quot;Margaret&quot;" id="characterdataSubStringValueAssert" ignoreCase="false"/>
            }
            // documentinvalidcharacterexceptioncreateentref1.xml
            #[test]
            fn test_documentinvalidcharacterexceptioncreateentref1() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#bad_entity_ref; // type: EntityReference // <var name="badEntityRef" type="EntityReference"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // // unimplemented: // <if><contentType type="text/html"/><assertDOMException id="throw_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><createEntityReference var="badEntityRef" obj="doc" name="&quot;foo&quot;"/></NOT_SUPPORTED_ERR></assertDOMException><else><assertDOMException id="throw_INVALID_CHARACTER_ERR"><INVALID_CHARACTER_ERR><createEntityReference var="badEntityRef" obj="doc" name="&quot;&quot;"/></INVALID_CHARACTER_ERR></assertDOMException></else></if>
            }
            // hc_attrinsertbefore3.xml
            #[test]
            fn test_hc_attrinsertbefore3() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let r#ter_node; // type: Text // <var name="terNode" type="Text"/>
                let r#day_node; // type: Text // <var name="dayNode" type="Text"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#ter_node = r#doc.create_text_node("ter"); // <createTextNode var="terNode" obj="doc" data="&quot;ter&quot;"/>
                r#day_node = r#doc.create_text_node("day"); // <createTextNode var="dayNode" obj="doc" data="&quot;day&quot;"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#retval = r#doc_frag.append_child(ter_node.into()).unwrap(); // <appendChild var="retval" obj="docFrag" newChild="terNode"/>
                r#retval = r#doc_frag.append_child(day_node.into()).unwrap(); // <appendChild var="retval" obj="docFrag" newChild="dayNode"/>
                r#retval = r#title_attr.insert_before(doc_frag.into(), None).unwrap(); // <insertBefore var="retval" obj="titleAttr" newChild="docFrag" refChild="refChild"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrNodeValue" ignoreCase="false"/>
                let r#value = r#retval.node_value(); // <nodeValue obj="retval" var="value"/>
                assert!(value.is_none()); // <assertNull actual="value" id="retvalValue"/>
                let r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                let mut r#value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="firstChildValue" ignoreCase="false"/>
                let r#last_child = r#title_attr.last_child().unwrap(); // <lastChild var="lastChild" obj="titleAttr" interface="Node"/>
                r#value = r#last_child.node_value().unwrap().to_string(); // <nodeValue obj="lastChild" var="value"/>
                assert_eq!(r#value, "day"); // <assertEquals actual="value" expected="&quot;day&quot;" id="lastChildValue" ignoreCase="false"/>
            }
            // hc_nodeinsertbeforerefchildnonexistent.xml
            #[test]
            fn test_hc_nodeinsertbeforerefchildnonexistent() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#new_child = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="newChild"/>
                r#ref_child = r#doc.create_element("b".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;b&quot;" var="refChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <insertBefore var="insertedNode" obj="elementNode" newChild="newChild" refChild="refChild"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .insert_before(new_child.into(), Some(ref_child.into()))
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // nodevalue09.xml
            #[test]
            fn test_nodevalue09() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                let mut r#new_value; // type: DOMString // <var name="newValue" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_node = r#doc
                    .create_processing_instruction("TARGET", Some("DATA"))
                    .unwrap(); // <createProcessingInstruction var="newNode" obj="doc" target="&quot;TARGET&quot;" data="&quot;DATA&quot;"/>
                r#new_value = r#new_node.node_value().unwrap().to_string(); // <nodeValue obj="newNode" var="newValue"/>
                assert_eq!(r#new_value, "DATA"); // <assertEquals actual="newValue" expected="&quot;DATA&quot;" ignoreCase="false" id="initial"/>
                r#new_node
                    .set_node_value("This should have an effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have an effect&quot;"/>
                r#new_value = r#new_node.node_value().unwrap().to_string(); // <nodeValue obj="newNode" var="newValue"/>
                assert_eq!(r#new_value, "This should have an effect"); // <assertEquals actual="newValue" expected="&quot;This should have an effect&quot;" ignoreCase="false" id="after"/>
            }
            // hc_nodevalue02.xml
            #[test]
            fn test_hc_nodevalue02() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                let mut r#new_value; // type: DOMString // <var name="newValue" type="DOMString"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#new_node = r#doc.create_comment("This is a new Comment node"); // <createComment obj="doc" var="newNode" data="&quot;This is a new Comment node&quot;"/>
                r#new_value = r#new_node.node_value().unwrap().to_string(); // <nodeValue obj="newNode" var="newValue"/>
                assert_eq!(r#new_value, "This is a new Comment node"); // <assertEquals actual="newValue" expected="&quot;This is a new Comment node&quot;" ignoreCase="false" id="initial"/>
                r#new_node
                    .set_node_value("This should have an effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have an effect&quot;"/>
                r#new_value = r#new_node.node_value().unwrap().to_string(); // <nodeValue obj="newNode" var="newValue"/>
                assert_eq!(r#new_value, "This should have an effect"); // <assertEquals actual="newValue" expected="&quot;This should have an effect&quot;" id="afterChange" ignoreCase="false"/>
            }
            // namednodemapreturnattrnode.xml
            #[test]
            fn test_namednodemapreturnattrnode() {
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="1"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                // unimplemented: // <assertInstanceOf obj="streetAttr" type="Attr" id="typeAssert"/>
                r#attr_name = r#street_attr.node_name().to_string(); // <nodeName obj="streetAttr" var="attrName"/>
                assert_eq!(r#attr_name, "street"); // <assertEquals actual="attrName" expected="&quot;street&quot;" id="nodeName" ignoreCase="false"/>
                r#attr_name = r#street_attr.name().to_string(); // <name obj="streetAttr" var="attrName" interface="Attr"/>
                assert_eq!(r#attr_name, "street"); // <assertEquals actual="attrName" expected="&quot;street&quot;" id="attrName" ignoreCase="false"/>
            }
            // documenttypegetdoctype.xml
            #[test]
            fn test_documenttypegetdoctype() {
                let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                r#name = r#doc_type.name().to_string(); // <name interface="DocumentType" obj="docType" var="name"/>

                // unimplemented: // <if><contentType type="image/svg+xml"/><assertEquals actual="name" expected="&quot;svg&quot;" id="doctypeName" ignoreCase="false"/><else><assertEquals actual="name" expected="&quot;staff&quot;" id="documenttypeGetDocTypeAssert" ignoreCase="false"/></else></if>
            }
            // hc_attrfirstchild.xml
            #[test]
            fn test_hc_attrfirstchild() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                let r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                let r#text_node = r#title_attr.first_child().unwrap(); // <firstChild var="textNode" obj="titleAttr" interface="Node"/>
                // unimplemented: // <assertNotNull actual="textNode" id="textNodeNotNull"/>
                let r#value = r#text_node.node_value().unwrap().to_string(); // <nodeValue var="value" obj="textNode"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="child1IsYes" ignoreCase="false"/>
                let r#other_child = r#text_node.next_sibling(); // <nextSibling var="otherChild" obj="textNode" interface="Node"/>
                assert!(other_child.is_none()); // <assertNull actual="otherChild" id="nextSiblingIsNull"/>
                let r#other_child = r#text_node.previous_sibling(); // <previousSibling var="otherChild" obj="textNode" interface="Node"/>
                assert!(other_child.is_none()); // <assertNull actual="otherChild" id="previousSiblingIsNull"/>
            }
            // namednodemapsetnameditemthatexists.xml
            #[test]
            fn test_namednodemapsetnameditemthatexists() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let r#district_node; // type: Attr // <var name="districtNode" type="Attr"/>
                let mut r#set_node; // type: Node // <var name="setNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="1"/>
                r#new_attribute = r#doc.create_attribute("street".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;street&quot;"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                r#set_node = r#attributes
                    .set_named_item(r#new_attribute)
                    .unwrap()
                    .unwrap(); // <setNamedItem var="setNode" obj="attributes" arg="newAttribute"/>
                r#district_node = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="districtNode" name="&quot;street&quot;"/>
                let r#attr_value = r#district_node.node_value().unwrap().to_string(); // <nodeValue obj="districtNode" var="attrValue"/>
                assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" id="streetValue" ignoreCase="false"/>
            }
            // hc_namednodemapnumberofnodes.xml
            #[test]
            fn test_hc_namednodemapnumberofnodes() {
                let mut r#length; // type: int // <var name="length" type="int"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                let r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="2"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                r#length = r#attributes.length(); // <length var="length" obj="attributes" interface="NamedNodeMap"/>

                // unimplemented: // <if><contentType type="text/html"/><assertEquals actual="length" expected="2" id="htmlLength" ignoreCase="false"/><else><assertEquals actual="length" expected="3" id="length" ignoreCase="false"/></else></if>
            }
            // attrentityreplacement.xml
            #[test]
            fn test_attrentityreplacement() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                let r#test_node = r#address_list.item(3).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="3"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                let r#value = r#street_attr.value().to_string(); // <value interface="Attr" obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="streetYes" ignoreCase="false"/>
            }
            // hc_nodeclonenodetrue.xml
            #[test]
            fn test_hc_nodeclonenodetrue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#cloned_node; // type: Node // <var name="clonedNode" type="Node"/>
                let r#cloned_list; // type: NodeList // <var name="clonedList" type="NodeList"/>
                let mut r#cloned_child; // type: Node // <var name="clonedChild" type="Node"/>
                let mut r#cloned_child_name; // type: DOMString // <var name="clonedChildName" type="DOMString"/>
                let r#orig_list; // type: NodeList // <var name="origList" type="NodeList"/>
                let mut r#orig_child; // type: Node // <var name="origChild" type="Node"/>
                let mut r#orig_child_name; // type: DOMString // <var name="origChildName" type="DOMString"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let mut r#expected = vec![]; // type: List // <var name="expected" type="List"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#orig_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="origList"/>
                // <for-each collection="origList" member="origChild">
                //  <nodeName obj="origChild" var="origChildName"/>
                //  <append collection="expected" item="origChildName"/>
                // </for-each>
                for i in 0..orig_list.length() {
                    orig_child = orig_list.item(i).unwrap();
                    orig_child_name = orig_child.node_name().to_string();
                    expected.push(orig_child_name);
                }
                r#cloned_node = r#employee_node.clone_node(true); // <cloneNode obj="employeeNode" deep="true" var="clonedNode"/>
                r#cloned_list = r#cloned_node.child_nodes(); // <childNodes obj="clonedNode" var="clonedList"/>
                // <for-each collection="clonedList" member="clonedChild">
                //  <nodeName obj="clonedChild" var="clonedChildName"/>
                //  <append collection="result" item="clonedChildName"/>
                // </for-each>
                for i in 0..cloned_list.length() {
                    cloned_child = cloned_list.item(i).unwrap();
                    cloned_child_name = cloned_child.node_name().to_string();
                    result.push(cloned_child_name);
                }
                assert_eq!(r#result, expected); // <assertEquals actual="result" expected="expected" id="clone" ignoreCase="false"/>
            }
            // hc_characterdataindexsizeerrdeletedataoffsetgreater.xml
            #[test]
            fn test_hc_characterdataindexsizeerrdeletedataoffsetgreater() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                // <assertDOMException id="throw_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <deleteData obj="child" offset="40" count="3"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
                assert!(
                    child
                        .delete_data(40, 3)
                        .is_err_and(|err| err == DOMException::IndexSizeErr)
                );
            }
            // elementgetattributenode.xml
            #[test]
            fn test_elementgetattributenode() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                let r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                let r#domestic_attr = r#test_employee.get_attribute_node("domestic").unwrap(); // <getAttributeNode obj="testEmployee" var="domesticAttr" name="&quot;domestic&quot;"/>
                let r#name = r#domestic_attr.node_name().to_string(); // <nodeName obj="domesticAttr" var="name"/>
                assert_eq!(r#name, "domestic"); // <assertEquals actual="name" expected="&quot;domestic&quot;" id="elementGetAttributeNodeAssert" ignoreCase="false"/>
            }
            // nodeappendchildnodeancestor.xml
            #[test]
            fn test_nodeappendchildnodeancestor() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_child = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="newChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <appendChild var="appendedChild" obj="employeeNode" newChild="newChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    employee_node
                        .append_child(new_child.into())
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // hc_nodelistindexequalzero.xml
            #[test]
            fn test_hc_nodelistindexequalzero() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;p&quot;"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#length = r#employee_list.length(); // <length var="length" obj="employeeList" interface="NodeList"/>
                let r#child = r#employee_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="employeeList" var="child" index="0"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                // <if><equals expected="13" actual="length" ignoreCase="false"/>
                //  <assertEquals actual="childName" expected="&quot;#text&quot;" ignoreCase="false" id="childName_w_whitespace"/>
                // <else>
                //  <assertEquals actual="childName" expected="&quot;em&quot;" ignoreCase="auto" id="childName_wo_whitespace"/>
                // </else>
                // </if>
                if length == 13 {
                    assert_eq!(child_name, "#text");
                } else {
                    assert_eq!(child_name, "em");
                }
            }
            // hc_nodecommentnodename.xml
            #[test]
            fn test_hc_nodecommentnodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#comment_node; // type: Node // <var name="commentNode" type="Node"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#comment_node_name; // type: DOMString // <var name="commentNodeName" type="DOMString"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#element_list = r#doc.child_nodes(); // <childNodes obj="doc" var="elementList"/>
                // <for-each collection="elementList" member="commentNode">
                //  <nodeType obj="commentNode" var="nodeType"/>
                //  <if><equals actual="nodeType" expected="8" ignoreCase="false"/>
                //      <nodeName obj="commentNode" var="commentNodeName"/>
                //      <assertEquals actual="commentNodeName" expected="&quot;#comment&quot;" id="existingNodeName" ignoreCase="false"/>
                //  </if>
                // </for-each>
                for i in 0..element_list.length() {
                    comment_node = element_list.item(i).unwrap();
                    node_type = comment_node.node_type();
                    if node_type as i32 == 8 {
                        comment_node_name = comment_node.node_name().to_string();
                        assert_eq!(comment_node_name, "#comment");
                    }
                }
                let r#comment_node = r#doc.create_comment("This is a comment"); // <createComment var="commentNode" obj="doc" data="&quot;This is a comment&quot;"/>
                r#comment_node_name = r#comment_node.node_name().to_string(); // <nodeName obj="commentNode" var="commentNodeName"/>
                assert_eq!(r#comment_node_name, "#comment"); // <assertEquals actual="commentNodeName" expected="&quot;#comment&quot;" id="createdNodeName" ignoreCase="false"/>
            }
            // hc_elementsetattributenodenull.xml
            #[test]
            fn test_hc_elementsetattributenodenull() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                let r#new_attribute = r#doc.create_attribute("lang".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;lang&quot;"/>
                let r#district_attr = r#test_employee.set_attribute_node(r#new_attribute).unwrap(); // <setAttributeNode obj="testEmployee" var="districtAttr" newAttr="newAttribute"/>
                assert!(district_attr.is_none()); // <assertNull actual="districtAttr" id="elementSetAttributeNodeNullAssert"/>
            }
            // nodeprocessinginstructionnodevalue.xml
            #[test]
            fn test_nodeprocessinginstructionnodevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#test_list = r#doc.child_nodes(); // <childNodes obj="doc" var="testList"/>
                let r#pi_node = r#test_list
                    .item(0)
                    .unwrap()
                    .clone()
                    .as_processing_instruction()
                    .unwrap(); // <item interface="NodeList" obj="testList" index="0" var="piNode"/>
                let r#pi_value = r#pi_node.node_value().unwrap().to_string(); // <nodeValue obj="piNode" var="piValue"/>
                assert_eq!(r#pi_value, "PIDATA"); // <assertEquals actual="piValue" expected="&quot;PIDATA&quot;" id="value" ignoreCase="false"/>
            }
            // nodeinsertbeforedocfragment.xml
            #[test]
            fn test_nodeinsertbeforedocfragment() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                let mut r#newdoc_fragment; // type: DocumentFragment // <var name="newdocFragment" type="DocumentFragment"/>
                let r#new_child1; // type: Node // <var name="newChild1" type="Node"/>
                let r#new_child2; // type: Node // <var name="newChild2" type="Node"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#inserted_node; // type: Node // <var name="insertedNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#ref_child = r#child_list.item(3).unwrap().clone(); // <item interface="NodeList" obj="childList" index="3" var="refChild"/>
                r#newdoc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="newdocFragment"/>
                r#new_child1 = r#doc.create_element("newChild1".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild1&quot;" var="newChild1"/>
                r#new_child2 = r#doc.create_element("newChild2".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild2&quot;" var="newChild2"/>
                r#appended_child = r#newdoc_fragment.append_child(new_child1.into()).unwrap(); // <appendChild var="appendedChild" obj="newdocFragment" newChild="newChild1"/>
                r#appended_child = r#newdoc_fragment.append_child(new_child2.into()).unwrap(); // <appendChild var="appendedChild" obj="newdocFragment" newChild="newChild2"/>
                r#inserted_node = r#employee_node
                    .insert_before(newdoc_fragment.into(), ref_child.into())
                    .unwrap(); // <insertBefore var="insertedNode" obj="employeeNode" newChild="newdocFragment" refChild="refChild"/>
                r#child = r#child_list.item(3).unwrap().clone(); // <item interface="NodeList" obj="childList" index="3" var="child"/>
                r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                assert_eq!(r#child_name, "newChild1"); // <assertEquals actual="childName" expected="&quot;newChild1&quot;" ignoreCase="false" id="childName3"/>
                r#child = r#child_list.item(4).unwrap().clone(); // <item interface="NodeList" obj="childList" index="4" var="child"/>
                r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                assert_eq!(r#child_name, "newChild2"); // <assertEquals actual="childName" expected="&quot;newChild2&quot;" ignoreCase="false" id="childName4"/>
            }
            // hc_nodelistreturnlastitem.xml
            #[test]
            fn test_hc_nodelistreturnlastitem() {
                let mut r#index; // type: int // <var name="index" type="int"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;p&quot;"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                r#index = r#employee_list.length(); // <length var="index" obj="employeeList" interface="NodeList"/>
                r#index -= 1; // <decrement var="index" value="1"/>
                let r#child = r#employee_list.item(index).unwrap().clone(); // <item interface="NodeList" obj="employeeList" var="child" index="index"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                // <if><equals actual="index" expected="12"/>
                //  <assertEquals actual="childName" expected="&quot;#text&quot;" id="lastNodeName_w_whitespace" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="childName" expected="&quot;acronym&quot;" id="lastNodeName" ignoreCase="auto"/>
                //  <assertEquals actual="index" expected="5" id="index" ignoreCase="false"/>
                // </else>
                // </if>
                if index == 12 {
                    assert_eq!(child_name, "#text");
                } else {
                    assert_eq!(child_name, "acronym");
                    assert_eq!(index, 5);
                }
            }
            // hc_nodereplacechild.xml
            #[test]
            fn test_hc_nodereplacechild() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#replaced_node; // type: Node // <var name="replacedNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#old_child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="oldChild"/>
                r#new_child = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="newChild"/>
                r#replaced_node = r#employee_node
                    .replace_child(new_child.into(), old_child)
                    .unwrap(); // <replaceChild var="replacedNode" obj="employeeNode" newChild="newChild" oldChild="oldChild"/>
                r#child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="child"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                assert_eq!(r#child_name, "br"); // <assertEquals actual="childName" expected="&quot;br&quot;" id="nodeName" ignoreCase="auto"/>
            }
            // characterdatadeletedatagetlengthanddata.xml
            #[test]
            fn test_characterdatadeletedatagetlengthanddata() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.delete_data(30, 5).unwrap(); // <deleteData obj="child" offset="30" count="5"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230 North Ave. Dallas, Texas "); // <assertEquals actual="childData" expected="&quot;1230 North Ave. Dallas, Texas &quot;" ignoreCase="false" id="data"/>
                let r#child_length = r#child.length(); // <length interface="CharacterData" obj="child" var="childLength"/>
                assert_eq!(r#child_length, 30); // <assertEquals actual="childLength" expected="30" ignoreCase="false" id="length"/>
            }
            // hc_nodeclonetruecopytext.xml
            #[test]
            fn test_hc_nodeclonetruecopytext() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("sup"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;sup&quot;" var="elementList"/>
                let r#child_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="childNode"/>
                let r#cloned_node = r#child_node.clone_node(true); // <cloneNode obj="childNode" deep="true" var="clonedNode"/>
                let r#last_child_node = r#cloned_node.last_child().unwrap(); // <lastChild interface="Node" obj="clonedNode" var="lastChildNode"/>
                let r#child_value = r#last_child_node.node_value().unwrap().to_string(); // <nodeValue obj="lastChildNode" var="childValue"/>
                assert_eq!(r#child_value, "35,000"); // <assertEquals actual="childValue" expected="&quot;35,000&quot;" id="cloneContainsText" ignoreCase="false"/>
            }
            // hc_nodegetprevioussibling.xml
            #[test]
            fn test_hc_nodegetprevioussibling() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="nameNode"/>
                let r#ps_node = r#name_node.previous_sibling().unwrap(); // <previousSibling interface="Node" obj="nameNode" var="psNode"/>
                let r#ps_name = r#ps_node.node_name().to_string(); // <nodeName obj="psNode" var="psName"/>
                assert_eq!(r#ps_name, "#text"); // <assertEquals actual="psName" expected="&quot;#text&quot;" id="whitespace" ignoreCase="false"/>
            }
            // hc_textsplittextone.xml
            #[test]
            fn test_hc_textsplittextone() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#split_node; // type: Text // <var name="splitNode" type="Text"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;strong&quot;"/>
                r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                r#text_node = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="textNode"/>
                r#split_node = r#text_node.split_text(7).unwrap(); // <splitText obj="textNode" var="splitNode" offset="7"/>
                let r#second_part = r#text_node.next_sibling().unwrap(); // <nextSibling interface="Node" obj="textNode" var="secondPart"/>
                let r#value = r#second_part.node_value().unwrap().to_string(); // <nodeValue obj="secondPart" var="value"/>
                assert_eq!(r#value, "Jones"); // <assertEquals actual="value" expected="&quot;Jones&quot;" id="textSplitTextOneAssert" ignoreCase="false"/>
            }
            // nodetextnodename.xml
            #[test]
            fn test_nodetextnodename() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#text_node = r#test_addr.first_child().unwrap(); // <firstChild interface="Node" obj="testAddr" var="textNode"/>
                let r#text_name = r#text_node.node_name().to_string(); // <nodeName obj="textNode" var="textName"/>
                assert_eq!(r#text_name, "#text"); // <assertEquals actual="textName" expected="&quot;#text&quot;" id="nodeTextNodeNameAssert1" ignoreCase="false"/>
            }
            // hc_nodereplacechildnewchilddiffdocument.xml
            #[test]
            fn test_hc_nodereplacechildnewchilddiffdocument() {
                let r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc1 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc1" href="hc_staff" willBeModified="false"/>
                r#doc2 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc2" href="hc_staff" willBeModified="true"/>
                r#new_child = r#doc1.create_element("br".to_string()).unwrap(); // <createElement obj="doc1" tagName="&quot;br&quot;" var="newChild"/>
                r#element_list = r#doc2.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc2" tagname="&quot;p&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                r#old_child = r#element_node.first_child().unwrap(); // <firstChild obj="elementNode" var="oldChild" interface="Node"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <replaceChild var="replacedChild" obj="elementNode" newChild="newChild" oldChild="oldChild"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .replace_child(new_child.into(), old_child)
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // hc_nodeelementnodeattributes.xml
            #[test]
            fn test_hc_nodeelementnodeattributes() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                // let mut r#addr_attr; // type: NamedNodeMap // <var name="addrAttr" type="NamedNodeMap"/>
                // let mut r#attr_node; // type: Node // <var name="attrNode" type="Node"/>
                // let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                // let mut r#attr_list; // type: Collection // <var name="attrList" type="Collection"/>
                // let mut r#html_expected; // type: Collection // <var name="htmlExpected" type="Collection"><member>"title"</member><member>"class"</member></var>
                // let mut r#expected; // type: Collection // <var name="expected" type="Collection"><member>"title"</member><member>"class"</member><member>"dir"</member></var>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                // r#test_addr = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testAddr"/>
                // r#addr_attr = r#test_addr.attributes(); // <attributes obj="testAddr" var="addrAttr"/>

                // // unimplemented: // <for-each collection="addrAttr" member="attrNode"><nodeName obj="attrNode" var="attrName"/><append collection="attrList" item="attrName"/></for-each>

                // // unimplemented: // <if><contentType type="text/html"/><assertEquals actual="attrList" expected="htmlExpected" id="attrNames_html" ignoreCase="true"/><else><assertEquals actual="attrList" expected="expected" id="attrNames" ignoreCase="false"/></else></if>
            }
            // entitygetentityname.xml
            #[test]
            fn test_entitygetentityname() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#entity_list = doc_type.entities(); // <entities obj="docType" var="entityList"/>
                // unimplemented: // <assertNotNull actual="entityList" id="entitiesNotNull"/>
                let r#entity_node = r#entity_list.get_named_item("ent1").unwrap(); // <getNamedItem obj="entityList" var="entityNode" name="&quot;ent1&quot;"/>
                let r#entity_name = r#entity_node.node_name().to_string(); // <nodeName obj="entityNode" var="entityName"/>
                assert_eq!(r#entity_name, "ent1"); // <assertEquals actual="entityName" expected="&quot;ent1&quot;" id="entityGetEntityNameAssert" ignoreCase="false"/>
            }
            // nodeappendchildgetnodename.xml
            #[test]
            fn test_nodeappendchildgetnodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#new_child = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="newChild"/>
                let r#append_node = r#employee_node.append_child(new_child.into()).unwrap(); // <appendChild obj="employeeNode" newChild="newChild" var="appendNode"/>
                let r#child_name = r#append_node.node_name().to_string(); // <nodeName obj="appendNode" var="childName"/>
                assert_eq!(r#child_name, "newChild"); // <assertEquals actual="childName" expected="&quot;newChild&quot;" id="nodeAppendChildGetNodeNameAssert1" ignoreCase="false"/>
            }
            // hc_nodeappendchildinvalidnodetype.xml
            #[test]
            fn test_hc_nodeappendchildinvalidnodetype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Element // <var name="rootNode" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                let r#new_child = r#doc.create_attribute("newAttribute".to_string()).unwrap(); // <createAttribute obj="doc" name="&quot;newAttribute&quot;" var="newChild"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <appendChild var="appendedChild" obj="rootNode" newChild="newChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    root_node
                        .append_child(new_child.into())
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // hc_nodeinsertbeforenodename.xml
            #[test]
            fn test_hc_nodeinsertbeforenodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#ref_child = r#child_list.item(3).unwrap().clone(); // <item interface="NodeList" obj="childList" index="3" var="refChild"/>
                let r#new_child = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="newChild"/>
                let r#inserted_node = r#employee_node
                    .insert_before(new_child.into(), Some(ref_child))
                    .unwrap(); // <insertBefore obj="employeeNode" newChild="newChild" refChild="refChild" var="insertedNode"/>
                let r#child_name = r#inserted_node.node_name().to_string(); // <nodeName obj="insertedNode" var="childName"/>
                assert_eq!(r#child_name, "br"); // <assertEquals actual="childName" expected="&quot;br&quot;" id="nodeName" ignoreCase="auto"/>
            }
            // hc_characterdatareplacedataexceedslengthofarg.xml
            #[test]
            fn test_hc_characterdatareplacedataexceedslengthofarg() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.replace_data(0, 4, "260030").unwrap(); // <replaceData obj="child" offset="0" count="4" arg="&quot;260030&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "260030 North Ave. Dallas, Texas 98551"); // <assertEquals actual="childData" expected="&quot;260030 North Ave. Dallas, Texas 98551&quot;" id="characterdataReplaceDataExceedsLengthOfArgAssert" ignoreCase="false"/>
            }
            // domimplementationfeaturexml.xml
            #[test]
            fn test_domimplementationfeaturexml() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                let r#state = dom_impl.has_feature("xml", Some("1.0")); // <hasFeature obj="domImpl" var="state" feature="&quot;xml&quot;" version="&quot;1.0&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="hasXML1"/>
            }
            // elementremoveattribute.xml
            #[test]
            fn test_elementremoveattribute() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(3).unwrap(); // <item interface="NodeList" obj="elementList" index="3" var="testEmployee"/>
                r#test_employee.remove_attribute("street").unwrap(); // <removeAttribute obj="testEmployee" name="&quot;street&quot;"/>
                let r#attr_value = r#test_employee.get_attribute("street"); // <getAttribute obj="testEmployee" var="attrValue" name="&quot;street&quot;"/>
                assert_eq!(r#attr_value, "Yes"); // <assertEquals actual="attrValue" expected="&quot;Yes&quot;" id="streetYes" ignoreCase="false"/>
            }
            // nodedocumentfragmentnodename.xml
            #[test]
            fn test_nodedocumentfragmentnodename() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="docFragment"/>
                let r#document_fragment_name = r#doc_fragment.node_name().to_string(); // <nodeName obj="docFragment" var="documentFragmentName"/>
                assert_eq!(r#document_fragment_name, "#document-fragment"); // <assertEquals actual="documentFragmentName" expected="&quot;#document-fragment&quot;" id="nodeDocumentFragmentNodeNameAssert1" ignoreCase="false"/>
            }
            // hc_characterdatareplacedatabegining.xml
            #[test]
            fn test_hc_characterdatareplacedatabegining() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.replace_data(0, 4, "2500").unwrap(); // <replaceData obj="child" offset="0" count="4" arg="&quot;2500&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "2500 North Ave. Dallas, Texas 98551"); // <assertEquals actual="childData" expected="&quot;2500 North Ave. Dallas, Texas 98551&quot;" id="characterdataReplaceDataBeginingAssert" ignoreCase="false"/>
            }
        }
    }
    mod level2 {
        use super::*;
        mod core {
            use exml::dom::{
                dom_implementation::DOM_IMPLEMENTATION_REGISTRY, named_node_map::NamedNodeMap,
                node_list::NodeList, notation::NotationIdentifier,
            };

            use super::*;

            const STAFF_XML: &str = "resources/DOM-Test-Suite/tests/level2/core/files/staff.xml";
            const STAFF_NS_XML: &str =
                "resources/DOM-Test-Suite/tests/level2/core/files/staffNS.xml";
            const HC_STAFF_XML: &str =
                "resources/DOM-Test-Suite/tests/level2/core/files/hc_staff.xml";

            #[rustfmt::skip]
            fn staff_xml(_doc: &str) -> Result<DocumentRef, DOMException> {
                let doctype = DocumentTypeRef::new("staff", None, Some("staff.dtd")).unwrap();
                let mut doc = DocumentRef::new(None, Some("staff"), Some(doctype)).unwrap();

                let mut doctype = doc.doctype().unwrap();
                // Internal Subset
                let mut ent = doctype.create_entity("ent1", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("es").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent2", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("1900 Dallas Road").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent3", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("Texas").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent4", EntityType::InternalGeneralEntity).unwrap();
                let mut ent_element = doc.create_element("entElement").unwrap();
                ent_element.set_attribute("domestic", "Yes").unwrap();
                ent_element.append_child(doc.create_text_node("Element data").into()).unwrap();
                ent.append_child(ent_element.into()).unwrap();
                ent.append_child(doc.create_processing_instruction("PItarget", Some("PIdata")).unwrap().into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent5", EntityType::ExternalGeneralUnparsedEntity).unwrap();
                ent.set_public_id(Some("entityURI"));
                ent.set_system_id(Some("entityFile"));
                ent.set_notation_name(Some("notation1"));
                doctype.add_entity::<false>(ent).unwrap();
                assert!(doctype.add_entity::<false>(doctype.create_entity("ent1", EntityType::InternalGeneralEntity).unwrap()).is_err());
                doctype.add_notation::<false>(doctype.create_notation("notation1",NotationIdentifier::PublicID { public_id: "notation1File".into() }).unwrap()).unwrap();
                doctype.add_notation::<false>(doctype.create_notation("notation2",NotationIdentifier::ExternalID { public_id: None, system_id: "notation2File".into() }).unwrap(),).unwrap();
                // External Subset
                doctype.add_element_decl::<true>(doctype.create_element_decl("employeeId",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("name",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("position",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("salary",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("address",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("entElement",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                let mut or = ElementContent::new_or(ElementContentOccur::Mult);
                or.set_first_child(Some(ElementContent::new_pcdata(ElementContentOccur::Once)));
                or.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"entElement")));
                doctype.add_element_decl::<true>(doctype.create_element_decl("gender", ContentSpec::Mixed(or)).unwrap()).unwrap();
                let mut seq1 = ElementContent::new_seq(ElementContentOccur::Once);
                seq1.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"employeeId")));
                let mut seq2 = ElementContent::new_seq(ElementContentOccur::Once);
                seq2.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"name")));
                let mut seq3 = ElementContent::new_seq(ElementContentOccur::Once);
                seq3.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"position")));
                let mut seq4 = ElementContent::new_seq(ElementContentOccur::Once);
                seq4.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"salary")));
                let mut seq5 = ElementContent::new_seq(ElementContentOccur::Once);
                seq5.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"gender")));
                seq5.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"address")));
                seq4.set_second_child(Some(seq5));
                seq3.set_second_child(Some(seq4));
                seq2.set_second_child(Some(seq3));
                seq1.set_second_child(Some(seq2));
                doctype.add_element_decl::<true>(doctype.create_element_decl("employee", ContentSpec::Children(seq1)).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("staff",ContentSpec::Children(ElementContent::new_element(ElementContentOccur::Plus,"employee"))).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("entElement","attr1",AttType::CDATA,DefaultDecl::None("Attr".into())).unwrap(),).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("address","domestic",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("address","street",AttType::CDATA,DefaultDecl::None("Yes".into())).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("entElement","domestic",AttType::CDATA,DefaultDecl::None("MALE".into())).unwrap()).unwrap();

                doc.insert_before(doc.create_processing_instruction("TEST-STYLE", Some("PIDATA")).unwrap().into(),Some(doctype.into())).unwrap();

                let mut root = doc.document_element().unwrap();
                assert!(root.parent_node().is_some());
                let comment = doc.create_comment(" This is comment number 1.").into();
                doc.insert_before(comment, Some(root.clone().into())).unwrap();

                let mut employee = root.append_child(doc.create_element("employee").unwrap().into()).unwrap();
                let mut employee_id = employee.append_child(doc.create_element("employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0001").into()).unwrap();
                let mut name = employee.append_child(doc.create_element("name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Margaret Martin").into()).unwrap();
                let mut position = employee.append_child(doc.create_element("position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Accountant").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element("salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("56,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element("gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("Female").into()).unwrap();
                let mut address = employee.append_child(doc.create_element("address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("1230 North Ave. Dallas, Texas 98551").into())?;
                address.set_attribute("domestic", "Yes").unwrap();

                let mut employee = root.append_child(doc.create_element("employee").unwrap().into()).unwrap();
                let mut employee_id = employee.append_child(doc.create_element("employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0002").into()).unwrap();
                let mut name = employee.append_child(doc.create_element("name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Martha Raynolds").into()).unwrap();
                name.append_child(doc.create_cdata_section("This is a CDATASection with EntityReference number 2 &ent2;").unwrap().into())?;
                name.append_child(doc.create_text_node("\n").into()).unwrap();
                name.append_child(doc.create_cdata_section("This is an adjacent CDATASection with a reference to a tab &tab;").unwrap().into())?;
                let mut position = employee.append_child(doc.create_element("position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Secretary").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element("salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("35,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element("gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("Female").into()).unwrap();
                let mut address = employee.append_child(doc.create_element("address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_entity_reference("ent2").unwrap().into()).unwrap();
                address.append_child(doc.create_text_node(" Dallas, ").into()).unwrap();
                address.append_child(doc.create_entity_reference("ent3").unwrap().into()).unwrap();
                address.append_child(doc.create_text_node("\n 98554").into()).unwrap();
                address.set_attribute("domestic", "Yes").unwrap();
                address.set_attribute("street", "Yes").unwrap();

                let mut employee = root.append_child(doc.create_element("employee").unwrap().into()).unwrap();
                let mut employee_id = employee.append_child(doc.create_element("employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0003").into()).unwrap();
                let mut name = employee.append_child(doc.create_element("name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Roger\n Jones").into()).unwrap();
                let mut position = employee.append_child(doc.create_element("position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Department Manager").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element("salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("100,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element("gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_entity_reference("ent4").unwrap().into()).unwrap();
                let mut address = employee.append_child(doc.create_element("address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("PO Box 27 Irving, texas 98553").into()).unwrap();
                address.set_attribute("domestic", "Yes").unwrap();
                address.set_attribute("street", "No").unwrap();

                let mut employee = root.append_child(doc.create_element("employee").unwrap().into()).unwrap();
                let mut employee_id = employee.append_child(doc.create_element("employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0004").into()).unwrap();
                let mut name = employee.append_child(doc.create_element("name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Jeny Oconnor").into()).unwrap();
                let mut position = employee.append_child(doc.create_element("position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Personnel Director").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element("salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("95,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element("gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("Female").into()).unwrap();
                let mut address = employee.append_child(doc.create_element("address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("PO Box 27 Irving, texas 98553").into()).unwrap();
                address.set_attribute("domestic", "Yes")?;
                address.set_attribute("street", "Y")?;
                let mut street = address.get_attribute_node("street").unwrap();
                street.append_child(doc.create_entity_reference("ent1").unwrap().into()).unwrap();

                let mut employee = root.append_child(doc.create_element("employee").unwrap().into()).unwrap();
                let mut employee_id = employee.append_child(doc.create_element("employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0005").into()).unwrap();
                let mut name = employee.append_child(doc.create_element("name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Robert Myers").into()).unwrap();
                let mut position = employee.append_child(doc.create_element("position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Computer Specialist").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element("salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("90,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element("gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("male").into()).unwrap();
                let mut address = employee.append_child(doc.create_element("address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("1821 Nordic. Road, Irving Texas 98558").into())?;
                address.set_attribute("street", "Yes").unwrap();

                doc.enable_read_only_check();
                Ok(doc)
                // Ok(load_xml::<false>(doc))
            }
            #[rustfmt::skip]
            fn staff_ns_xml(_doc: &str) -> Result<DocumentRef, DOMException> {
                let doctype = DocumentTypeRef::new("staff", Some("STAFF"), Some("staffNS.dtd")).unwrap();
                let mut doc = DocumentRef::new(None, Some("staff"), Some(doctype)).unwrap();

                let mut doctype = doc.doctype().unwrap();
                // Internal Subset
                let mut ent = doctype.create_entity("ent1", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("es").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent2", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("1900 Dallas Road").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent3", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("Texas").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent4", EntityType::InternalGeneralEntity).unwrap();
                let mut ent_element = doc.create_element("entElement1").unwrap();
                ent_element.set_attribute_ns(Some(XML_NS_NAMESPACE), "xmlns:local1", "www.xyz.com").unwrap();
                ent_element.append_child(doc.create_text_node("Element data").into()).unwrap();
                ent.append_child(ent_element.into()).unwrap();
                ent.append_child(doc.create_processing_instruction("PItarget", Some("PIdata")).unwrap().into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent5", EntityType::ExternalGeneralUnparsedEntity).unwrap();
                ent.set_public_id(Some("entityURI"));
                ent.set_system_id(Some("entityFile"));
                ent.set_notation_name(Some("notation1"));
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent6", EntityType::ExternalGeneralUnparsedEntity).unwrap();
                ent.set_public_id(Some("uri"));
                ent.set_system_id(Some("file"));
                ent.set_notation_name(Some("notation2"));
                doctype.add_entity::<false>(ent).unwrap();
                assert!(doctype.add_entity::<false>(doctype.create_entity("ent1", EntityType::InternalGeneralEntity).unwrap()).is_err());
                doctype.add_notation::<false>(doctype.create_notation("notation1",NotationIdentifier::PublicID { public_id: "notation1File".into() }).unwrap()).unwrap();
                doctype.add_notation::<false>(doctype.create_notation("notation2",NotationIdentifier::ExternalID { public_id: None, system_id: "notation2File".into() }).unwrap(),).unwrap();
                // External Subset
                // <!ELEMENT staff (employee+,emp:employee,employee) >
                let mut seq1 = ElementContent::new_seq(ElementContentOccur::Once);
                seq1.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Plus, "employee")));
                let mut seq2 = ElementContent::new_seq(ElementContentOccur::Once);
                seq2.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once, "emp:employee")));
                seq2.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once, "employee")));
                seq1.set_second_child(Some(seq2));
                doctype.add_element_decl::<true>(doctype.create_element_decl("staff",ContentSpec::Children(seq1)).unwrap()).unwrap();
                // <!ELEMENT employee (employeeId,name,position,salary,gender,address) >
                let mut seq1 = ElementContent::new_seq(ElementContentOccur::Once);
                seq1.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"employeeId")));
                let mut seq2 = ElementContent::new_seq(ElementContentOccur::Once);
                seq2.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"name")));
                let mut seq3 = ElementContent::new_seq(ElementContentOccur::Once);
                seq3.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"position")));
                let mut seq4 = ElementContent::new_seq(ElementContentOccur::Once);
                seq4.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"salary")));
                let mut seq5 = ElementContent::new_seq(ElementContentOccur::Once);
                seq5.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"gender")));
                seq5.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"address")));
                seq4.set_second_child(Some(seq5));
                seq3.set_second_child(Some(seq4));
                seq2.set_second_child(Some(seq3));
                seq1.set_second_child(Some(seq2));
                doctype.add_element_decl::<true>(doctype.create_element_decl("employee", ContentSpec::Children(seq1)).unwrap()).unwrap();
                // <!ATTLIST employee xmlns CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("employee", "xmlns", AttType::CDATA, DefaultDecl::Implied).unwrap()).unwrap();
                // <!ATTLIST employee xmlns:dmstc CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("employee", "xmlns:dmstc", AttType::CDATA, DefaultDecl::Implied).unwrap()).unwrap();
                // <!ATTLIST employee xmlns:emp2 CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("employee", "xmlns:emp2", AttType::CDATA, DefaultDecl::Implied).unwrap()).unwrap();
                // <!ELEMENT employeeId (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("employeeId",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ELEMENT name (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("name",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ELEMENT position (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("position",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ELEMENT salary (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("salary",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ELEMENT entElement1 (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("entElement1",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ELEMENT gender (#PCDATA | entElement1)* >
                let mut or = ElementContent::new_or(ElementContentOccur::Mult);
                or.set_first_child(Some(ElementContent::new_pcdata(ElementContentOccur::Once)));
                or.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"entElement")));
                doctype.add_element_decl::<true>(doctype.create_element_decl("gender", ContentSpec::Mixed(or)).unwrap()).unwrap();
                // <!ELEMENT address (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("address",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ATTLIST address dmstc:domestic CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("address","dmstc:domestic",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                // <!ATTLIST address street CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("address","street",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                // <!ATTLIST address domestic CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("address","domestic",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                // <!ATTLIST address xmlns CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("address","xmlns",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                // <!ELEMENT emp:employee (emp:employeeId,nm:name,emp:position,emp:salary,emp:gender,emp:address) >
                let mut seq1 = ElementContent::new_seq(ElementContentOccur::Once);
                seq1.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once, "emp:employeeId")));
                let mut seq2 = ElementContent::new_seq(ElementContentOccur::Once);
                seq2.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once, "emp:position")));
                let mut seq3 = ElementContent::new_seq(ElementContentOccur::Once);
                seq3.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once, "emp:salary")));
                let mut seq4 = ElementContent::new_seq(ElementContentOccur::Once);
                seq4.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once, "emp:gender")));
                seq4.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once, "emp:address")));
                seq3.set_second_child(Some(seq4));
                seq2.set_second_child(Some(seq3));
                seq1.set_second_child(Some(seq2));
                doctype.add_element_decl::<true>(doctype.create_element_decl("emp:employee",ContentSpec::Children(seq1)).unwrap()).unwrap();
                // <!ATTLIST emp:employee xmlns:emp CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("emp:employee","xmlns:emp",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                // <!ATTLIST emp:employee xmlns:nm CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("emp:employee","xmlns:ns",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                // <!ATTLIST emp:employee defaultAttr CDATA 'defaultVal'>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("emp:employee","defaultAttr",AttType::CDATA,DefaultDecl::None("defaultVal".into())).unwrap()).unwrap();
                // <!ELEMENT emp:employeeId (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("emp:employeeId",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ELEMENT nm:name (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("nm:name",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ELEMENT emp:position (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("emp:position",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ELEMENT emp:salary (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("emp:salary",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ELEMENT emp:gender (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("emp:gender",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ELEMENT emp:address (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("emp:address",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ATTLIST emp:address emp:domestic CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("emp:address","emp:domestic",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                // <!ATTLIST emp:address street CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("emp:address","street",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                // <!ATTLIST emp:address emp:zone ID #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("emp:address","emp:zone",AttType::ID,DefaultDecl::Implied).unwrap()).unwrap();
                // <!ATTLIST emp:address emp:district CDATA 'DISTRICT'>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("emp:address","emp:district",AttType::CDATA,DefaultDecl::None("DISTRICT".into())).unwrap()).unwrap();
                // <!ATTLIST emp:address emp:local1 CDATA 'FALSE'>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("emp:address","emp:local1",AttType::CDATA,DefaultDecl::None("FALSE".into())).unwrap()).unwrap();

                doc.insert_before(doc.create_processing_instruction("TEST-STYLE", Some("PIDATA")).unwrap().into(),Some(doctype.into())).unwrap();

                let mut root = doc.document_element().unwrap();
                assert!(root.parent_node().is_some());
                let comment = doc.create_comment(" This is comment number 1.").into();
                doc.insert_before(comment, Some(root.clone().into())).unwrap();

                let mut employee = root.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "employee").unwrap().into()).unwrap().as_element().unwrap();
                employee.set_attribute_ns(Some(XML_NS_NAMESPACE), "xmlns", "http://www.nist.gov").unwrap();
                employee.set_attribute_ns(Some(XML_NS_NAMESPACE), "xmlns:dmstc", "http://www.usa.com").unwrap();
                let mut employee_id = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0001").into()).unwrap();
                let mut name = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Margaret Martin").into()).unwrap();
                let mut position = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Accountant").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("56,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("Female").into()).unwrap();
                let mut address = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("1230 North Ave. Dallas, Texas 98551").into())?;
                address.set_attribute_ns(Some("http://www.usa.com"), "dmstc:domestic", "Yes").unwrap();

                let mut employee = root.append_child(doc.create_element_ns(None, "employee").unwrap().into()).unwrap().as_element().unwrap();
                employee.set_attribute_ns(Some(XML_NS_NAMESPACE), "xmlns:dmstc", "http://www.usa.com").unwrap();
                let mut employee_id = employee.append_child(doc.create_element_ns(None, "employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0002").into()).unwrap();
                let mut name = employee.append_child(doc.create_element_ns(None, "name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Martha Raynolds").into()).unwrap();
                name.append_child(doc.create_cdata_section("This is a CDATASection with EntityReference number 2 &ent2;").unwrap().into())?;
                name.append_child(doc.create_text_node("\n").into()).unwrap();
                name.append_child(doc.create_cdata_section("This is an adjacent CDATASection with a reference to a tab &tab;").unwrap().into())?;
                let mut position = employee.append_child(doc.create_element_ns(None, "position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Secretary").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element_ns(None, "salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("35,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element_ns(None, "gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("Female").into()).unwrap();
                let mut address = employee.append_child(doc.create_element_ns(None, "address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_entity_reference("ent2").unwrap().into()).unwrap();
                address.append_child(doc.create_text_node(" Dallas, ").into()).unwrap();
                address.append_child(doc.create_entity_reference("ent3").unwrap().into()).unwrap();
                address.append_child(doc.create_text_node("\n 98554").into()).unwrap();
                address.set_attribute_ns(Some("http://www.usa.com"), "dmstc:domestic", "Yes").unwrap();
                address.set_attribute_ns(None, "street", "Yes").unwrap();

                let mut employee = root.append_child(doc.create_element_ns(None, "employee").unwrap().into()).unwrap().as_element().unwrap();
                employee.set_attribute_ns(Some(XML_NS_NAMESPACE), "xmlns:dmstc", "http://www.netzero.com");
                let mut employee_id = employee.append_child(doc.create_element_ns(None, "employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0003").into()).unwrap();
                let mut name = employee.append_child(doc.create_element_ns(None, "name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Roger\n Jones").into()).unwrap();
                let mut position = employee.append_child(doc.create_element_ns(None, "position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Department Manager").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element_ns(None, "salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("100,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element_ns(None, "gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_entity_reference("ent4").unwrap().into()).unwrap();
                let mut address = employee.append_child(doc.create_element_ns(None, "address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("PO Box 27 Irving, texas 98553").into()).unwrap();
                address.set_attribute_ns(Some("http://www.netzero.com"), "dmstc:domestic", "Yes").unwrap();
                address.set_attribute("street", "No").unwrap();

                let mut employee = root.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "emp:employee").unwrap().into()).unwrap().as_element().unwrap();
                employee.set_attribute_ns(Some(XML_NS_NAMESPACE), "xmlns:emp", "http://www.nist.gov").unwrap();
                employee.set_attribute_ns(Some(XML_NS_NAMESPACE), "xmlns:nm", "http://www.altavista.com").unwrap();
                let mut employee_id = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "emp:employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0004").into()).unwrap();
                let mut name = employee.append_child(doc.create_element_ns(Some("http://www.altavista.com"), "nm:name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Jeny Oconnor").into()).unwrap();
                let mut position = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "emp:position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Personnel Director").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "emp:salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("95,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "emp:gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("Female").into()).unwrap();
                let mut address = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "emp:address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("27 South Road. Dallas, texas 98556").into()).unwrap();
                address.set_attribute_ns(Some("http://www.nist.gov"), "emp:domestic", "Yes").unwrap();
                address.set_attribute("street", "Y").unwrap();
                let mut street = address.get_attribute_node("street").unwrap();
                street.append_child(doc.create_entity_reference("ent1").unwrap().into()).unwrap();
                address.set_attribute_ns(Some("http://www.nist.gov"), "emp:zone", "CANADA").unwrap();
                address.set_attribute_ns(Some("http://www.nist.gov"), "emp:local1", "TRUE").unwrap();

                let mut employee = root.append_child(doc.create_element_ns(None, "employee").unwrap().into()).unwrap().as_element().unwrap();
                employee.set_attribute_ns(Some(XML_NS_NAMESPACE), "xmlns:emp2", "http://www.nist.gov").unwrap();
                let mut employee_id = employee.append_child(doc.create_element_ns(None, "employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0005").into()).unwrap();
                let mut name = employee.append_child(doc.create_element_ns(None, "name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Robert Myers").into()).unwrap();
                let mut position = employee.append_child(doc.create_element_ns(None, "position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Computer Specialist").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element_ns(None, "salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("90,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element_ns(None, "gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("male").into()).unwrap();
                let mut address = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("1821 Nordic. Road, Irving Texas 98558").into())?;
                address.set_attribute("street", "Yes").unwrap();
                address.set_attribute_ns(Some(XML_NS_NAMESPACE), "xmlns", "http://www.nist.gov").unwrap();

                doc.enable_read_only_check();
                Ok(doc)
                // Ok(load_xml::<false>(doc))
            }
            #[rustfmt::skip]
            fn hc_staff_xml(_doc: &str) -> Result<DocumentRef, DOMException> {
                let doctype = DocumentTypeRef::new("html",Some("-//W3C//DTD HTML 4.01//EN"),Some("http://www.w3.org/TR/html4/strict.dtd")).unwrap();
                let mut doc = DocumentRef::new(None, Some("html"), Some(doctype)).unwrap();
                let mut doctype = doc.doctype().unwrap();

                let mut ent = doctype.create_entity("alpha", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B1}").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("beta", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B2}").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("gamma", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B3}").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("delta", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B4}").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("epsilon", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B5}").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("alpha", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B6}").into()).unwrap();
                assert!(doctype.add_entity::<false>(ent).is_err());
                doctype.add_notation::<false>(doctype.create_notation("notation1",NotationIdentifier::PublicID { public_id: "notation1File".into() }).unwrap()).unwrap();
                doctype.add_notation::<false>(doctype.create_notation("notation2",NotationIdentifier::ExternalID { public_id: None, system_id: "notation2File".into() }).unwrap()).unwrap();

                // TODO: add external subset
                let mut seq = ElementContent::new_seq(ElementContentOccur::Once);
                seq.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"head")));
                seq.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"body")));
                doctype.add_element_decl::<true>(doctype.create_element_decl("html", ContentSpec::Children(seq)).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("html","xmlns",AttType::CDATA,DefaultDecl::Implied,).unwrap()).unwrap();
                let mut seq = ElementContent::new_seq(ElementContentOccur::Once);
                seq.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"meta")));
                let seq2 = ElementContent::new_seq(ElementContentOccur::Once);
                seq.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"title")));
                seq.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Mult,"script")));
                seq.set_second_child(Some(seq2));
                doctype.add_element_decl::<true>(doctype.create_element_decl("head", ContentSpec::Children(seq)).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("meta", ContentSpec::Empty).unwrap()).unwrap();
                doctype.create_attlist_decl("meta", "http-equiv", AttType::CDATA, DefaultDecl::Implied).unwrap();
                doctype.create_attlist_decl("meta", "content", AttType::CDATA, DefaultDecl::Implied).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("title",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("body",ContentSpec::Children(ElementContent::new_element(ElementContentOccur::Mult,"p"))).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("body","onload",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                let mut or = ElementContent::new_or(ElementContentOccur::Mult);
                or.set_first_child(Some(ElementContent::new_pcdata(ElementContentOccur::Once)));
                let mut or2 = ElementContent::new_or(ElementContentOccur::Once);
                or2.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"em")));
                let mut or3 = ElementContent::new_or(ElementContentOccur::Once);
                or3.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"strong")));
                let mut or4 = ElementContent::new_or(ElementContentOccur::Once);
                or4.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"code")));
                let mut or5 = ElementContent::new_or(ElementContentOccur::Once);
                or5.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"sup")));
                let mut or6 = ElementContent::new_or(ElementContentOccur::Once);
                or6.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"var")));
                let mut or7 = ElementContent::new_or(ElementContentOccur::Once);
                or7.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"acronym")));
                or7.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"abbr")));
                or6.set_second_child(Some(or7));
                or5.set_second_child(Some(or6));
                or4.set_second_child(Some(or5));
                or3.set_second_child(Some(or4));
                or2.set_second_child(Some(or3));
                or.set_second_child(Some(or2));
                doctype.add_element_decl::<true>(doctype.create_element_decl("p", ContentSpec::Mixed(or)).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("p","xmlns:dmstc",AttType::CDATA,DefaultDecl::Implied,).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("p","xmlns:nm",AttType::CDATA,DefaultDecl::Implied,).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("p","xmlns:emp2",AttType::CDATA,DefaultDecl::Implied,).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("p", "id", AttType::ID, DefaultDecl::Implied).unwrap()).unwrap();

                doctype.add_element_decl::<true>(doctype.create_element_decl("em",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("span",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("strong",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("code",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("sup",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                let mut or = ElementContent::new_or(ElementContentOccur::Mult);
                or.set_first_child(Some(ElementContent::new_pcdata(ElementContentOccur::Once)));
                or.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"span")));
                doctype.add_element_decl::<true>(doctype.create_element_decl("var", ContentSpec::Mixed(or)).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("acronym",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("acronym","title",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("acronym","class",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("acronym", "id", AttType::ID, DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("abbr",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("abbr","title",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("abbr","class",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("abbr", "id", AttType::ID, DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("script",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("script","type",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("script","src",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("script","charset",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();

                doc.insert_before(doc.create_processing_instruction("TEST-STYLE", Some("PIDATA")).unwrap().into(),Some(doctype.into())).unwrap();

                let mut root = doc.document_element().unwrap();
                assert!(root.parent_node().is_some());
                let comment = doc.create_comment(" This is comment number 1.").into();
                doc.insert_before(comment, Some(root.clone().into())).unwrap();

                let mut head = root.append_child(doc.create_element("head").unwrap().into()).unwrap();
                let mut meta = head.append_child(doc.create_element("meta").unwrap().into()).unwrap().as_element().unwrap();
                meta.set_attribute("http-equiv", "Content-Type").unwrap();
                meta.set_attribute("content", "text/html; charset=UTF-8").unwrap();
                let mut title = head.append_child(doc.create_element("title").unwrap().into()).unwrap();
                title.append_child(doc.create_text_node("hc_staff").into()).unwrap();
                let mut script = head.append_child(doc.create_element("script").unwrap().into()).unwrap().as_element().unwrap();
                script.set_attribute("type", "text/javascript").unwrap();
                script.set_attribute("src", "svgunit.js").unwrap();
                let mut script = head.append_child(doc.create_element("script").unwrap().into()).unwrap().as_element().unwrap();
                script.set_attribute("charset", "UTF-8").unwrap();
                script.set_attribute("type", "text/javascript").unwrap();
                script.set_attribute("src", "svgtest.js").unwrap();
                let mut script = head.append_child(doc.create_element("script").unwrap().into()).unwrap().as_element().unwrap();
                script.set_attribute("type", "text/javascript").unwrap();
                script.append_child(doc.create_text_node("function loadComplete() { startTest(); }").into(),).unwrap();

                let mut body = root.append_child(doc.create_element("body").unwrap().into()).unwrap().as_element().unwrap();
                body.set_attribute("onload", "parent.loadComplete()").unwrap();

                let mut p = body.append_child(doc.create_element("p").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut em = p.append_child(doc.create_element("em").unwrap().into()).unwrap();
                em.append_child(doc.create_text_node("EMP0001").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p.append_child(doc.create_element("strong").unwrap().into()).unwrap();
                strong.append_child(doc.create_text_node("Margaret Martin").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p.append_child(doc.create_element("code").unwrap().into()).unwrap();
                code.append_child(doc.create_text_node("Accountant").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p.append_child(doc.create_element("sup").unwrap().into()).unwrap();
                sup.append_child(doc.create_text_node("56,000").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p.append_child(doc.create_element("var").unwrap().into()).unwrap();
                var.append_child(doc.create_text_node("Female").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p.append_child(doc.create_element("acronym").unwrap().into()).unwrap().as_element().unwrap();
                acronym.append_child(doc.create_text_node("1230 North Ave. Dallas, Texas 98551").into())?;
                acronym.set_attribute("title", "Yes").unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();

                let mut p = body.append_child(doc.create_element("p").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut em = p.append_child(doc.create_element("em").unwrap().into()).unwrap();
                em.append_child(doc.create_text_node("EMP0002").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p.append_child(doc.create_element("strong").unwrap().into()).unwrap();
                strong.append_child(doc.create_text_node("Martha RaynoldsThis is a CDATASection with EntityReference number 2 &ent2;\nThis is an adjacent CDATASection with a reference to a tab &tab;").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p.append_child(doc.create_element("code").unwrap().into()).unwrap();
                code.append_child(doc.create_text_node("Secretary").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p.append_child(doc.create_element("sup").unwrap().into()).unwrap();
                sup.append_child(doc.create_text_node("35,000").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p.append_child(doc.create_element("var").unwrap().into()).unwrap();
                var.append_child(doc.create_text_node("Female").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p.append_child(doc.create_element("acronym").unwrap().into()).unwrap().as_element().unwrap();
                acronym.append_child(doc.create_entity_reference("beta").unwrap().into()).unwrap();
                acronym.append_child(doc.create_text_node(" Dallas, ").into()).unwrap();
                acronym.append_child(doc.create_entity_reference("gamma").unwrap().into()).unwrap();
                acronym.append_child(doc.create_text_node("\n 98554").into()).unwrap();
                acronym.set_attribute("title", "Yes").unwrap();
                acronym.set_attribute("class", "Yes").unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();

                let mut p = body.append_child(doc.create_element("p").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut em = p.append_child(doc.create_element("em").unwrap().into()).unwrap();
                em.append_child(doc.create_text_node("EMP0003").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p.append_child(doc.create_element("strong").unwrap().into()).unwrap();
                strong.append_child(doc.create_text_node("Roger\n Jones").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p.append_child(doc.create_element("code").unwrap().into()).unwrap();
                code.append_child(doc.create_text_node("Department Manager").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p.append_child(doc.create_element("sup").unwrap().into()).unwrap();
                sup.append_child(doc.create_text_node("100,000").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p.append_child(doc.create_element("var").unwrap().into()).unwrap();
                var.append_child(doc.create_entity_reference("delta").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p.append_child(doc.create_element("acronym").unwrap().into()).unwrap().as_element().unwrap();
                acronym.append_child(doc.create_text_node("PO Box 27 Irving, texas 98553").into()).unwrap();
                acronym.set_attribute("title", "Yes").unwrap();
                acronym.set_attribute("class", "No").unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();

                let mut p = body.append_child(doc.create_element("p").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut em = p.append_child(doc.create_element("em").unwrap().into()).unwrap();
                em.append_child(doc.create_text_node("EMP0004").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p.append_child(doc.create_element("strong").unwrap().into()).unwrap();
                strong.append_child(doc.create_text_node("Jeny Oconnor").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p.append_child(doc.create_element("code").unwrap().into()).unwrap();
                code.append_child(doc.create_text_node("Personnel Director").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p.append_child(doc.create_element("sup").unwrap().into()).unwrap();
                sup.append_child(doc.create_text_node("95,000").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p.append_child(doc.create_element("var").unwrap().into()).unwrap();
                var.append_child(doc.create_text_node("Female").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p.append_child(doc.create_element("acronym").unwrap().into()).unwrap().as_element().unwrap();
                acronym.append_child(doc.create_text_node("PO Box 27 Irving, texas 98553").into()).unwrap();
                acronym.set_attribute("title", "Yes")?;
                acronym.set_attribute("class", "Y")?;
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut class = acronym.get_attribute_node("class").unwrap();
                class.append_child(doc.create_entity_reference("alpha").unwrap().into()).unwrap();

                let mut p = body.append_child(doc.create_element("p").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut em = p.append_child(doc.create_element("em").unwrap().into()).unwrap();
                em.append_child(doc.create_text_node("EMP0005").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p.append_child(doc.create_element("strong").unwrap().into()).unwrap();
                strong.append_child(doc.create_text_node("Robert Myers").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p.append_child(doc.create_element("code").unwrap().into()).unwrap();
                code.append_child(doc.create_text_node("Computer Specialist").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p.append_child(doc.create_element("sup").unwrap().into()).unwrap();
                sup.append_child(doc.create_text_node("90,000").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p.append_child(doc.create_element("var").unwrap().into()).unwrap();
                var.append_child(doc.create_text_node("male").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p.append_child(doc.create_element("acronym").unwrap().into()).unwrap().as_element().unwrap();
                acronym.append_child(doc.create_text_node("1821 Nordic. Road, Irving Texas 98558").into(),)?;
                acronym.set_attribute("title", "Yes").unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();

                doc.enable_read_only_check();
                Ok(doc)
            }

            // namednodemapsetnameditemns08.xml
            #[test]
            fn test_namednodemapsetnameditemns08() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attr = r#attributes
                    .get_named_item_ns(Some("http://www.usa.com"), "domestic")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attr" obj="attributes" namespaceURI="&quot;http://www.usa.com&quot;" localName="&quot;domestic&quot;"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>

                // <assertDOMException id="namednodemapsetnameditemns08">
                //  <INUSE_ATTRIBUTE_ERR>
                //      <setNamedItemNS var="newNode" obj="attributes" arg="attr"/>
                //  </INUSE_ATTRIBUTE_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .set_named_item_ns(attr)
                        .is_err_and(|err| err == DOMException::InuseAttributeErr)
                );
            }
            // prefix08.xml
            #[test]
            fn test_prefix08() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                let mut r#ent_element; // type: Node // <var name="entElement" type="Node"/>
                let mut r#created_node; // type: Node // <var name="createdNode" type="Node"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" index="2" var="genderNode"/>
                r#ent_ref = r#gender_node.first_child().unwrap(); // <firstChild interface="Node" obj="genderNode" var="entRef"/>
                r#node_type = r#ent_ref.node_type(); // <nodeType var="nodeType" obj="entRef"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="entRef" name="&quot;ent4&quot;" obj="doc"/>
                //  <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    ent_ref = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#ent_element = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" obj="entRef" var="entElement"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElement"/>
                r#created_node = r#doc.create_element("text3".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;text3&quot;" var="createdNode"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <prefix obj="entElement" value="&quot;newPrefix&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element
                        .set_prefix(Some("newPrefix"))
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // namednodemapremovenameditemns05.xml
            #[test]
            fn test_namednodemapremovenameditemns05() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                entities = doc_type.entities(); // <entities var="entities" obj="docType"/>
                // unimplemented: // <assertNotNull actual="entities" id="entitiesNotNull"/>
                notations = doc_type.notations(); // <notations var="notations" obj="docType"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                // <try>
                //  <removeNamedItemNS var="removedNode" obj="entities" namespaceURI="nullNS" localName="&quot;ent1&quot;"/>
                //  <fail id="entity_throw_DOMException"/>
                // <catch>
                //  <DOMException code="NOT_FOUND_ERR"/>
                //  <DOMException code="NO_MODIFICATION_ALLOWED_ERR"/>
                // </catch>
                // </try>
                assert!(
                    entities
                        .remove_named_item_ns(None, "ent1")
                        .is_err_and(|err| {
                            matches!(
                                err,
                                DOMException::NotFoundErr | DOMException::NoModificationAllowedErr
                            )
                        })
                );
                // <try>
                //  <removeNamedItemNS var="removedNode" obj="notations" namespaceURI="nullNS" localName="&quot;notation1&quot;"/>
                //  <fail id="notation_throw_DOMException"/>
                // <catch>
                //  <DOMException code="NOT_FOUND_ERR"/>
                //  <DOMException code="NO_MODIFICATION_ALLOWED_ERR"/>
                // </catch>
                // </try>
                assert!(
                    notations
                        .remove_named_item_ns(None, "notation1")
                        .is_err_and(|err| {
                            matches!(
                                err,
                                DOMException::NotFoundErr | DOMException::NoModificationAllowedErr
                            )
                        })
                );
            }
            // prefix07.xml
            #[test]
            fn test_prefix07() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="employeeNode"/>
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <prefix obj="employeeNode" value="&quot;emp::&quot;"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    employee_node
                        .set_prefix(Some("emp::"))
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // createDocument01.xml
            #[test]
            fn test_create_document01() {
                let mut r#namespace_uri = "http://www.ecommerce.org/"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.ecommerce.org/&quot;"/>
                let mut r#malformed_name = "prefix::local"; // type: DOMString // <var name="malformedName" type="DOMString" value="&quot;prefix::local&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <createDocument obj="domImpl" var="aNewDoc" namespaceURI="namespaceURI" qualifiedName="malformedName" doctype="docType"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    dom_impl
                        .create_document(Some(namespace_uri), Some(malformed_name), None)
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // isSupported07.xml
            #[test]
            fn test_is_supported07() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                state = root_node.is_supported("XML", Some("")); // <isSupported obj="rootNode" feature="&quot;XML&quot;" version="&quot;&quot;" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="throw_True"/>
            }
            // localName02.xml
            #[test]
            fn test_local_name02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#created_node; // type: Node // <var name="createdNode" type="Node"/>
                let mut r#local_name; // type: DOMString // <var name="localName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#created_node = r#doc.create_element("test:employee".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;test:employee&quot;" var="createdNode"/>
                r#local_name = r#created_node.local_name(); // <localName obj="createdNode" var="localName"/>
                assert!(local_name.is_none()); // <assertNull actual="localName" id="localNameNull"/>
            }
            // setNamedItemNS02.xml
            #[test]
            fn test_set_named_item_n_s02() {
                let mut r#namespace_uri = "http://www.usa.com"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.usa.com&quot;"/>
                let mut r#qualified_name = "dmstc:domestic"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;dmstc:domestic&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#another_doc: DocumentRef; // <var name="anotherDoc" type="Document"/>
                let mut r#arg; // type: Node // <var name="arg" type="Node"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#another_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="anotherDoc" href="staffNS" willBeModified="true"/>
                r#arg = r#another_doc
                    .create_attribute_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                    .unwrap(); // <createAttributeNS obj="anotherDoc" var="arg" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                r#arg.set_node_value("Maybe").unwrap(); // <nodeValue obj="arg" value="&quot;Maybe&quot;"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="0"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <setNamedItemNS var="setNode" interface="NamedNodeMap" obj="attributes" arg="arg"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .set_named_item_ns(arg)
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // namednodemapgetnameditemns05.xml
            #[test]
            fn test_namednodemapgetnameditemns05() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Node // <var name="element" type="Node"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attribute = r#attributes.get_named_item_ns(Some("*"), "street").unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;*&quot;" localName="&quot;street&quot;"/>
                assert!(attribute.is_none()); // <assertNull actual="attribute" id="namednodemapgetnameditemns05"/>
            }
            // hasAttribute03.xml
            #[test]
            fn test_has_attribute03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_node; // type: Element // <var name="testNode" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="0"/>
                r#state = r#test_node.has_attribute("nomatch"); // <hasAttribute obj="testNode" var="state" name="&quot;nomatch&quot;"/>
                assert!(!r#state); // <assertFalse actual="state" id="throw_False"/>
            }
            // createDocument06.xml
            #[test]
            fn test_create_document06() {
                let mut r#namespace_uri = "http://ecommerce.org/schema"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://ecommerce.org/schema&quot;"/>
                let mut r#qualified_name = "xml:local"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;xml:local&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <createDocument obj="domImpl" var="aNewDoc" namespaceURI="namespaceURI" qualifiedName="qualifiedName" doctype="docType"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    dom_impl
                        .create_document(Some(namespace_uri), Some(qualified_name), None)
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // setAttributeNS10.xml
            #[test]
            fn test_set_attribute_n_s10() {
                let mut r#namespace_uri = "http://www.example.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.example.gov&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;em&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <setAttributeNS obj="testAddr" namespaceURI="namespaceURI" qualifiedName="&quot;&quot;" value="&quot;newValue&quot;"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    test_addr
                        .set_attribute_ns(Some(namespace_uri), "", "newValue")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // removeAttributeNS02.xml
            #[test]
            fn test_remove_attribute_n_s02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                let mut r#addr_attr; // type: Attr // <var name="addrAttr" type="Attr"/>
                let mut r#attr; // type: DOMString // <var name="attr" type="DOMString"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                let mut r#local_name; // type: DOMString // <var name="localName" type="DOMString"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:address&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>
                r#test_addr
                    .remove_attribute_ns(Some("http://www.nist.gov"), "local1")
                    .unwrap(); // <removeAttributeNS obj="testAddr" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;local1&quot;"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:address&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>
                r#addr_attr = r#test_addr
                    .get_attribute_node_ns(Some("http://www.nist.gov"), "local1")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS obj="testAddr" var="addrAttr" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;local1&quot;"/>
                r#attr = r#test_addr
                    .get_attribute_ns(Some("http://www.nist.gov"), "local1")
                    .unwrap(); // <getAttributeNS obj="testAddr" var="attr" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;local1&quot;"/>
                r#namespace_uri = r#addr_attr.namespace_uri().unwrap().to_string(); // <namespaceURI obj="addrAttr" var="namespaceURI"/>
                r#local_name = r#addr_attr.local_name().unwrap().to_string(); // <localName obj="addrAttr" var="localName"/>
                r#prefix = r#test_addr.prefix().unwrap().to_string(); // <prefix obj="testAddr" var="prefix"/>
                assert_eq!(r#attr, "FALSE"); // <assertEquals actual="attr" expected="&quot;FALSE&quot;" ignoreCase="false" id="attr"/>
                assert_eq!(r#namespace_uri, "http://www.nist.gov"); // <assertEquals actual="namespaceURI" expected="&quot;http://www.nist.gov&quot;" ignoreCase="false" id="uri"/>
                assert_eq!(r#local_name, "local1"); // <assertEquals actual="localName" expected="&quot;local1&quot;" ignoreCase="false" id="lname"/>
                assert_eq!(r#prefix, "emp"); // <assertEquals actual="prefix" expected="&quot;emp&quot;" ignoreCase="false" id="prefix"/>
            }
            // nodehasattributes01.xml
            #[test]
            fn test_nodehasattributes01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#has_attributes; // type: boolean // <var name="hasAttributes" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employeeId"); // <getElementsByTagName var="elementList" obj="doc" tagname="&quot;employeeId&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                r#has_attributes = r#element.has_attributes(); // <hasAttributes var="hasAttributes" obj="element"/>
                assert!(!r#has_attributes); // <assertFalse actual="hasAttributes" id="employeeIdHasAttributesFalse"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName var="elementList" obj="doc" tagname="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                r#has_attributes = r#element.has_attributes(); // <hasAttributes var="hasAttributes" obj="element"/>
                assert!(r#has_attributes); // <assertTrue actual="hasAttributes" id="addressHasAttributesTrue"/>
            }
            // documentcreateattributeNS07.xml
            #[test]
            fn test_documentcreateattribute_n_s07() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#namespace_uri = "http://www.W3.org/2000/xmlns"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.W3.org/2000/xmlns&quot;"/>
                let mut r#qualified_name = "xmlns"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;xmlns&quot;"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // <assertDOMException id="documentcreateattributeNS07">
                //  <NAMESPACE_ERR>
                //      <createAttributeNS obj="doc" var="attribute" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_attribute_ns(Some(namespace_uri), qualified_name)
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // nodesetprefix07.xml
            #[test]
            fn test_nodesetprefix07() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#attribute = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Test/L2"), "abc:elem".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/L2&quot;" qualifiedName="&quot;abc:elem&quot;"/>
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <prefix obj="attribute" value="&quot;xmlns&quot;"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    attribute
                        .set_prefix(Some("xmlns"))
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // hasAttributes01.xml
            #[test]
            fn test_has_attributes01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#addr_list; // type: NodeList // <var name="addrList" type="NodeList"/>
                let mut r#addr_node; // type: Node // <var name="addrNode" type="Node"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#addr_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="addrList"/>
                r#addr_node = r#addr_list.item(0).unwrap(); // <item interface="NodeList" obj="addrList" index="0" var="addrNode"/>
                r#state = r#addr_node.has_attributes(); // <hasAttributes obj="addrNode" var="state"/>
                assert!(!r#state); // <assertFalse actual="state" id="throw_False"/>
            }
            // elementsetattributenodens04.xml
            #[test]
            fn test_elementsetattributenodens04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element1; // type: Element // <var name="element1" type="Element"/>
                let mut r#element2; // type: Element // <var name="element2" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element1 = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test"), "elem1".as_ref())
                    .unwrap(); // <createElementNS var="element1" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;elem1&quot;"/>
                r#element2 = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test"), "elem2".as_ref())
                    .unwrap(); // <createElementNS var="element2" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;elem2&quot;"/>
                r#attribute = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Test"), "attr".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;attr&quot;"/>
                r#new_attribute = r#element1
                    .set_attribute_node_ns(r#attribute.clone())
                    .unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element1" newAttr="attribute"/>
                // <assertDOMException id="elementsetattributenodens04">
                //  <INUSE_ATTRIBUTE_ERR>
                //      <setAttributeNodeNS var="newAttribute" obj="element2" newAttr="attribute"/>
                //  </INUSE_ATTRIBUTE_ERR>
                // </assertDOMException>
                assert!(
                    element2
                        .set_attribute_node_ns(attribute)
                        .is_err_and(|err| err == DOMException::InuseAttributeErr)
                );
            }
            // documentcreateattributeNS05.xml
            #[test]
            fn test_documentcreateattribute_n_s05() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#qualified_name = "abc:def"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;abc:def&quot;"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation var="domImpl" obj="doc"/>
                new_doc = dom_impl
                    .create_document(Some("http://www.w3.org/DOM/Test"), Some("dom:doc"), None)
                    .unwrap(); // <createDocument var="newDoc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;dom:doc&quot;" doctype="docType"/>
                // <assertDOMException id="documentcreateattributeNS05">
                //  <NAMESPACE_ERR>
                //      <createAttributeNS obj="newDoc" var="attribute" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    new_doc
                        .create_attribute_ns(None, qualified_name)
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // nodehasattributes04.xml
            #[test]
            fn test_nodehasattributes04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#element_test; // type: Element // <var name="elementTest" type="Element"/>
                let mut r#element_doc; // type: Element // <var name="elementDoc" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#set_node; // type: Node // <var name="setNode" type="Node"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#has_attributes; // type: boolean // <var name="hasAttributes" type="boolean"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation var="domImpl" obj="doc"/>
                new_doc = dom_impl
                    .create_document(Some("http://www.w3.org/DOM/Test"), Some("test"), None)
                    .unwrap(); // <createDocument var="newDoc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;test&quot;" doctype="docType"/>
                r#element = r#new_doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test"), "dom:elem".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="newDoc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;dom:elem&quot;"/>
                r#attribute = r#new_doc.create_attribute("attr".to_string()).unwrap(); // <createAttribute var="attribute" obj="newDoc" name="&quot;attr&quot;"/>
                r#set_node = r#element.set_attribute_node(r#attribute).unwrap(); // <setAttributeNode var="setNode" obj="element" newAttr="attribute"/>
                r#element_doc = r#new_doc.document_element().unwrap(); // <documentElement var="elementDoc" obj="newDoc"/>
                r#appended_child = r#element_doc.append_child(element.into()).unwrap(); // <appendChild var="appendedChild" obj="elementDoc" newChild="element"/>
                r#element_list = r#new_doc
                    .get_elements_by_tag_name_ns(Some("http://www.w3.org/DOM/Test"), "elem"); // <getElementsByTagNameNS var="elementList" obj="newDoc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" localName="&quot;elem&quot;" interface="Document"/>
                r#element_test = r#element_list.item(0).unwrap(); // <item var="elementTest" obj="elementList" index="0" interface="NodeList"/>
                r#has_attributes = r#element_test.has_attributes(); // <hasAttributes var="hasAttributes" obj="elementTest"/>
                assert!(r#has_attributes); // <assertTrue actual="hasAttributes" id="nodehasattributes04"/>
            }
            // namednodemapgetnameditemns01.xml
            #[test]
            fn test_namednodemapgetnameditemns01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                entities = doc_type.entities(); // <entities var="entities" obj="docType"/>
                // unimplemented: // <assertNotNull actual="entities" id="entitiesNotNull"/>
                notations = doc_type.notations(); // <notations var="notations" obj="docType"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                r#entity = r#entities.get_named_item_ns(None, "ent1").unwrap(); // <getNamedItemNS var="entity" obj="entities" namespaceURI="nullNS" localName="&quot;ent1&quot;"/>
                assert!(entity.is_none()); // <assertNull actual="entity" id="entityNull"/>
                r#notation = r#notations.get_named_item_ns(None, "notation1").unwrap(); // <getNamedItemNS var="notation" obj="notations" namespaceURI="nullNS" localName="&quot;notation1&quot;"/>
                assert!(notation.is_none()); // <assertNull actual="notation" id="notationNull"/>
            }
            // nodegetlocalname03.xml
            #[test]
            fn test_nodegetlocalname03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#qelement; // type: Element // <var name="qelement" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#qattr; // type: Attr // <var name="qattr" type="Attr"/>
                let mut r#local_elem_name; // type: DOMString // <var name="localElemName" type="DOMString"/>
                let mut r#local_q_elem_name; // type: DOMString // <var name="localQElemName" type="DOMString"/>
                let mut r#local_attr_name; // type: DOMString // <var name="localAttrName" type="DOMString"/>
                let mut r#local_q_attr_name; // type: DOMString // <var name="localQAttrName" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test/elem"), "elem".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/elem&quot;" qualifiedName="&quot;elem&quot;"/>
                r#qelement = r#doc
                    .create_element_ns(
                        Some("http://www.w3.org/DOM/Test/elem"),
                        "qual:qelem".as_ref(),
                    )
                    .unwrap(); // <createElementNS var="qelement" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/elem&quot;" qualifiedName="&quot;qual:qelem&quot;"/>
                r#attr = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Test/attr"), "attr".as_ref())
                    .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/attr&quot;" qualifiedName="&quot;attr&quot;"/>
                r#qattr = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/DOM/Test/attr"),
                        "qual:qattr".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="qattr" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/attr&quot;" qualifiedName="&quot;qual:qattr&quot;"/>
                r#local_elem_name = r#element.local_name().unwrap().to_string(); // <localName var="localElemName" obj="element"/>
                r#local_q_elem_name = r#qelement.local_name().unwrap().to_string(); // <localName var="localQElemName" obj="qelement"/>
                r#local_attr_name = r#attr.local_name().unwrap().to_string(); // <localName var="localAttrName" obj="attr"/>
                r#local_q_attr_name = r#qattr.local_name().unwrap().to_string(); // <localName var="localQAttrName" obj="qattr"/>
                assert_eq!(r#local_elem_name, "elem"); // <assertEquals actual="localElemName" expected="&quot;elem&quot;" id="nodegetlocalname03_localElemName" ignoreCase="false"/>
                assert_eq!(r#local_q_elem_name, "qelem"); // <assertEquals actual="localQElemName" expected="&quot;qelem&quot;" id="nodegetlocalname03_localQElemName" ignoreCase="false"/>
                assert_eq!(r#local_attr_name, "attr"); // <assertEquals actual="localAttrName" expected="&quot;attr&quot;" id="nodegetlocalname03_localAttrName" ignoreCase="false"/>
                assert_eq!(r#local_q_attr_name, "qattr"); // <assertEquals actual="localQAttrName" expected="&quot;qattr&quot;" id="nodegetlocalname03_localQAttrName" ignoreCase="false"/>
            }
            // getNamedItemNS02.xml
            #[test]
            fn test_get_named_item_n_s02() {
                let mut r#namespace_uri = "http://www.usa.com"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.usa.com&quot;"/>
                let mut r#local_name = "domest"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;domest&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="1"/>
                r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                r#new_attr = r#attributes
                    .get_named_item_ns(Some(r#namespace_uri), r#local_name)
                    .unwrap(); // <getNamedItemNS obj="attributes" var="newAttr" namespaceURI="namespaceURI" localName="localName"/>
                assert!(new_attr.is_none()); // <assertNull actual="newAttr" id="throw_Null"/>
            }
            // namednodemapsetnameditemns06.xml
            #[test]
            fn test_namednodemapsetnameditemns06() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attr = r#attributes
                    .get_named_item_ns(Some("http://www.usa.com"), "domestic")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attr" obj="attributes" namespaceURI="&quot;http://www.usa.com&quot;" localName="&quot;domestic&quot;"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                // <assertDOMException id="namednodemapsetnameditemns06">
                //  <INUSE_ATTRIBUTE_ERR>
                //      <setNamedItemNS var="newNode" obj="attributes" arg="attr"/>
                //  </INUSE_ATTRIBUTE_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .set_named_item_ns(attr)
                        .is_err_and(|err| err == DOMException::InuseAttributeErr)
                );
            }
            // elementsetattributenodens03.xml
            #[test]
            fn test_elementsetattributenodens03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element1; // type: Element // <var name="element1" type="Element"/>
                let mut r#element2; // type: Element // <var name="element2" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element1 = r#element_list.item(1).unwrap(); // <item var="element1" obj="elementList" index="1" interface="NodeList"/>
                r#attribute = r#element1
                    .get_attribute_node_ns(None, "street")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attribute" obj="element1" namespaceURI="nullNS" localName="&quot;street&quot;"/>
                r#element2 = r#element_list.item(2).unwrap(); // <item var="element2" obj="elementList" index="2" interface="NodeList"/>
                // <assertDOMException id="elementsetattributenodens03">
                //  <INUSE_ATTRIBUTE_ERR>
                //      <setAttributeNodeNS var="newAttribute" obj="element2" newAttr="attribute"/>
                //  </INUSE_ATTRIBUTE_ERR>
                // </assertDOMException>
                assert!(
                    element2
                        .set_attribute_node_ns(attribute)
                        .is_err_and(|err| err == DOMException::InuseAttributeErr)
                );
            }
            // createElementNS02.xml
            #[test]
            fn test_create_element_n_s02() {
                let mut r#qualified_name = "prefix:local"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;prefix:local&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // unimplemented:
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <createElementNS obj="doc" var="newElement" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_element_ns(None, qualified_name)
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // nodegetownerdocument02.xml
            #[test]
            fn test_nodegetownerdocument02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                let mut r#new_elem; // type: Element // <var name="newElem" type="Element"/>
                let mut r#owner_doc_elem: DocumentRef; // <var name="ownerDocElem" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation var="domImpl" obj="doc"/>
                doc_type = dom_impl.create_document_type("mydoc", None, None).unwrap(); // <createDocumentType var="docType" obj="domImpl" qualifiedName="&quot;mydoc&quot;" publicId="nullNS" systemId="nullNS"/>
                new_doc = dom_impl
                    .create_document(
                        Some("http://www.w3.org/DOM/Test"),
                        Some("mydoc"),
                        Some(doc_type),
                    )
                    .unwrap(); // <createDocument var="newDoc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;mydoc&quot;" doctype="docType"/>
                let r#owner_doc_doc = r#new_doc.owner_document(); // <ownerDocument var="ownerDocDoc" obj="newDoc"/>
                assert!(owner_doc_doc.is_none()); // <assertNull actual="ownerDocDoc" id="nodegetownerdocument02_1"/>
                r#new_elem = r#new_doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test"), "myelem".as_ref())
                    .unwrap(); // <createElementNS var="newElem" obj="newDoc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;myelem&quot;"/>
                r#owner_doc_elem = r#new_elem.owner_document().unwrap(); // <ownerDocument var="ownerDocElem" obj="newElem"/>
                // unimplemented: // <assertNotNull actual="ownerDocElem" id="nodegetownerdocument02_2"/>
            }
            // importNode12.xml
            #[test]
            fn test_import_node12() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#doc1_type; // type: DocumentType // <var name="doc1Type" type="DocumentType"/>
                let mut r#entity_list; // type: NamedNodeMap // <var name="entityList" type="NamedNodeMap"/>
                let mut r#entity2; // type: Entity // <var name="entity2" type="Entity"/>
                let mut r#entity1; // type: Entity // <var name="entity1" type="Entity"/>
                let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                let mut r#entity_name; // type: DOMString // <var name="entityName" type="DOMString"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: D`OMString // <var name="childName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                r#doc1_type = r#a_new_doc.doctype().unwrap(); // <doctype obj="aNewDoc" var="doc1Type"/>
                entity_list = doc1_type.entities(); // <entities obj="doc1Type" var="entityList"/>
                // unimplemented: // <assertNotNull actual="entityList" id="entitiesNotNull"/>
                r#entity2 = r#entity_list.get_named_item("ent4").unwrap(); // <getNamedItem obj="entityList" var="entity2" name="&quot;ent4&quot;"/>
                r#entity1 = r#doc.import_node(r#entity2.into(), true).unwrap(); // <importNode obj="doc" var="entity1" importedNode="entity2" deep="true"/>
                r#owner_document = r#entity1.owner_document().unwrap(); // <ownerDocument obj="entity1" var="ownerDocument"/>
                r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>
                assert_eq!(system, "staffNS.dtd"); // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="systemId"/>
                r#entity_name = r#entity1.node_name().to_string(); // <nodeName obj="entity1" var="entityName"/>
                assert_eq!(r#entity_name, "ent4"); // <assertEquals actual="entityName" expected="&quot;ent4&quot;" id="entityName" ignoreCase="false"/>
                r#child = r#entity1.first_child().unwrap(); // <firstChild interface="Node" obj="entity1" var="child"/>
                // unimplemented: // <assertNotNull actual="child" id="notnull"/>
                r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                assert_eq!(r#child_name, "entElement1"); // <assertEquals actual="childName" expected="&quot;entElement1&quot;" id="childName" ignoreCase="false"/>
            }
            // setAttributeNS04.xml
            #[test]
            fn test_set_attribute_n_s04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                let mut r#addr_attr; // type: Attr // <var name="addrAttr" type="Attr"/>
                let mut r#result_attr; // type: DOMString // <var name="resultAttr" type="DOMString"/>
                let mut r#result_namespace_uri; // type: DOMString // <var name="resultNamespaceURI" type="DOMString"/>
                let mut r#result_local_name; // type: DOMString // <var name="resultLocalName" type="DOMString"/>
                let mut r#result_prefix; // type: DOMString // <var name="resultPrefix" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:address&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                r#test_addr
                    .set_attribute_ns(Some("http://www.nist.gov"), "newprefix:zone", "newValue")
                    .unwrap(); // <setAttributeNS obj="testAddr" namespaceURI="&quot;http://www.nist.gov&quot;" qualifiedName="&quot;newprefix:zone&quot;" value="&quot;newValue&quot;"/>
                r#addr_attr = r#test_addr
                    .get_attribute_node_ns(Some("http://www.nist.gov"), "zone")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS obj="testAddr" var="addrAttr" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;zone&quot;"/>
                r#result_attr = r#test_addr
                    .get_attribute_ns(Some("http://www.nist.gov"), "zone")
                    .unwrap(); // <getAttributeNS obj="testAddr" var="resultAttr" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;zone&quot;"/>
                assert_eq!(r#result_attr, "newValue"); // <assertEquals actual="resultAttr" expected="&quot;newValue&quot;" id="attrValue" ignoreCase="false"/>
                r#result_namespace_uri = r#addr_attr.namespace_uri().unwrap().to_string(); // <namespaceURI obj="addrAttr" var="resultNamespaceURI"/>
                assert_eq!(r#result_namespace_uri, "http://www.nist.gov"); // <assertEquals actual="resultNamespaceURI" expected="&quot;http://www.nist.gov&quot;" id="nsuri" ignoreCase="false"/>
                r#result_local_name = r#addr_attr.local_name().unwrap().to_string(); // <localName obj="addrAttr" var="resultLocalName"/>
                assert_eq!(r#result_local_name, "zone"); // <assertEquals actual="resultLocalName" expected="&quot;zone&quot;" id="lname" ignoreCase="false"/>
                r#result_prefix = r#addr_attr.prefix().unwrap().to_string(); // <prefix obj="addrAttr" var="resultPrefix"/>
                assert_eq!(r#result_prefix, "newprefix"); // <assertEquals actual="resultPrefix" expected="&quot;newprefix&quot;" id="prefix" ignoreCase="false"/>
            }
            // documentimportnode08.xml
            #[test]
            fn test_documentimportnode08() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                dom_impl = doc.implementation(); // <implementation var="domImpl" obj="doc"/>
                doc_type = dom_impl
                    .create_document_type("test:root", None, None)
                    .unwrap(); // <createDocumentType var="docType" obj="domImpl" qualifiedName="&quot;test:root&quot;" publicId="nullNS" systemId="nullNS"/>
                // <assertDOMException id="throw_NOT_SUPPORTED_ERR">
                //  <NOT_SUPPORTED_ERR>
                //      <importNode var="imported" obj="doc" importedNode="docType" deep="true"/>
                //  </NOT_SUPPORTED_ERR>
                // </assertDOMException>
                assert!(
                    doc.import_node(doc_type.into(), true)
                        .is_err_and(|err| err == DOMException::NotSupportedErr)
                );
            }
            // createElementNS05.xml
            #[test]
            fn test_create_element_n_s05() {
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#qualified_name = "gov:faculty"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;gov:faculty&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_element; // type: Element // <var name="newElement" type="Element"/>
                let mut r#element_name; // type: DOMString // <var name="elementName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#new_element = r#doc
                    .create_element_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                    .unwrap(); // <createElementNS obj="doc" var="newElement" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                r#element_name = r#new_element.tag_name().to_string(); // <tagName obj="newElement" var="elementName"/>
                assert_eq!(r#element_name, qualified_name); // <assertEquals actual="elementName" expected="qualifiedName" id="throw_Equals" ignoreCase="false"/>
            }
            // documentgetelementsbytagnameNS02.xml
            #[test]
            fn test_documentgetelementsbytagname_n_s02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#element = r#doc
                    .create_element_ns(Some("test"), "employeeId".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;test&quot;" qualifiedName="&quot;employeeId&quot;"/>
                r#appended_child = r#doc_elem.append_child(element.into()).unwrap(); // <appendChild var="appendedChild" obj="docElem" newChild="element"/>
                r#child_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "employeeId"); // <getElementsByTagNameNS var="childList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;employeeId&quot;" interface="Document"/>
                assert_eq!(child_list.length(), 6); // <assertSize size="6" collection="childList" id="documentgetelementsbytagnameNS02"/>
            }
            // documentimportnode22.xml
            #[test]
            fn test_documentimportnode22() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_imp: DocumentRef; // <var name="docImp" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#node_map; // type: NamedNodeMap // <var name="nodeMap" type="NamedNodeMap"/>
                let mut r#notation1; // type: Notation // <var name="notation1" type="Notation"/>
                let mut r#notation2; // type: Notation // <var name="notation2" type="Notation"/>
                let mut r#notation_imp1; // type: Notation // <var name="notationImp1" type="Notation"/>
                let mut r#notation_imp2; // type: Notation // <var name="notationImp2" type="Notation"/>
                let mut r#notation_imp_new1; // type: Notation // <var name="notationImpNew1" type="Notation"/>
                let mut r#notation_imp_new2; // type: Notation // <var name="notationImpNew2" type="Notation"/>
                let mut r#public_id1; // type: DOMString // <var name="publicId1" type="DOMString"/>
                let mut r#public_id1_imp; // type: DOMString // <var name="publicId1Imp" type="DOMString"/>
                let mut r#public_id1_new_imp; // type: DOMString // <var name="publicId1NewImp" type="DOMString"/>
                let mut r#public_id2_imp; // type: DOMString // <var name="publicId2Imp" type="DOMString"/>
                let mut r#public_id2_new_imp; // type: DOMString // <var name="publicId2NewImp" type="DOMString"/>
                let mut r#system_id1_imp; // type: DOMString // <var name="systemId1Imp" type="DOMString"/>
                let mut r#system_id1_new_imp; // type: DOMString // <var name="systemId1NewImp" type="DOMString"/>
                let mut r#system_id2; // type: DOMString // <var name="systemId2" type="DOMString"/>
                let mut r#system_id2_imp; // type: DOMString // <var name="systemId2Imp" type="DOMString"/>
                let mut r#system_id2_new_imp; // type: DOMString // <var name="systemId2NewImp" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                dom_impl = doc.implementation(); // <implementation var="domImpl" obj="doc"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                doc_imp = dom_impl
                    .create_document(Some("http://www.w3.org/DOM/Test"), Some("a:b"), None)
                    .unwrap(); // <createDocument var="docImp" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;a:b&quot;" doctype="docTypeNull"/>
                node_map = doc_type.notations(); // <notations var="nodeMap" obj="docType"/>
                // unimplemented: // <assertNotNull actual="nodeMap" id="notationsNotNull"/>
                r#notation1 = r#node_map.get_named_item("notation1").unwrap(); // <getNamedItem var="notation1" obj="nodeMap" name="&quot;notation1&quot;"/>
                r#notation2 = r#node_map.get_named_item("notation2").unwrap(); // <getNamedItem var="notation2" obj="nodeMap" name="&quot;notation2&quot;"/>
                r#notation_imp1 = r#doc.import_node(r#notation1.clone().into(), true); // <importNode var="notationImp1" obj="doc" importedNode="notation1" deep="true"/>
                r#notation_imp2 = r#doc.import_node(r#notation2.clone().into(), false); // <importNode var="notationImp2" obj="doc" importedNode="notation2" deep="false"/>
                r#notation_imp_new1 = r#doc_imp.import_node(r#notation1.clone().into(), false); // <importNode var="notationImpNew1" obj="docImp" importedNode="notation1" deep="false"/>
                r#notation_imp_new2 = r#doc_imp.import_node(r#notation2.clone().into(), true); // <importNode var="notationImpNew2" obj="docImp" importedNode="notation2" deep="true"/>
                r#public_id1 = r#notation1.public_id().unwrap().to_string(); // <publicId var="publicId1" obj="notation1" interface="Notation"/>
                r#public_id1_imp = r#notation1.public_id().unwrap().to_string(); // <publicId var="publicId1Imp" obj="notation1" interface="Notation"/>
                r#public_id1_new_imp = r#notation1.public_id().unwrap().to_string(); // <publicId var="publicId1NewImp" obj="notation1" interface="Notation"/>
                r#system_id1_imp = r#notation1.system_id(); // <systemId var="systemId1Imp" obj="notation1" interface="Notation"/>
                r#system_id1_new_imp = r#notation1.system_id(); // <systemId var="systemId1NewImp" obj="notation1" interface="Notation"/>
                r#public_id2_imp = r#notation2.public_id(); // <publicId var="publicId2Imp" obj="notation2" interface="Notation"/>
                r#public_id2_new_imp = r#notation2.public_id(); // <publicId var="publicId2NewImp" obj="notation2" interface="Notation"/>
                r#system_id2 = r#notation2.system_id().unwrap().to_string(); // <systemId var="systemId2" obj="notation2" interface="Notation"/>
                r#system_id2_imp = r#notation2.system_id().unwrap().to_string(); // <systemId var="systemId2Imp" obj="notation2" interface="Notation"/>
                r#system_id2_new_imp = r#notation2.system_id().unwrap().to_string(); // <systemId var="systemId2NewImp" obj="notation2" interface="Notation"/>
                assert_eq!(r#public_id1_imp, public_id1); // <assertEquals expected="publicId1" actual="publicId1Imp" id="documentimportnode22_N1PID" ignoreCase="false"/>
                assert_eq!(r#public_id1_new_imp, public_id1); // <assertEquals expected="publicId1" actual="publicId1NewImp" id="documentimportnode22_N1NPID" ignoreCase="false"/>
                assert!(system_id1_imp.is_none()); // <assertNull actual="systemId1Imp" id="documentimportnode22_N1SID"/>
                assert!(system_id1_new_imp.is_none()); // <assertNull actual="systemId1NewImp" id="documentimportnode22_N1NSID"/>
                assert_eq!(r#system_id2_imp, system_id2); // <assertEquals expected="systemId2" actual="systemId2Imp" id="documentimportnode22_N2SID" ignoreCase="false"/>
                assert_eq!(r#system_id2_new_imp, system_id2); // <assertEquals expected="systemId2" actual="systemId2NewImp" id="documentimportnode22_N2NSID" ignoreCase="false"/>
                assert!(public_id2_imp.is_none()); // <assertNull actual="publicId2Imp" id="documentimportnode22_N2PID"/>
                assert!(public_id2_new_imp.is_none()); // <assertNull actual="publicId2Imp" id="documentimportnode22_N2NPID"/>
            }
            // systemId01.xml
            #[test]
            fn test_system_id01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#system_id; // type: DOMString // <var name="systemId" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                r#system_id = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="systemId"/>
                assert_eq!(system_id, "staffNS.dtd"); // <assertURIEquals actual="systemId" file="&quot;staffNS.dtd&quot;" id="systemId"/>
            }
            // setAttributeNS09.xml
            #[test]
            fn test_set_attribute_n_s09() {
                let mut r#local_name = "newAttr"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;newAttr&quot;"/>
                let mut r#namespace_uri = "http://www.newattr.com"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.newattr.com&quot;"/>
                let mut r#qualified_name = "emp:newAttr"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:newAttr&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                let mut r#addr_attr; // type: Attr // <var name="addrAttr" type="Attr"/>
                let mut r#result_attr; // type: DOMString // <var name="resultAttr" type="DOMString"/>
                let mut r#result_namespace_uri; // type: DOMString // <var name="resultNamespaceURI" type="DOMString"/>
                let mut r#result_local_name; // type: DOMString // <var name="resultLocalName" type="DOMString"/>
                let mut r#result_prefix; // type: DOMString // <var name="resultPrefix" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:address&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                r#test_addr
                    .set_attribute_ns(Some(r#namespace_uri), r#qualified_name, "newValue")
                    .unwrap(); // <setAttributeNS obj="testAddr" namespaceURI="namespaceURI" qualifiedName="qualifiedName" value="&quot;newValue&quot;"/>
                r#addr_attr = r#test_addr
                    .get_attribute_node_ns(Some(r#namespace_uri), r#local_name)
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS obj="testAddr" var="addrAttr" namespaceURI="namespaceURI" localName="localName"/>
                r#result_attr = r#test_addr
                    .get_attribute_ns(Some(r#namespace_uri), r#local_name)
                    .unwrap(); // <getAttributeNS obj="testAddr" var="resultAttr" namespaceURI="namespaceURI" localName="localName"/>
                assert_eq!(r#result_attr, "newValue"); // <assertEquals actual="resultAttr" expected="&quot;newValue&quot;" id="attrValue" ignoreCase="false"/>
                r#result_namespace_uri = r#addr_attr.namespace_uri().unwrap().to_string(); // <namespaceURI obj="addrAttr" var="resultNamespaceURI"/>
                assert_eq!(r#result_namespace_uri, "http://www.newattr.com"); // <assertEquals actual="resultNamespaceURI" expected="&quot;http://www.newattr.com&quot;" id="nsuri" ignoreCase="false"/>
                r#result_local_name = r#addr_attr.local_name().unwrap().to_string(); // <localName obj="addrAttr" var="resultLocalName"/>
                assert_eq!(r#result_local_name, "newAttr"); // <assertEquals actual="resultLocalName" expected="&quot;newAttr&quot;" id="lname" ignoreCase="false"/>
                r#result_prefix = r#addr_attr.prefix().unwrap().to_string(); // <prefix obj="addrAttr" var="resultPrefix"/>
                assert_eq!(r#result_prefix, "emp"); // <assertEquals actual="resultPrefix" expected="&quot;emp&quot;" id="prefix" ignoreCase="false"/>
            }
            // documentimportnode18.xml
            #[test]
            fn test_documentimportnode18() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_imp: DocumentRef; // <var name="docImp" type="Document"/>
                let mut r#pi_import; // type: ProcessingInstruction // <var name="piImport" type="ProcessingInstruction"/>
                let mut r#pi_to_import; // type: ProcessingInstruction // <var name="piToImport" type="ProcessingInstruction"/>
                let mut r#pi_data; // type: DOMString // <var name="piData" type="DOMString"/>
                let mut r#pi_target; // type: DOMString // <var name="piTarget" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_imp = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="docImp" href="staffNS" willBeModified="true"/>
                r#pi_to_import = r#doc
                    .create_processing_instruction("Target", Some("Data"))
                    .unwrap(); // <createProcessingInstruction var="piToImport" obj="doc" target="&quot;Target&quot;" data="&quot;Data&quot;"/>
                r#pi_import = r#doc
                    .import_node(r#pi_to_import.into(), false)
                    .unwrap()
                    .as_processing_instruction()
                    .unwrap(); // <importNode var="piImport" obj="doc" importedNode="piToImport" deep="false"/>
                r#pi_target = r#pi_import.target().to_string(); // <target var="piTarget" obj="piImport" interface="ProcessingInstruction"/>
                r#pi_data = r#pi_import.data().unwrap().to_string(); // <data var="piData" obj="piImport" interface="ProcessingInstruction"/>
                assert_eq!(r#pi_target, "Target"); // <assertEquals expected="&quot;Target&quot;" actual="piTarget" id="documentimportnode18_Target" ignoreCase="false"/>
                assert_eq!(r#pi_data, "Data"); // <assertEquals expected="&quot;Data&quot;" actual="piData" id="documentimportnode18_Data" ignoreCase="false"/>
            }
            // domimplementationcreatedocumenttype02.xml
            #[test]
            fn test_domimplementationcreatedocumenttype02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#new_doc_type; // type: DocumentType // <var name="newDocType" type="DocumentType"/>
                let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                let mut r#public_id = "http://www.w3.org/DOM/Test/dom2.dtd"; // type: DOMString // <var name="publicId" type="DOMString" value="&quot;http://www.w3.org/DOM/Test/dom2.dtd&quot;"/>
                let mut r#system_id = "dom2.dtd"; // type: DOMString // <var name="systemId" type="DOMString" value="&quot;dom2.dtd&quot;"/>
                let mut r#qualified_names = vec![
                    "_:_", "_:h0", "_:test", "_:_.", "_:a-", "l_:_", "ns:_0", "ns:a0", "ns0:test",
                    "ns:EEE.", "ns:_-", "a.b:c", "a-b:c.j", "a-b:c",
                ]; // type: List // <var name="qualifiedNames" type="List"><member>"_:_"</member><member>"_:h0"</member><member>"_:test"</member><member>"_:_."</member><member>"_:a-"</member><member>"l_:_"</member><member>"ns:_0"</member><member>"ns:a0"</member><member>"ns0:test"</member><member>"ns:EEE."</member><member>"ns:_-"</member><member>"a.b:c"</member><member>"a-b:c.j"</member><member>"a-b:c"</member></var>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                // <for-each collection="qualifiedNames" member="qualifiedName">
                //  <createDocumentType obj="domImpl" var="newDocType" qualifiedName="qualifiedName" publicId="publicId" systemId="systemId"/>
                //  <assertNotNull actual="newDocType" id="domimplementationcreatedocumenttype02_newDocType"/>
                //  <ownerDocument obj="newDocType" var="ownerDocument"/>
                //  <assertNull actual="ownerDocument" id="domimplementationcreatedocumenttype02_ownerDocument"/>
                // </for-each>
                for qualified_name in qualified_names {
                    new_doc_type = dom_impl
                        .create_document_type(qualified_name, Some(public_id), Some(system_id))
                        .unwrap();
                    let owner_document = new_doc_type.owner_document();
                    assert!(owner_document.is_none());
                }
            }
            // localName03.xml
            #[test]
            fn test_local_name03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let mut r#text_node; // type: Node // <var name="textNode" type="Node"/>
                let mut r#local_name; // type: DOMString // <var name="localName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employeeId"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employeeId&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                r#text_node = r#test_employee.first_child().unwrap(); // <firstChild interface="Node" obj="testEmployee" var="textNode"/>
                r#local_name = r#text_node.local_name(); // <localName obj="textNode" var="localName"/>
                assert!(local_name.is_none()); // <assertNull actual="localName" id="textNodeLocalName"/>
            }
            // setAttributeNodeNS04.xml
            #[test]
            fn test_set_attribute_node_n_s04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                let mut r#new_addr_attr; // type: Attr // <var name="newAddrAttr" type="Attr"/>
                let mut r#new_name; // type: DOMString // <var name="newName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:address&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                r#new_attr = r#doc
                    .create_attribute_ns(Some("http://www.nist.gov"), "xxx:domestic".as_ref())
                    .unwrap(); // <createAttributeNS obj="doc" var="newAttr" namespaceURI="&quot;http://www.nist.gov&quot;" qualifiedName="&quot;xxx:domestic&quot;"/>
                r#new_addr_attr = r#test_addr
                    .set_attribute_node_ns(r#new_attr)
                    .unwrap()
                    .unwrap(); // <setAttributeNodeNS obj="testAddr" newAttr="newAttr" var="newAddrAttr"/>
                r#new_name = r#new_addr_attr.node_name().to_string(); // <nodeName obj="newAddrAttr" var="newName"/>
                assert_eq!(r#new_name, "emp:domestic"); // <assertEquals actual="newName" expected="&quot;emp:domestic&quot;" id="nodeName" ignoreCase="false"/>
            }
            // documentimportnode03.xml
            #[test]
            fn test_documentimportnode03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#imported_attr; // type: Node // <var name="importedAttr" type="Node"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#child_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "employee"); // <getElementsByTagNameNS var="childList" obj="doc" localName="&quot;employee&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" interface="Document"/>
                r#element = r#child_list.item(1).unwrap(); // <item var="element" obj="childList" index="1" interface="NodeList"/>
                r#attr = r#element.get_attribute_node("defaultAttr").unwrap(); // <getAttributeNode var="attr" obj="element" name="&quot;defaultAttr&quot;"/>
                r#imported_attr = r#doc.import_node(r#attr.into(), false).unwrap(); // <importNode var="importedAttr" obj="doc" importedNode="attr" deep="false"/>
                r#node_name = r#imported_attr.node_name().to_string(); // <nodeName var="nodeName" obj="importedAttr"/>
                r#node_value = r#imported_attr.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="importedAttr"/>
                r#node_type = r#imported_attr.node_type(); // <nodeType var="nodeType" obj="importedAttr"/>
                assert_eq!(r#node_name, "defaultAttr"); // <assertEquals expected="&quot;defaultAttr&quot;" actual="nodeName" id="documentimportnode03_nodeName" ignoreCase="false"/>
                assert_eq!(r#node_type as i32, 2); // <assertEquals expected="2" actual="nodeType" id="documentimportnode03_nodeType" ignoreCase="false"/>
                assert_eq!(r#node_value, "defaultVal"); // <assertEquals expected="&quot;defaultVal&quot;" actual="nodeValue" id="documentimportnode03_nodeValue" ignoreCase="false"/>
            }
            // createElementNS06.xml
            #[test]
            fn test_create_element_n_s06() {
                let mut r#namespace_uri = "http://www.example.com/"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.example.com/&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <createElementNS obj="doc" var="newElement" namespaceURI="namespaceURI" qualifiedName="&quot;&quot;"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_element_ns(Some(namespace_uri), "")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // prefix04.xml
            #[test]
            fn test_prefix04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                r#prefix = r#test_employee.prefix(); // <prefix obj="testEmployee" var="prefix"/>
                assert!(prefix.is_none()); // <assertNull actual="prefix" id="throw_Null"/>
            }
            // documentimportnode17.xml
            #[test]
            fn test_documentimportnode17() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_imp: DocumentRef; // <var name="docImp" type="Document"/>
                let mut r#comment_import; // type: Node // <var name="commentImport" type="Node"/>
                let mut r#comment_to_import; // type: Node // <var name="commentToImport" type="Node"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_imp = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="docImp" href="staffNS" willBeModified="true"/>
                r#comment_to_import =
                    r#doc.create_comment("Document.importNode test for a COMMENT_NODE"); // <createComment var="commentToImport" obj="doc" data="&quot;Document.importNode test for a COMMENT_NODE&quot;"/>
                r#comment_import = r#doc.import_node(r#comment_to_import.into(), true).unwrap(); // <importNode var="commentImport" obj="doc" importedNode="commentToImport" deep="true"/>
                r#node_value = r#comment_import.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="commentImport"/>
                assert_eq!(r#node_value, "Document.importNode test for a COMMENT_NODE"); // <assertEquals expected="&quot;Document.importNode test for a COMMENT_NODE&quot;" actual="nodeValue" id="documentimportnode17" ignoreCase="false"/>
            }
            // createDocument07.xml
            #[test]
            fn test_create_document07() {
                let mut r#namespace_uri = "http://www.ecommerce.org/schema"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.ecommerce.org/schema&quot;"/>
                let mut r#qualified_name = "y:x"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;y:x&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                a_new_doc = dom_impl
                    .create_document(Some(namespace_uri), Some(qualified_name), None)
                    .unwrap(); // <createDocument obj="domImpl" var="aNewDoc" namespaceURI="namespaceURI" qualifiedName="qualifiedName" doctype="docType"/>
                r#node_name = r#a_new_doc.node_name().to_string(); // <nodeName var="nodeName" obj="aNewDoc"/>
                r#node_value = r#a_new_doc.node_value(); // <nodeValue var="nodeValue" obj="aNewDoc"/>
                assert_eq!(r#node_name, "#document"); // <assertEquals actual="nodeName" expected="&quot;#document&quot;" id="nodeName" ignoreCase="false"/>
                assert!(node_value.is_none()); // <assertNull actual="nodeValue" id="nodeValue"/>
            }
            // elementsetattributens04.xml
            #[test]
            fn test_elementsetattributens04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#qualified_names =
                    vec!["/", "//", "\\", ";", "&amp;", "*", "]]", "&gt;", "&lt;"]; // type: List // <var name="qualifiedNames" type="List">    <member>"/"</member>    <member>"//"</member>    <member>"\\"</member>    <member>";"</member>    <member>"&amp;"</member>    <member>"*"</member>    <member>"]]"</member>    <member>"&gt;"</member>    <member>"&lt;"</member>  </var>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test/L2"), "dom:elem".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/L2&quot;" qualifiedName="&quot;dom:elem&quot;"/>
                // <for-each collection="qualifiedNames" member="qualifiedName">
                //  <assertDOMException id="elementsetattributens04">
                //      <INVALID_CHARACTER_ERR>
                //          <setAttributeNS obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/L2&quot;" qualifiedName="qualifiedName" value="&quot;test&quot;"/>
                //      </INVALID_CHARACTER_ERR>
                //  </assertDOMException>
                // </for-each>
                for qualified_name in qualified_names {
                    assert!(
                        element
                            .set_attribute_ns(
                                Some("http://www.w3.org/DOM/Test/L2"),
                                qualified_name,
                                "test"
                            )
                            .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                    );
                }
            }
            // createDocument04.xml
            #[test]
            fn test_create_document04() {
                let mut r#namespace_uri = "http://www.ecommerce.org/schema"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.ecommerce.org/schema&quot;"/>
                let mut r#qualified_name = "namespaceURI:x"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;namespaceURI:x&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                dom_impl = a_new_doc.implementation(); // <implementation obj="aNewDoc" var="domImpl"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <createDocument obj="domImpl" var="aNewDoc" namespaceURI="namespaceURI" qualifiedName="qualifiedName" doctype="docType"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    dom_impl
                        .create_document(
                            Some(namespace_uri),
                            Some(qualified_name),
                            Some(doc_type.clone())
                        )
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // publicId01.xml
            #[test]
            fn test_public_id01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#public_id; // type: DOMString // <var name="publicId" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                r#public_id = r#doc_type.public_id().unwrap().to_string(); // <publicId interface="DocumentType" obj="docType" var="publicId"/>
                assert_eq!(r#public_id, "STAFF"); // <assertEquals actual="publicId" expected="&quot;STAFF&quot;" id="throw_Equals" ignoreCase="false"/>
            }
            // elementhasattribute04.xml
            #[test]
            fn test_elementhasattribute04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element = r#doc.create_element("address".to_string()).unwrap(); // <createElement var="element" obj="doc" tagName="&quot;address&quot;"/>
                r#attribute = r#doc.create_attribute("domestic".to_string()).unwrap(); // <createAttribute var="attribute" obj="doc" name="&quot;domestic&quot;"/>
                r#new_attribute = r#element.set_attribute_node(r#attribute).unwrap(); // <setAttributeNode var="newAttribute" obj="element" newAttr="attribute"/>
                r#state = r#element.has_attribute("domestic"); // <hasAttribute var="state" obj="element" name="&quot;domestic&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="elementhasattribute04"/>
            }
            // getNamedItemNS01.xml
            #[test]
            fn test_get_named_item_n_s01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#domestic_attr; // type: Attr // <var name="domesticAttr" type="Attr"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="1"/>
                r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                r#domestic_attr = r#attributes
                    .get_named_item_ns(Some("http://www.usa.com"), "domestic")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS obj="attributes" var="domesticAttr" namespaceURI="&quot;http://www.usa.com&quot;" localName="&quot;domestic&quot;"/>
                r#attr_name = r#domestic_attr.node_name().to_string(); // <nodeName obj="domesticAttr" var="attrName"/>
                assert_eq!(r#attr_name, "dmstc:domestic"); // <assertEquals actual="attrName" expected="&quot;dmstc:domestic&quot;" id="attrName" ignoreCase="false"/>
            }
            // elementgetelementsbytagnamens02.xml
            #[test]
            fn test_elementgetelementsbytagnamens02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element = r#doc.document_element().unwrap(); // <documentElement var="element" obj="doc"/>
                r#element_list = r#element
                    .get_elements_by_tag_name_ns(Some("**"), "*")
                    .unwrap(); // <getElementsByTagNameNS var="elementList" obj="element" namespaceURI="&quot;**&quot;" localName="&quot;*&quot;" interface="Element"/>
                assert_eq!(element_list.length(), 0); // <assertSize size="0" collection="elementList" id="elementgetelementsbytagnamens02"/>
            }
            // hasAttribute02.xml
            #[test]
            fn test_has_attribute02() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_node; // type: Element // <var name="testNode" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="0"/>
                r#state = r#test_node.has_attribute("street"); // <hasAttribute obj="testNode" var="state" name="&quot;street&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="throw_True"/>
            }
            // getAttributeNS05.xml
            #[test]
            fn test_get_attribute_n_s05() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                r#attr_value = r#test_addr
                    .get_attribute_ns(Some("http://www.nist.gov"), "domestic")
                    .unwrap(); // <getAttributeNS obj="testAddr" var="attrValue" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;domestic&quot;"/>
                assert_eq!(r#attr_value, "Yes"); // <assertEquals actual="attrValue" expected="&quot;Yes&quot;" id="attrValue" ignoreCase="false"/>
            }
            // documentimportnode09.xml
            #[test]
            fn test_documentimportnode09() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_fragment; // type: DocumentFragment // <var name="docFragment" type="DocumentFragment"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                let mut r#address_node; // type: Node // <var name="addressNode" type="Node"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#imported_doc_frag; // type: Node // <var name="importedDocFrag" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment var="docFragment" obj="doc"/>
                r#child_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="childList" obj="doc" localName="&quot;address&quot;" namespaceURI="&quot;*&quot;" interface="Document"/>
                r#address_node = r#child_list.item(0).unwrap(); // <item var="addressNode" obj="childList" index="0" interface="NodeList"/>
                r#appended_child = r#doc_fragment.append_child(address_node.into()).unwrap(); // <appendChild var="appendedChild" obj="docFragment" newChild="addressNode"/>
                r#imported_doc_frag = r#doc.import_node(r#doc_fragment.into(), false).unwrap(); // <importNode var="importedDocFrag" obj="doc" importedNode="docFragment" deep="false"/>
                r#success = r#imported_doc_frag.has_child_nodes(); // <hasChildNodes var="success" obj="importedDocFrag"/>
                assert!(!r#success); // <assertFalse actual="success" id="documentimportnode09"/>
            }
            // elementgetattributenodens02.xml
            #[test]
            fn test_elementgetattributenodens02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attribute1; // type: Attr // <var name="newAttribute1" type="Attr"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element = r#doc
                    .create_element_ns(Some("namespaceURI"), "root".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;namespaceURI&quot;" qualifiedName="&quot;root&quot;"/>
                r#attribute = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Level2"), "l2:att".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Level2&quot;" qualifiedName="&quot;l2:att&quot;"/>
                r#new_attribute1 = r#element.set_attribute_node_ns(r#attribute).unwrap(); // <setAttributeNodeNS var="newAttribute1" obj="element" newAttr="attribute"/>
                r#attribute = r#element
                    .get_attribute_node_ns(Some("http://www.w3.org/DOM/Level2"), "att")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attribute" obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Level2&quot;" localName="&quot;att&quot;"/>
                r#attr_value = r#attribute.node_value().unwrap().to_string(); // <nodeValue var="attrValue" obj="attribute"/>
                assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" id="elementgetattributenodens02" ignoreCase="false"/>
            }
            // elementsetattributens08.xml
            #[test]
            fn test_elementsetattributens08() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element = r#doc
                    .create_element_ns(
                        Some("http://www.w3.org/DOMTest/level2"),
                        "dom:elem".as_ref(),
                    )
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOMTest/level2&quot;" qualifiedName="&quot;dom:elem&quot;"/>
                // <assertDOMException id="elementsetattributens08_Err1">
                //  <NAMESPACE_ERR>
                //      <setAttributeNS obj="element" namespaceURI="&quot;http://www.w3.org/DOMTest/level2&quot;" qualifiedName="&quot;xmlns&quot;" value="&quot;test&quot;"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    element
                        .set_attribute_ns(Some("http://www.w3.org/DOMTest/level2"), "xmlns", "test")
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
                // <assertDOMException id="elementsetattributens08_Err2">
                //  <NAMESPACE_ERR>
                //      <setAttributeNS obj="element" namespaceURI="&quot;http://www.w3.org/DOMTest/level2&quot;" qualifiedName="&quot;xmlns:root&quot;" value="&quot;test&quot;"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    element
                        .set_attribute_ns(
                            Some("http://www.w3.org/DOMTest/level2"),
                            "xmlns:root",
                            "test"
                        )
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // createDocument02.xml
            #[test]
            fn test_create_document02() {
                let mut r#qualified_name = "k:local"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;k:local&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <createDocument obj="domImpl" var="aNewDoc" namespaceURI="namespaceURI" qualifiedName="qualifiedName" doctype="docType"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    dom_impl
                        .create_document(None, Some(qualified_name), None)
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // importNode16.xml
            #[test]
            fn test_import_node16() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#another_doc: DocumentRef; // <var name="anotherDoc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#another_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="anotherDoc" href="staffNS" willBeModified="true"/>
                r#doc_type = r#another_doc.doctype().unwrap(); // <doctype obj="anotherDoc" var="docType"/>
                // <assertDOMException id="throw_NOT_SUPPORTED_ERR">
                //  <NOT_SUPPORTED_ERR>
                //      <importNode obj="doc" var="node" importedNode="docType" deep="false"/>
                //  </NOT_SUPPORTED_ERR>
                // </assertDOMException>
                assert!(
                    doc.import_node(doc_type.into(), false)
                        .is_err_and(|err| err == DOMException::NotSupportedErr)
                );
            }
            // elementsetattributenodens01.xml
            #[test]
            fn test_elementsetattributenodens01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute1; // type: Attr // <var name="attribute1" type="Attr"/>
                let mut r#attribute2; // type: Attr // <var name="attribute2" type="Attr"/>
                let mut r#attr_node; // type: Attr // <var name="attrNode" type="Attr"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                let mut r#attr_ns; // type: DOMString // <var name="attrNS" type="DOMString"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#length; // type: int // <var name="length" type="int"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element = r#doc
                    .create_element_ns(
                        Some("http://www.w3.org/DOM/Test/Level2"),
                        "new:element".as_ref(),
                    )
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/Level2&quot;" qualifiedName="&quot;new:element&quot;"/>
                r#attribute1 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Test/att1"), "p1:att".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute1" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/att1&quot;" qualifiedName="&quot;p1:att&quot;"/>
                r#attribute2 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Test/att1"), "p2:att".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute2" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/att1&quot;" qualifiedName="&quot;p2:att&quot;"/>
                r#attribute2.set_value("value2").unwrap(); // <value obj="attribute2" value="&quot;value2&quot;" interface="Attr"/>
                r#new_attribute = r#element.set_attribute_node_ns(r#attribute1).unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="attribute1"/>
                r#new_attribute = r#element.set_attribute_node_ns(r#attribute2).unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="attribute2"/>
                r#attr_node = r#element
                    .get_attribute_node_ns(Some("http://www.w3.org/DOM/Test/att1"), "att")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attrNode" obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/att1&quot;" localName="&quot;att&quot;"/>
                r#attr_name = r#attr_node.node_name().to_string(); // <nodeName var="attrName" obj="attrNode"/>
                r#attr_ns = r#attr_node.namespace_uri().unwrap().to_string(); // <namespaceURI var="attrNS" obj="attrNode"/>
                assert_eq!(r#attr_name, "p2:att"); // <assertEquals actual="attrName" expected="&quot;p2:att&quot;" id="elementsetattributenodens01_attrName" ignoreCase="false"/>
                assert_eq!(r#attr_ns, "http://www.w3.org/DOM/Test/att1"); // <assertEquals actual="attrNS" expected="&quot;http://www.w3.org/DOM/Test/att1&quot;" id="elementsetattributenodens01_attrNS" ignoreCase="false"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#length = r#attributes.length(); // <length var="length" obj="attributes" interface="NamedNodeMap"/>
                assert_eq!(r#length, 1); // <assertEquals actual="length" expected="1" id="length" ignoreCase="false"/>
            }
            // getAttributeNS02.xml
            #[test]
            fn test_get_attribute_n_s02() {
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#local_name = "district"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;district&quot;"/>
                let mut r#qualified_name = "emp:district"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:district&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                let mut r#district_attr; // type: Attr // <var name="districtAttr" type="Attr"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#new_attribute = r#doc
                    .create_attribute_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                    .unwrap(); // <createAttributeNS obj="doc" var="newAttribute" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                r#district_attr = r#test_addr.set_attribute_node_ns(r#new_attribute).unwrap(); // <setAttributeNodeNS obj="testAddr" var="districtAttr" newAttr="newAttribute"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                r#attr_value = r#test_addr
                    .get_attribute_ns(Some(r#namespace_uri), r#local_name)
                    .unwrap(); // <getAttributeNS obj="testAddr" var="attrValue" namespaceURI="namespaceURI" localName="localName"/>
                assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" id="throw_Equals" ignoreCase="false"/>
            }
            // removeAttributeNS01.xml
            #[test]
            fn test_remove_attribute_n_s01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender; // type: Node // <var name="gender" type="Node"/>
                let mut r#gen; // type: Node // <var name="gen" type="Node"/>
                let mut r#g_list; // type: NodeList // <var name="gList" type="NodeList"/>
                let mut r#gen_element; // type: Element // <var name="genElement" type="Element"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#gen = r#gender.first_child().unwrap(); // <firstChild var="gen" obj="gender" interface="Node"/>
                r#node_type = r#gen.node_type(); // <nodeType var="nodeType" obj="gen"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference name="&quot;ent4&quot;" obj="doc" var="gen"/>
                //  <assertNotNull actual="gen" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    r#gen = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#g_list = r#gen.child_nodes(); // <childNodes obj="gen" var="gList"/>
                r#gen_element = r#g_list.item(0).unwrap().clone().as_element().unwrap(); // <item interface="NodeList" obj="gList" var="genElement" index="0"/>
                // unimplemented: // <assertNotNull actual="genElement" id="notnull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <removeAttributeNS obj="genElement" namespaceURI="&quot;www.xyz.com&quot;" localName="&quot;local1&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    gen_element
                        .remove_attribute_ns(Some("www.xyz.com"), "local1")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // elementhasattributens03.xml
            #[test]
            fn test_elementhasattributens03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM"), "address".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM&quot;" qualifiedName="&quot;address&quot;"/>
                // unimplemented: // <assertNotNull actual="element" id="createElementNotNull"/>
                r#attribute = r#doc
                    .create_attribute_ns(None, "domestic".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute" obj="doc" namespaceURI="nullNS" qualifiedName="&quot;domestic&quot;"/>
                r#new_attribute = r#element.set_attribute_node(r#attribute).unwrap(); // <setAttributeNode var="newAttribute" obj="element" newAttr="attribute"/>
                r#state = r#element.has_attribute_ns(None, "domestic").unwrap(); // <hasAttributeNS var="state" obj="element" namespaceURI="nullNS" localName="&quot;domestic&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="elementhasattributens03"/>
            }
            // namednodemapremovenameditemns04.xml
            #[test]
            fn test_namednodemapremovenameditemns04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Node // <var name="element" type="Node"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#attribute_removed; // type: Attr // <var name="attributeRemoved" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "employee"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;employee&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attribute_removed = r#attributes
                    .remove_named_item_ns(Some("http://www.w3.org/2000/xmlns/"), "xmlns")
                    .unwrap(); // <removeNamedItemNS var="attributeRemoved" obj="attributes" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" localName="&quot;xmlns&quot;"/>
                r#attribute = r#attributes
                    .get_named_item_ns(Some("http://www.w3.org/2000/xmlns/"), "xmlns")
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" localName="&quot;xmlns&quot;"/>
                assert!(attribute.is_none()); // <assertNull actual="attribute" id="namednodemapremovenameditemns04_1"/>
                r#attribute_removed = r#attributes
                    .remove_named_item_ns(Some("http://www.w3.org/2000/xmlns/"), "dmstc")
                    .unwrap(); // <removeNamedItemNS var="attributeRemoved" obj="attributes" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" localName="&quot;dmstc&quot;"/>
                r#attribute = r#attributes
                    .get_named_item_ns(Some("http://www.w3.org/2000/xmlns/"), "dmstc")
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" localName="&quot;dmstc&quot;"/>
                assert!(attribute.is_none()); // <assertNull actual="attribute" id="namednodemapremovenameditemns04_2"/>
            }
            // namespaceURI03.xml
            #[test]
            fn test_namespace_ur_i03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let mut r#employee_namespace; // type: DOMString // <var name="employeeNamespace" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                // unimplemented: // <assertNotNull actual="testEmployee" id="employeeNotNull"/>
                r#employee_namespace = r#test_employee.namespace_uri().unwrap().to_string(); // <namespaceURI obj="testEmployee" var="employeeNamespace"/>
                assert_eq!(r#employee_namespace, "http://www.nist.gov"); // <assertEquals actual="employeeNamespace" expected="&quot;http://www.nist.gov&quot;" id="namespaceURI" ignoreCase="false"/>
            }
            // importNode02.xml
            #[test]
            fn test_import_node02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#c_data_sec; // type: CDATASection // <var name="cDataSec" type="CDATASection"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                r#c_data_sec = r#a_new_doc
                    .create_cdata_section("this is CDATASection data")
                    .unwrap(); // <createCDATASection obj="aNewDoc" var="cDataSec" data="&quot;this is CDATASection data&quot;"/>
                r#a_node = r#doc.import_node(r#c_data_sec.into(), false).unwrap(); // <importNode obj="doc" var="aNode" importedNode="cDataSec" deep="false"/>
                r#owner_document = r#a_node.owner_document().unwrap(); // <ownerDocument obj="aNode" var="ownerDocument"/>
                // unimplemented: // <assertNotNull actual="ownerDocument" id="ownerDocumentNotNull"/>
                r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>
                assert_eq!(system, "staffNS.dtd"); // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="dtdSystemId"/>
                r#value = r#a_node.node_value().unwrap().to_string(); // <nodeValue obj="aNode" var="value"/>
                assert_eq!(r#value, "this is CDATASection data"); // <assertEquals actual="value" expected="&quot;this is CDATASection data&quot;" id="nodeValue" ignoreCase="false"/>
            }
            // documentgetelementbyid01.xml
            #[test]
            fn test_documentgetelementbyid01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#element_id = "---"; // type: DOMString // <var name="elementId" type="DOMString" value="&quot;---&quot;"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element = r#doc.get_element_by_id(r#element_id.as_ref()); // <getElementById var="element" obj="doc" elementId="elementId"/>
                assert!(element.is_none()); // <assertNull actual="element" id="documentgetelementbyid01"/>
            }
            // hasAttributeNS01.xml
            #[test]
            fn test_has_attribute_n_s01() {
                let mut r#local_name = "nomatch"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;nomatch&quot;"/>
                let mut r#namespace_uri = "http://www.usa.com"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.usa.com&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_node; // type: Element // <var name="testNode" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="0"/>
                r#state = r#test_node
                    .has_attribute_ns(Some(r#namespace_uri), r#local_name.as_ref())
                    .unwrap(); // <hasAttributeNS obj="testNode" var="state" namespaceURI="namespaceURI" localName="localName"/>
                assert!(!r#state); // <assertFalse actual="state" id="throw_False"/>
            }
            // documentcreateattributeNS04.xml
            #[test]
            fn test_documentcreateattribute_n_s04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#namespace_uri = "http://www.w3.org/DOM/Test/Level2"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/DOM/Test/Level2&quot;"/>
                let mut r#qualified_names = vec!["_:", ":0a", ":", "a:b:c", "_::a"]; // type: List // <var name="qualifiedNames" type="List"><member>"_:"</member><member>":0a"</member><member>":"</member><member>"a:b:c"</member><member>"_::a"</member></var>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // <for-each collection="qualifiedNames" member="qualifiedName">
                //  <assertDOMException id="documentcreateattributeNS04">
                //      <NAMESPACE_ERR>
                //          <createAttributeNS obj="doc" var="attribute" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                //      </NAMESPACE_ERR>
                //  </assertDOMException>
                // </for-each>
                for qualified_name in qualified_names {
                    assert!(
                        doc.create_attribute_ns(Some(namespace_uri), qualified_name)
                            .is_err_and(|err| err == DOMException::NamespaceErr)
                    );
                }
            }
            // getAttributeNS01.xml
            #[test]
            fn test_get_attribute_n_s01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#local_name = "district"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;district&quot;"/>
                let mut r#qualified_name = "emp:district"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:district&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                r#attr_value = r#test_addr
                    .get_attribute_ns(Some(r#namespace_uri), r#local_name)
                    .unwrap(); // <getAttributeNS obj="testAddr" var="attrValue" namespaceURI="namespaceURI" localName="localName"/>
                assert_eq!(r#attr_value, "DISTRICT"); // <assertEquals actual="attrValue" expected="&quot;DISTRICT&quot;" id="attrValue" ignoreCase="false"/>
            }
            // elementgetelementsbytagnamens05.xml
            #[test]
            fn test_elementgetelementsbytagnamens05() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element = r#doc.document_element().unwrap(); // <documentElement var="element" obj="doc"/>
                r#element_list = r#element
                    .get_elements_by_tag_name_ns(Some("http://www.altavista.com"), "*")
                    .unwrap(); // <getElementsByTagNameNS var="elementList" obj="element" namespaceURI="&quot;http://www.altavista.com&quot;" localName="&quot;*&quot;" interface="Element"/>
                assert_eq!(element_list.length(), 1); // <assertSize size="1" collection="elementList" id="elementgetelementsbytagnamens05"/>
            }
            // getElementsByTagNameNS04.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let mut r#expected_result =
                    vec!["address", "address", "address", "emp:address", "address"]; // type: List // <var name="expectedResult" type="List"><member>"address"</member><member>"address"</member><member>"address"</member><member>"emp:address"</member><member>"address"</member></var>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS interface="Document" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" var="elementList"/>
                // <for-each collection="elementList" member="child">
                //  <nodeName obj="child" var="childName"/>
                //  <append collection="result" item="childName"/>
                // </for-each>
                for i in 0..element_list.length() {
                    child = element_list.item(i).unwrap();
                    child_name = child.node_name().to_string();
                    result.push(child_name);
                }
                assert_eq!(r#result, expected_result); // <assertEquals actual="result" expected="expectedResult" id="nodeNames" ignoreCase="false"/>
            }
            // hasAttributeNS04.xml
            #[test]
            fn test_has_attribute_n_s04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#local_name = "district"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;district&quot;"/>
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_node; // type: Element // <var name="testNode" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:address&quot;"/>
                r#test_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="0"/>
                // unimplemented: // <assertNotNull actual="testNode" id="empAddressNotNull"/>
                r#state = r#test_node
                    .has_attribute_ns(Some(r#namespace_uri), r#local_name.as_ref())
                    .unwrap(); // <hasAttributeNS obj="testNode" var="state" namespaceURI="namespaceURI" localName="localName"/>
                assert!(r#state); // <assertTrue actual="state" id="hasAttribute"/>
            }
            // namednodemapgetnameditemns03.xml
            #[test]
            fn test_namednodemapgetnameditemns03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Node // <var name="element" type="Node"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attr1; // type: Attr // <var name="newAttr1" type="Attr"/>
                let mut r#new_attr2; // type: Attr // <var name="newAttr2" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test"), "root".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;root&quot;"/>
                r#new_attr1 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/L1"), "L1:att".as_ref())
                    .unwrap(); // <createAttributeNS var="newAttr1" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" qualifiedName="&quot;L1:att&quot;"/>
                r#new_attribute = r#element.set_attribute_node_ns(r#new_attr1).unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="newAttr1"/>
                r#new_attr2 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/L2"), "L2:att".as_ref())
                    .unwrap(); // <createAttributeNS var="newAttr2" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/L2&quot;" qualifiedName="&quot;L2:att&quot;"/>
                r#new_attribute = r#element.set_attribute_node_ns(r#new_attr2).unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="newAttr2"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attribute = r#attributes
                    .get_named_item_ns(Some("http://www.w3.org/DOM/L2"), "att")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.w3.org/DOM/L2&quot;" localName="&quot;att&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                assert_eq!(r#attr_name, "L2:att"); // <assertEquals actual="attrName" expected="&quot;L2:att&quot;" id="namednodemapgetnameditemns03" ignoreCase="false"/>
            }
            // prefix09.xml
            #[test]
            fn test_prefix09() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#addr_node; // type: Element // <var name="addrNode" type="Element"/>
                let mut r#addr_attr; // type: Attr // <var name="addrAttr" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#addr_node = r#element_list.item(3).unwrap(); // <item interface="NodeList" obj="elementList" index="3" var="addrNode"/>
                r#addr_attr = r#addr_node.get_attribute_node("xmlns").unwrap(); // <getAttributeNode obj="addrNode" name="&quot;xmlns&quot;" var="addrAttr"/>
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <prefix obj="addrAttr" value="&quot;xxx&quot;"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    addr_attr
                        .set_prefix(Some("xxx"))
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // namednodemapremovenameditemns07.xml
            #[test]
            fn test_namednodemapremovenameditemns07() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Node // <var name="element" type="Node"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "employee"); // <getElementsByTagNameNS var="elementList" obj="doc" localName="&quot;employee&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <removeNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;domestic&quot;"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .remove_named_item_ns(Some("http://www.nist.gov"), "domestic")
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // namednodemapremovenameditemns08.xml
            #[test]
            fn test_namednodemapremovenameditemns08() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" localName="&quot;address&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#element
                    .remove_attribute_ns(Some("http://www.nist.gov"), "domestic")
                    .unwrap(); // <removeAttributeNS obj="element" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;domestic&quot;"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <removeNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;domestic&quot;"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .remove_named_item_ns(Some("http://www.nist.gov"), "domestic")
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // setAttributeNS07.xml
            #[test]
            fn test_set_attribute_n_s07() {
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#qualified_name = "xmlns"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;xmlns&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <setAttributeNS obj="testAddr" namespaceURI="namespaceURI" qualifiedName="qualifiedName" value="&quot;newValue&quot;"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    test_addr
                        .set_attribute_ns(Some(namespace_uri), qualified_name, "newValue")
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // namednodemapsetnameditemns09.xml
            #[test]
            fn test_namednodemapsetnameditemns09() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                // entities = doc_type.entities(); // <entities var="entities" obj="docType"/>
                // notations = doc_type.notations(); // <notations var="notations" obj="docType"/>
                // r#attr = r#doc
                //     .create_attribute_ns(Some("http://www.w3.org/DOM/Test"), "test".as_ref())
                //     .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;test&quot;"/>
                // // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR_entities">
                // //  <NO_MODIFICATION_ALLOWED_ERR>
                // //      <setNamedItemNS var="newNode" obj="entities" arg="attr"/>
                // //  </NO_MODIFICATION_ALLOWED_ERR>
                // // </assertDOMException>
                // assert!(
                //     entities
                //         .set_named_item_ns(attr)
                //         .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                // );
                // // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR_notations">
                // //  <NO_MODIFICATION_ALLOWED_ERR>
                // //      <setNamedItemNS var="newNode" obj="notations" arg="attr"/>
                // //  </NO_MODIFICATION_ALLOWED_ERR>
                // // </assertDOMException>
                // assert!(
                //     notations
                //         .set_named_item_ns(attr)
                //         .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                // );
            }
            // elementsetattributenodens06.xml
            #[test]
            fn test_elementsetattributenodens06() {
                // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#attribute2; // type: Attr // <var name="attribute2" type="Attr"/>
                let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#new_attribute; // type: Node // <var name="newAttribute" type="Node"/>
                let mut r#new_child; // type: Node // <var name="newChild" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test"), "elem1".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;elem1&quot;"/>
                r#attribute = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Test"), "attr".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;attr&quot;"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                r#new_child = r#attribute.append_child(ent_ref.clone().into()).unwrap(); // <appendChild var="newChild" obj="attribute" newChild="entRef"/>
                r#new_attribute = r#element.set_attribute_node_ns(r#attribute).unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="attribute"/>
                r#element_list = r#ent_ref.child_nodes(); // <childNodes var="elementList" obj="entRef"/>
                r#element = r#element_list
                    .item(0)
                    .unwrap()
                    .clone()
                    .as_element()
                    .unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                r#attribute2 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Test"), "attr2".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute2" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;attr2&quot;"/>
                // <assertDOMException id="elementsetattributenodens06">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <setAttributeNodeNS var="newAttribute" obj="element" newAttr="attribute2"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    element
                        .set_attribute_node_ns(attribute2)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodesetprefix08.xml
            #[test]
            fn test_nodesetprefix08() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName var="elementList" obj="doc" tagname="&quot;employee&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                r#attribute = r#element.get_attribute_node("xmlns").unwrap(); // <getAttributeNode var="attribute" obj="element" name="&quot;xmlns&quot;"/>
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <prefix obj="attribute" value="&quot;xml&quot;"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    attribute
                        .set_prefix(Some("xml"))
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // importNode10.xml
            #[test]
            fn test_import_node10() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                r#ent_ref = r#a_new_doc
                    .create_entity_reference("entRef1".to_string())
                    .unwrap(); // <createEntityReference obj="aNewDoc" var="entRef" name="&quot;entRef1&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                r#ent_ref.set_node_value("entRef1Value").unwrap(); // <nodeValue obj="entRef" value="&quot;entRef1Value&quot;"/>
                r#a_node = r#doc.import_node(r#ent_ref.into(), false).unwrap(); // <importNode obj="doc" var="aNode" importedNode="entRef" deep="false"/>
                r#owner_document = r#a_node.owner_document().unwrap(); // <ownerDocument obj="aNode" var="ownerDocument"/>
                r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>
                assert_eq!(system, "staffNS.dtd"); // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="systemId"/>
                r#name = r#a_node.node_name().to_string(); // <nodeName obj="aNode" var="name"/>
                assert_eq!(r#name, "entRef1"); // <assertEquals actual="name" expected="&quot;entRef1&quot;" id="nodeName" ignoreCase="false"/>
            }
            // documentimportnode04.xml
            #[test]
            fn test_documentimportnode04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#imported_attr; // type: Node // <var name="importedAttr" type="Node"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                dom_impl = doc.implementation(); // <implementation var="domImpl" obj="doc"/>
                new_doc = dom_impl
                    .create_document(Some("http://www.w3.org/DOM/Test"), Some("l2:root"), None)
                    .unwrap(); // <createDocument var="newDoc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;l2:root&quot;" doctype="docType"/>
                r#child_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "employee"); // <getElementsByTagNameNS var="childList" obj="doc" localName="&quot;employee&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" interface="Document"/>
                r#element = r#child_list.item(1).unwrap().clone(); // <item var="element" obj="childList" index="1" interface="NodeList"/>
                r#attr = r#element.get_attribute_node("defaultAttr").unwrap(); // <getAttributeNode var="attr" obj="element" name="&quot;defaultAttr&quot;"/>
                r#imported_attr = r#new_doc.import_node(r#attr.into(), true).unwrap(); // <importNode var="importedAttr" obj="newDoc" importedNode="attr" deep="true"/>
                r#node_name = r#imported_attr.node_name().to_string(); // <nodeName var="nodeName" obj="importedAttr"/>
                r#node_value = r#imported_attr.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="importedAttr"/>
                r#node_type = r#imported_attr.node_type(); // <nodeType var="nodeType" obj="importedAttr"/>
                assert_eq!(r#node_name, "defaultAttr"); // <assertEquals expected="&quot;defaultAttr&quot;" actual="nodeName" id="documentimportnode04_nodeName" ignoreCase="false"/>
                assert_eq!(r#node_type as i32, 2); // <assertEquals expected="2" actual="nodeType" id="documentimportnode04_nodeType" ignoreCase="false"/>
                assert_eq!(r#node_value, "defaultVal"); // <assertEquals expected="&quot;defaultVal&quot;" actual="nodeValue" id="documentimportnode04_nodeValue" ignoreCase="false"/>
            }
            // getAttributeNS03.xml
            #[test]
            fn test_get_attribute_n_s03() {
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#local_name = "domestic"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;domestic&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                r#test_addr
                    .remove_attribute_ns(Some(r#namespace_uri), r#local_name)
                    .unwrap(); // <removeAttributeNS obj="testAddr" namespaceURI="namespaceURI" localName="localName"/>
                r#attr_value = r#test_addr
                    .get_attribute_ns(Some(r#namespace_uri), r#local_name)
                    .unwrap(); // <getAttributeNS obj="testAddr" var="attrValue" namespaceURI="namespaceURI" localName="localName"/>
                assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" id="throw_Equals" ignoreCase="false"/>
            }
            // elementremoveattributens01.xml
            #[test]
            fn test_elementremoveattributens01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM"), "elem".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM&quot;" qualifiedName="&quot;elem&quot;"/>
                r#attribute = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/DOM/Test/createAttributeNS"),
                        "attr".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="attribute" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/createAttributeNS&quot;" qualifiedName="&quot;attr&quot;"/>
                r#new_attribute = r#element.set_attribute_node_ns(r#attribute).unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="attribute"/>
                r#element
                    .remove_attribute_ns(
                        Some("http://www.w3.org/DOM/Test/createAttributeNS"),
                        "attr",
                    )
                    .unwrap(); // <removeAttributeNS obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/createAttributeNS&quot;" localName="&quot;attr&quot;"/>
                r#state = r#element
                    .has_attribute_ns(Some("http://www.w3.org/DOM/Test/createAttributeNS"), "attr")
                    .unwrap(); // <hasAttributeNS var="state" obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/createAttributeNS&quot;" localName="&quot;attr&quot;"/>
                assert!(!r#state); // <assertFalse actual="state" id="elementremoveattributens01"/>
            }
            // documentgetelementsbytagnameNS04.xml
            #[test]
            fn test_documentgetelementsbytagname_n_s04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#child_list = r#doc.get_elements_by_tag_name_ns(None, "0"); // <getElementsByTagNameNS var="childList" obj="doc" namespaceURI="nullNS" localName="&quot;0&quot;" interface="Document"/>
                assert_eq!(child_list.length(), 0); // <assertSize size="0" collection="childList" id="documentgetelementsbytagnameNS04"/>
            }
            // elementgetattributenodens01.xml
            #[test]
            fn test_elementgetattributenodens01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute1; // type: Attr // <var name="attribute1" type="Attr"/>
                let mut r#attribute2; // type: Attr // <var name="attribute2" type="Attr"/>
                let mut r#new_attribute1; // type: Attr // <var name="newAttribute1" type="Attr"/>
                let mut r#new_attribute2; // type: Attr // <var name="newAttribute2" type="Attr"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                let mut r#att_node_name; // type: DOMString // <var name="attNodeName" type="DOMString"/>
                let mut r#attr_local_name; // type: DOMString // <var name="attrLocalName" type="DOMString"/>
                let mut r#attr_ns; // type: DOMString // <var name="attrNS" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element = r#doc
                    .create_element_ns(Some("namespaceURI"), "root".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;namespaceURI&quot;" qualifiedName="&quot;root&quot;"/>
                r#attribute1 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Level2"), "l2:att".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute1" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Level2&quot;" qualifiedName="&quot;l2:att&quot;"/>
                r#new_attribute1 = r#element.set_attribute_node_ns(r#attribute1).unwrap(); // <setAttributeNodeNS var="newAttribute1" obj="element" newAttr="attribute1"/>
                r#attribute2 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Level1"), "att".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute2" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Level1&quot;" qualifiedName="&quot;att&quot;"/>
                r#new_attribute2 = r#element.set_attribute_node_ns(r#attribute2).unwrap(); // <setAttributeNodeNS var="newAttribute2" obj="element" newAttr="attribute2"/>
                r#attribute = r#element
                    .get_attribute_node_ns(Some("http://www.w3.org/DOM/Level2"), "att")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attribute" obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Level2&quot;" localName="&quot;att&quot;"/>
                r#attr_value = r#attribute.node_value().unwrap().to_string(); // <nodeValue var="attrValue" obj="attribute"/>
                r#attr_name = r#attribute.name().to_string(); // <name var="attrName" obj="attribute" interface="Attr"/>
                r#att_node_name = r#attribute.node_name().to_string(); // <nodeName var="attNodeName" obj="attribute"/>
                r#attr_local_name = r#attribute.local_name().unwrap().to_string(); // <localName var="attrLocalName" obj="attribute"/>
                r#attr_ns = r#attribute.namespace_uri().unwrap().to_string(); // <namespaceURI var="attrNS" obj="attribute"/>
                assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" id="elementgetattributenodens01_attrValue" ignoreCase="false"/>
                assert_eq!(r#attr_name, "l2:att"); // <assertEquals actual="attrName" expected="&quot;l2:att&quot;" id="elementgetattributenodens01_attrName" ignoreCase="false"/>
                assert_eq!(r#att_node_name, "l2:att"); // <assertEquals actual="attNodeName" expected="&quot;l2:att&quot;" id="elementgetattributenodens01_attrNodeName" ignoreCase="false"/>
                assert_eq!(r#attr_local_name, "att"); // <assertEquals actual="attrLocalName" expected="&quot;att&quot;" id="elementgetattributenodens01_attrLocalName" ignoreCase="false"/>
                assert_eq!(r#attr_ns, "http://www.w3.org/DOM/Level2"); // <assertEquals actual="attrNS" expected="&quot;http://www.w3.org/DOM/Level2&quot;" id="elementgetattributenodens01_attrNs" ignoreCase="false"/>
            }
            // createDocument05.xml
            #[test]
            fn test_create_document05() {
                let mut r#namespace_uri = "http://www.ecommerce.org/schema"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.ecommerce.org/schema&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#illegal_q_names = vec![
                    "namespaceURI:{",
                    "namespaceURI:}",
                    "namespaceURI:~",
                    "namespaceURI:'",
                    "namespaceURI:!",
                    "namespaceURI:@",
                    "namespaceURI:#",
                    "namespaceURI:$",
                    "namespaceURI:%",
                    "namespaceURI:^",
                    "namespaceURI:&",
                    "namespaceURI:*",
                    "namespaceURI:(",
                    "namespaceURI:)",
                    "namespaceURI:+",
                    "namespaceURI:=",
                    "namespaceURI:[",
                    "namespaceURI:]",
                    "namespaceURI:\\",
                    "namespaceURI:/",
                    "namespaceURI:;",
                    "namespaceURI:`",
                    "namespaceURI:<",
                    "namespaceURI:>",
                    "namespaceURI:,",
                    "namespaceURI:a ",
                    "namespaceURI:\"",
                ]; // type: List // <var name="illegalQNames" type="List"><member>"namespaceURI:{"</member><member>"namespaceURI:}"</member><member>"namespaceURI:~"</member><member>"namespaceURI:'"</member><member>"namespaceURI:!"</member><member>"namespaceURI:@"</member><member>"namespaceURI:#"</member><member>"namespaceURI:$"</member><member>"namespaceURI:%"</member><member>"namespaceURI:^"</member><member>"namespaceURI:&amp;"</member><member>"namespaceURI:*"</member><member>"namespaceURI:("</member><member>"namespaceURI:)"</member><member>"namespaceURI:+"</member><member>"namespaceURI:="</member><member>"namespaceURI:["</member><member>"namespaceURI:]"</member><member>"namespaceURI:\\"</member><member>"namespaceURI:/"</member><member>"namespaceURI:;"</member><member>"namespaceURI:`"</member><member>"namespaceURI:&lt;"</member><member>"namespaceURI:&gt;"</member><member>"namespaceURI:,"</member><member>"namespaceURI:a "</member><member>"namespaceURI:\""</member></var>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // <for-each collection="illegalQNames" member="qualifiedName">
                //  <implementation obj="doc" var="domImpl"/>
                //  <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //      <INVALID_CHARACTER_ERR>
                //          <createDocument obj="domImpl" var="aNewDoc" namespaceURI="namespaceURI" qualifiedName="qualifiedName" doctype="docType"/>
                //      </INVALID_CHARACTER_ERR>
                //  </assertDOMException>
                // </for-each>
                for qualified_name in illegal_q_names {
                    dom_impl = doc.implementation();
                    assert!(
                        dom_impl
                            .create_document(Some(namespace_uri), Some(qualified_name), None)
                            .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                    );
                }
            }
            // nodehasattributes02.xml
            #[test]
            fn test_nodehasattributes02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#has_attributes; // type: boolean // <var name="hasAttributes" type="boolean"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                r#has_attributes = r#doc_type.has_attributes(); // <hasAttributes var="hasAttributes" obj="docType"/>
                assert!(!r#has_attributes); // <assertFalse actual="hasAttributes" id="nodehasattributes02"/>
            }
            // namednodemapsetnameditemns07.xml
            #[test]
            fn test_namednodemapsetnameditemns07() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attr = r#attributes
                    .get_named_item_ns(Some("http://www.usa.com"), "domestic")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attr" obj="attributes" namespaceURI="&quot;http://www.usa.com&quot;" localName="&quot;domestic&quot;"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                // <assertDOMException id="namednodemapsetnameditemns07">
                //  <INUSE_ATTRIBUTE_ERR>
                //      <setNamedItemNS var="newNode" obj="attributes" arg="attr"/>
                //  </INUSE_ATTRIBUTE_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .set_named_item_ns(attr)
                        .is_err_and(|err| err == DOMException::InuseAttributeErr)
                );
            }
            // hc_nodedocumentfragmentnormalize1.xml
            #[test]
            fn test_hc_nodedocumentfragmentnormalize1() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_fragment; // type: DocumentFragment // <var name="docFragment" type="DocumentFragment"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                let mut r#txt_node; // type: Text // <var name="txtNode" type="Text"/>
                let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="docFragment"/>
                r#txt_node = r#doc.create_text_node("foo"); // <createTextNode var="txtNode" obj="doc" data="&quot;foo&quot;"/>
                r#retval = r#doc_fragment.append_child(txt_node.into()).unwrap(); // <appendChild var="retval" obj="docFragment" newChild="txtNode"/>
                r#txt_node = r#doc.create_text_node("bar"); // <createTextNode var="txtNode" obj="doc" data="&quot;bar&quot;"/>
                r#retval = r#doc_fragment.append_child(txt_node.into()).unwrap(); // <appendChild var="retval" obj="docFragment" newChild="txtNode"/>
                r#doc_fragment.normalize(); // <normalize obj="docFragment"/>
                r#txt_node = r#doc_fragment
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild var="txtNode" obj="docFragment" interface="Node"/>
                r#node_value = r#txt_node.node_value().unwrap().to_string(); // <nodeValue obj="txtNode" var="nodeValue"/>
                assert_eq!(r#node_value, "foobar"); // <assertEquals actual="nodeValue" expected="&quot;foobar&quot;" id="normalizedNodeValue" ignoreCase="false"/>
                let r#retval = r#txt_node.next_sibling(); // <nextSibling var="retval" obj="txtNode" interface="Node"/>
                assert!(retval.is_none()); // <assertNull actual="retval" id="singleChild"/>
            }
            // createAttributeNS01.xml
            #[test]
            fn test_create_attribute_n_s01() {
                let mut r#namespace_uri = "http://www.ecommerce.org/"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.ecommerce.org/&quot;"/>
                let mut r#malformed_name = "prefix::local"; // type: DOMString // <var name="malformedName" type="DOMString" value="&quot;prefix::local&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <createAttributeNS obj="doc" var="newAttr" namespaceURI="namespaceURI" qualifiedName="malformedName"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_attribute_ns(Some(namespace_uri), malformed_name)
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // createAttributeNS06.xml
            #[test]
            fn test_create_attribute_n_s06() {
                let mut r#namespace_uri = "http://www.example.com/"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.example.com/&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <createAttributeNS obj="doc" var="newAttr" namespaceURI="namespaceURI" qualifiedName="&quot;&quot;"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_attribute_ns(Some(namespace_uri), "")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // documenttypesystemid01.xml
            #[test]
            fn test_documenttypesystemid01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#public_id; // type: DOMString // <var name="publicId" type="DOMString"/>
                let mut r#system_id; // type: DOMString // <var name="systemId" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation var="domImpl" obj="doc"/>
                doc_type = dom_impl
                    .create_document_type("l2:root", Some("PUB"), Some("SYS"))
                    .unwrap(); // <createDocumentType var="docType" obj="domImpl" qualifiedName="&quot;l2:root&quot;" publicId="&quot;PUB&quot;" systemId="&quot;SYS&quot;"/>
                r#public_id = r#doc_type.public_id().unwrap().to_string(); // <publicId var="publicId" obj="docType" interface="DocumentType"/>
                r#system_id = r#doc_type.system_id().unwrap().to_string(); // <systemId var="systemId" obj="docType" interface="DocumentType"/>
                assert_eq!(r#public_id, "PUB"); // <assertEquals actual="publicId" expected="&quot;PUB&quot;" id="documenttypepublicid01" ignoreCase="false"/>
                assert_eq!(r#system_id, "SYS"); // <assertEquals actual="systemId" expected="&quot;SYS&quot;" id="documenttypesystemid01" ignoreCase="false"/>
            }
            // namednodemapsetnameditemns01.xml
            #[test]
            fn test_namednodemapsetnameditemns01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Node // <var name="element" type="Node"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#new_attr1; // type: Attr // <var name="newAttr1" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#new_attr1 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/L1"), "streets".as_ref())
                    .unwrap(); // <createAttributeNS var="newAttr1" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" qualifiedName="&quot;streets&quot;"/>
                r#new_attribute = r#element.set_attribute_node_ns(r#new_attr1).unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="newAttr1"/>
                r#attribute = r#attributes
                    .get_named_item_ns(Some("http://www.w3.org/DOM/L1"), "streets")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" localName="&quot;streets&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                assert_eq!(r#attr_name, "streets"); // <assertEquals actual="attrName" expected="&quot;streets&quot;" id="namednodemapsetnameditemns01" ignoreCase="false"/>
            }
            // getElementById01.xml
            #[test]
            fn test_get_element_by_id01() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#tagname; // type: DOMString // <var name="tagname" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element = r#doc.get_element_by_id("CANADA".as_ref()).unwrap(); // <getElementById interface="Document" obj="doc" var="element" elementId="&quot;CANADA&quot;"/>
                r#tagname = r#element.tag_name().to_string(); // <tagName obj="element" var="tagname"/>
                assert_eq!(r#tagname, "emp:address"); // <assertEquals actual="tagname" expected="&quot;emp:address&quot;" id="throw_Equals" ignoreCase="false"/>
            }
            // isSupported14.xml
            #[test]
            fn test_is_supported14() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                state = root_node.is_supported("Core", None); // <isSupported obj="rootNode" feature="&quot;Core&quot;" version="nullString" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="Core"/>
            }
            // namednodemapsetnameditemns05.xml
            #[test]
            fn test_namednodemapsetnameditemns05() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                entities = doc_type.entities(); // <entities var="entities" obj="docType"/>
                // unimplemented: // <assertNotNull actual="entities" id="entitiesNotNull"/>
                notations = doc_type.notations(); // <notations var="notations" obj="docType"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                r#entity = r#entities.get_named_item("ent1").unwrap(); // <getNamedItem var="entity" obj="entities" name="&quot;ent1&quot;"/>
                r#notation = r#notations.get_named_item("notation1").unwrap(); // <getNamedItem var="notation" obj="notations" name="&quot;notation1&quot;"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR_entities">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <setNamedItemNS var="newNode" obj="entities" arg="entity"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    entities
                        .set_named_item_ns(entity)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR_notations">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <setNamedItemNS var="newNode" obj="notations" arg="notation"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    notations
                        .set_named_item_ns(notation)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hasAttribute01.xml
            #[test]
            fn test_has_attribute01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_node; // type: Element // <var name="testNode" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_node = r#element_list.item(4).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="4"/>
                r#state = r#test_node.has_attribute("domestic"); // <hasAttribute obj="testNode" var="state" name="&quot;domestic&quot;"/>
                assert!(!r#state); // <assertFalse actual="state" id="throw_False"/>
            }
            // attrgetownerelement01.xml
            #[test]
            fn test_attrgetownerelement01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#owner_element; // type: Element // <var name="ownerElement" type="Element"/>
                let mut r#owner_element_name; // type: DOMString // <var name="ownerElementName" type="DOMString"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "employee"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;employee&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attr = r#attributes
                    .get_named_item_ns(None, "defaultAttr")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attr" obj="attributes" namespaceURI="nullNS" localName="&quot;defaultAttr&quot;"/>
                r#owner_element = r#attr.owner_element().unwrap(); // <ownerElement var="ownerElement" obj="attr"/>
                r#owner_element_name = r#owner_element.node_name().to_string(); // <nodeName var="ownerElementName" obj="ownerElement"/>
                assert_eq!(r#owner_element_name, "emp:employee"); // <assertEquals actual="ownerElementName" expected="&quot;emp:employee&quot;" id="attrgetownerelement01" ignoreCase="false"/>
            }
            // documentimportnode10.xml
            #[test]
            fn test_documentimportnode10() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_fragment; // type: DocumentFragment // <var name="docFragment" type="DocumentFragment"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                let mut r#address_node; // type: Node // <var name="addressNode" type="Node"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#imported_doc_frag; // type: Node // <var name="importedDocFrag" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment var="docFragment" obj="doc"/>
                r#child_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="childList" obj="doc" localName="&quot;address&quot;" namespaceURI="&quot;*&quot;" interface="Document"/>
                r#address_node = r#child_list.item(0).unwrap(); // <item var="addressNode" obj="childList" index="0" interface="NodeList"/>
                r#appended_child = r#doc_fragment.append_child(address_node.into()).unwrap(); // <appendChild var="appendedChild" obj="docFragment" newChild="addressNode"/>
                r#imported_doc_frag = r#doc.import_node(r#doc_fragment.into(), true).unwrap(); // <importNode var="importedDocFrag" obj="doc" importedNode="docFragment" deep="true"/>
                r#success = r#imported_doc_frag.has_child_nodes(); // <hasChildNodes var="success" obj="importedDocFrag"/>
                assert!(r#success); // <assertTrue actual="success" id="documentimportnode10"/>
            }
            // setNamedItemNS05.xml
            #[test]
            fn test_set_named_item_n_s05() {
                let mut r#namespace_uri = "http://www.usa.com"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.usa.com&quot;"/>
                let mut r#qualified_name = "dmstc:domestic"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;dmstc:domestic&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#arg; // type: Node // <var name="arg" type="Node"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#retnode; // type: Node // <var name="retnode" type="Node"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#arg = r#doc
                    .create_attribute_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                    .unwrap(); // <createAttributeNS obj="doc" var="arg" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                r#arg.set_node_value("newValue").unwrap(); // <nodeValue obj="arg" value="&quot;newValue&quot;"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="0"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                r#retnode = r#attributes.set_named_item_ns(r#arg).unwrap().unwrap(); // <setNamedItemNS interface="NamedNodeMap" obj="attributes" var="retnode" arg="arg"/>
                r#value = r#retnode.node_value().unwrap().to_string(); // <nodeValue obj="retnode" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="throw_Equals" ignoreCase="false"/>
            }
            // documentcreateelementNS01.xml
            #[test]
            fn test_documentcreateelement_n_s01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#namespace_uri = "http://www.w3.org/DOM/Test/level2"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/DOM/Test/level2&quot;"/>
                let mut r#qualified_name = "XML:XML"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;XML:XML&quot;"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#ns_uri; // type: DOMString // <var name="nsURI" type="DOMString"/>
                let mut r#local_name; // type: DOMString // <var name="localName" type="DOMString"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                let mut r#tag_name; // type: DOMString // <var name="tagName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element = r#doc
                    .create_element_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                    .unwrap(); // <createElementNS obj="doc" var="element" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                r#node_name = r#element.node_name().to_string(); // <nodeName var="nodeName" obj="element"/>
                r#ns_uri = r#element.namespace_uri().unwrap().to_string(); // <namespaceURI var="nsURI" obj="element"/>
                r#local_name = r#element.local_name().unwrap().to_string(); // <localName var="localName" obj="element"/>
                r#prefix = r#element.prefix().unwrap().to_string(); // <prefix var="prefix" obj="element"/>
                r#tag_name = r#element.tag_name().to_string(); // <tagName var="tagName" obj="element"/>
                assert_eq!(r#node_name, "XML:XML"); // <assertEquals actual="nodeName" expected="&quot;XML:XML&quot;" id="documentcreateelementNS01_nodeName" ignoreCase="false"/>
                assert_eq!(r#ns_uri, "http://www.w3.org/DOM/Test/level2"); // <assertEquals actual="nsURI" expected="&quot;http://www.w3.org/DOM/Test/level2&quot;" id="documentcreateelementNS01_namespaceURI" ignoreCase="false"/>
                assert_eq!(r#local_name, "XML"); // <assertEquals actual="localName" expected="&quot;XML&quot;" id="documentcreateelementNS01_localName" ignoreCase="false"/>
                assert_eq!(r#prefix, "XML"); // <assertEquals actual="prefix" expected="&quot;XML&quot;" id="documentcreateelementNS01_prefix" ignoreCase="false"/>
                assert_eq!(r#tag_name, "XML:XML"); // <assertEquals actual="tagName" expected="&quot;XML:XML&quot;" id="documentcreateelementNS01_tagName" ignoreCase="false"/>
            }
            // namednodemapremovenameditemns03.xml
            #[test]
            fn test_namednodemapremovenameditemns03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Node // <var name="element" type="Node"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#attribute1; // type: Attr // <var name="attribute1" type="Attr"/>
                let mut r#attribute2; // type: Attr // <var name="attribute2" type="Attr"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test"), "root".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;root&quot;"/>
                r#attribute1 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/L1"), "L1:att".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute1" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" qualifiedName="&quot;L1:att&quot;"/>
                r#new_attribute = r#element.set_attribute_node_ns(r#attribute1).unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="attribute1"/>
                r#attribute2 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/L2"), "L2:att".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute2" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/L2&quot;" qualifiedName="&quot;L2:att&quot;"/>
                r#new_attribute = r#element.set_attribute_node_ns(r#attribute2).unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="attribute2"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attribute = r#attributes
                    .remove_named_item_ns(Some("http://www.w3.org/DOM/L1"), "att")
                    .unwrap(); // <removeNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" localName="&quot;att&quot;"/>
                r#attribute = r#attributes
                    .get_named_item_ns(Some("http://www.w3.org/DOM/L2"), "att")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.w3.org/DOM/L2&quot;" localName="&quot;att&quot;"/>
                r#node_name = r#attribute.node_name().to_string(); // <nodeName var="nodeName" obj="attribute"/>
                assert_eq!(r#node_name, "L2:att"); // <assertEquals actual="nodeName" expected="&quot;L2:att&quot;" id="namednodemapremovenameditemns02" ignoreCase="false"/>
            }
            // nodeissupported05.xml
            #[test]
            fn test_nodeissupported05() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#pi = r#doc
                    .create_processing_instruction("PITarget", Some("PIData"))
                    .unwrap(); // <createProcessingInstruction var="pi" obj="doc" target="&quot;PITarget&quot;" data="&quot;PIData&quot;"/>
                success = pi.is_supported("-", Some("+")); // <isSupported obj="pi" var="success" feature="&quot;-&quot;" version="&quot;+&quot;"/>
                assert!(!r#success); // <assertFalse actual="success" id="nodeissupported05"/>
            }
            // domimplementationcreatedocument04.xml
            #[test]
            fn test_domimplementationcreatedocument04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                let mut r#qualified_name = "dom:root"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;dom:root&quot;"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                // <assertDOMException id="domimplementationcreatedocument04">
                //  <NAMESPACE_ERR>
                //      <createDocument obj="domImpl" var="newDoc" namespaceURI="namespaceURI" qualifiedName="qualifiedName" doctype="docType"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    dom_impl
                        .create_document(None, Some(qualified_name), None)
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // createDocumentType03.xml
            #[test]
            fn test_create_document_type03() {
                let mut r#namespace_uri = "http://ecommerce.org/schema"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://ecommerce.org/schema&quot;"/>
                let mut r#qualified_name = "prefix:myDoc"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;prefix:myDoc&quot;"/>
                let mut r#public_id = "http://www.localhost.com"; // type: DOMString // <var name="publicId" type="DOMString" value="&quot;http://www.localhost.com&quot;"/>
                let mut r#system_id = "myDoc.dtd"; // type: DOMString // <var name="systemId" type="DOMString" value="&quot;myDoc.dtd&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#new_type; // type: DocumentType // <var name="newType" type="DocumentType" isNull="true"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                new_type = dom_impl
                    .create_document_type(qualified_name, Some(public_id), Some(system_id))
                    .unwrap(); // <createDocumentType obj="domImpl" var="newType" qualifiedName="qualifiedName" publicId="publicId" systemId="systemId"/>
                r#node_name = r#new_type.node_name().to_string(); // <nodeName var="nodeName" obj="newType"/>
                assert_eq!(r#node_name, "prefix:myDoc"); // <assertEquals actual="nodeName" expected="&quot;prefix:myDoc&quot;" ignoreCase="false" id="nodeName"/>
                r#node_value = r#new_type.node_value(); // <nodeValue var="nodeValue" obj="newType"/>
                assert!(node_value.is_none()); // <assertNull actual="nodeValue" id="nodeValue"/>
            }
            // nodeissupported03.xml
            #[test]
            fn test_nodeissupported03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                success = doc_type.is_supported("", Some("")); // <isSupported obj="docType" var="success" feature="&quot;&quot;" version="&quot;&quot;"/>
                assert!(!r#success); // <assertFalse actual="success" id="nodeissupported03"/>
            }
            // importNode05.xml
            #[test]
            fn test_import_node05() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#has_child; // type: boolean // <var name="hasChild" type="boolean"/>
                let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                let mut r#addresses; // type: NodeList // <var name="addresses" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                r#addresses = r#a_new_doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName var="addresses" obj="aNewDoc" interface="Document" tagname="&quot;emp:address&quot;"/>
                r#element = r#addresses.item(0).unwrap(); // <item var="element" obj="addresses" interface="NodeList" index="0"/>
                // unimplemented: // <assertNotNull actual="element" id="empAddressNotNull"/>
                r#a_node = r#doc.import_node(r#element.into(), false).unwrap(); // <importNode obj="doc" var="aNode" importedNode="element" deep="false"/>
                r#has_child = r#a_node.has_child_nodes(); // <hasChildNodes obj="aNode" var="hasChild"/>
                assert!(!r#has_child); // <assertFalse actual="hasChild" id="hasChild"/>
                r#owner_document = r#a_node.owner_document().unwrap(); // <ownerDocument obj="aNode" var="ownerDocument"/>
                r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>
                assert_eq!(system, "staffNS.dtd"); // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="dtdSystemId"/>
                r#name = r#a_node.node_name().to_string(); // <nodeName obj="aNode" var="name"/>
                assert_eq!(r#name, "emp:address"); // <assertEquals actual="name" expected="&quot;emp:address&quot;" id="nodeName" ignoreCase="false"/>
            }
            // setAttributeNodeNS05.xml
            #[test]
            fn test_set_attribute_node_n_s05() {
                let mut r#namespace_uri = "http://www.newattr.com"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.newattr.com&quot;"/>
                let mut r#qualified_name = "emp:newAttr"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:newAttr&quot;"/>
                let mut r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let mut r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                r#doc1 = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc1" href="staffNS" willBeModified="true"/>
                r#doc2 = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc2" href="staffNS" willBeModified="true"/>
                r#new_attr = r#doc2
                    .create_attribute_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                    .unwrap(); // <createAttributeNS obj="doc2" var="newAttr" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                r#element_list = r#doc1.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc1" var="elementList" tagname="&quot;emp:address&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <setAttributeNodeNS var="setAttr1" obj="testAddr" newAttr="newAttr"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    test_addr
                        .set_attribute_node_ns(new_attr)
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // elementsetattributensurinull.xml
            #[test]
            fn test_elementsetattributensurinull() {
                let mut r#qualified_name = "emp:qualifiedName"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:qualifiedName&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <setAttributeNS obj="testAddr" namespaceURI="namespaceURI" qualifiedName="qualifiedName" value="&quot;newValue&quot;"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    test_addr
                        .set_attribute_ns(None, qualified_name, "newValue")
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // namednodemapremovenameditemns01.xml
            #[test]
            fn test_namednodemapremovenameditemns01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Node // <var name="element" type="Node"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attribute = r#attributes
                    .remove_named_item_ns(Some("http://www.nist.gov"), "domestic")
                    .unwrap(); // <removeNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;domestic&quot;"/>
                let r#attribute = r#attributes
                    .get_named_item_ns(Some("http://www.nist.gov"), "domestic")
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;domestic&quot;"/>
                assert!(attribute.is_none()); // <assertNull actual="attribute" id="namednodemapremovenameditemns01"/>
            }
            // domimplementationfeaturecore.xml
            #[test]
            fn test_domimplementationfeaturecore() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                state = dom_impl.has_feature("core", Some("2.0")); // <hasFeature obj="domImpl" var="state" feature="&quot;core&quot;" version="&quot;2.0&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="domimplementationFeaturecoreAssert"/>
            }
            // hc_nodedocumentfragmentnormalize2.xml
            #[test]
            fn test_hc_nodedocumentfragmentnormalize2() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_fragment; // type: DocumentFragment // <var name="docFragment" type="DocumentFragment"/>
                let mut r#txt_node; // type: Text // <var name="txtNode" type="Text"/>
                let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="docFragment"/>
                r#txt_node = r#doc.create_text_node(""); // <createTextNode var="txtNode" obj="doc" data="&quot;&quot;"/>
                r#retval = r#doc_fragment.append_child(txt_node.into()).unwrap(); // <appendChild var="retval" obj="docFragment" newChild="txtNode"/>
                r#doc_fragment.normalize(); // <normalize obj="docFragment"/>
                let r#txt_node = r#doc_fragment.first_child(); // <firstChild var="txtNode" obj="docFragment" interface="Node"/>
                assert!(txt_node.is_none()); // <assertNull actual="txtNode" id="noChild"/>
            }
            // nodeissupported02.xml
            #[test]
            fn test_nodeissupported02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#version = ""; // type: DOMString // <var name="version" type="DOMString" value="&quot;&quot;"/>
                let mut r#version1 = "1.0"; // type: DOMString // <var name="version1" type="DOMString" value="&quot;1.0&quot;"/>
                let mut r#version2 = "2.0"; // type: DOMString // <var name="version2" type="DOMString" value="&quot;2.0&quot;"/>
                let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                let mut r#features_xml = vec!["XML", "xmL"]; // type: List // <var name="featuresXML" type="List"><member>"XML"</member><member>"xmL"</member></var>
                let mut r#features_core = vec!["Core", "CORE"]; // type: List // <var name="featuresCore" type="List"><member>"Core"</member><member>"CORE"</member></var>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#attribute = r#doc.create_attribute("TestAttr".to_string()).unwrap(); // <createAttribute obj="doc" var="attribute" name="&quot;TestAttr&quot;"/>
                // <for-each collection="featuresXML" member="featureXML">
                //  <isSupported obj="attribute" var="success" feature="featureXML" version="version"/>
                //  <assertTrue actual="success" id="nodeissupported02_XML1"/>
                //  <isSupported obj="attribute" var="success" feature="featureXML" version="version1"/>
                //  <assertTrue actual="success" id="nodeissupported02_XML2"/>
                // </for-each>
                for feature_xml in features_xml {
                    success = attribute.is_supported(feature_xml, Some(version));
                    assert!(success);
                    success = attribute.is_supported(feature_xml, Some(version1));
                    assert!(success);
                }
                // <for-each collection="featuresCore" member="featureCore">
                //  <isSupported obj="attribute" var="success" feature="featureCore" version="version"/>
                //  <assertTrue actual="success" id="nodeissupported02_Core1"/>
                //  <!--   isSupported("Core", "1.0") is unspecified since "Core" was not defined in L1  -->
                //  <isSupported obj="attribute" var="success" feature="featureCore" version="version1"/>
                //  <isSupported obj="attribute" var="success" feature="featureCore" version="version2"/>
                //  <assertTrue actual="success" id="nodeissupported02_Core3"/>
                // </for-each>
                for feature_core in features_core {
                    success = attribute.is_supported(feature_core, Some(version));
                    assert!(success);
                    success = attribute.is_supported(feature_core, Some(version1));
                    success = attribute.is_supported(feature_core, Some(version2));
                }
            }
            // localName01.xml
            #[test]
            fn test_local_name01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                let mut r#addr_attr; // type: Attr // <var name="addrAttr" type="Attr"/>
                let mut r#local_name; // type: DOMString // <var name="localName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                r#addr_attr = r#test_addr.get_attribute_node("emp:domestic").unwrap(); // <getAttributeNode obj="testAddr" name="&quot;emp:domestic&quot;" var="addrAttr"/>
                r#local_name = r#addr_attr.local_name().unwrap().to_string(); // <localName obj="addrAttr" var="localName"/>
                assert_eq!(r#local_name, "domestic"); // <assertEquals actual="localName" expected="&quot;domestic&quot;" id="localName" ignoreCase="false"/>
            }
            // isSupported04.xml
            #[test]
            fn test_is_supported04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                state = root_node.is_supported("xml", Some("1.0")); // <isSupported obj="rootNode" feature="&quot;xml&quot;" version="&quot;1.0&quot;" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="throw_True"/>
            }
            // prefix02.xml
            #[test]
            fn test_prefix02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let mut r#text_node; // type: Node // <var name="textNode" type="Node"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:employeeId"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:employeeId&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                // unimplemented: // <assertNotNull actual="testEmployee" id="empEmployeeNotNull"/>
                r#text_node = r#test_employee.first_child().unwrap(); // <firstChild interface="Node" obj="testEmployee" var="textNode"/>
                r#prefix = r#text_node.prefix(); // <prefix obj="textNode" var="prefix"/>
                assert!(prefix.is_none()); // <assertNull actual="prefix" id="textNodePrefix"/>
            }
            // attrgetownerelement04.xml
            #[test]
            fn test_attrgetownerelement04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_imp: DocumentRef; // <var name="docImp" type="Document"/>
                let mut r#owner_element; // type: Node // <var name="ownerElement" type="Node"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#attr_imp; // type: Attr // <var name="attrImp" type="Attr"/>
                let mut r#addresses; // type: NodeList // <var name="addresses" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_imp = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="docImp" href="staff" willBeModified="false"/>
                r#addresses =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="addresses" obj="doc" interface="Document" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;"/>
                r#element = r#addresses.item(1).unwrap(); // <item var="element" obj="addresses" interface="NodeList" index="1"/>
                // unimplemented: // <assertNotNull actual="element" id="empAddressNotNull"/>
                r#attr = r#element
                    .get_attribute_node_ns(Some("http://www.nist.gov"), "zone")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attr" obj="element" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;zone&quot;"/>
                r#attr_imp = r#doc_imp
                    .import_node(r#attr.into(), true)
                    .unwrap()
                    .as_attribute()
                    .unwrap(); // <importNode var="attrImp" obj="docImp" importedNode="attr" deep="true"/>
                r#owner_element = r#attr_imp.owner_element(); // <ownerElement var="ownerElement" obj="attrImp"/>
                assert!(owner_element.is_none()); // <assertNull actual="ownerElement" id="attrgetownerelement04"/>
            }
            // namednodemapgetnameditemns04.xml
            #[test]
            fn test_namednodemapgetnameditemns04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attr1; // type: Attr // <var name="newAttr1" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#new_attr1 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/L1"), "street".as_ref())
                    .unwrap(); // <createAttributeNS var="newAttr1" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" qualifiedName="&quot;street&quot;"/>
                r#new_attribute = r#element.set_attribute_node_ns(r#new_attr1).unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="newAttr1"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attribute = r#attributes
                    .get_named_item_ns(Some("http://www.w3.org/DOM/L1"), "street")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" localName="&quot;street&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                assert_eq!(r#attr_name, "street"); // <assertEquals actual="attrName" expected="&quot;street&quot;" id="namednodemapgetnameditemns04" ignoreCase="false"/>
            }
            // nodegetownerdocument01.xml
            #[test]
            fn test_nodegetownerdocument01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#owner_doc: DocumentRef; // <var name="ownerDoc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation var="domImpl" obj="doc"/>
                doc_type = dom_impl.create_document_type("mydoc", None, None).unwrap(); // <createDocumentType var="docType" obj="domImpl" qualifiedName="&quot;mydoc&quot;" publicId="nullID" systemId="nullID"/>
                let r#owner_doc = r#doc_type.owner_document(); // <ownerDocument var="ownerDoc" obj="docType"/>
                assert!(owner_doc.is_none()); // <assertNull actual="ownerDoc" id="nodegetownerdocument01"/>
            }
            // elementsetattributens02.xml
            #[test]
            fn test_elementsetattributens02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                r#element
                    .set_attribute_ns(
                        Some("http://www.w3.org/DOM/Test/setAttributeNS"),
                        "this:street",
                        "Silver Street",
                    )
                    .unwrap(); // <setAttributeNS obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/setAttributeNS&quot;" qualifiedName="&quot;this:street&quot;" value="&quot;Silver Street&quot;"/>
                r#attribute = r#element
                    .get_attribute_node_ns(
                        Some("http://www.w3.org/DOM/Test/setAttributeNS"),
                        "street",
                    )
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attribute" obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/setAttributeNS&quot;" localName="&quot;street&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                r#attr_value = r#attribute.node_value().unwrap().to_string(); // <nodeValue var="attrValue" obj="attribute"/>
                assert_eq!(r#attr_name, "this:street"); // <assertEquals actual="attrName" expected="&quot;this:street&quot;" id="elementsetattributens02_attrName" ignoreCase="false"/>
                assert_eq!(r#attr_value, "Silver Street"); // <assertEquals actual="attrValue" expected="&quot;Silver Street&quot;" id="elementsetattributens02_attrValue" ignoreCase="false"/>
            }
            // hasAttributeNS02.xml
            #[test]
            fn test_has_attribute_n_s02() {
                let mut r#local_name = "domestic"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;domestic&quot;"/>
                let mut r#namespace_uri = "http://www.nomatch.com"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nomatch.com&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_node; // type: Element // <var name="testNode" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="0"/>
                r#state = r#test_node
                    .has_attribute_ns(Some(r#namespace_uri), r#local_name)
                    .unwrap(); // <hasAttributeNS obj="testNode" var="state" namespaceURI="namespaceURI" localName="localName"/>
                assert!(!r#state); // <assertFalse actual="state" id="throw_False"/>
            }
            // documentimportnode07.xml
            #[test]
            fn test_documentimportnode07() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                // <assertDOMException id="throw_NOT_SUPPORTED_ERR">
                //  <NOT_SUPPORTED_ERR>
                //      <importNode var="imported" obj="doc" importedNode="docType" deep="true"/>
                //  </NOT_SUPPORTED_ERR>
                // </assertDOMException>
                assert!(
                    doc.import_node(doc_type.into(), true)
                        .is_err_and(|err| err == DOMException::NotSupportedErr)
                );
            }
            // setAttributeNS06.xml
            #[test]
            fn test_set_attribute_n_s06() {
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#qualified_name = "xml:qualifiedName"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;xml:qualifiedName&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <setAttributeNS obj="testAddr" namespaceURI="namespaceURI" qualifiedName="qualifiedName" value="&quot;newValue&quot;"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    test_addr
                        .set_attribute_ns(Some(namespace_uri), qualified_name, "newValue")
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // createElementNS04.xml
            #[test]
            fn test_create_element_n_s04() {
                let mut r#namespace_uri = "http://www.w3.org/XML/1998/namespaces"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/XML/1998/namespaces&quot;"/>
                let mut r#qualified_name = "xml:element1"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;xml:element1&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <createElementNS obj="doc" var="newElement" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_element_ns(Some(namespace_uri), qualified_name)
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // documentcreateattributeNS01.xml
            #[test]
            fn test_documentcreateattribute_n_s01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#qualified_name = "test"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;test&quot;"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#attribute = r#doc
                    .create_attribute_ns(None, r#qualified_name.as_ref())
                    .unwrap(); // <createAttributeNS obj="doc" var="attribute" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                r#node_name = r#attribute.node_name().to_string(); // <nodeName var="nodeName" obj="attribute"/>
                r#node_value = r#attribute.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="attribute"/>
                assert_eq!(r#node_name, "test"); // <assertEquals actual="nodeName" expected="&quot;test&quot;" id="documentcreateattributeNS01" ignoreCase="false"/>
            }
            // namednodemapsetnameditemns03.xml
            #[test]
            fn test_namednodemapsetnameditemns03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_alt: DocumentRef; // <var name="docAlt" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#attributes_alt; // type: NamedNodeMap // <var name="attributesAlt" type="NamedNodeMap"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_list_alt; // type: NodeList // <var name="elementListAlt" type="NodeList"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#element_alt; // type: Element // <var name="elementAlt" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#doc_alt = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="docAlt" href="staffNS" willBeModified="true"/>
                r#element_list_alt = r#doc_alt.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementListAlt" obj="docAlt" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element_alt = r#element_list_alt.item(1).unwrap(); // <item var="elementAlt" obj="elementListAlt" index="1" interface="NodeList"/>
                r#attributes_alt = r#element_alt.attributes(); // <attributes var="attributesAlt" obj="elementAlt"/>
                r#attr = r#attributes_alt
                    .get_named_item_ns(None, "street")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attr" obj="attributesAlt" namespaceURI="nullNS" localName="&quot;street&quot;"/>
                r#new_node = r#attributes_alt
                    .remove_named_item_ns(None, "street")
                    .unwrap(); // <removeNamedItemNS var="newNode" obj="attributesAlt" namespaceURI="nullNS" localName="&quot;street&quot;"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <setNamedItemNS var="newNode" obj="attributes" arg="attr"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .set_named_item_ns(attr)
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // attrgetownerelement05.xml
            #[test]
            fn test_attrgetownerelement05() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Node // <var name="element" type="Node"/>
                let mut r#owner_element; // type: Element // <var name="ownerElement" type="Element"/>
                let mut r#parent_element; // type: Element // <var name="parentElement" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#owner_element_name; // type: DOMString // <var name="ownerElementName" type="DOMString"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#removed_child; // type: Node // <var name="removedChild" type="Node"/>
                let mut r#node_map; // type: NamedNodeMap // <var name="nodeMap" type="NamedNodeMap"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#parent_element = r#element.parent_node().unwrap(); // <parentNode interface="Node" var="parentElement" obj="element"/>
                r#node_map = r#element.attributes(); // <attributes var="nodeMap" obj="element"/>
                r#removed_child = r#parent_element.remove_child(element.into()).unwrap(); // <removeChild var="removedChild" obj="parentElement" oldChild="element"/>
                r#attr = r#node_map
                    .get_named_item_ns(None, "street")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attr" obj="nodeMap" namespaceURI="nullNS" localName="&quot;street&quot;"/>
                r#owner_element = r#attr.owner_element().unwrap(); // <ownerElement var="ownerElement" obj="attr"/>
                r#owner_element_name = r#owner_element.node_name().to_string(); // <nodeName var="ownerElementName" obj="ownerElement"/>
                assert_eq!(r#owner_element_name, "address"); // <assertEquals actual="ownerElementName" expected="&quot;address&quot;" id="attrgetownerelement05" ignoreCase="false"/>
            }
            // setAttributeNS03.xml
            #[test]
            fn test_set_attribute_n_s03() {
                let mut r#namespace_uri = "www.xyz.com"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;www.xyz.com&quot;"/>
                let mut r#qualified_name = "emp:local1"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:local1&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender; // type: Node // <var name="gender" type="Node"/>
                let mut r#gen_list; // type: NodeList // <var name="genList" type="NodeList"/>
                let mut r#gen; // type: Node // <var name="gen" type="Node"/>
                let mut r#g_list; // type: NodeList // <var name="gList" type="NodeList"/>
                let mut r#gen_element; // type: Element // <var name="genElement" type="Element"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#gen_list = r#gender.child_nodes(); // <childNodes obj="gender" var="genList"/>
                r#gen = r#gen_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="genList" var="gen" index="0"/>
                r#node_type = r#gen.node_type(); // <nodeType var="nodeType" obj="gen"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="gen" name="&quot;ent4&quot;" obj="doc"/>
                //  <assertNotNull actual="gen" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    r#gen = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#g_list = r#gen.child_nodes(); // <childNodes obj="gen" var="gList"/>
                r#gen_element = r#g_list.item(0).unwrap().clone().as_element().unwrap(); // <item interface="NodeList" obj="gList" var="genElement" index="0"/>
                // unimplemented: // <assertNotNull actual="genElement" id="notnull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <setAttributeNS obj="genElement" namespaceURI="namespaceURI" qualifiedName="qualifiedName" value="&quot;newValue&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    gen_element
                        .set_attribute_ns(Some(namespace_uri), qualified_name, "newValue")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodesetprefix02.xml
            #[test]
            fn test_nodesetprefix02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#set_node; // type: Node // <var name="setNode" type="Node"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                let mut r#new_attr_name; // type: DOMString // <var name="newAttrName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName var="elementList" obj="doc" tagname="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#new_attribute = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/DOM/Test"),
                        "test:address".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="newAttribute" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;test:address&quot;"/>
                r#set_node = r#element
                    .set_attribute_node_ns(r#new_attribute.clone())
                    .unwrap(); // <setAttributeNodeNS var="setNode" obj="element" newAttr="newAttribute"/>
                r#new_attribute.set_prefix(Some("dom")).unwrap(); // <prefix obj="newAttribute" value="&quot;dom&quot;"/>
                r#attribute = r#element
                    .get_attribute_node_ns(Some("http://www.usa.com"), "domestic")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attribute" obj="element" namespaceURI="&quot;http://www.usa.com&quot;" localName="&quot;domestic&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                r#new_attr_name = r#new_attribute.node_name().to_string(); // <nodeName var="newAttrName" obj="newAttribute"/>
                assert_eq!(r#attr_name, "dmstc:domestic"); // <assertEquals actual="attrName" expected="&quot;dmstc:domestic&quot;" id="nodesetprefix02_attrName" ignoreCase="false"/>
                assert_eq!(r#new_attr_name, "dom:address"); // <assertEquals actual="newAttrName" expected="&quot;dom:address&quot;" id="nodesetprefix02_newAttrName" ignoreCase="false"/>
            }
            // ownerDocument01.xml
            #[test]
            fn test_owner_document01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#owner_document; // type: DocumentType // <var name="ownerDocument" type="DocumentType"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#owner_document = r#doc.owner_document(); // <ownerDocument obj="doc" var="ownerDocument"/>
                assert!(owner_document.is_none()); // <assertNull actual="ownerDocument" id="throw_Null"/>
            }
            // removeNamedItemNS02.xml
            #[test]
            fn test_remove_named_item_n_s02() {
                let mut r#namespace_uri = "http://www.usa.com"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.usa.com&quot;"/>
                let mut r#local_name = "domest"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;domest&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="1"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <removeNamedItemNS var="removedNode" interface="NamedNodeMap" obj="attributes" namespaceURI="namespaceURI" localName="localName"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .remove_named_item_ns(Some(namespace_uri), local_name)
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // setAttributeNS01.xml
            #[test]
            fn test_set_attribute_n_s01() {
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#qualified_name = "emp:qual?name"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:qual?name&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <setAttributeNS obj="testAddr" namespaceURI="namespaceURI" qualifiedName="qualifiedName" value="&quot;newValue&quot;"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    test_addr
                        .set_attribute_ns(Some(namespace_uri), qualified_name, "newValue")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // namednodemapremovenameditemns06.xml
            #[test]
            fn test_namednodemapremovenameditemns06() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Node // <var name="element" type="Node"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "employee"); // <getElementsByTagNameNS var="elementList" obj="doc" localName="&quot;employee&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <removeNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.Nist.gov&quot;" localName="&quot;domestic&quot;"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .remove_named_item_ns(Some("http://www.Nist.gov"), "domestic")
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // importNode03.xml
            #[test]
            fn test_import_node03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                r#comment = r#a_new_doc.create_comment("this is a comment"); // <createComment obj="aNewDoc" var="comment" data="&quot;this is a comment&quot;"/>
                r#a_node = r#doc.import_node(r#comment.into(), false).unwrap(); // <importNode obj="doc" var="aNode" importedNode="comment" deep="false"/>
                r#owner_document = r#a_node.owner_document().unwrap(); // <ownerDocument obj="aNode" var="ownerDocument"/>
                // unimplemented: // <assertNotNull actual="ownerDocument" id="ownerDocumentNotNull"/>
                r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>
                assert_eq!(system, "staffNS.dtd"); // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="systemId"/>
                r#value = r#a_node.node_value().unwrap().to_string(); // <nodeValue obj="aNode" var="value"/>
                assert_eq!(r#value, "this is a comment"); // <assertEquals actual="value" expected="&quot;this is a comment&quot;" id="nodeValue" ignoreCase="false"/>
            }
            // createDocumentType01.xml
            #[test]
            fn test_create_document_type01() {
                let mut r#public_id = "STAFF"; // type: DOMString // <var name="publicId" type="DOMString" value="&quot;STAFF&quot;"/>
                let mut r#system_id = "staff.xml"; // type: DOMString // <var name="systemId" type="DOMString" value="&quot;staff.xml&quot;"/>
                let mut r#malformed_name = "prefix::local"; // type: DOMString // <var name="malformedName" type="DOMString" value="&quot;prefix::local&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <createDocumentType obj="domImpl" var="newType" publicId="publicId" qualifiedName="malformedName" systemId="systemId"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    dom_impl
                        .create_document_type(malformed_name, Some(public_id), Some(system_id))
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // elementsetattributenodens02.xml
            #[test]
            fn test_elementsetattributenodens02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#element2; // type: Element // <var name="element2" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#attribute_cloned; // type: Attr // <var name="attributeCloned" type="Attr"/>
                let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attribute = r#element
                    .get_attribute_node_ns(None, "street")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attribute" obj="element" namespaceURI="nullNS" localName="&quot;street&quot;"/>
                r#attribute_cloned = r#attribute.clone_node(true); // <cloneNode var="attributeCloned" obj="attribute" deep="true"/>
                r#element2 = r#element_list.item(2).unwrap(); // <item var="element2" obj="elementList" index="2" interface="NodeList"/>
                r#new_attr = r#element2
                    .set_attribute_node_ns(r#attribute_cloned.as_attribute().unwrap())
                    .unwrap()
                    .unwrap(); // <setAttributeNodeNS var="newAttr" obj="element2" newAttr="attributeCloned"/>
                r#attr_name = r#new_attr.node_name().to_string(); // <nodeName var="attrName" obj="newAttr"/>
                r#attr_value = r#new_attr.node_value().unwrap().to_string(); // <nodeValue var="attrValue" obj="newAttr"/>
                assert_eq!(r#attr_name, "street"); // <assertEquals actual="attrName" expected="&quot;street&quot;" id="elementsetattributenodens02_attrName" ignoreCase="false"/>
                assert_eq!(r#attr_value, "Yes"); // <assertEquals actual="attrValue" expected="&quot;Yes&quot;" id="elementsetattributenodens02_attrValue" ignoreCase="false"/>
            }
            // documentimportnode11.xml
            #[test]
            fn test_documentimportnode11() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_element; // type: Element // <var name="docElement" type="Element"/>
                let mut r#imported; // type: Node // <var name="imported" type="Node"/>
                let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                let mut r#node_name_orig; // type: DOMString // <var name="nodeNameOrig" type="DOMString"/>
                let mut r#node_name_imported; // type: DOMString // <var name="nodeNameImported" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_element = r#doc.document_element().unwrap(); // <documentElement var="docElement" obj="doc"/>
                r#imported = r#doc
                    .import_node(r#doc_element.clone().into(), false)
                    .unwrap(); // <importNode var="imported" obj="doc" importedNode="docElement" deep="false"/>
                r#success = r#imported.has_child_nodes(); // <hasChildNodes var="success" obj="imported"/>
                assert!(!r#success); // <assertFalse actual="success" id="documentimportnode11"/>
                r#node_name_imported = r#imported.node_name().to_string(); // <nodeName var="nodeNameImported" obj="imported"/>
                r#node_name_orig = r#doc_element.node_name().to_string(); // <nodeName var="nodeNameOrig" obj="docElement"/>
                assert_eq!(r#node_name_orig, node_name_imported); // <assertEquals actual="nodeNameOrig" expected="nodeNameImported" id="documentimportnode11_NodeName" ignoreCase="false"/>
            }
            // nodesetprefix01.xml
            #[test]
            fn test_nodesetprefix01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_fragment; // type: DocumentFragment // <var name="docFragment" type="DocumentFragment"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#element_tag_name; // type: DOMString // <var name="elementTagName" type="DOMString"/>
                let mut r#element_node_name; // type: DOMString // <var name="elementNodeName" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment var="docFragment" obj="doc"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test"), "emp:address".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;emp:address&quot;"/>
                r#appended_child = r#doc_fragment.append_child(element.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="docFragment" newChild="element"/>
                r#element.set_prefix(Some("dmstc")).unwrap(); // <prefix obj="element" value="&quot;dmstc&quot;"/>
                r#element_tag_name = r#element.tag_name().to_string(); // <tagName var="elementTagName" obj="element"/>
                r#element_node_name = r#element.node_name().to_string(); // <nodeName var="elementNodeName" obj="element"/>
                assert_eq!(r#element_tag_name, "dmstc:address"); // <assertEquals actual="elementTagName" expected="&quot;dmstc:address&quot;" id="nodesetprefix01_tagname" ignoreCase="false"/>
                assert_eq!(r#element_node_name, "dmstc:address"); // <assertEquals actual="elementNodeName" expected="&quot;dmstc:address&quot;" id="nodesetprefix01_nodeName" ignoreCase="false"/>
            }
            // getElementsByTagNameNS12.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s12() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#element_list = r#doc_elem
                    .get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "nomatch")
                    .unwrap(); // <getElementsByTagNameNS interface="Element" obj="docElem" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;nomatch&quot;" var="elementList"/>
                assert_eq!(element_list.length(), 0); // <assertSize collection="elementList" size="0" id="size"/>
            }
            // hc_entitiessetnameditemns1.xml
            #[test]
            fn test_hc_entitiessetnameditemns1() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <if><not><contentType type="text/html"/></not><assertNotNull actual="docType" id="docTypeNotNull"/><entities var="entities" obj="docType"/><assertNotNull actual="entities" id="entitiesNotNull"/><createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;br&quot;"/><try>	<setNamedItemNS var="retval" obj="entities" arg="elem"/>	<fail id="throw_HIER_OR_NO_MOD_ERR"/>	<catch>		<DOMException code="HIERARCHY_REQUEST_ERR"/>		<DOMException code="NO_MODIFICATION_ALLOWED_ERR"/>	</catch></try> </if>
            }
            // getElementsByTagNameNS02.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_list; // type: NodeList // <var name="newList" type="NodeList"/>
                let mut r#new_element; // type: Element // <var name="newElement" type="Element"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                let mut r#lname; // type: DOMString // <var name="lname" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#new_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "employee"); // <getElementsByTagNameNS interface="Document" obj="doc" var="newList" namespaceURI="&quot;*&quot;" localName="&quot;employee&quot;"/>
                assert_eq!(new_list.length(), 5); // <assertSize collection="newList" size="5" id="employeeCount"/>
                r#new_element = r#new_list.item(3).unwrap(); // <item interface="NodeList" obj="newList" var="newElement" index="3"/>
                r#prefix = r#new_element.prefix().unwrap().to_string(); // <prefix obj="newElement" var="prefix"/>
                assert_eq!(r#prefix, "emp"); // <assertEquals actual="prefix" expected="&quot;emp&quot;" id="prefix" ignoreCase="false"/>
                r#lname = r#new_element.local_name().unwrap().to_string(); // <localName obj="newElement" var="lname"/>
                assert_eq!(r#lname, "employee"); // <assertEquals actual="lname" expected="&quot;employee&quot;" id="lname" ignoreCase="false"/>
            }
            // createDocument03.xml
            #[test]
            fn test_create_document03() {
                let mut r#namespace_uri = "http://www.ecommerce.org/schema"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.ecommerce.org/schema&quot;"/>
                let mut r#qualified_name = "namespaceURI:x"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;namespaceURI:x&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <createDocument obj="domImpl" var="aNewDoc" namespaceURI="namespaceURI" qualifiedName="qualifiedName" doctype="docType"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    dom_impl
                        .create_document(Some(namespace_uri), Some(qualified_name), Some(doc_type))
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // setNamedItemNS03.xml
            #[test]
            fn test_set_named_item_n_s03() {
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#qualified_name = "prefix:newAttr"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;prefix:newAttr&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#arg; // type: Node // <var name="arg" type="Node"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#retnode; // type: Node // <var name="retnode" type="Node"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let mut r#set_node; // type: Node // <var name="setNode" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#arg = r#doc
                    .create_attribute_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                    .unwrap(); // <createAttributeNS obj="doc" var="arg" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                r#arg.set_node_value("newValue").unwrap(); // <nodeValue obj="arg" value="&quot;newValue&quot;"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="0"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                r#set_node = r#attributes.set_named_item_ns(r#arg).unwrap(); // <setNamedItemNS var="setNode" interface="NamedNodeMap" obj="attributes" arg="arg"/>
                r#retnode = r#attributes
                    .get_named_item_ns(Some(r#namespace_uri), "newAttr")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS obj="attributes" var="retnode" namespaceURI="namespaceURI" localName="&quot;newAttr&quot;"/>
                r#value = r#retnode.node_value().unwrap().to_string(); // <nodeValue obj="retnode" var="value"/>
                assert_eq!(r#value, "newValue"); // <assertEquals actual="value" expected="&quot;newValue&quot;" id="throw_Equals" ignoreCase="false"/>
            }
            // prefix11.xml
            #[test]
            fn test_prefix11() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                // r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>

                // // unimplemented: // <if><contentType type="image/svg+xml"/><createElementNS var="employeeNode" obj="doc" namespaceURI="nullNS" qualifiedName="&quot;employee&quot;"/></if>
                // r#namespace_uri = r#employee_node.namespace_uri().unwrap().to_string();
                // // <namespaceURI obj="employeeNode" var="namespaceURI"/>

                // // unimplemented: // <assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><prefix obj="employeeNode" value="&quot;employee1&quot;"/></NAMESPACE_ERR></assertDOMException>

                // // unimplemented: // <assertNull actual="namespaceURI" id="employeeNS"/>
            }
            // isSupported13.xml
            #[test]
            fn test_is_supported13() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                state = root_node.is_supported("Core", Some("")); // <isSupported obj="rootNode" feature="&quot;Core&quot;" version="&quot;&quot;" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="Core"/>
            }
            // getAttributeNodeNS01.xml
            #[test]
            fn test_get_attribute_node_n_s01() {
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#local_name = "invalidlocalname"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;invalidlocalname&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                r#attribute = r#test_addr
                    .get_attribute_node_ns(Some(r#namespace_uri), r#local_name)
                    .unwrap(); // <getAttributeNodeNS obj="testAddr" var="attribute" namespaceURI="namespaceURI" localName="localName"/>
                assert!(attribute.is_none()); // <assertNull actual="attribute" id="throw_Null"/>
            }
            // nodehasattributes03.xml
            #[test]
            fn test_nodehasattributes03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#has_attributes; // type: boolean // <var name="hasAttributes" type="boolean"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:employee"); // <getElementsByTagName var="elementList" obj="doc" tagname="&quot;emp:employee&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                // unimplemented: // <assertNotNull actual="element" id="empEmployeeNotNull"/>
                r#has_attributes = r#element.has_attributes(); // <hasAttributes var="hasAttributes" obj="element"/>
                assert!(r#has_attributes); // <assertTrue actual="hasAttributes" id="hasAttributes"/>
            }
            // setNamedItemNS04.xml
            #[test]
            fn test_set_named_item_n_s04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#namespace_uri = "http://www.w3.org/2000/xmlns/"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/2000/xmlns/&quot;"/>
                let mut r#local_name = "local1"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;local1&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#n_list; // type: NodeList // <var name="nList" type="NodeList"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#n2_list; // type: NodeList // <var name="n2List" type="NodeList"/>
                let mut r#child2; // type: Node // <var name="child2" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#arg; // type: Node // <var name="arg" type="Node"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;gender&quot;"/>
                r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                r#n_list = r#test_address.child_nodes(); // <childNodes obj="testAddress" var="nList"/>
                r#child = r#n_list.item(0).unwrap(); // <item interface="NodeList" obj="nList" var="child" index="0"/>
                r#node_type = r#child.node_type(); // <nodeType var="nodeType" obj="child"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="child" name="&quot;ent4&quot;" obj="doc"/>
                //  <assertNotNull actual="child" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    child = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#n2_list = r#child.child_nodes(); // <childNodes obj="child" var="n2List"/>
                r#child2 = r#n2_list.item(0).unwrap(); // <item interface="NodeList" obj="n2List" var="child2" index="0"/>
                // unimplemented: // <assertNotNull actual="child2" id="notnull"/>
                r#attributes = r#child2.attributes().unwrap(); // <attributes obj="child2" var="attributes"/>
                r#arg = r#attributes
                    .get_named_item_ns(Some(r#namespace_uri), r#local_name)
                    .unwrap()
                    .unwrap(); // <getNamedItemNS obj="attributes" var="arg" namespaceURI="namespaceURI" localName="localName"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <setNamedItemNS var="setNode" interface="NamedNodeMap" obj="attributes" arg="arg"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .set_named_item_ns(arg)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // attrgetownerelement02.xml
            #[test]
            fn test_attrgetownerelement02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#owner_element; // type: Element // <var name="ownerElement" type="Element"/>
                let mut r#owner_element_name; // type: DOMString // <var name="ownerElementName" type="DOMString"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element = r#doc.create_element("root".to_string()).unwrap(); // <createElement var="element" obj="doc" tagName="&quot;root&quot;"/>
                r#attr = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/L1"), "L1:att".as_ref())
                    .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" qualifiedName="&quot;L1:att&quot;"/>
                r#new_attr = r#element.set_attribute_node_ns(r#attr.clone()).unwrap(); // <setAttributeNodeNS var="newAttr" obj="element" newAttr="attr"/>
                r#owner_element = r#attr.owner_element().unwrap(); // <ownerElement var="ownerElement" obj="attr"/>
                r#owner_element_name = r#owner_element.node_name().to_string(); // <nodeName var="ownerElementName" obj="ownerElement"/>
                assert_eq!(r#owner_element_name, "root"); // <assertEquals actual="ownerElementName" expected="&quot;root&quot;" id="attrgetownerelement02" ignoreCase="true"/>
            }
            // domimplementationcreatedocumenttype01.xml
            #[test]
            fn test_domimplementationcreatedocumenttype01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#new_doc_type; // type: DocumentType // <var name="newDocType" type="DocumentType"/>
                let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                let mut r#qualified_name = "test:root"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;test:root&quot;"/>
                let mut r#public_ids = vec!["1234", "test"]; // type: List // <var name="publicIds" type="List"><member>"1234"</member><member>"test"</member></var>
                let mut r#system_ids = vec!["", "test"]; // type: List // <var name="systemIds" type="List"><member>""</member><member>"test"</member></var>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                // <for-each collection="publicIds" member="publicId">
                //  <for-each collection="systemIds" member="systemId">
                //      <createDocumentType obj="domImpl" var="newDocType" qualifiedName="qualifiedName" publicId="publicId" systemId="systemId"/>
                //      <assertNotNull actual="newDocType" id="domimplementationcreatedocumenttype01_newDocType"/>
                //      <ownerDocument obj="newDocType" var="ownerDocument"/>
                //      <assertNull actual="ownerDocument" id="domimplementationcreatedocumenttype01_ownerDocument"/>
                //  </for-each>
                // </for-each>
                for public_id in public_ids {
                    for &system_id in &system_ids {
                        new_doc_type = dom_impl
                            .create_document_type(qualified_name, Some(public_id), Some(system_id))
                            .unwrap();
                        let owner_document = new_doc_type.owner_document();
                        assert!(owner_document.is_none());
                    }
                }
            }
            // setNamedItemNS01.xml
            #[test]
            fn test_set_named_item_n_s01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#another_element; // type: Node // <var name="anotherElement" type="Node"/>
                let mut r#another_map; // type: NamedNodeMap // <var name="anotherMap" type="NamedNodeMap"/>
                let mut r#arg; // type: Node // <var name="arg" type="Node"/>
                let mut r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#map; // type: NamedNodeMap // <var name="map" type="NamedNodeMap"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#another_element = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="anotherElement" index="2"/>
                r#another_map = r#another_element.attributes(); // <attributes obj="anotherElement" var="anotherMap"/>
                r#arg = r#another_map
                    .get_named_item_ns(Some("http://www.netzero.com"), "domestic")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS obj="anotherMap" var="arg" namespaceURI="&quot;http://www.netzero.com&quot;" localName="&quot;domestic&quot;"/>
                r#test_address = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="0"/>
                r#map = r#test_address.attributes(); // <attributes obj="testAddress" var="map"/>
                // <assertDOMException id="throw_INUSE_ATTRIBUTE_ERR">
                //  <INUSE_ATTRIBUTE_ERR>
                //      <setNamedItemNS var="setNode" interface="NamedNodeMap" obj="map" arg="arg"/>
                //  </INUSE_ATTRIBUTE_ERR>
                // </assertDOMException>
                assert!(
                    map.set_named_item_ns(arg)
                        .is_err_and(|err| err == DOMException::InuseAttributeErr)
                );
            }
            // importNode11.xml
            #[test]
            fn test_import_node11() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_value; // type: DOMString // <var name="childValue" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#a_new_doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="aNewDoc" href="staff" willBeModified="true"/>
                r#ent_ref = r#a_new_doc
                    .create_entity_reference("ent3".to_string())
                    .unwrap(); // <createEntityReference obj="aNewDoc" var="entRef" name="&quot;ent3&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                r#a_node = r#doc.import_node(r#ent_ref.into(), true).unwrap(); // <importNode obj="doc" var="aNode" importedNode="entRef" deep="true"/>
                r#name = r#a_node.node_name().to_string(); // <nodeName obj="aNode" var="name"/>
                assert_eq!(r#name, "ent3"); // <assertEquals actual="name" id="entityName" expected="&quot;ent3&quot;" ignoreCase="false"/>
                r#child = r#a_node.first_child().unwrap(); // <firstChild interface="Node" obj="aNode" var="child"/>
                // unimplemented: // <assertNotNull id="child" actual="child"/>
                r#child_value = r#child.node_value().unwrap().to_string(); // <nodeValue obj="child" var="childValue"/>
                assert_eq!(r#child_value, "Texas"); // <assertEquals actual="childValue" id="childValue" expected="&quot;Texas&quot;" ignoreCase="false"/>
            }
            // documentimportnode02.xml
            #[test]
            fn test_documentimportnode02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_imported: DocumentRef; // <var name="docImported" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#imported_attr; // type: Node // <var name="importedAttr" type="Node"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                let mut r#addresses; // type: NodeList // <var name="addresses" type="NodeList"/>
                let mut r#attrs_parent; // type: Node // <var name="attrsParent" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_imported = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="docImported" href="staff" willBeModified="true"/>
                r#addresses =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="addresses" obj="doc" interface="Document" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;"/>
                r#element = r#addresses.item(1).unwrap(); // <item var="element" obj="addresses" interface="NodeList" index="1"/>
                r#attr = r#element
                    .get_attribute_node_ns(Some("http://www.nist.gov"), "zone")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attr" obj="element" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;zone&quot;"/>
                r#imported_attr = r#doc_imported.import_node(r#attr.into(), false).unwrap(); // <importNode var="importedAttr" obj="docImported" importedNode="attr" deep="false"/>
                r#node_name = r#imported_attr.node_name().to_string(); // <nodeName var="nodeName" obj="importedAttr"/>
                r#node_type = r#imported_attr.node_type(); // <nodeType var="nodeType" obj="importedAttr"/>
                r#node_value = r#imported_attr.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="importedAttr"/>
                r#attrs_parent = r#imported_attr.parent_node(); // <parentNode var="attrsParent" obj="importedAttr" interface="Node"/>
                assert!(attrs_parent.is_none()); // <assertNull actual="attrsParent" id="documentimportnode02_parentNull"/>
                assert_eq!(r#node_name, "emp:zone"); // <assertEquals expected="&quot;emp:zone&quot;" actual="nodeName" id="documentimportnode02_nodeName" ignoreCase="false"/>
                assert_eq!(r#node_type as i32, 2); // <assertEquals expected="2" actual="nodeType" id="documentimportnode02_nodeType" ignoreCase="false"/>
                assert_eq!(r#node_value, "CANADA"); // <assertEquals expected="&quot;CANADA&quot;" actual="nodeValue" id="documentimportnode02_nodeValue" ignoreCase="false"/>
            }
            // hc_namednodemapinvalidtype1.xml
            #[test]
            fn test_hc_namednodemapinvalidtype1() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#new_elem; // type: Element // <var name="newElem" type="Element"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#attributes = r#doc_elem.attributes(); // <attributes var="attributes" obj="docElem"/>
                // r#new_elem = r#doc.create_element("html".to_string()).unwrap(); // <createElement var="newElem" obj="doc" tagName="&quot;html&quot;"/>
                // // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                // //  <HIERARCHY_REQUEST_ERR>
                // //      <setNamedItem var="retval" obj="attributes" arg="newElem"/>
                // //  </HIERARCHY_REQUEST_ERR>
                // // </assertDOMException>
                // assert!(
                //     attributes
                //         .set_named_item(new_elem)
                //         .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                // );
            }
            // importNode15.xml
            #[test]
            fn test_import_node15() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#text; // type: Text // <var name="text" type="Text"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                r#text = r#a_new_doc.create_text_node("this is text data"); // <createTextNode obj="aNewDoc" var="text" data="&quot;this is text data&quot;"/>
                r#a_node = r#doc.import_node(r#text.into(), false).unwrap(); // <importNode obj="doc" var="aNode" importedNode="text" deep="false"/>
                r#owner_document = r#a_node.owner_document().unwrap(); // <ownerDocument obj="aNode" var="ownerDocument"/>
                // unimplemented: // <assertNotNull actual="ownerDocument" id="ownerDocumentNotNull"/>
                r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>
                assert_eq!(system, "staffNS.dtd"); // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="systemId"/>
                r#value = r#a_node.node_value().unwrap().to_string(); // <nodeValue obj="aNode" var="value"/>
                assert_eq!(r#value, "this is text data"); // <assertEquals actual="value" expected="&quot;this is text data&quot;" id="nodeValue" ignoreCase="false"/>
            }
            // prefix06.xml
            #[test]
            fn test_prefix06() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="employeeNode"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <prefix obj="employeeNode" value="&quot;pre^fix xmlns='http//www.nist.gov'&quot;"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    employee_node
                        .set_prefix(Some("pre^fix xmlns='http//www.nist.gov'"))
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // elementsetattributens05.xml
            #[test]
            fn test_elementsetattributens05() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test/L2"), "dom:elem".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/L2&quot;" qualifiedName="&quot;dom:elem&quot;"/>
                // <assertDOMException id="elementsetattributens05">
                //  <NAMESPACE_ERR>
                //      <setAttributeNS obj="element" namespaceURI="nullNS" qualifiedName="&quot;dom:root&quot;" value="&quot;test&quot;"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    element
                        .set_attribute_ns(None, "dom:root", "test")
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // createAttributeNS04.xml
            #[test]
            fn test_create_attribute_n_s04() {
                let mut r#namespace_uri = "http://www.w3.org/XML/1998/namespaces"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/XML/1998/namespaces&quot;"/>
                let mut r#qualified_name = "xml:attr1"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;xml:attr1&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <createAttributeNS obj="doc" var="newAttr" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_attribute_ns(Some(namespace_uri), qualified_name)
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // createAttributeNS02.xml
            #[test]
            fn test_create_attribute_n_s02() {
                let mut r#qualified_name = "prefix:local"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;prefix:local&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <createAttributeNS obj="doc" var="newAttr" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_attribute_ns(None, qualified_name)
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // getNamedItemNS04.xml
            #[test]
            fn test_get_named_item_n_s04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                notations = doc_type.notations(); // <notations var="notations" obj="docType"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                r#notation = r#notations.get_named_item_ns(None, "notation1").unwrap(); // <getNamedItemNS var="notation" obj="notations" namespaceURI="nullNS" localName="&quot;notation1&quot;"/>
                assert!(notation.is_none()); // <assertNull actual="notation" id="notationNull"/>
            }
            // nodeissupported04.xml
            #[test]
            fn test_nodeissupported04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#ent_ref = r#doc.create_entity_reference("ent1".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent1&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                success = ent_ref.is_supported("XML CORE", Some("")); // <isSupported obj="entRef" var="success" feature="&quot;XML CORE&quot;" version="&quot;&quot;"/>
                assert!(!r#success); // <assertFalse actual="success" id="nodeissupported04"/>
            }
            // documentcreateelementNS02.xml
            #[test]
            fn test_documentcreateelement_n_s02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#qualified_name = "^^"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;^^&quot;"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // <assertDOMException id="documentcreateelementNS02">
                //  <INVALID_CHARACTER_ERR>
                //      <createElementNS obj="doc" var="element" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_element_ns(None, qualified_name)
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // domimplementationcreatedocumenttype04.xml
            #[test]
            fn test_domimplementationcreatedocumenttype04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#public_id = "http://www.w3.org/DOM/Test/dom2.dtd"; // type: DOMString // <var name="publicId" type="DOMString" value="&quot;http://www.w3.org/DOM/Test/dom2.dtd&quot;"/>
                let mut r#system_id = "dom2.dtd"; // type: DOMString // <var name="systemId" type="DOMString" value="&quot;dom2.dtd&quot;"/>
                let mut r#qualified_names = vec![
                    "{", "}", "'", "~", "`", "@", "#", "$", "%", "^", "&", "*", "(", ")",
                ]; // type: List // <var name="qualifiedNames" type="List"><member>"{"</member><member>"}"</member><member>"'"</member><member>"~"</member><member>"`"</member><member>"@"</member><member>"#"</member><member>"$"</member><member>"%"</member><member>"^"</member><member>"&amp;"</member><member>"*"</member><member>"("</member><member>")"</member>	</var>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                // <for-each collection="qualifiedNames" member="qualifiedName">
                //  <assertDOMException id="domimplementationcreatedocumenttype04">
                //      <INVALID_CHARACTER_ERR>
                //          <createDocumentType obj="domImpl" var="newDocType" qualifiedName="qualifiedName" publicId="publicId" systemId="systemId"/>
                //      </INVALID_CHARACTER_ERR>
                //  </assertDOMException>
                // </for-each>
                for qualified_name in qualified_names {
                    assert!(
                        dom_impl
                            .create_document_type(qualified_name, Some(public_id), Some(system_id))
                            .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                    );
                }
            }
            // namespaceURI04.xml
            #[test]
            fn test_namespace_ur_i04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let mut r#employee_namespace; // type: DOMString // <var name="employeeNamespace" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="testEmployee"/>
                r#employee_namespace = r#test_employee.namespace_uri(); // <namespaceURI obj="testEmployee" var="employeeNamespace"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //  <!--  the element is staffNS.svg has a non-null namespace but since namespace awareness is not asserted, the namespaceURI may be null -->
                //  <assertTrue id="employeeNS_svg">
                //      <or>
                //          <isNull obj="employeeNamespace"/>
                //          <equals actual="employeeNamespace" expected="&quot;http://www.w3.org/2001/DOM-Test-Suite/Level-2/Files&quot;" ignoreCase="false"/>
                //      </or>
                //  </assertTrue>
                // <else>
                //  <assertNull actual="employeeNamespace" id="employeeNS_null"/>
                assert!(employee_namespace.is_none());
                // </else>
                // </if>
            }
            // ownerElement01.xml
            #[test]
            fn test_owner_element01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#address_list; // type: NodeList // <var name="addressList" type="NodeList"/>
                let mut r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#domestic_attr; // type: Attr // <var name="domesticAttr" type="Attr"/>
                let mut r#element_node; // type: Element // <var name="elementNode" type="Element"/>
                let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#domestic_attr = r#attributes.get_named_item("domestic").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;domestic&quot;"/>
                r#element_node = r#domestic_attr.owner_element().unwrap(); // <ownerElement obj="domesticAttr" var="elementNode"/>
                r#name = r#element_node.node_name().to_string(); // <nodeName obj="elementNode" var="name"/>
                assert_eq!(r#name, "address"); // <assertEquals actual="name" expected="&quot;address&quot;" id="throw_Equals" ignoreCase="false"/>
            }
            // nodesetprefix06.xml
            #[test]
            fn test_nodesetprefix06() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test/L2"), "dom:elem".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/L2&quot;" qualifiedName="&quot;dom:elem&quot;"/>
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <prefix obj="element" value="&quot;xml&quot;"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    element
                        .set_prefix(Some("xml"))
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // importNode07.xml
            #[test]
            fn test_import_node07() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                let mut r#attr; // type: Node // <var name="attr" type="Node"/>
                let mut r#lname; // type: DOMString // <var name="lname" type="DOMString"/>
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#qualified_name = "emp:employee"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:employee&quot;"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#a_new_doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="aNewDoc" href="staff" willBeModified="true"/>
                r#element = r#a_new_doc
                    .create_element_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                    .unwrap(); // <createElementNS obj="aNewDoc" var="element" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                r#a_node = r#doc.import_node(r#element.into(), false).unwrap(); // <importNode obj="doc" var="aNode" importedNode="element" deep="false"/>
                r#attributes = r#a_node.attributes().unwrap(); // <attributes obj="aNode" var="attributes"/>
                assert_eq!(attributes.length(), 1); // <assertSize collection="attributes" size="1" id="throw_Size"/>
                r#name = r#a_node.node_name().to_string(); // <nodeName obj="aNode" var="name"/>
                assert_eq!(r#name, "emp:employee"); // <assertEquals actual="name" expected="&quot;emp:employee&quot;" ignoreCase="false" id="nodeName"/>
                r#attr = r#attributes.item(0).unwrap(); // <item interface="NamedNodeMap" obj="attributes" var="attr" index="0"/>
                r#lname = r#attr.local_name().unwrap().to_string(); // <localName obj="attr" var="lname"/>
                assert_eq!(r#lname, "defaultAttr"); // <assertEquals actual="lname" expected="&quot;defaultAttr&quot;" ignoreCase="false" id="lname"/>
            }
            // domimplementationcreatedocument05.xml
            #[test]
            fn test_domimplementationcreatedocument05() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                let mut r#namespace_uri = "http://www.w3.org/xml/1998/namespace"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/xml/1998/namespace&quot;"/>
                let mut r#qualified_name = "xml:root"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;xml:root&quot;"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                // <assertDOMException id="domimplementationcreatedocument05">
                //  <NAMESPACE_ERR>
                //      <createDocument obj="domImpl" var="newDoc" namespaceURI="namespaceURI" qualifiedName="qualifiedName" doctype="docType"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    dom_impl
                        .create_document(Some(namespace_uri), Some(qualified_name), None)
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // getAttributeNodeNS02.xml
            #[test]
            fn test_get_attribute_node_n_s02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                r#attribute = r#test_addr
                    .get_attribute_node_ns(Some("http://www.nist.gov"), "domestic")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS obj="testAddr" var="attribute" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;domestic&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName obj="attribute" var="attrName"/>
                assert_eq!(r#attr_name, "emp:domestic"); // <assertEquals actual="attrName" expected="&quot;emp:domestic&quot;" id="attrName" ignoreCase="false"/>
            }
            // domimplementationcreatedocument03.xml
            #[test]
            fn test_domimplementationcreatedocument03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                let mut r#namespace_uri = "http://www.w3.org/DOMTest/L2"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/DOMTest/L2&quot;"/>
                let mut r#qualified_names = vec![
                    "_:_", "_:h0", "_:test", "l_:_", "ns:_0", "ns:a0", "ns0:test", "a.b:c",
                    "a-b:c", "a-b:c",
                ]; // type: List // <var name="qualifiedNames" type="List"><member>"_:_"</member><member>"_:h0"</member><member>"_:test"</member><member>"l_:_"</member><member>"ns:_0"</member><member>"ns:a0"</member><member>"ns0:test"</member><member>"a.b:c"</member><member>"a-b:c"</member><member>"a-b:c"</member></var>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                // <for-each collection="qualifiedNames" member="qualifiedName">
                //  <createDocument obj="domImpl" var="newDoc" namespaceURI="namespaceURI" qualifiedName="qualifiedName" doctype="docType"/>
                //  <assertNotNull actual="newDoc" id="domimplementationcreatedocument03"/>
                // </for-each>
                for qualified_name in qualified_names {
                    new_doc = dom_impl
                        .create_document(Some(namespace_uri), Some(qualified_name), None)
                        .unwrap();
                }
            }
            // documenttypepublicid01.xml
            #[test]
            fn test_documenttypepublicid01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#public_id; // type: DOMString // <var name="publicId" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation var="domImpl" obj="doc"/>
                doc_type = dom_impl
                    .create_document_type("l2:root", Some("PUB"), None)
                    .unwrap(); // <createDocumentType var="docType" obj="domImpl" qualifiedName="&quot;l2:root&quot;" publicId="&quot;PUB&quot;" systemId="nullNS"/>
                r#public_id = r#doc_type.public_id().unwrap().to_string(); // <publicId var="publicId" obj="docType" interface="DocumentType"/>
                assert_eq!(r#public_id, "PUB"); // <assertEquals actual="publicId" expected="&quot;PUB&quot;" id="documenttypepublicid01" ignoreCase="false"/>
            }
            // createElementNS01.xml
            #[test]
            fn test_create_element_n_s01() {
                let mut r#namespace_uri = "http://www.ecommerce.org/"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.ecommerce.org/&quot;"/>
                let mut r#malformed_name = "prefix::local"; // type: DOMString // <var name="malformedName" type="DOMString" value="&quot;prefix::local&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <createElementNS obj="doc" var="newElement" namespaceURI="namespaceURI" qualifiedName="malformedName"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_element_ns(Some(namespace_uri), malformed_name)
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // nodesetprefix05.xml
            #[test]
            fn test_nodesetprefix05() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#prefix_values = vec!["_:", ":0", ":", "_::", "a:0:c"]; // type: List // <var name="prefixValues" type="List"><member>"_:"</member><member>":0"</member><member>":"</member><member>"_::"</member><member>"a:0:c"</member></var>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test/L2"), "dom:elem".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/L2&quot;" qualifiedName="&quot;dom:elem&quot;"/>
                // <for-each collection="prefixValues" member="prefixValue">
                //  <assertDOMException id="throw_NAMESPACE_ERR">
                //      <NAMESPACE_ERR>
                //          <prefix obj="element" value="prefixValue"/>
                //      </NAMESPACE_ERR>
                //  </assertDOMException>
                // </for-each>
                for prefix_value in prefix_values {
                    assert!(
                        element
                            .set_prefix(Some(prefix_value))
                            .is_err_and(|err| err == DOMException::NamespaceErr)
                    );
                }
            }
            // documentimportnode20.xml
            #[test]
            fn test_documentimportnode20() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_imp: DocumentRef; // <var name="docImp" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#node_map; // type: NamedNodeMap // <var name="nodeMap" type="NamedNodeMap"/>
                let mut r#entity4; // type: Entity // <var name="entity4" type="Entity"/>
                let mut r#entity_imp4; // type: Entity // <var name="entityImp4" type="Entity"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#cdata; // type: CharacterData // <var name="cdata" type="CharacterData"/>
                let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#elemchild_list; // type: NodeList // <var name="elemchildList" type="NodeList"/>
                let mut r#ent4_name; // type: DOMString // <var name="ent4Name" type="DOMString"/>
                let mut r#ent4_imp_name; // type: DOMString // <var name="ent4ImpName" type="DOMString"/>
                let mut r#cdata_val; // type: DOMString // <var name="cdataVal" type="DOMString"/>
                let mut r#pi_target_val; // type: DOMString // <var name="piTargetVal" type="DOMString"/>
                let mut r#pi_data_val; // type: DOMString // <var name="piDataVal" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                dom_impl = doc.implementation(); // <implementation var="domImpl" obj="doc"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                doc_imp = dom_impl
                    .create_document(Some("http://www.w3.org/DOM/Test"), Some("a:b"), None)
                    .unwrap(); // <createDocument var="docImp" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;a:b&quot;" doctype="docTypeNull"/>
                node_map = doc_type.entities(); // <entities var="nodeMap" obj="docType"/>
                r#entity4 = r#node_map.get_named_item("ent4").unwrap(); // <getNamedItem var="entity4" obj="nodeMap" name="&quot;ent4&quot;"/>
                r#entity_imp4 = r#doc_imp
                    .import_node(r#entity4.clone().into(), true)
                    .unwrap(); // <importNode var="entityImp4" obj="docImp" importedNode="entity4" deep="true"/>
                r#child_list = r#entity_imp4.child_nodes(); // <childNodes var="childList" obj="entityImp4"/>
                r#element = r#child_list.item(0).unwrap().clone(); // <item var="element" obj="childList" index="0" interface="NodeList"/>
                r#elemchild_list = r#element.child_nodes(); // <childNodes var="elemchildList" obj="element"/>
                r#cdata = r#elemchild_list.item(0).unwrap().as_text_node().unwrap(); // <item var="cdata" obj="elemchildList" index="0" interface="NodeList"/>
                r#pi = r#child_list
                    .item(1)
                    .unwrap()
                    .clone()
                    .as_processing_instruction()
                    .unwrap(); // <item var="pi" obj="childList" index="1" interface="NodeList"/>
                r#ent4_name = r#entity4.node_name().to_string(); // <nodeName var="ent4Name" obj="entity4"/>
                r#ent4_imp_name = r#entity_imp4.node_name().to_string(); // <nodeName var="ent4ImpName" obj="entityImp4"/>
                r#cdata_val = r#cdata.data().to_string(); // <data var="cdataVal" obj="cdata" interface="CharacterData"/>
                r#pi_target_val = r#pi.target().to_string(); // <target var="piTargetVal" obj="pi" interface="ProcessingInstruction"/>
                r#pi_data_val = r#pi.data().unwrap().to_string(); // <data var="piDataVal" obj="pi" interface="ProcessingInstruction"/>
                assert_eq!(r#ent4_imp_name, ent4_name); // <assertEquals expected="ent4Name" actual="ent4ImpName" id="documentimportnode20_Ent4NodeName" ignoreCase="false"/>
                assert_eq!(r#cdata_val, "Element data"); // <assertEquals expected="&quot;Element data&quot;" actual="cdataVal" id="documentimportnode20_Cdata" ignoreCase="false"/>
                assert_eq!(r#pi_target_val, "PItarget"); // <assertEquals expected="&quot;PItarget&quot;" actual="piTargetVal" id="documentimportnode20_PITarget" ignoreCase="false"/>
                assert_eq!(r#pi_data_val, "PIdata"); // <assertEquals expected="&quot;PIdata&quot;" actual="piDataVal" id="documentimportnode20_PIData" ignoreCase="false"/>
            }
            // internalSubset01.xml
            #[test]
            fn test_internal_subset01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#internal; // type: DOMString // <var name="internal" type="DOMString"/>
                // r#doc = todo!(); // staff2.xml // <load var="doc" href="staff2" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>

                // // unimplemented: // <internalSubset obj="docType" var="internal"/>

                // // unimplemented: // <assertNull actual="internal" id="internalSubsetNull"/>
            }
            // documentcreateattributeNS06.xml
            #[test]
            fn test_documentcreateattribute_n_s06() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#namespace_uri = "http://www.w3.org/XML/1998 /namespace"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/XML/1998 /namespace&quot;"/>
                let mut r#qualified_name = "xml:root"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;xml:root&quot;"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation var="domImpl" obj="doc"/>
                new_doc = dom_impl
                    .create_document(Some("http://www.w3.org/DOM/Test"), Some("dom:doc"), None)
                    .unwrap(); // <createDocument var="newDoc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;dom:doc&quot;" doctype="docType"/>
                // <assertDOMException id="documentcreateattributeNS06">
                //  <NAMESPACE_ERR>
                //      <createAttributeNS obj="newDoc" var="attribute" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    new_doc
                        .create_attribute_ns(Some(namespace_uri), qualified_name)
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // namednodemapgetnameditemns02.xml
            #[test]
            fn test_namednodemapgetnameditemns02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Node // <var name="element" type="Node"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attribute = r#attributes
                    .get_named_item_ns(Some("http://www.nist.gov"), "domestic")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;domestic&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                assert_eq!(r#attr_name, "emp:domestic"); // <assertEquals actual="attrName" expected="&quot;emp:domestic&quot;" id="namednodemapgetnameditemns02" ignoreCase="false"/>
            }
            // domimplementationhasfeature02.xml
            #[test]
            fn test_domimplementationhasfeature02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                success = dom_impl.has_feature("Blah Blah", Some("")); // <hasFeature obj="domImpl" var="success" feature="&quot;Blah Blah&quot;" version="&quot;&quot;"/>
                assert!(!r#success); // <assertFalse actual="success" id="domimplementationhasfeature02"/>
            }
            // nodegetprefix03.xml
            #[test]
            fn test_nodegetprefix03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#qelement; // type: Element // <var name="qelement" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#qattr; // type: Attr // <var name="qattr" type="Attr"/>
                let mut r#elem_no_prefix; // type: DOMString // <var name="elemNoPrefix" type="DOMString"/>
                let mut r#elem_prefix; // type: DOMString // <var name="elemPrefix" type="DOMString"/>
                let mut r#attr_no_prefix; // type: DOMString // <var name="attrNoPrefix" type="DOMString"/>
                let mut r#attr_prefix; // type: DOMString // <var name="attrPrefix" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test/elem"), "elem".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/elem&quot;" qualifiedName="&quot;elem&quot;"/>
                r#qelement = r#doc
                    .create_element_ns(
                        Some("http://www.w3.org/DOM/Test/elem"),
                        "qual:qelem".as_ref(),
                    )
                    .unwrap(); // <createElementNS var="qelement" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/elem&quot;" qualifiedName="&quot;qual:qelem&quot;"/>
                r#attr = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Test/attr"), "attr".as_ref())
                    .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/attr&quot;" qualifiedName="&quot;attr&quot;"/>
                r#qattr = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/DOM/Test/attr"),
                        "qual:qattr".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="qattr" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/attr&quot;" qualifiedName="&quot;qual:qattr&quot;"/>
                r#elem_no_prefix = r#element.prefix(); // <prefix var="elemNoPrefix" obj="element"/>
                r#elem_prefix = r#qelement.prefix().unwrap().to_string(); // <prefix var="elemPrefix" obj="qelement"/>
                r#attr_no_prefix = r#attr.prefix(); // <prefix var="attrNoPrefix" obj="attr"/>
                r#attr_prefix = r#qattr.prefix().unwrap().to_string(); // <prefix var="attrPrefix" obj="qattr"/>
                assert!(elem_no_prefix.is_none()); // <assertNull actual="elemNoPrefix" id="nodegetprefix03_1"/>
                assert_eq!(r#elem_prefix, "qual"); // <assertEquals actual="elemPrefix" expected="&quot;qual&quot;" id="nodegetprefix03_2" ignoreCase="false"/>
                assert!(attr_no_prefix.is_none()); // <assertNull actual="attrNoPrefix" id="nodegetprefix03_3"/>
                assert_eq!(r#attr_prefix, "qual"); // <assertEquals actual="attrPrefix" expected="&quot;qual&quot;" id="nodegetprefix03_4" ignoreCase="false"/>
            }
            // isSupported05.xml
            #[test]
            fn test_is_supported05() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                state = root_node.is_supported("core", Some("2.0")); // <isSupported obj="rootNode" feature="&quot;core&quot;" version="&quot;2.0&quot;" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="throw_True"/>
            }
            // importNode06.xml
            #[test]
            fn test_import_node06() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#has_child; // type: boolean // <var name="hasChild" type="boolean"/>
                let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let mut r#addresses; // type: NodeList // <var name="addresses" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                r#addresses = r#a_new_doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName var="addresses" obj="aNewDoc" interface="Document" tagname="&quot;emp:address&quot;"/>
                r#element = r#addresses.item(0).unwrap(); // <item var="element" obj="addresses" interface="NodeList" index="0"/>
                // unimplemented: // <assertNotNull actual="element" id="empAddressNotNull"/>
                r#a_node = r#doc.import_node(r#element.into(), true).unwrap(); // <importNode obj="doc" var="aNode" importedNode="element" deep="true"/>
                r#has_child = r#a_node.has_child_nodes(); // <hasChildNodes obj="aNode" var="hasChild"/>
                assert!(r#has_child); // <assertTrue actual="hasChild" id="throw_True"/>
                r#name = r#a_node.node_name().to_string(); // <nodeName obj="aNode" var="name"/>
                assert_eq!(r#name, "emp:address"); // <assertEquals actual="name" expected="&quot;emp:address&quot;" id="nodeName" ignoreCase="false"/>
                r#child = r#a_node.first_child().unwrap(); // <firstChild interface="Node" obj="aNode" var="child"/>
                r#value = r#child.node_value().unwrap().to_string(); // <nodeValue obj="child" var="value"/>
                assert_eq!(r#value, "27 South Road. Dallas, texas 98556"); // <assertEquals actual="value" expected="&quot;27 South Road. Dallas, texas 98556&quot;" id="nodeValue" ignoreCase="false"/>
            }
            // documentimportnode06.xml
            #[test]
            fn test_documentimportnode06() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_imported: DocumentRef; // <var name="docImported" type="Document"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // <assertDOMException id="throw_NOT_SUPPORTED_ERR">
                //  <NOT_SUPPORTED_ERR>
                //      <importNode var="docImported" obj="doc" importedNode="doc" deep="false"/>
                //  </NOT_SUPPORTED_ERR>
                // </assertDOMException>
                assert!(
                    doc.import_node(doc.clone().into(), false)
                        .is_err_and(|err| err == DOMException::NotSupportedErr)
                );
            }
            // ownerElement02.xml
            #[test]
            fn test_owner_element02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                let mut r#element_node; // type: Element // <var name="elementNode" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#new_attr = r#doc.create_attribute("newAttribute".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttr" name="&quot;newAttribute&quot;"/>
                r#element_node = r#new_attr.owner_element(); // <ownerElement obj="newAttr" var="elementNode"/>
                assert!(element_node.is_none()); // <assertNull actual="elementNode" id="throw_Null"/>
            }
            // hc_entitiesremovenameditemns1.xml
            #[test]
            fn test_hc_entitiesremovenameditemns1() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <if><not><contentType type="text/html"/></not>	<assertNotNull actual="docType" id="docTypeNotNull"/>	<entities var="entities" obj="docType"/>	<assertNotNull actual="entities" id="entitiesNotNull"/>	<try>		<removeNamedItemNS var="retval" obj="entities" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" localName="&quot;alpha&quot;"/>		<fail id="throw_NO_MOD_OR_NOT_FOUND_ERR"/>		<catch>			<DOMException code="NO_MODIFICATION_ALLOWED_ERR"/>			<DOMException code="NOT_FOUND_ERR"/>		</catch>	</try></if>
            }
            // hasAttributeNS05.xml
            #[test]
            fn test_has_attribute_n_s05() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#local_name = "domestic"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;domestic&quot;"/>
                let mut r#namespace_uri = "http://www.usa.com"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.usa.com&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_node; // type: Element // <var name="testNode" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="0"/>
                r#state = r#test_node
                    .has_attribute_ns(Some(r#namespace_uri), r#local_name.as_ref())
                    .unwrap(); // <hasAttributeNS obj="testNode" var="state" namespaceURI="namespaceURI" localName="localName"/>
                assert!(r#state); // <assertTrue actual="state" id="hasAttribute"/>
            }
            // namednodemapsetnameditemns04.xml
            #[test]
            fn test_namednodemapsetnameditemns04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#doc_alt: DocumentRef; // <var name="docAlt" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attr_alt; // type: Attr // <var name="attrAlt" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                dom_impl = doc.implementation(); // <implementation var="domImpl" obj="doc"/>
                doc_alt = dom_impl
                    .create_document(None, Some("newDoc"), None)
                    .unwrap(); // <createDocument var="docAlt" obj="domImpl" namespaceURI="nullNS" qualifiedName="&quot;newDoc&quot;" doctype="docType"/>
                r#attr_alt = r#doc_alt
                    .create_attribute_ns(None, "street".as_ref())
                    .unwrap(); // <createAttributeNS var="attrAlt" obj="docAlt" namespaceURI="nullNS" qualifiedName="&quot;street&quot;"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <setNamedItemNS var="newNode" obj="attributes" arg="attrAlt"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .set_named_item_ns(attr_alt)
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // isSupported10.xml
            #[test]
            fn test_is_supported10() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                state = root_node.is_supported("CORE", Some("2.0")); // <isSupported obj="rootNode" feature="&quot;CORE&quot;" version="&quot;2.0&quot;" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="throw_True"/>
            }
            // namespaceURI02.xml
            #[test]
            fn test_namespace_ur_i02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                let mut r#addr_attr; // type: Attr // <var name="addrAttr" type="Attr"/>
                let mut r#attr_namespace_uri; // type: DOMString // <var name="attrNamespaceURI" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddressNotNull"/>
                r#addr_attr = r#test_addr
                    .get_attribute_node_ns(Some("http://www.nist.gov"), "domestic")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS obj="testAddr" localName="&quot;domestic&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" var="addrAttr"/>
                r#attr_namespace_uri = r#addr_attr.namespace_uri().unwrap().to_string(); // <namespaceURI obj="addrAttr" var="attrNamespaceURI"/>
                assert_eq!(r#attr_namespace_uri, "http://www.nist.gov"); // <assertEquals actual="attrNamespaceURI" expected="&quot;http://www.nist.gov&quot;" id="namespaceURI" ignoreCase="false"/>
            }
            // elementhasattribute01.xml
            #[test]
            fn test_elementhasattribute01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="false"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element = r#doc.document_element().unwrap(); // <documentElement var="element" obj="doc"/>
                r#state = r#element.has_attribute(""); // <hasAttribute var="state" obj="element" name="&quot;&quot;"/>
                assert!(!r#state); // <assertFalse actual="state" id="elementhasattribute01"/>
            }
            // getElementsByTagNameNS10.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s10() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let mut r#expected_result = vec![
                    "employee",
                    "employeeId",
                    "name",
                    "position",
                    "salary",
                    "gender",
                    "address",
                    "emp:employee",
                    "emp:employeeId",
                    "emp:position",
                    "emp:salary",
                    "emp:gender",
                    "emp:address",
                    "address",
                ]; // type: List // <var name="expectedResult" type="List"><member>"employee"</member><member>"employeeId"</member><member>"name"</member><member>"position"</member><member>"salary"</member><member>"gender"</member><member>"address"</member><member>"emp:employee"</member><member>"emp:employeeId"</member><member>"emp:position"</member><member>"emp:salary"</member><member>"emp:gender"</member><member>"emp:address"</member><member>"address"</member></var>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#element_list = r#doc_elem
                    .get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "*")
                    .unwrap(); // <getElementsByTagNameNS interface="Element" obj="docElem" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;*&quot;" var="elementList"/>
                // <for-each collection="elementList" member="child">
                //  <nodeName obj="child" var="childName"/>
                //  <append collection="result" item="childName"/>
                // </for-each>
                for i in 0..element_list.length() {
                    child = element_list.item(i).unwrap();
                    child_name = child.node_name().to_string();
                    result.push(child_name);
                }
                assert_eq!(r#result, expected_result); // <assertEquals actual="result" expected="expectedResult" id="nodeNames" ignoreCase="false"/>
            }
            // getElementsByTagNameNS08.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s08() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#new_list; // type: NodeList // <var name="newList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#new_list = r#doc_elem.get_elements_by_tag_name_ns(Some("*"), "*"); // <getElementsByTagNameNS interface="Element" obj="docElem" var="newList" namespaceURI="&quot;*&quot;" localName="&quot;*&quot;"/>

                // unimplemented: // <if><contentType type="image/svg+xml"/><assertSize collection="newList" size="38" id="listSize_svg"/><else><assertSize collection="newList" size="36" id="listSize"/></else></if>
            }
            // documentimportnode21.xml
            #[test]
            fn test_documentimportnode21() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_imp: DocumentRef; // <var name="docImp" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#address_list; // type: NodeList // <var name="addressList" type="NodeList"/>
                let mut r#address_child_list; // type: NodeList // <var name="addressChildList" type="NodeList"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#ent_ref2; // type: EntityReference // <var name="entRef2" type="EntityReference"/>
                let mut r#ent_ref_imp2; // type: EntityReference // <var name="entRefImp2" type="EntityReference"/>
                let mut r#ent_ref3; // type: EntityReference // <var name="entRef3" type="EntityReference"/>
                let mut r#ent_ref_imp3; // type: EntityReference // <var name="entRefImp3" type="EntityReference"/>
                let mut r#node_name2; // type: DOMString // <var name="nodeName2" type="DOMString"/>
                let mut r#node_name3; // type: DOMString // <var name="nodeName3" type="DOMString"/>
                let mut r#node_name_imp2; // type: DOMString // <var name="nodeNameImp2" type="DOMString"/>
                let mut r#node_name_imp3; // type: DOMString // <var name="nodeNameImp3" type="DOMString"/>
                let mut r#nodes; // type: NodeList // <var name="nodes" type="NodeList"/>
                let mut r#node_imp3; // type: Node // <var name="nodeImp3" type="Node"/>
                let mut r#node_imp2; // type: Node // <var name="nodeImp2" type="Node"/>
                let mut r#node_value_imp2; // type: DOMString // <var name="nodeValueImp2" type="DOMString"/>
                let mut r#node_value_imp3; // type: DOMString // <var name="nodeValueImp3" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                dom_impl = doc.implementation(); // <implementation var="domImpl" obj="doc"/>
                doc_imp = dom_impl
                    .create_document(Some("http://www.w3.org/DOM/Test"), Some("a:b"), None)
                    .unwrap(); // <createDocument var="docImp" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;a:b&quot;" doctype="docTypeNull"/>
                r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName var="addressList" obj="doc" tagname="&quot;address&quot;" interface="Document"/>
                r#element = r#address_list.item(1).unwrap(); // <item var="element" obj="addressList" index="1" interface="NodeList"/>
                r#address_child_list = r#element.child_nodes(); // <childNodes var="addressChildList" obj="element"/>
                r#ent_ref2 = r#address_child_list.item(0).unwrap(); // <item var="entRef2" obj="addressChildList" index="0" interface="NodeList"/>
                r#ent_ref3 = r#address_child_list.item(2).unwrap(); // <item var="entRef3" obj="addressChildList" index="2" interface="NodeList"/>
                r#ent_ref_imp2 = r#doc_imp.import_node(r#ent_ref2.clone(), true).unwrap(); // <importNode var="entRefImp2" obj="docImp" importedNode="entRef2" deep="true"/>
                r#ent_ref_imp3 = r#doc_imp.import_node(r#ent_ref3.clone(), false).unwrap(); // <importNode var="entRefImp3" obj="docImp" importedNode="entRef3" deep="false"/>
                r#node_name2 = r#ent_ref2.node_name().to_string(); // <nodeName var="nodeName2" obj="entRef2"/>
                r#node_name3 = r#ent_ref3.node_name().to_string(); // <nodeName var="nodeName3" obj="entRef3"/>
                r#node_name_imp2 = r#ent_ref_imp2.node_name().to_string(); // <nodeName var="nodeNameImp2" obj="entRefImp2"/>
                r#node_name_imp3 = r#ent_ref_imp3.node_name().to_string(); // <nodeName var="nodeNameImp3" obj="entRefImp3"/>
                assert_eq!(r#node_name_imp2, node_name2); // <assertEquals expected="nodeName2" actual="nodeNameImp2" id="documentimportnode21_Ent2NodeName" ignoreCase="false"/>
                assert_eq!(r#node_name_imp3, node_name3); // <assertEquals expected="nodeName3" actual="nodeNameImp3" id="documentimportnode21_Ent3NodeName" ignoreCase="false"/>
                r#ent_ref_imp2 = r#doc.import_node(r#ent_ref2, true).unwrap(); // <importNode var="entRefImp2" obj="doc" importedNode="entRef2" deep="true"/>
                r#ent_ref_imp3 = r#doc.import_node(r#ent_ref3, false).unwrap(); // <importNode var="entRefImp3" obj="doc" importedNode="entRef3" deep="false"/>
                r#nodes = r#ent_ref_imp2.child_nodes(); // <childNodes var="nodes" obj="entRefImp2" interface="Node"/>
                r#node_imp2 = r#nodes.item(0).unwrap(); // <item var="nodeImp2" obj="nodes" index="0" interface="NodeList"/>
                r#node_value_imp2 = r#node_imp2.node_value().unwrap().to_string(); // <nodeValue var="nodeValueImp2" obj="nodeImp2"/>
                r#nodes = r#ent_ref_imp3.child_nodes(); // <childNodes var="nodes" obj="entRefImp3" interface="Node"/>
                r#node_imp3 = r#nodes.item(0).unwrap(); // <item var="nodeImp3" obj="nodes" index="0" interface="NodeList"/>
                r#node_value_imp3 = r#node_imp3.node_value().unwrap().to_string(); // <nodeValue var="nodeValueImp3" obj="nodeImp3"/>
                assert_eq!(r#node_value_imp2, "1900 Dallas Road"); // <assertEquals actual="nodeValueImp2" expected="&quot;1900 Dallas Road&quot;" id="documentimportnode21_Ent2NodeValue" ignoreCase="false"/>
                assert_eq!(r#node_value_imp3, "Texas"); // <assertEquals actual="nodeValueImp3" expected="&quot;Texas&quot;" id="documentimportnode21_Ent3Nodevalue" ignoreCase="false"/>
            }
            // domimplementationfeaturexmlversion2.xml
            #[test]
            fn test_domimplementationfeaturexmlversion2() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                state = dom_impl.has_feature("xml", Some("2.0")); // <hasFeature obj="domImpl" var="state" feature="&quot;xml&quot;" version="&quot;2.0&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="domimplementationFeaturexmlVersion2Assert"/>
            }
            // namednodemapsetnameditemns02.xml
            #[test]
            fn test_namednodemapsetnameditemns02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#attribute1; // type: Attr // <var name="attribute1" type="Attr"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test"), "root".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;root&quot;"/>
                r#attribute1 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/L1"), "L1:att".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute1" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" qualifiedName="&quot;L1:att&quot;"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#new_node = r#attributes.set_named_item_ns(r#attribute1).unwrap(); // <setNamedItemNS var="newNode" obj="attributes" arg="attribute1"/>
                r#attribute = r#attributes
                    .get_named_item_ns(Some("http://www.w3.org/DOM/L1"), "att")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" localName="&quot;att&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                assert_eq!(r#attr_name, "L1:att"); // <assertEquals actual="attrName" expected="&quot;L1:att&quot;" id="namednodemapsetnameditemns02" ignoreCase="false"/>
            }
            // createDocument08.xml
            #[test]
            fn test_create_document08() {
                let mut r#namespace_uri = "http://www.example.org/schema"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.example.org/schema&quot;"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                dom_impl = DOM_IMPLEMENTATION_REGISTRY
                    .get_dom_implementation("XML")
                    .unwrap(); // <implementation var="domImpl"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <createDocument obj="domImpl" var="aNewDoc" namespaceURI="namespaceURI" qualifiedName="&quot;&quot;" doctype="docType"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    dom_impl
                        .create_document(Some(namespace_uri), Some(""), None)
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // elementhasattribute03.xml
            #[test]
            fn test_elementhasattribute03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element = r#doc.create_element("address".to_string()).unwrap(); // <createElement var="element" obj="doc" tagName="&quot;address&quot;"/>
                r#attribute = r#doc.create_attribute("domestic".to_string()).unwrap(); // <createAttribute var="attribute" obj="doc" name="&quot;domestic&quot;"/>
                r#state = r#element.has_attribute("domestic"); // <hasAttribute var="state" obj="element" name="&quot;domestic&quot;"/>
                assert!(!r#state); // <assertFalse actual="state" id="elementhasattribute03_False"/>
                r#new_attribute = r#element.set_attribute_node(r#attribute).unwrap(); // <setAttributeNode var="newAttribute" obj="element" newAttr="attribute"/>
                r#state = r#element.has_attribute("domestic"); // <hasAttribute var="state" obj="element" name="&quot;domestic&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="elementhasattribute03_True"/>
            }
            // prefix03.xml
            #[test]
            fn test_prefix03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:employee&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                // unimplemented: // <assertNotNull actual="testEmployee" id="empEmployeeNotNull"/>
                r#prefix = r#test_employee.prefix().unwrap().to_string(); // <prefix obj="testEmployee" var="prefix"/>
                assert_eq!(r#prefix, "emp"); // <assertEquals actual="prefix" expected="&quot;emp&quot;" id="prefix" ignoreCase="false"/>
            }
            // importNode14.xml
            #[test]
            fn test_import_node14() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                let mut r#a_node; // type: ProcessingInstruction // <var name="aNode" type="ProcessingInstruction"/>
                let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                let mut r#target; // type: DOMString // <var name="target" type="DOMString"/>
                let mut r#data; // type: DOMString // <var name="data" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                r#pi = r#a_new_doc
                    .create_processing_instruction("target1", Some("data1"))
                    .unwrap(); // <createProcessingInstruction obj="aNewDoc" var="pi" target="&quot;target1&quot;" data="&quot;data1&quot;"/>
                r#a_node = r#doc
                    .import_node(r#pi.into(), false)
                    .unwrap()
                    .as_processing_instruction()
                    .unwrap(); // <importNode obj="doc" var="aNode" importedNode="pi" deep="false"/>
                r#owner_document = r#a_node.owner_document().unwrap(); // <ownerDocument obj="aNode" var="ownerDocument"/>
                // unimplemented: // <assertNotNull actual="ownerDocument" id="ownerDocumentNotNull"/>
                r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>
                assert_eq!(system, "staffNS.dtd"); // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="systemId"/>
                r#target = r#a_node.target().to_string(); // <target interface="ProcessingInstruction" obj="aNode" var="target"/>
                assert_eq!(r#target, "target1"); // <assertEquals actual="target" expected="&quot;target1&quot;" id="piTarget" ignoreCase="false"/>
                r#data = r#a_node.data().unwrap().to_string(); // <data interface="ProcessingInstruction" obj="aNode" var="data"/>
                assert_eq!(r#data, "data1"); // <assertEquals actual="data" expected="&quot;data1&quot;" id="piData" ignoreCase="false"/>
            }
            // setAttributeNS02.xml
            #[test]
            fn test_set_attribute_n_s02() {
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#qualified_name = "emp:"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:employee&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <setAttributeNS obj="testAddr" namespaceURI="namespaceURI" qualifiedName="qualifiedName" value="&quot;newValue&quot;"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    test_addr
                        .set_attribute_ns(Some(namespace_uri), qualified_name, "newValue")
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // elementhasattributens01.xml
            #[test]
            fn test_elementhasattributens01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "employee"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;employee&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                r#state = r#element
                    .has_attribute_ns(Some("http://www.w3.org/2000/xmlns/"), "xmlns")
                    .unwrap(); // <hasAttributeNS var="state" obj="element" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" localName="&quot;xmlns&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="elementhasattributens01"/>
            }
            // setAttributeNodeNS03.xml
            #[test]
            fn test_set_attribute_node_n_s03() {
                let mut r#namespace_uri = "http://www.newattr.com"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.newattr.com&quot;"/>
                let mut r#qualified_name = "emp:newAttr"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:newAttr&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                let mut r#new_addr_attr; // type: Attr // <var name="newAddrAttr" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:address&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                r#new_attr = r#doc
                    .create_attribute_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                    .unwrap(); // <createAttributeNS obj="doc" var="newAttr" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                r#new_addr_attr = r#test_addr.set_attribute_node_ns(r#new_attr).unwrap(); // <setAttributeNodeNS obj="testAddr" newAttr="newAttr" var="newAddrAttr"/>
                assert!(new_addr_attr.is_none()); // <assertNull actual="newAddrAttr" id="throw_Null"/>
            }
            // importNode17.xml
            #[test]
            fn test_import_node17() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#another_doc: DocumentRef; // <var name="anotherDoc" type="Document"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#another_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="anotherDoc" href="staffNS" willBeModified="true"/>
                // <assertDOMException id="throw_NOT_SUPPORTED_ERR">
                //  <NOT_SUPPORTED_ERR>
                //      <importNode obj="doc" var="node" importedNode="anotherDoc" deep="false"/>
                //  </NOT_SUPPORTED_ERR>
                // </assertDOMException>
                assert!(
                    doc.import_node(another_doc.into(), false)
                        .is_err_and(|err| err == DOMException::NotSupportedErr)
                );
            }
            // isSupported01.xml
            #[test]
            fn test_is_supported01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                state = root_node.is_supported("XXX", Some("1.0")); // <isSupported obj="rootNode" feature="&quot;XXX&quot;" version="&quot;1.0&quot;" var="state"/>
                assert!(!r#state); // <assertFalse actual="state" id="throw_False"/>
            }
            // documentcreateattributeNS03.xml
            #[test]
            fn test_documentcreateattribute_n_s03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#namespace_uri = "http://www.w3.org/DOM/Test/Level2"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/DOM/Test/Level2&quot;"/>
                let mut r#qualified_names =
                    vec!["/", "//", "\\", ";", "&amp;", "*", "]]", "&gt;", "&lt;"]; // type: List // <var name="qualifiedNames" type="List"><member>"/"</member><member>"//"</member><member>"\\"</member><member>";"</member><member>"&amp;"</member><member>"*"</member><member>"]]"</member><member>"&gt;"</member><member>"&lt;"</member></var>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // <for-each collection="qualifiedNames" member="qualifiedName">
                //  <assertDOMException id="documentcreateattributeNS03">
                //      <INVALID_CHARACTER_ERR>
                //          <createAttributeNS obj="doc" var="attribute" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                //      </INVALID_CHARACTER_ERR>
                //  </assertDOMException>
                // </for-each>
                for qualified_name in qualified_names {
                    assert!(
                        doc.create_attribute_ns(Some(namespace_uri), qualified_name)
                            .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                    );
                }
            }
            // getElementsByTagNameNS13.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s13() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#element_list = r#doc_elem
                    .get_elements_by_tag_name_ns(Some("http://www.nomatch.com"), "address")
                    .unwrap(); // <getElementsByTagNameNS interface="Element" obj="docElem" namespaceURI="&quot;http://www.nomatch.com&quot;" localName="&quot;address&quot;" var="elementList"/>
                assert_eq!(element_list.length(), 0); // <assertSize collection="elementList" size="0" id="matchSize"/>
            }
            // documentgetelementsbytagnameNS03.xml
            #[test]
            fn test_documentgetelementsbytagname_n_s03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#child_list = r#doc.get_elements_by_tag_name_ns(Some("**"), "*"); // <getElementsByTagNameNS var="childList" obj="doc" namespaceURI="&quot;**&quot;" localName="&quot;*&quot;" interface="Document"/>
                assert_eq!(child_list.length(), 0); // <assertSize size="0" collection="childList" id="documentgetelementsbytagnameNS03"/>
            }
            // isSupported09.xml
            #[test]
            fn test_is_supported09() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                state = root_node.is_supported("XML", Some("1.0")); // <isSupported obj="rootNode" feature="&quot;XML&quot;" version="&quot;1.0&quot;" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="throw_True"/>
            }
            // documentcreateelementNS05.xml
            #[test]
            fn test_documentcreateelement_n_s05() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#qualified_name = "null:xml"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;null:xml&quot;"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // <assertDOMException id="documentcreateelementNS05">
                //  <NAMESPACE_ERR>
                //      <createElementNS obj="doc" var="element" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_element_ns(None, qualified_name)
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // domimplementationhasfeature01.xml
            #[test]
            fn test_domimplementationhasfeature01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#version = ""; // type: DOMString // <var name="version" type="DOMString" value="&quot;&quot;"/>
                let mut r#version1 = "1.0"; // type: DOMString // <var name="version1" type="DOMString" value="&quot;1.0&quot;"/>
                let mut r#version2 = "2.0"; // type: DOMString // <var name="version2" type="DOMString" value="&quot;2.0&quot;"/>
                let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                let mut r#features_xml = vec!["XML", "xmL"]; // type: List // <var name="featuresXML" type="List"><member>"XML"</member><member>"xmL"</member></var>
                let mut r#features_core = vec!["Core", "CORE"]; // type: List // <var name="featuresCore" type="List"><member>"Core"</member><member>"CORE"</member></var>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                // <for-each collection="featuresXML" member="featureXML">
                //  <hasFeature obj="domImpl" var="success" feature="featureXML" version="version"/>
                //  <assertTrue actual="success" id="domimplementationhasfeature01_XML_1"/>
                //  <hasFeature obj="domImpl" var="success" feature="featureXML" version="version1"/>
                //  <assertTrue actual="success" id="domimplementationhasfeature01_XML_2"/>
                // </for-each>
                for feature_xml in features_xml {
                    success = dom_impl.has_feature(feature_xml, Some(version));
                    assert!(success);
                    success = dom_impl.has_feature(feature_xml, Some(version1));
                    assert!(success);
                }
                // <for-each collection="featuresCore" member="featureCore">
                //  <hasFeature obj="domImpl" var="success" feature="featureCore" version="version"/>
                //  <assertTrue actual="success" id="domimplementationhasfeature01_Core_1"/>
                //  <!--  result is indeterminant since Core was not defined in DOM L1   -->
                //  <hasFeature obj="domImpl" var="success" feature="featureCore" version="version1"/>
                //  <hasFeature obj="domImpl" var="success" feature="featureCore" version="version2"/>
                //  <assertTrue actual="success" id="domimplementationhasfeature01_Core_3"/>
                // </for-each>
                for feature_core in features_core {
                    success = dom_impl.has_feature(feature_core, Some(version));
                    assert!(success);
                    success = dom_impl.has_feature(feature_core, Some(version1));
                    success = dom_impl.has_feature(feature_core, Some(version2));
                    assert!(success);
                }
            }
            // hasAttributes02.xml
            #[test]
            fn test_has_attributes02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#addr_list; // type: NodeList // <var name="addrList" type="NodeList"/>
                let mut r#addr_node; // type: Node // <var name="addrNode" type="Node"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#addr_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="addrList"/>
                r#addr_node = r#addr_list.item(0).unwrap(); // <item interface="NodeList" obj="addrList" index="0" var="addrNode"/>
                r#state = r#addr_node.has_attributes(); // <hasAttributes obj="addrNode" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="throw_True"/>
            }
            // getElementsByTagNameNS01.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s01() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;*&quot;"/>
                // let mut r#local_name; // type: DOMString // <var name="localName" type="DOMString" value="&quot;*&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_list; // type: NodeList // <var name="newList" type="NodeList"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#new_list = r#doc.get_elements_by_tag_name_ns(
                //     Some(r#namespace_uri),
                //     r#local_name.as_ref(),
                // ); // <getElementsByTagNameNS interface="Document" obj="doc" var="newList" namespaceURI="namespaceURI" localName="localName"/>

                // // unimplemented: // <if><contentType type="image/svg+xml"/><assertSize collection="newList" size="39" id="listLength_svg"/><else><assertSize collection="newList" size="37" id="listLength"/></else></if>
            }
            // hasAttributeNS03.xml
            #[test]
            fn test_has_attribute_n_s03() {
                let mut r#local_name = "blank"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;blank&quot;"/>
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_node; // type: Element // <var name="testNode" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:address&quot;"/>
                r#test_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="0"/>
                // unimplemented: // <assertNotNull actual="testNode" id="empAddrNotNull"/>
                r#state = r#test_node
                    .has_attribute_ns(Some(r#namespace_uri), r#local_name.as_ref())
                    .unwrap(); // <hasAttributeNS obj="testNode" var="state" namespaceURI="namespaceURI" localName="localName"/>
                assert!(!r#state); // <assertFalse actual="state" id="throw_False"/>
            }
            // importNode08.xml
            #[test]
            fn test_import_node08() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#has_child; // type: boolean // <var name="hasChild" type="boolean"/>
                let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                r#doc_frag = r#a_new_doc.create_document_fragment(); // <createDocumentFragment obj="aNewDoc" var="docFrag"/>
                r#a_node = r#doc.import_node(r#doc_frag.into(), false).unwrap(); // <importNode obj="doc" var="aNode" importedNode="docFrag" deep="false"/>
                r#has_child = r#a_node.has_child_nodes(); // <hasChildNodes obj="aNode" var="hasChild"/>
                assert!(!r#has_child); // <assertFalse actual="hasChild" id="hasChild"/>
                r#owner_document = r#a_node.owner_document().unwrap(); // <ownerDocument obj="aNode" var="ownerDocument"/>
                r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>
                assert_eq!(system, "staffNS.dtd"); // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="system"/>
            }
            // setAttributeNodeNS02.xml
            #[test]
            fn test_set_attribute_node_n_s02() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                // let mut r#gender; // type: Node // <var name="gender" type="Node"/>
                // let mut r#gen_list; // type: NodeList // <var name="genList" type="NodeList"/>
                // let mut r#gen; // type: Node // <var name="gen" type="Node"/>
                // let mut r#g_list; // type: NodeList // <var name="gList" type="NodeList"/>
                // let mut r#gen_element; // type: Element // <var name="genElement" type="Element"/>
                // let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                // let mut r#set_attr1; // type: Attr // <var name="setAttr1" type="Attr"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // // <if><implementationAttribute name="expandEntityReferences" value="false"/>
                // //  <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                // //  <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                // //  <childNodes obj="gender" var="genList"/>
                // //  <item interface="NodeList" obj="genList" var="gen" index="0"/>
                // // <else>
                // //  <createEntityReference var="gen" name="&quot;ent4&quot;" obj="doc"/>
                // // </else>
                // // </if>
                // r#g_list = r#gen.child_nodes(); // <childNodes obj="gen" var="gList"/>
                // r#gen_element = r#g_list.item(0).unwrap().clone().as_element().unwrap(); // <item interface="NodeList" obj="gList" var="genElement" index="0"/>
                // // unimplemented: // <assertNotNull actual="genElement" id="notnull"/>
                // r#new_attr = r#doc
                //     .create_attribute_ns(Some("www.xyz.com".as_ref()), "emp:local1".as_ref())
                //     .unwrap(); // <createAttributeNS obj="doc" var="newAttr" namespaceURI="&quot;www.xyz.com&quot;" qualifiedName="&quot;emp:local1&quot;"/>
                // // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                // //  <NO_MODIFICATION_ALLOWED_ERR>
                // //      <setAttributeNodeNS var="setAttr1" obj="genElement" newAttr="newAttr"/>
                // //  </NO_MODIFICATION_ALLOWED_ERR>
                // // </assertDOMException>
                // assert!(
                //     gen_element
                //         .set_attribute_node_ns(new_attr)
                //         .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                // );
            }
            // hasAttribute04.xml
            #[test]
            fn test_has_attribute04() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_node; // type: Element // <var name="testNode" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="0"/>
                r#state = r#test_node.has_attribute("dmstc:domestic"); // <hasAttribute obj="testNode" var="state" name="&quot;dmstc:domestic&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="hasDomesticAttr"/>
            }
            // removeNamedItemNS01.xml
            #[test]
            fn test_remove_named_item_n_s01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="1"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                r#removed_node = r#attributes
                    .remove_named_item_ns(Some("http://www.usa.com"), "domestic")
                    .unwrap(); // <removeNamedItemNS var="removedNode" interface="NamedNodeMap" obj="attributes" namespaceURI="&quot;http://www.usa.com&quot;" localName="&quot;domestic&quot;"/>
                // unimplemented: // <assertNotNull actual="removedNode" id="retval"/>
                r#new_attr = r#attributes.get_named_item("dmstc:domestic"); // <getNamedItem obj="attributes" var="newAttr" name="&quot;dmstc:domestic&quot;"/>
                assert!(new_attr.is_none()); // <assertNull actual="newAttr" id="nodeRemoved"/>
            }
            // nodegetnamespaceuri03.xml
            #[test]
            fn test_nodegetnamespaceuri03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#element_ns; // type: Element // <var name="elementNS" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#attr_ns; // type: Attr // <var name="attrNS" type="Attr"/>
                let mut r#elem_nsuri; // type: DOMString // <var name="elemNSURI" type="DOMString"/>
                let mut r#elem_nsuri_null; // type: DOMString // <var name="elemNSURINull" type="DOMString"/>
                let mut r#attr_nsuri; // type: DOMString // <var name="attrNSURI" type="DOMString"/>
                let mut r#attr_nsuri_null; // type: DOMString // <var name="attrNSURINull" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element = r#doc.create_element_ns(None, "elem".as_ref()).unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="nullNS" qualifiedName="&quot;elem&quot;"/>
                r#element_ns = r#doc
                    .create_element_ns(
                        Some("http://www.w3.org/DOM/Test/elem"),
                        "qual:qelem".as_ref(),
                    )
                    .unwrap(); // <createElementNS var="elementNS" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/elem&quot;" qualifiedName="&quot;qual:qelem&quot;"/>
                r#attr = r#doc.create_attribute_ns(None, "attr".as_ref()).unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="nullNS" qualifiedName="&quot;attr&quot;"/>
                r#attr_ns = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/DOM/Test/attr"),
                        "qual:qattr".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="attrNS" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/attr&quot;" qualifiedName="&quot;qual:qattr&quot;"/>
                r#elem_nsuri = r#element_ns.namespace_uri().unwrap().to_string(); // <namespaceURI var="elemNSURI" obj="elementNS"/>
                r#elem_nsuri_null = r#element.namespace_uri(); // <namespaceURI var="elemNSURINull" obj="element"/>
                r#attr_nsuri = r#attr_ns.namespace_uri().unwrap().to_string(); // <namespaceURI var="attrNSURI" obj="attrNS"/>
                r#attr_nsuri_null = r#attr.namespace_uri(); // <namespaceURI var="attrNSURINull" obj="attr"/>
                assert_eq!(r#elem_nsuri, "http://www.w3.org/DOM/Test/elem"); // <assertEquals actual="elemNSURI" expected="&quot;http://www.w3.org/DOM/Test/elem&quot;" id="nodegetnamespaceuri03_elemNSURI" ignoreCase="false"/>
                assert!(elem_nsuri_null.is_none()); // <assertNull actual="elemNSURINull" id="nodegetnamespaceuri03_1"/>
                assert_eq!(r#attr_nsuri, "http://www.w3.org/DOM/Test/attr"); // <assertEquals actual="attrNSURI" expected="&quot;http://www.w3.org/DOM/Test/attr&quot;" id="nodegetnamespaceuri03_attrNSURI" ignoreCase="false"/>
                assert!(attr_nsuri_null.is_none()); // <assertNull actual="attrNSURINull" id="nodegetnamespaceuri03_2"/>
            }
            // elementhasattributens02.xml
            #[test]
            fn test_elementhasattributens02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM"), "address".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM&quot;" qualifiedName="&quot;address&quot;"/>
                r#attribute = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM"), "domestic".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM&quot;" qualifiedName="&quot;domestic&quot;"/>
                r#new_attribute = r#element.set_attribute_node(r#attribute).unwrap(); // <setAttributeNode var="newAttribute" obj="element" newAttr="attribute"/>
                r#state = r#element
                    .has_attribute_ns(Some("http://www.w3.org/DOM"), "domestic")
                    .unwrap(); // <hasAttributeNS var="state" obj="element" namespaceURI="&quot;http://www.w3.org/DOM&quot;" localName="&quot;domestic&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="hasDomesticAttr"/>
            }
            // elementhasattribute02.xml
            #[test]
            fn test_elementhasattribute02() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:employee&quot;" var="elementList"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                // unimplemented: // <assertNotNull actual="element" id="empEmployeeNotNull"/>
                r#state = r#element.has_attribute("defaultAttr"); // <hasAttribute var="state" obj="element" name="&quot;defaultAttr&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="elementhasattribute02"/>
            }
            // namednodemapremovenameditemns09.xml
            #[test]
            fn test_namednodemapremovenameditemns09() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#new_attributes; // type: NamedNodeMap // <var name="newAttributes" type="NamedNodeMap"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" localName="&quot;address&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attribute = r#attributes
                    .remove_named_item_ns(Some("http://www.nist.gov"), "domestic")
                    .unwrap(); // <removeNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;domestic&quot;"/>
                r#new_attributes = r#element.attributes(); // <attributes var="newAttributes" obj="element"/>
                let r#attribute = r#new_attributes
                    .get_named_item_ns(Some("http://www.nist.gov"), "domestic")
                    .unwrap(); // <getNamedItemNS var="attribute" obj="newAttributes" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;domestic&quot;"/>
                assert!(attribute.is_none()); // <assertNull actual="attribute" id="namednodemapremovenameditemns09"/>
            }
            // getElementsByTagNameNS07.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s07() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS interface="Document" obj="doc" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;" var="elementList"/>
                assert_eq!(element_list.length(), 3); // <assertSize collection="elementList" size="3" id="addresses"/>
            }
            // createDocumentType02.xml
            #[test]
            fn test_create_document_type02() {
                let mut r#public_id = "http://www.localhost.com/"; // type: DOMString // <var name="publicId" type="DOMString" value="&quot;http://www.localhost.com/&quot;"/>
                let mut r#system_id = "myDoc.dtd"; // type: DOMString // <var name="systemId" type="DOMString" value="&quot;myDoc.dtd&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#illegal_q_names = vec![
                    "edi:{", "edi:}", "edi:~", "edi:'", "edi:!", "edi:@", "edi:#", "edi:$",
                    "edi:%", "edi:^", "edi:&", "edi:*", "edi:(", "edi:)", "edi:+", "edi:=",
                    "edi:[", "edi:]", "edi:\\", "edi:/", "edi:;", "edi:`", "edi:<", "edi:>",
                    "edi:,", "edi:a ", "edi:\"",
                ]; // type: List // <var name="illegalQNames" type="List"><member>"edi:{"</member><member>"edi:}"</member><member>"edi:~"</member><member>"edi:'"</member><member>"edi:!"</member><member>"edi:@"</member><member>"edi:#"</member><member>"edi:$"</member><member>"edi:%"</member><member>"edi:^"</member><member>"edi:&amp;"</member><member>"edi:*"</member><member>"edi:("</member><member>"edi:)"</member><member>"edi:+"</member><member>"edi:="</member><member>"edi:["</member><member>"edi:]"</member><member>"edi:\\"</member><member>"edi:/"</member><member>"edi:;"</member><member>"edi:`"</member><member>"edi:&lt;"</member><member>"edi:&gt;"</member><member>"edi:,"</member><member>"edi:a "</member><member>"edi:\""</member></var>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // <for-each collection="illegalQNames" member="qualifiedName">
                //  <implementation obj="doc" var="domImpl"/>
                //  <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //      <INVALID_CHARACTER_ERR>
                //          <createDocumentType obj="domImpl" var="docType" qualifiedName="qualifiedName" publicId="publicId" systemId="systemId"/>
                //      </INVALID_CHARACTER_ERR>
                //  </assertDOMException>
                // </for-each>
                for qualified_name in illegal_q_names {
                    dom_impl = doc.implementation();
                    assert!(
                        dom_impl
                            .create_document_type(qualified_name, Some(public_id), Some(system_id))
                            .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                    );
                }
            }
            // elementsetattributens01.xml
            #[test]
            fn test_elementsetattributens01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM"), "dom:elem".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM&quot;" qualifiedName="&quot;dom:elem&quot;"/>
                r#element
                    .set_attribute_ns(
                        Some("http://www.w3.org/DOM/Test/setAttributeNS"),
                        "attr",
                        "value",
                    )
                    .unwrap(); // <setAttributeNS obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/setAttributeNS&quot;" qualifiedName="&quot;attr&quot;" value="&quot;value&quot;"/>
                r#attribute = r#element
                    .get_attribute_node_ns(
                        Some("http://www.w3.org/DOM/Test/setAttributeNS"),
                        "attr",
                    )
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attribute" obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/setAttributeNS&quot;" localName="&quot;attr&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                r#attr_value = r#attribute.node_value().unwrap().to_string(); // <nodeValue var="attrValue" obj="attribute"/>
                assert_eq!(r#attr_name, "attr"); // <assertEquals actual="attrName" expected="&quot;attr&quot;" id="elementsetattributens01_attrName" ignoreCase="false"/>
                assert_eq!(r#attr_value, "value"); // <assertEquals actual="attrValue" expected="&quot;value&quot;" id="elementsetattributens01_attrValue" ignoreCase="false"/>
            }
            // hc_notationsremovenameditemns1.xml
            #[test]
            fn test_hc_notationsremovenameditemns1() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <if><not><contentType type="text/html"/></not><assertNotNull actual="docType" id="docTypeNotNull"/><notations var="notations" obj="docType"/><assertNotNull actual="notations" id="notationsNotNull"/><try>	<removeNamedItemNS var="retval" obj="notations" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" localName="&quot;alpha&quot;"/>	<fail id="throw_NO_MOD_OR_NOT_FOUND_ERR"/>	<catch>		<DOMException code="NO_MODIFICATION_ALLOWED_ERR"/>		<DOMException code="NOT_FOUND_ERR"/>	</catch></try></if>
            }
            // isSupported06.xml
            #[test]
            fn test_is_supported06() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                state = root_node.is_supported("xml", Some("2.0")); // <isSupported obj="rootNode" feature="&quot;xml&quot;" version="&quot;2.0&quot;" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="throw_True"/>
            }
            // isSupported12.xml
            #[test]
            fn test_is_supported12() {
                let mut r#features = vec![
                    "Core",
                    "XML",
                    "HTML",
                    "Views",
                    "StyleSheets",
                    "CSS",
                    "CSS2",
                    "Events",
                    "UIEvents",
                    "MouseEvents",
                    "MutationEvents",
                    "HTMLEvents",
                    "Range",
                    "Traversal",
                    "bogus.bogus.bogus",
                ]; // type: List // <var name="features" type="List"><member>"Core"</member><member>"XML"</member><member>"HTML"</member><member>"Views"</member><member>"StyleSheets"</member><member>"CSS"</member><member>"CSS2"</member><member>"Events"</member><member>"UIEvents"</member><member>"MouseEvents"</member><member>"MutationEvents"</member><member>"HTMLEvents"</member><member>"Range"</member><member>"Traversal"</member><member>"bogus.bogus.bogus"</member></var>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                state = root_node.is_supported("Core", Some("2.0")); // <isSupported obj="rootNode" feature="&quot;Core&quot;" version="&quot;2.0&quot;" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="Core2"/>
                // <for-each collection="features" member="featureElement">
                //  <isSupported obj="rootNode" feature="featureElement" version="&quot;1.0&quot;" var="state"/>
                // </for-each>
                for &feature_element in &features {
                    state = root_node.is_supported(feature_element, Some("1.0"));
                }
                // <for-each collection="features" member="featureElement">
                //  <isSupported obj="rootNode" feature="featureElement" version="&quot;2.0&quot;" var="state"/>
                // </for-each>
                for &feature_element in &features {
                    state = root_node.is_supported(feature_element, Some("2.0"));
                }
            }
            // documenttypeinternalSubset01.xml
            #[test]
            fn test_documenttypeinternal_subset01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#internal; // type: DOMString // <var name="internal" type="DOMString"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // dom_impl = doc.implementation(); // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocumentType var="docType" obj="domImpl" qualifiedName="&quot;l2:root&quot;" publicId="nullNS" systemId="nullNS"/>

                // // unimplemented: // <internalSubset var="internal" obj="docType"/>

                // // unimplemented: // <assertNull actual="internal" id="internalSubsetNull"/>
            }
            // setAttributeNS05.xml
            #[test]
            fn test_set_attribute_n_s05() {
                let mut r#local_name = "newAttr"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;newAttr&quot;"/>
                let mut r#namespace_uri = "http://www.newattr.com"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.newattr.com&quot;"/>
                let mut r#qualified_name = "emp:newAttr"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:newAttr&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                let mut r#result_attr; // type: DOMString // <var name="resultAttr" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:address&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                r#test_addr
                    .set_attribute_ns(Some(r#namespace_uri), r#qualified_name, "<newValue>")
                    .unwrap(); // <setAttributeNS obj="testAddr" namespaceURI="namespaceURI" qualifiedName="qualifiedName" value="&quot;&lt;newValue&gt;&quot;"/>
                r#result_attr = r#test_addr
                    .get_attribute_ns(Some(r#namespace_uri), r#local_name)
                    .unwrap(); // <getAttributeNS obj="testAddr" var="resultAttr" namespaceURI="namespaceURI" localName="localName"/>
                assert_eq!(r#result_attr, "<newValue>"); // <assertEquals actual="resultAttr" expected="&quot;&lt;newValue&gt;&quot;" id="throw_Equals" ignoreCase="false"/>
            }
            // elementgetattributenodens03.xml
            #[test]
            fn test_elementgetattributenodens03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#child_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "employee"); // <getElementsByTagNameNS var="childList" obj="doc" localName="&quot;employee&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" interface="Document"/>
                r#element = r#child_list.item(1).unwrap(); // <item var="element" obj="childList" index="1" interface="NodeList"/>
                r#attribute = r#element
                    .get_attribute_node_ns(None, "defaultAttr")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attribute" obj="element" localName="&quot;defaultAttr&quot;" namespaceURI="nullNS"/>
                r#attr_value = r#attribute.node_value().unwrap().to_string(); // <nodeValue var="attrValue" obj="attribute"/>
                assert_eq!(r#attr_value, "defaultVal"); // <assertEquals actual="attrValue" expected="&quot;defaultVal&quot;" id="elementgetattributenodens03" ignoreCase="false"/>
            }
            // namednodemapgetnameditemns06.xml
            #[test]
            fn test_namednodemapgetnameditemns06() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes_map1; // type: NamedNodeMap // <var name="attributesMap1" type="NamedNodeMap"/>
                let mut r#attributes_map2; // type: NamedNodeMap // <var name="attributesMap2" type="NamedNodeMap"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attr1; // type: Attr // <var name="newAttr1" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes_map1 = r#element.attributes(); // <attributes var="attributesMap1" obj="element"/>
                r#attributes_map2 = r#element.attributes(); // <attributes var="attributesMap2" obj="element"/>
                r#new_attr1 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/L1"), "street".as_ref())
                    .unwrap(); // <createAttributeNS var="newAttr1" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" qualifiedName="&quot;street&quot;"/>
                r#new_attribute = r#element.set_attribute_node_ns(r#new_attr1).unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="newAttr1"/>
                r#attribute = r#attributes_map1
                    .get_named_item_ns(Some("http://www.w3.org/DOM/L1"), "street")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributesMap1" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" localName="&quot;street&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                assert_eq!(r#attr_name, "street"); // <assertEquals actual="attrName" expected="&quot;street&quot;" id="namednodemapgetnameditemnsMap106" ignoreCase="false"/>
                r#attribute = r#attributes_map2
                    .get_named_item_ns(Some("http://www.w3.org/DOM/L1"), "street")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributesMap2" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" localName="&quot;street&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                assert_eq!(r#attr_name, "street"); // <assertEquals actual="attrName" expected="&quot;street&quot;" id="namednodemapgetnameditemnsMap206" ignoreCase="false"/>
            }
            // elementgetelementsbytagnamens04.xml
            #[test]
            fn test_elementgetelementsbytagnamens04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#child1; // type: Element // <var name="child1" type="Element"/>
                let mut r#child2; // type: Element // <var name="child2" type="Element"/>
                let mut r#child3; // type: Element // <var name="child3" type="Element"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM"), "root".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM&quot;" qualifiedName="&quot;root&quot;"/>
                r#child1 = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Level1"), "dom:child".as_ref())
                    .unwrap(); // <createElementNS var="child1" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Level1&quot;" qualifiedName="&quot;dom:child&quot;"/>
                r#child2 = r#doc.create_element_ns(None, "child".as_ref()).unwrap(); // <createElementNS var="child2" obj="doc" namespaceURI="nullNS" qualifiedName="&quot;child&quot;"/>
                r#child3 = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Level2"), "dom:child".as_ref())
                    .unwrap(); // <createElementNS var="child3" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Level2&quot;" qualifiedName="&quot;dom:child&quot;"/>
                r#appended_child = r#element.append_child(child1.into()).unwrap(); // <appendChild var="appendedChild" obj="element" newChild="child1"/>
                r#appended_child = r#element.append_child(child2.into()).unwrap(); // <appendChild var="appendedChild" obj="element" newChild="child2"/>
                r#appended_child = r#element.append_child(child3.into()).unwrap(); // <appendChild var="appendedChild" obj="element" newChild="child3"/>
                r#element_list = r#element
                    .get_elements_by_tag_name_ns(None, "child")
                    .unwrap(); // <getElementsByTagNameNS var="elementList" obj="element" namespaceURI="nullNS" localName="&quot;child&quot;" interface="Element"/>
                assert_eq!(element_list.length(), 1); // <assertSize size="1" collection="elementList" id="elementgetelementsbytagnamens04_1"/>
                r#element_list = r#element
                    .get_elements_by_tag_name_ns(Some("*"), "child")
                    .unwrap(); // <getElementsByTagNameNS var="elementList" obj="element" namespaceURI="&quot;*&quot;" localName="&quot;child&quot;" interface="Element"/>
                assert_eq!(element_list.length(), 3); // <assertSize size="3" collection="elementList" id="elementgetelementsbytagnamens04_2"/>
            }
            // elementsetattributenodens05.xml
            #[test]
            fn test_elementsetattributenodens05() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_alt: DocumentRef; // <var name="docAlt" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_alt = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="docAlt" href="staffNS" willBeModified="true"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test"), "elem1".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;elem1&quot;"/>
                r#attribute = r#doc_alt
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Test"), "attr".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute" obj="docAlt" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;attr&quot;"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <setAttributeNodeNS var="newAttribute" obj="element" newAttr="attribute"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    element
                        .set_attribute_node_ns(attribute)
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // createElementNS03.xml
            #[test]
            fn test_create_element_n_s03() {
                let mut r#namespace_uri = "http://www.wedding.com/"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.wedding.com/&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#illegal_q_names = vec![
                    "person:{",
                    "person:}",
                    "person:~",
                    "person:'",
                    "person:!",
                    "person:@",
                    "person:#",
                    "person:$",
                    "person:%",
                    "person:^",
                    "person:&",
                    "person:*",
                    "person:(",
                    "person:)",
                    "person:+",
                    "person:=",
                    "person:[",
                    "person:]",
                    "person:\\",
                    "person:/",
                    "person:;",
                    "person:`",
                    "person:<",
                    "person:>",
                    "person:,",
                    "person:a ",
                    "person:\"",
                ]; // type: List // <var name="illegalQNames" type="List"><member>"person:{"</member><member>"person:}"</member><member>"person:~"</member><member>"person:'"</member><member>"person:!"</member><member>"person:@"</member><member>"person:#"</member><member>"person:$"</member><member>"person:%"</member><member>"person:^"</member><member>"person:&amp;"</member><member>"person:*"</member><member>"person:("</member><member>"person:)"</member><member>"person:+"</member><member>"person:="</member><member>"person:["</member><member>"person:]"</member><member>"person:\\"</member><member>"person:/"</member><member>"person:;"</member><member>"person:`"</member><member>"person:&lt;"</member><member>"person:&gt;"</member><member>"person:,"</member><member>"person:a "</member><member>"person:\""</member></var>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // <for-each collection="illegalQNames" member="qualifiedName">
                //  <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //      <INVALID_CHARACTER_ERR>
                //          <createElementNS obj="doc" var="newElement" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                //      </INVALID_CHARACTER_ERR>
                //  </assertDOMException>
                // </for-each>
                for qualified_name in illegal_q_names {
                    assert!(
                        doc.create_element_ns(Some(namespace_uri), qualified_name)
                            .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                    );
                }
            }
            // hc_notationssetnameditemns1.xml
            #[test]
            fn test_hc_notationssetnameditemns1() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <if><not><contentType type="text/html"/></not><assertNotNull actual="docType" id="docTypeNotNull"/><notations var="notations" obj="docType"/><assertNotNull actual="notations" id="notationsNotNull"/><createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;br&quot;"/><try>	<setNamedItemNS var="retval" obj="notations" arg="elem"/>	<fail id="throw_HIER_OR_NO_MOD_ERR"/>	<catch>		<DOMException code="HIERARCHY_REQUEST_ERR"/>		<DOMException code="NO_MODIFICATION_ALLOWED_ERR"/>	</catch></try></if>
            }
            // getAttributeNS04.xml
            #[test]
            fn test_get_attribute_n_s04() {
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#local_name = "blank"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;blank&quot;"/>
                let mut r#qualified_name = "emp:blank"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:blank&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#new_attribute = r#doc
                    .create_attribute_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                    .unwrap(); // <createAttributeNS obj="doc" var="newAttribute" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                r#test_addr
                    .set_attribute_ns(Some(r#namespace_uri), r#qualified_name, "NewValue")
                    .unwrap(); // <setAttributeNS obj="testAddr" namespaceURI="namespaceURI" qualifiedName="qualifiedName" value="&quot;NewValue&quot;"/>
                r#attr_value = r#test_addr
                    .get_attribute_ns(Some(r#namespace_uri), r#local_name)
                    .unwrap(); // <getAttributeNS obj="testAddr" var="attrValue" namespaceURI="namespaceURI" localName="localName"/>
                assert_eq!(r#attr_value, "NewValue"); // <assertEquals actual="attrValue" expected="&quot;NewValue&quot;" id="throw_Equals" ignoreCase="false"/>
            }
            // nodenormalize01.xml
            #[test]
            fn test_nodenormalize01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#document_element; // type: Element // <var name="documentElement" type="Element"/>
                let mut r#element1; // type: Element // <var name="element1" type="Element"/>
                let mut r#element2; // type: Element // <var name="element2" type="Element"/>
                let mut r#element3; // type: Element // <var name="element3" type="Element"/>
                let mut r#element4; // type: Element // <var name="element4" type="Element"/>
                let mut r#element5; // type: Element // <var name="element5" type="Element"/>
                let mut r#element6; // type: Element // <var name="element6" type="Element"/>
                let mut r#element7; // type: Element // <var name="element7" type="Element"/>
                let mut r#text1; // type: Text // <var name="text1" type="Text"/>
                let mut r#text2; // type: Text // <var name="text2" type="Text"/>
                let mut r#text3; // type: Text // <var name="text3" type="Text"/>
                let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                let mut r#c_data; // type: CDATASection // <var name="cData" type="CDATASection"/>
                let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                dom_impl = doc.implementation(); // <implementation var="domImpl" obj="doc"/>
                new_doc = dom_impl
                    .create_document(Some("http://www.w3.org/DOM/Test"), Some("dom:root"), None)
                    .unwrap(); // <createDocument var="newDoc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;dom:root&quot;" doctype="docTypeNull"/>
                r#element1 = r#new_doc.create_element("element1".to_string()).unwrap(); // <createElement var="element1" obj="newDoc" tagName="&quot;element1&quot;"/>
                r#element2 = r#new_doc.create_element("element2".to_string()).unwrap(); // <createElement var="element2" obj="newDoc" tagName="&quot;element2&quot;"/>
                r#element3 = r#new_doc.create_element("element3".to_string()).unwrap(); // <createElement var="element3" obj="newDoc" tagName="&quot;element3&quot;"/>
                r#element4 = r#new_doc.create_element("element4".to_string()).unwrap(); // <createElement var="element4" obj="newDoc" tagName="&quot;element4&quot;"/>
                r#element5 = r#new_doc.create_element("element5".to_string()).unwrap(); // <createElement var="element5" obj="newDoc" tagName="&quot;element5&quot;"/>
                r#element6 = r#new_doc.create_element("element6".to_string()).unwrap(); // <createElement var="element6" obj="newDoc" tagName="&quot;element6&quot;"/>
                r#element7 = r#new_doc.create_element("element7".to_string()).unwrap(); // <createElement var="element7" obj="newDoc" tagName="&quot;element7&quot;"/>
                r#text1 = r#new_doc.create_text_node("text1"); // <createTextNode var="text1" obj="newDoc" data="&quot;text1&quot;"/>
                r#text2 = r#new_doc.create_text_node("text2"); // <createTextNode var="text2" obj="newDoc" data="&quot;text2&quot;"/>
                r#text3 = r#new_doc.create_text_node("text3"); // <createTextNode var="text3" obj="newDoc" data="&quot;text3&quot;"/>
                r#c_data = r#new_doc.create_cdata_section("Cdata").unwrap(); // <createCDATASection var="cData" obj="newDoc" data="&quot;Cdata&quot;"/>
                r#comment = r#new_doc.create_comment("comment"); // <createComment var="comment" obj="newDoc" data="&quot;comment&quot;"/>
                r#pi = r#new_doc
                    .create_processing_instruction("PITarget", Some("PIData"))
                    .unwrap(); // <createProcessingInstruction var="pi" obj="newDoc" target="&quot;PITarget&quot;" data="&quot;PIData&quot;"/>
                r#ent_ref = r#new_doc
                    .create_entity_reference("EntRef".to_string())
                    .unwrap(); // <createEntityReference var="entRef" obj="newDoc" name="&quot;EntRef&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                r#document_element = r#new_doc.document_element().unwrap(); // <documentElement var="documentElement" obj="newDoc"/>
                r#appended_child = r#document_element
                    .append_child(element1.clone().into())
                    .unwrap(); // <appendChild var="appendedChild" obj="documentElement" newChild="element1"/>
                r#appended_child = r#element2.append_child(text1.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element2" newChild="text1"/>
                r#appended_child = r#element2.append_child(text2.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element2" newChild="text2"/>
                r#appended_child = r#element2.append_child(text3.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element2" newChild="text3"/>
                r#appended_child = r#element1.append_child(element2.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element1" newChild="element2"/>
                r#text1 = r#text1.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text1" obj="text1" deep="false"/>
                r#text2 = r#text2.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text2" obj="text2" deep="false"/>
                r#appended_child = r#element3.append_child(ent_ref.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element3" newChild="entRef"/>
                r#appended_child = r#element3.append_child(text1.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element3" newChild="text1"/>
                r#appended_child = r#element3.append_child(text2.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element3" newChild="text2"/>
                r#appended_child = r#element1.append_child(element3.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element1" newChild="element3"/>
                r#text1 = r#text1.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text1" obj="text1" deep="false"/>
                r#text2 = r#text2.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text2" obj="text2" deep="false"/>
                r#appended_child = r#element4.append_child(c_data.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element4" newChild="cData"/>
                r#appended_child = r#element4.append_child(text1.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element4" newChild="text1"/>
                r#appended_child = r#element4.append_child(text2.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element4" newChild="text2"/>
                r#appended_child = r#element1.append_child(element4.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element1" newChild="element4"/>
                r#text2 = r#text2.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text2" obj="text2" deep="false"/>
                r#text3 = r#text3.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text3" obj="text3" deep="false"/>
                r#appended_child = r#element5.append_child(comment.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element5" newChild="comment"/>
                r#appended_child = r#element5.append_child(text2.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element5" newChild="text2"/>
                r#appended_child = r#element5.append_child(text3.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element5" newChild="text3"/>
                r#appended_child = r#element1.append_child(element5.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element1" newChild="element5"/>
                r#text2 = r#text2.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text2" obj="text2" deep="false"/>
                r#text3 = r#text3.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text3" obj="text3" deep="false"/>
                r#appended_child = r#element6.append_child(pi.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element6" newChild="pi"/>
                r#appended_child = r#element6.append_child(text2.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element6" newChild="text2"/>
                r#appended_child = r#element6.append_child(text3.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element6" newChild="text3"/>
                r#appended_child = r#element1.append_child(element6.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element1" newChild="element6"/>
                r#ent_ref = r#ent_ref.clone_node(false).as_entity_reference().unwrap(); // <cloneNode var="entRef" obj="entRef" deep="false"/>
                r#text1 = r#text1.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text1" obj="text1" deep="false"/>
                r#text2 = r#text2.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text2" obj="text2" deep="false"/>
                r#text3 = r#text3.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text3" obj="text3" deep="false"/>
                r#appended_child = r#element7.append_child(ent_ref.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element7" newChild="entRef"/>
                r#appended_child = r#element7.append_child(text1.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element7" newChild="text1"/>
                r#appended_child = r#element7.append_child(text2.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element7" newChild="text2"/>
                r#appended_child = r#element7.append_child(text3.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element7" newChild="text3"/>
                r#appended_child = r#element1.append_child(element7.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="element1" newChild="element7"/>
                r#element_list = r#element1.child_nodes(); // <childNodes var="elementList" obj="element1"/>
                assert_eq!(element_list.length(), 6); // <assertSize size="6" collection="elementList" id="nodeNormalize01_1Bef"/>
                r#element_list = r#element2.child_nodes(); // <childNodes var="elementList" obj="element2"/>
                assert_eq!(element_list.length(), 3); // <assertSize size="3" collection="elementList" id="nodeNormalize01_2Bef"/>
                r#element_list = r#element3.child_nodes(); // <childNodes var="elementList" obj="element3"/>
                assert_eq!(element_list.length(), 3); // <assertSize size="3" collection="elementList" id="nodeNormalize01_3Bef"/>
                r#element_list = r#element4.child_nodes(); // <childNodes var="elementList" obj="element4"/>
                assert_eq!(element_list.length(), 3); // <assertSize size="3" collection="elementList" id="nodeNormalize01_4Bef"/>
                r#element_list = r#element5.child_nodes(); // <childNodes var="elementList" obj="element5"/>
                assert_eq!(element_list.length(), 3); // <assertSize size="3" collection="elementList" id="nodeNormalize01_5Bef"/>
                r#element_list = r#element6.child_nodes(); // <childNodes var="elementList" obj="element6"/>
                assert_eq!(element_list.length(), 3); // <assertSize size="3" collection="elementList" id="nodeNormalize01_6Bef"/>
                r#element_list = r#element7.child_nodes(); // <childNodes var="elementList" obj="element7"/>
                assert_eq!(element_list.length(), 4); // <assertSize size="4" collection="elementList" id="nodeNormalize01_7Bef"/>
                r#new_doc.normalize(); // <normalize obj="newDoc"/>
                r#element_list = r#element1.child_nodes(); // <childNodes var="elementList" obj="element1"/>
                assert_eq!(element_list.length(), 6); // <assertSize size="6" collection="elementList" id="nodeNormalize01_1Aft"/>
                r#element_list = r#element2.child_nodes(); // <childNodes var="elementList" obj="element2"/>
                assert_eq!(element_list.length(), 1); // <assertSize size="1" collection="elementList" id="nodeNormalize01_2Aft"/>
                r#element_list = r#element3.child_nodes(); // <childNodes var="elementList" obj="element3"/>
                assert_eq!(element_list.length(), 2); // <assertSize size="2" collection="elementList" id="nodeNormalize01_3Aft"/>
                r#element_list = r#element4.child_nodes(); // <childNodes var="elementList" obj="element4"/>
                assert_eq!(element_list.length(), 2); // <assertSize size="2" collection="elementList" id="nodeNormalize01_4Aft"/>
                r#element_list = r#element5.child_nodes(); // <childNodes var="elementList" obj="element5"/>
                assert_eq!(element_list.length(), 2); // <assertSize size="2" collection="elementList" id="nodeNormalize01_5Aft"/>
                r#element_list = r#element6.child_nodes(); // <childNodes var="elementList" obj="element6"/>
                assert_eq!(element_list.length(), 2); // <assertSize size="2" collection="elementList" id="nodeNormalize01_6Aft"/>
                r#element_list = r#element7.child_nodes(); // <childNodes var="elementList" obj="element7"/>
                assert_eq!(element_list.length(), 2); // <assertSize size="2" collection="elementList" id="nodeNormalize01_7Aft"/>
            }
            // namednodemapsetnameditemns10.xml
            #[test]
            fn test_namednodemapsetnameditemns10() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                // entities = doc_type.entities(); // <entities var="entities" obj="docType"/>
                // // unimplemented: // <assertNotNull actual="entities" id="entitiesNotNull"/>
                // r#entity = r#entities.get_named_item("ent1".into()).unwrap(); // <getNamedItem var="entity" obj="entities" name="&quot;ent1&quot;"/>
                // r#element_list =
                //     r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;" interface="Document"/>
                // r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                // r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                // // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                // //  <HIERARCHY_REQUEST_ERR>
                // //      <setNamedItemNS var="newNode" obj="attributes" arg="entity"/>
                // //  </HIERARCHY_REQUEST_ERR>
                // // </assertDOMException>
                // assert!(
                //     attributes
                //         .set_named_item_ns(entity)
                //         .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                // );
            }
            // namednodemapremovenameditemns02.xml
            #[test]
            fn test_namednodemapremovenameditemns02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Node // <var name="element" type="Node"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "employee"); // <getElementsByTagNameNS var="elementList" obj="doc" localName="&quot;employee&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attribute = r#attributes
                    .remove_named_item_ns(None, "defaultAttr")
                    .unwrap(); // <removeNamedItemNS var="attribute" obj="attributes" namespaceURI="nullNS" localName="&quot;defaultAttr&quot;"/>
                r#attribute = r#attributes
                    .get_named_item_ns(None, "defaultAttr")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="nullNS" localName="&quot;defaultAttr&quot;"/>
                r#attr_value = r#attribute.node_value().unwrap().to_string(); // <nodeValue var="attrValue" obj="attribute"/>
                // unimplemented: // <assertNotNull actual="attribute" id="namednodemapremovenameditemns02"/>
                assert_eq!(r#attr_value, "defaultVal"); // <assertEquals actual="attrValue" expected="&quot;defaultVal&quot;" id="namednodemapremovenameditemns02_attrValue" ignoreCase="false"/>
            }
            // getElementsByTagNameNS03.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let mut r#expected_result = vec![
                    "employee",
                    "employeeId",
                    "name",
                    "position",
                    "salary",
                    "gender",
                    "address",
                    "emp:employee",
                    "emp:employeeId",
                    "emp:position",
                    "emp:salary",
                    "emp:gender",
                    "emp:address",
                    "address",
                ]; // type: List // <var name="expectedResult" type="List"><member>"employee"</member><member>"employeeId"</member><member>"name"</member><member>"position"</member><member>"salary"</member><member>"gender"</member><member>"address"</member><member>"emp:employee"</member><member>"emp:employeeId"</member><member>"emp:position"</member><member>"emp:salary"</member><member>"emp:gender"</member><member>"emp:address"</member><member>"address"</member></var>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "*"); // <getElementsByTagNameNS interface="Document" obj="doc" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;*&quot;" var="elementList"/>
                // <for-each collection="elementList" member="child">
                //  <nodeName obj="child" var="childName"/>
                //  <append collection="result" item="childName"/>
                // </for-each>
                for i in 0..element_list.length() {
                    child = element_list.item(i).unwrap();
                    child_name = child.node_name().to_string();
                    result.push(child_name);
                }
                assert_eq!(r#result, expected_result); // <assertEquals actual="result" expected="expectedResult" id="nodeNames" ignoreCase="false"/>
            }
            // importNode04.xml
            #[test]
            fn test_import_node04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#children; // type: NodeList // <var name="children" type="NodeList"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_value; // type: DOMString // <var name="childValue" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#a_new_doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="aNewDoc" href="staff" willBeModified="true"/>
                r#doc_frag = r#a_new_doc.create_document_fragment(); // <createDocumentFragment obj="aNewDoc" var="docFrag"/>
                r#comment = r#a_new_doc.create_comment("descendant1"); // <createComment obj="aNewDoc" var="comment" data="&quot;descendant1&quot;"/>
                r#a_node = r#doc_frag.append_child(comment.into()).unwrap(); // <appendChild obj="docFrag" var="aNode" newChild="comment"/>
                r#a_node = r#doc.import_node(r#doc_frag.into(), true).unwrap(); // <importNode obj="doc" var="aNode" importedNode="docFrag" deep="true"/>
                r#children = r#a_node.child_nodes(); // <childNodes obj="aNode" var="children"/>
                assert_eq!(children.length(), 1); // <assertSize collection="children" size="1" id="throw_Size"/>
                r#child = r#a_node.first_child().unwrap(); // <firstChild interface="Node" obj="aNode" var="child"/>
                r#child_value = r#child.node_value().unwrap().to_string(); // <nodeValue obj="child" var="childValue"/>
                assert_eq!(r#child_value, "descendant1"); // <assertEquals actual="childValue" expected="&quot;descendant1&quot;" id="descendant1" ignoreCase="false"/>
            }
            // prefix05.xml
            #[test]
            fn test_prefix05() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#addr_node; // type: Element // <var name="addrNode" type="Element"/>
                let mut r#addr_attr; // type: Attr // <var name="addrAttr" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                r#addr_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="addrNode"/>
                // unimplemented: // <assertNotNull actual="addrNode" id="empAddrNotNull"/>
                r#addr_attr = r#addr_node.get_attribute_node("emp:domestic").unwrap(); // <getAttributeNode obj="addrNode" name="&quot;emp:domestic&quot;" var="addrAttr"/>
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <prefix obj="addrAttr" value="&quot;xmlns&quot;"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    addr_attr
                        .set_prefix(Some("xmlns"))
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // localName04.xml
            #[test]
            fn test_local_name04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let mut r#employee_local_name; // type: DOMString // <var name="employeeLocalName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                r#employee_local_name = r#test_employee.local_name().unwrap().to_string(); // <localName obj="testEmployee" var="employeeLocalName"/>
                assert_eq!(r#employee_local_name, "employee"); // <assertEquals actual="employeeLocalName" expected="&quot;employee&quot;" id="lname" ignoreCase="false"/>
            }
            // getNamedItemNS03.xml
            #[test]
            fn test_get_named_item_n_s03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                entities = doc_type.entities(); // <entities var="entities" obj="docType"/>
                // unimplemented: // <assertNotNull actual="entities" id="entitiesNotNull"/>
                r#entity = r#entities.get_named_item_ns(None, "ent1").unwrap(); // <getNamedItemNS var="entity" obj="entities" namespaceURI="nullNS" localName="&quot;ent1&quot;"/>
                assert!(entity.is_none()); // <assertNull actual="entity" id="entityNull"/>
            }
            // setAttributeNodeNS01.xml
            #[test]
            fn test_set_attribute_node_n_s01() {
                let mut r#namespace_uri = "http://www.newattr.com"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.newattr.com&quot;"/>
                let mut r#qualified_name = "emp:newAttr"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:newAttr&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_element; // type: Element // <var name="newElement" type="Element"/>
                let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#set_attr1; // type: Attr // <var name="setAttr1" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:address&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                r#new_element = r#doc.create_element("newElement".to_string()).unwrap(); // <createElement obj="doc" var="newElement" tagName="&quot;newElement&quot;"/>
                r#appended_child = r#test_addr
                    .append_child(new_element.clone().into())
                    .unwrap(); // <appendChild var="appendedChild" obj="testAddr" newChild="newElement"/>
                r#new_attr = r#doc
                    .create_attribute_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                    .unwrap(); // <createAttributeNS obj="doc" var="newAttr" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                r#set_attr1 = r#new_element
                    .set_attribute_node_ns(r#new_attr.clone())
                    .unwrap(); // <setAttributeNodeNS var="setAttr1" obj="newElement" newAttr="newAttr"/>
                // <assertDOMException id="throw_INUSE_ATTRIBUTE_ERR">
                //  <INUSE_ATTRIBUTE_ERR>
                //      <setAttributeNodeNS var="setAttr2" obj="testAddr" newAttr="newAttr"/>
                //  </INUSE_ATTRIBUTE_ERR>
                // </assertDOMException>
                assert!(
                    test_addr
                        .set_attribute_node_ns(new_attr)
                        .is_err_and(|err| err == DOMException::InuseAttributeErr)
                );
            }
            // importNode13.xml
            #[test]
            fn test_import_node13() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#doc1_type; // type: DocumentType // <var name="doc1Type" type="DocumentType"/>
                let mut r#notation_list; // type: NamedNodeMap // <var name="notationList" type="NamedNodeMap"/>
                let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                let mut r#a_node; // type: Notation // <var name="aNode" type="Notation"/>
                let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                let mut r#public_val; // type: DOMString // <var name="publicVal" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                r#doc1_type = r#a_new_doc.doctype().unwrap(); // <doctype obj="aNewDoc" var="doc1Type"/>
                notation_list = doc1_type.notations(); // <notations obj="doc1Type" var="notationList"/>
                // unimplemented: // <assertNotNull actual="notationList" id="notationsNotNull"/>
                r#notation = r#notation_list.get_named_item("notation1").unwrap(); // <getNamedItem obj="notationList" var="notation" name="&quot;notation1&quot;"/>
                r#a_node = r#doc
                    .import_node(r#notation.into(), false)
                    .unwrap()
                    .as_notation()
                    .unwrap(); // <importNode obj="doc" var="aNode" importedNode="notation" deep="false"/>
                r#owner_document = r#a_node.owner_document().unwrap(); // <ownerDocument obj="aNode" var="ownerDocument"/>
                r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>
                assert_eq!(system, "staffNS.dtd"); // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="systemId"/>
                r#public_val = r#a_node.public_id().unwrap().to_string(); // <publicId interface="Notation" obj="aNode" var="publicVal"/>
                assert_eq!(r#public_val, "notation1File"); // <assertEquals actual="publicVal" expected="&quot;notation1File&quot;" id="publicId" ignoreCase="false"/>
                let r#system = r#a_node.system_id(); // <systemId interface="Notation" obj="aNode" var="system"/>
                assert!(system.is_none()); // <assertNull actual="system" id="notationSystemId"/>
            }
            // prefix01.xml
            #[test]
            fn test_prefix01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#created_node; // type: Node // <var name="createdNode" type="Node"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#created_node = r#doc.create_element("test:employee".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;test:employee&quot;" var="createdNode"/>
                r#prefix = r#created_node.prefix(); // <prefix obj="createdNode" var="prefix"/>
                assert!(prefix.is_none()); // <assertNull actual="prefix" id="throw_Null"/>
            }
            // documentimportnode12.xml
            #[test]
            fn test_documentimportnode12() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#imported; // type: Node // <var name="imported" type="Node"/>
                let mut r#address_elem; // type: Node // <var name="addressElem" type="Node"/>
                let mut r#address_elem_children; // type: NodeList // <var name="addressElemChildren" type="NodeList"/>
                let mut r#imported_children; // type: NodeList // <var name="importedChildren" type="NodeList"/>
                let mut r#address_elem_len; // type: int // <var name="addressElemLen" type="int"/>
                let mut r#imported_len; // type: int // <var name="importedLen" type="int"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#child_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="childList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#address_elem = r#child_list.item(0).unwrap(); // <item var="addressElem" obj="childList" index="0" interface="NodeList"/>
                r#imported = r#doc
                    .import_node(r#address_elem.clone().into(), true)
                    .unwrap(); // <importNode var="imported" obj="doc" importedNode="addressElem" deep="true"/>
                r#address_elem_children = r#address_elem.child_nodes(); // <childNodes var="addressElemChildren" obj="addressElem"/>
                r#imported_children = r#imported.child_nodes(); // <childNodes var="importedChildren" obj="imported"/>
                r#address_elem_len = r#address_elem_children.length(); // <length var="addressElemLen" obj="addressElemChildren" interface="NodeList"/>
                r#imported_len = r#imported_children.length(); // <length var="importedLen" obj="importedChildren" interface="NodeList"/>
                assert_eq!(r#address_elem_len, imported_len); // <assertEquals actual="addressElemLen" expected="importedLen" id="documentimportnode12" ignoreCase="false"/>
            }
            // documentimportnode13.xml
            #[test]
            fn test_documentimportnode13() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#imported; // type: Node // <var name="imported" type="Node"/>
                let mut r#imported_list; // type: NodeList // <var name="importedList" type="NodeList"/>
                let mut r#employee_elem; // type: Node // <var name="employeeElem" type="Node"/>
                let mut r#imported_len; // type: int // <var name="importedLen" type="int"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#child_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "employee"); // <getElementsByTagNameNS var="childList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;employee&quot;" interface="Document"/>
                r#employee_elem = r#child_list.item(0).unwrap(); // <item var="employeeElem" obj="childList" index="0" interface="NodeList"/>
                r#imported = r#doc.import_node(r#employee_elem.into(), false).unwrap(); // <importNode var="imported" obj="doc" importedNode="employeeElem" deep="false"/>
                r#imported_list = r#imported.child_nodes(); // <childNodes var="importedList" obj="imported"/>
                r#imported_len = r#imported_list.length(); // <length var="importedLen" obj="importedList" interface="NodeList"/>
                assert_eq!(r#imported_len, 0); // <assertEquals expected="0" actual="importedLen" id="documentimportnode13" ignoreCase="false"/>
            }
            // normalize01.xml
            #[test]
            fn test_normalize01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root; // type: Element // <var name="root" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                let mut r#text_list; // type: NodeList // <var name="textList" type="NodeList"/>
                let mut r#text_node; // type: CharacterData // <var name="textNode" type="CharacterData"/>
                let mut r#data; // type: DOMString // <var name="data" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#root = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="root"/>
                r#root.normalize(); // <normalize obj="root"/>
                r#element_list = r#root.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Element" obj="root" tagname="&quot;name&quot;" var="elementList"/>
                r#first_child = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="firstChild"/>
                r#text_list = r#first_child.child_nodes(); // <childNodes obj="firstChild" var="textList"/>
                r#text_node = r#text_list.item(0).unwrap().clone().as_text_node().unwrap(); // <item interface="NodeList" obj="textList" index="0" var="textNode"/>
                r#data = r#text_node.data().to_string(); // <data interface="CharacterData" obj="textNode" var="data"/>
                assert_eq!(r#data, "Roger\n Jones"); // <assertEquals actual="data" expected="&quot;Roger\n Jones&quot;" id="data" ignoreCase="false"/>
            }
            // namespaceURI01.xml
            #[test]
            fn test_namespace_ur_i01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                let mut r#addr_attr; // type: Attr // <var name="addrAttr" type="Attr"/>
                let mut r#attr_namespace_uri; // type: DOMString // <var name="attrNamespaceURI" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                r#addr_attr = r#test_addr
                    .get_attribute_node_ns(Some("http://www.nist.gov"), "district")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS obj="testAddr" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;district&quot;" var="addrAttr"/>
                r#attr_namespace_uri = r#addr_attr.namespace_uri().unwrap().to_string(); // <namespaceURI obj="addrAttr" var="attrNamespaceURI"/>
                assert_eq!(r#attr_namespace_uri, "http://www.nist.gov"); // <assertEquals actual="attrNamespaceURI" expected="&quot;http://www.nist.gov&quot;" id="namespaceURI" ignoreCase="false"/>
            }
            // importNode09.xml
            #[test]
            fn test_import_node09() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#entity_list; // type: NamedNodeMap // <var name="entityList" type="NamedNodeMap"/>
                let mut r#entity2; // type: Entity // <var name="entity2" type="Entity"/>
                let mut r#entity1; // type: Entity // <var name="entity1" type="Entity"/>
                let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                let mut r#entity_name; // type: DOMString // <var name="entityName" type="DOMString"/>
                let mut r#public_val; // type: DOMString // <var name="publicVal" type="DOMString"/>
                let mut r#notation_name; // type: DOMString // <var name="notationName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                r#doc_type = r#a_new_doc.doctype().unwrap(); // <doctype obj="aNewDoc" var="docType"/>
                entity_list = doc_type.entities(); // <entities obj="docType" var="entityList"/>
                // unimplemented: // <assertNotNull actual="entityList" id="entitiesNotNull"/>
                r#entity2 = r#entity_list.get_named_item("ent6").unwrap(); // <getNamedItem obj="entityList" var="entity2" name="&quot;ent6&quot;"/>
                r#entity1 = r#doc
                    .import_node(r#entity2.into(), false)
                    .unwrap()
                    .as_entity()
                    .unwrap(); // <importNode obj="doc" var="entity1" importedNode="entity2" deep="false"/>
                r#owner_document = r#entity1.owner_document().unwrap(); // <ownerDocument obj="entity1" var="ownerDocument"/>
                r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>
                assert_eq!(system, "staffNS.dtd"); // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="dtdSystemId"/>
                r#entity_name = r#entity1.node_name().to_string(); // <nodeName obj="entity1" var="entityName"/>
                assert_eq!(r#entity_name, "ent6"); // <assertEquals actual="entityName" expected="&quot;ent6&quot;" ignoreCase="false" id="entityName"/>
                r#public_val = r#entity1.public_id().unwrap().to_string(); // <publicId interface="Entity" obj="entity1" var="publicVal"/>
                assert_eq!(r#public_val, "uri"); // <assertEquals actual="publicVal" expected="&quot;uri&quot;" ignoreCase="false" id="entityPublicId"/>
                r#system = r#entity1.system_id().unwrap().to_string(); // <systemId interface="Entity" obj="entity1" var="system"/>
                assert_eq!(system, "file"); // <assertURIEquals actual="system" file="&quot;file&quot;" id="entitySystemId"/>
                r#notation_name = r#entity1.notation_name().unwrap().to_string(); // <notationName obj="entity1" var="notationName"/>
                assert_eq!(r#notation_name, "notation2"); // <assertEquals actual="notationName" expected="&quot;notation2&quot;" ignoreCase="false" id="notationName"/>
            }
            // getElementById02.xml
            #[test]
            fn test_get_element_by_id02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element = r#doc.get_element_by_id("Cancun".as_ref()); // <getElementById interface="Document" obj="doc" var="element" elementId="&quot;Cancun&quot;"/>
                assert!(element.is_none()); // <assertNull actual="element" id="throw_Null"/>
            }
            // attrgetownerelement03.xml
            #[test]
            fn test_attrgetownerelement03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#owner_element; // type: Node // <var name="ownerElement" type="Node"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#attr = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM"), "dom:attr".as_ref())
                    .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM&quot;" qualifiedName="&quot;dom:attr&quot;"/>
                r#owner_element = r#attr.owner_element(); // <ownerElement var="ownerElement" obj="attr"/>
                assert!(owner_element.is_none()); // <assertNull actual="ownerElement" id="attrgetownerelement03"/>
            }
            // elementgetattributens02.xml
            #[test]
            fn test_elementgetattributens02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#child_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "employee"); // <getElementsByTagNameNS var="childList" obj="doc" localName="&quot;employee&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" interface="Document"/>
                r#element = r#child_list.item(1).unwrap(); // <item var="element" obj="childList" index="1" interface="NodeList"/>
                r#attr_value = r#element.get_attribute_ns(None, "defaultAttr").unwrap(); // <getAttributeNS var="attrValue" obj="element" localName="&quot;defaultAttr&quot;" namespaceURI="nullNS"/>
                assert_eq!(r#attr_value, "defaultVal"); // <assertEquals actual="attrValue" expected="&quot;defaultVal&quot;" id="elementgetattributens02" ignoreCase="false"/>
            }
            // getElementsByTagNameNS06.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s06() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nomatch.com"), "address"); // <getElementsByTagNameNS interface="Document" obj="doc" namespaceURI="&quot;http://www.nomatch.com&quot;" localName="&quot;address&quot;" var="elementList"/>
                assert_eq!(element_list.length(), 0); // <assertSize collection="elementList" size="0" id="matchSize"/>
            }
            // isSupported11.xml
            #[test]
            fn test_is_supported11() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                state = root_node.is_supported("XML", Some("2.0")); // <isSupported obj="rootNode" feature="&quot;XML&quot;" version="&quot;2.0&quot;" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="throw_True"/>
            }
            // documentimportnode01.xml
            #[test]
            fn test_documentimportnode01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#imported_attr; // type: Node // <var name="importedAttr" type="Node"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#child_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="childList" obj="doc" localName="&quot;address&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" interface="Document"/>
                r#element = r#child_list.item(1).unwrap(); // <item var="element" obj="childList" index="1" interface="NodeList"/>
                r#attr = r#element.get_attribute_node("street").unwrap(); // <getAttributeNode var="attr" obj="element" name="&quot;street&quot;"/>
                r#imported_attr = r#doc.import_node(r#attr.into(), false).unwrap(); // <importNode var="importedAttr" obj="doc" importedNode="attr" deep="false"/>
                r#node_name = r#imported_attr.node_name().to_string(); // <nodeName var="nodeName" obj="importedAttr"/>
                r#node_value = r#imported_attr.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="importedAttr"/>
                r#node_type = r#imported_attr.node_type(); // <nodeType var="nodeType" obj="importedAttr"/>
                assert_eq!(r#node_name, "street"); // <assertEquals expected="&quot;street&quot;" actual="nodeName" id="documentimportnode01_nodeName" ignoreCase="false"/>
                assert_eq!(r#node_type as i32, 2); // <assertEquals expected="2" actual="nodeType" id="documentimportnode01_nodeType" ignoreCase="false"/>
                assert_eq!(r#node_value, "Yes"); // <assertEquals expected="&quot;Yes&quot;" actual="nodeValue" id="documentimportnode01_nodeValue" ignoreCase="false"/>
            }
            // elementsetattributens03.xml
            #[test]
            fn test_elementsetattributens03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:employee"); // <getElementsByTagName var="elementList" obj="doc" tagname="&quot;emp:employee&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                // unimplemented: // <assertNotNull actual="element" id="empEmployeeNotNull"/>
                r#element
                    .set_attribute_ns(
                        Some("http://www.w3.org/DOM/Test/1"),
                        "defaultAttr",
                        "default1",
                    )
                    .unwrap(); // <setAttributeNS obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/1&quot;" qualifiedName="&quot;defaultAttr&quot;" value="&quot;default1&quot;"/>
                r#element
                    .set_attribute_ns(
                        Some("http://www.w3.org/DOM/Test/2"),
                        "defaultAttr",
                        "default2",
                    )
                    .unwrap(); // <setAttributeNS obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/2&quot;" qualifiedName="&quot;defaultAttr&quot;" value="&quot;default2&quot;"/>
                r#attribute = r#element
                    .get_attribute_node_ns(Some("http://www.w3.org/DOM/Test/1"), "defaultAttr")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attribute" obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/1&quot;" localName="&quot;defaultAttr&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                r#attr_value = r#attribute.node_value().unwrap().to_string(); // <nodeValue var="attrValue" obj="attribute"/>
                assert_eq!(r#attr_name, "defaultAttr"); // <assertEquals actual="attrName" expected="&quot;defaultAttr&quot;" id="elementsetattributens03_attrName" ignoreCase="false"/>
                assert_eq!(r#attr_value, "default1"); // <assertEquals actual="attrValue" expected="&quot;default1&quot;" id="elementsetattributens03_attrValue" ignoreCase="false"/>
            }
            // getElementsByTagNameNS09.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s09() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_list; // type: NodeList // <var name="newList" type="NodeList"/>
                let mut r#new_element; // type: Element // <var name="newElement" type="Element"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                let mut r#lname; // type: DOMString // <var name="lname" type="DOMString"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#new_list = r#doc_elem
                    .get_elements_by_tag_name_ns(Some("*"), "employee")
                    .unwrap(); // <getElementsByTagNameNS interface="Element" obj="docElem" var="newList" namespaceURI="&quot;*&quot;" localName="&quot;employee&quot;"/>
                assert_eq!(new_list.length(), 5); // <assertSize collection="newList" size="5" id="employeeCount"/>
                r#new_element = r#new_list.item(3).unwrap(); // <item interface="NodeList" obj="newList" var="newElement" index="3"/>
                r#prefix = r#new_element.prefix().unwrap().to_string(); // <prefix obj="newElement" var="prefix"/>
                assert_eq!(r#prefix, "emp"); // <assertEquals actual="prefix" expected="&quot;emp&quot;" id="prefix" ignoreCase="false"/>
                r#lname = r#new_element.local_name().unwrap().to_string(); // <localName obj="newElement" var="lname"/>
                assert_eq!(r#lname, "employee"); // <assertEquals actual="lname" expected="&quot;employee&quot;" id="lname" ignoreCase="false"/>
            }
            // documentimportnode19.xml
            #[test]
            fn test_documentimportnode19() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_imp: DocumentRef; // <var name="docImp" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#node_map; // type: NamedNodeMap // <var name="nodeMap" type="NamedNodeMap"/>
                let mut r#entity2; // type: Entity // <var name="entity2" type="Entity"/>
                let mut r#entity6; // type: Entity // <var name="entity6" type="Entity"/>
                let mut r#entity_imp2; // type: Entity // <var name="entityImp2" type="Entity"/>
                let mut r#entity_imp6; // type: Entity // <var name="entityImp6" type="Entity"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#system_id; // type: DOMString // <var name="systemId" type="DOMString"/>
                let mut r#notation_name; // type: DOMString // <var name="notationName" type="DOMString"/>
                let mut r#node_name_imp; // type: DOMString // <var name="nodeNameImp" type="DOMString"/>
                let mut r#system_id_imp; // type: DOMString // <var name="systemIdImp" type="DOMString"/>
                let mut r#notation_name_imp; // type: DOMString // <var name="notationNameImp" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                dom_impl = doc.implementation(); // <implementation var="domImpl" obj="doc"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                doc_imp = dom_impl
                    .create_document(Some("http://www.w3.org/DOM/Test"), Some("a:b"), None)
                    .unwrap(); // <createDocument var="docImp" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;a:b&quot;" doctype="docTypeNull"/>
                node_map = doc_type.entities(); // <entities var="nodeMap" obj="docType"/>
                // unimplemented: // <assertNotNull actual="nodeMap" id="entitiesNotNull"/>
                r#entity2 = r#node_map.get_named_item("ent2").unwrap(); // <getNamedItem var="entity2" obj="nodeMap" name="&quot;ent2&quot;"/>
                r#entity6 = r#node_map.get_named_item("ent6").unwrap(); // <getNamedItem var="entity6" obj="nodeMap" name="&quot;ent6&quot;"/>
                r#entity_imp2 = r#doc_imp
                    .import_node(r#entity2.clone().into(), false)
                    .unwrap()
                    .as_entity()
                    .unwrap(); // <importNode var="entityImp2" obj="docImp" importedNode="entity2" deep="false"/>
                r#entity_imp6 = r#doc_imp
                    .import_node(r#entity6.clone().into(), true)
                    .unwrap()
                    .as_entity()
                    .unwrap(); // <importNode var="entityImp6" obj="docImp" importedNode="entity6" deep="true"/>
                r#node_name = r#entity2.node_name().to_string(); // <nodeName var="nodeName" obj="entity2"/>
                r#node_name_imp = r#entity_imp2.node_name().to_string(); // <nodeName var="nodeNameImp" obj="entityImp2"/>
                assert_eq!(r#node_name_imp, node_name); // <assertEquals expected="nodeName" actual="nodeNameImp" id="documentimportnode19_Ent2NodeName" ignoreCase="false"/>
                r#node_name = r#entity6.node_name().to_string(); // <nodeName var="nodeName" obj="entity6"/>
                r#node_name_imp = r#entity_imp6.node_name().to_string(); // <nodeName var="nodeNameImp" obj="entityImp6"/>
                assert_eq!(r#node_name_imp, node_name); // <assertEquals expected="nodeName" actual="nodeNameImp" id="documentimportnode19_Ent6NodeName" ignoreCase="false"/>
                r#system_id = r#entity2.system_id(); // <systemId var="systemId" obj="entity2" interface="Entity"/>
                r#system_id_imp = r#entity_imp2.system_id(); // <systemId var="systemIdImp" obj="entityImp2" interface="Entity"/>
                assert_eq!(r#system_id_imp, system_id); // <assertEquals expected="systemId" actual="systemIdImp" id="documentimportnode19_Ent2SystemId" ignoreCase="false"/>
                r#system_id = r#entity6.system_id(); // <systemId var="systemId" obj="entity6" interface="Entity"/>
                r#system_id_imp = r#entity_imp6.system_id(); // <systemId var="systemIdImp" obj="entityImp6" interface="Entity"/>
                assert_eq!(r#system_id_imp, system_id); // <assertEquals expected="systemId" actual="systemIdImp" id="documentimportnode19_Ent6SystemId" ignoreCase="false"/>
                r#notation_name = r#entity2.notation_name(); // <notationName var="notationName" obj="entity2" interface="Entity"/>
                r#notation_name_imp = r#entity_imp2.notation_name(); // <notationName var="notationNameImp" obj="entityImp2" interface="Entity"/>
                assert_eq!(r#notation_name_imp, notation_name); // <assertEquals expected="notationName" actual="notationNameImp" id="documentimportnode19_Ent2NotationName" ignoreCase="false"/>
                r#notation_name = r#entity6.notation_name(); // <notationName var="notationName" obj="entity6" interface="Entity"/>
                r#notation_name_imp = r#entity_imp6.notation_name(); // <notationName var="notationNameImp" obj="entityImp6" interface="Entity"/>
                assert_eq!(r#notation_name_imp, notation_name); // <assertEquals expected="notationName" actual="notationNameImp" id="documentimportnode19_Ent6NotationName" ignoreCase="false"/>
            }
            // createDocumentType04.xml
            #[test]
            fn test_create_document_type04() {
                let mut r#public_id = "http://www.example.com/"; // type: DOMString // <var name="publicId" type="DOMString" value="&quot;http://www.example.com/&quot;"/>
                let mut r#system_id = "myDoc.dtd"; // type: DOMString // <var name="systemId" type="DOMString" value="&quot;myDoc.dtd&quot;"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                dom_impl = DOM_IMPLEMENTATION_REGISTRY
                    .get_dom_implementation("XML")
                    .unwrap(); // <implementation var="domImpl"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <createDocumentType obj="domImpl" var="docType" qualifiedName="&quot;&quot;" publicId="publicId" systemId="systemId"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    dom_impl
                        .create_document_type("", Some(public_id), Some(system_id))
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // prefix10.xml
            #[test]
            fn test_prefix10() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <prefix obj="employeeNode" value="&quot;xml&quot;"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    employee_node
                        .set_prefix(Some("xml"))
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // createAttributeNS03.xml
            #[test]
            fn test_create_attribute_n_s03() {
                let mut r#namespace_uri = "http://www.wedding.com/"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.wedding.com/&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#illegal_q_names = vec![
                    "person:{",
                    "person:}",
                    "person:~",
                    "person:'",
                    "person:!",
                    "person:@",
                    "person:#",
                    "person:$",
                    "person:%",
                    "person:^",
                    "person:&",
                    "person:*",
                    "person:(",
                    "person:)",
                    "person:+",
                    "person:=",
                    "person:[",
                    "person:]",
                    "person:\\",
                    "person:/",
                    "person:;",
                    "person:`",
                    "person:<",
                    "person:>",
                    "person:,",
                    "person:a ",
                    "person:\"",
                ]; // type: List // <var name="illegalQNames" type="List"><member>"person:{"</member><member>"person:}"</member><member>"person:~"</member><member>"person:'"</member><member>"person:!"</member><member>"person:@"</member><member>"person:#"</member><member>"person:$"</member><member>"person:%"</member><member>"person:^"</member><member>"person:&amp;"</member><member>"person:*"</member><member>"person:("</member><member>"person:)"</member><member>"person:+"</member><member>"person:="</member><member>"person:["</member><member>"person:]"</member><member>"person:\\"</member><member>"person:/"</member><member>"person:;"</member><member>"person:`"</member><member>"person:&lt;"</member><member>"person:&gt;"</member><member>"person:,"</member><member>"person:a "</member><member>"person:\""</member></var>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // <for-each collection="illegalQNames" member="qualifiedName">
                //  <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //      <INVALID_CHARACTER_ERR>
                //          <createAttributeNS obj="doc" var="newAttr" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                //      </INVALID_CHARACTER_ERR>
                //  </assertDOMException>
                // </for-each>
                for qualified_name in illegal_q_names {
                    assert!(
                        doc.create_attribute_ns(Some(namespace_uri), qualified_name)
                            .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                    );
                }
            }
            // getElementsByTagNameNS11.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s11() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let mut r#expected_result =
                    vec!["address", "address", "address", "emp:address", "address"]; // type: List // <var name="expectedResult" type="List"><member>"address"</member><member>"address"</member><member>"address"</member><member>"emp:address"</member><member>"address"</member></var>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#element_list = r#doc_elem
                    .get_elements_by_tag_name_ns(Some("*"), "address")
                    .unwrap(); // <getElementsByTagNameNS interface="Element" obj="docElem" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" var="elementList"/>
                // <for-each collection="elementList" member="child">
                //  <nodeName obj="child" var="childName"/>
                //  <append collection="result" item="childName"/>
                // </for-each>
                for i in 0..element_list.length() {
                    child = element_list.item(i).unwrap();
                    child_name = child.node_name().to_string();
                    result.push(child_name);
                }
                assert_eq!(r#result, expected_result); // <assertEquals actual="result" expected="expectedResult" id="nodeNames" ignoreCase="false"/>
            }
            // getElementsByTagNameNS05.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s05() {
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#local_name = "nomatch"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;nomatch&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some(r#namespace_uri), r#local_name.as_ref()); // <getElementsByTagNameNS interface="Document" obj="doc" namespaceURI="namespaceURI" localName="localName" var="elementList"/>
                assert_eq!(element_list.length(), 0); // <assertSize collection="elementList" size="0" id="throw_Size"/>
            }
            // documentcreateelementNS06.xml
            #[test]
            fn test_documentcreateelement_n_s06() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#namespace_uri = "http://www.w3.org/xml/1998/namespace "; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/xml/1998/namespace &quot;"/>
                let mut r#qualified_name = "xml:root"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;xml:root&quot;"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation var="domImpl" obj="doc"/>
                new_doc = dom_impl
                    .create_document(Some("http://www.w3.org/DOM/Test"), Some("dom:doc"), None)
                    .unwrap(); // <createDocument var="newDoc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;dom:doc&quot;" doctype="docType"/>
                // <assertDOMException id="documentcreateelementNS06">
                //  <NAMESPACE_ERR>
                //      <createElementNS obj="newDoc" var="element" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    new_doc
                        .create_element_ns(Some(namespace_uri), qualified_name)
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // documentimportnode15.xml
            #[test]
            fn test_documentimportnode15() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_imp: DocumentRef; // <var name="docImp" type="Document"/>
                let mut r#text_import; // type: Node // <var name="textImport" type="Node"/>
                let mut r#text_to_import; // type: Node // <var name="textToImport" type="Node"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_imp = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="docImp" href="staffNS" willBeModified="true"/>
                r#text_to_import =
                    r#doc.create_text_node("Document.importNode test for a TEXT_NODE"); // <createTextNode var="textToImport" obj="doc" data="&quot;Document.importNode test for a TEXT_NODE&quot;"/>
                r#text_import = r#doc.import_node(r#text_to_import.into(), true).unwrap(); // <importNode var="textImport" obj="doc" importedNode="textToImport" deep="true"/>
                r#node_value = r#text_import.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="textImport"/>
                assert_eq!(r#node_value, "Document.importNode test for a TEXT_NODE"); // <assertEquals expected="&quot;Document.importNode test for a TEXT_NODE&quot;" actual="nodeValue" id="documentimportnode15" ignoreCase="false"/>
            }
            // domimplementationcreatedocument07.xml
            #[test]
            fn test_domimplementationcreatedocument07() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                let mut r#namespace_uri = "http://www.w3.org/DOMTest/level2"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/DOMTest/level2&quot;"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                // <assertDOMException id="domimplementationcreatedocument07">
                //  <NAMESPACE_ERR>
                //      <createDocument obj="domImpl" var="newDoc" namespaceURI="namespaceURI" qualifiedName="&quot;:&quot;" doctype="docType"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    dom_impl
                        .create_document(Some(namespace_uri), Some(":"), None)
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // namednodemapsetnameditemns11.xml
            #[test]
            fn test_namednodemapsetnameditemns11() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                // notations = doc_type.notations(); // <notations var="notations" obj="docType"/>
                // // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                // r#notation = r#notations.get_named_item("notation1".into()).unwrap(); // <getNamedItem var="notation" obj="notations" name="&quot;notation1&quot;"/>
                // r#element_list =
                //     r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;" interface="Document"/>
                // r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                // r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                // // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                // //  <HIERARCHY_REQUEST_ERR>
                // //      <setNamedItemNS var="newNode" obj="attributes" arg="notation"/>
                // //  </HIERARCHY_REQUEST_ERR>
                // // </assertDOMException>
                // assert!(
                //     attributes
                //         .set_named_item_ns(notations)
                //         .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                // );
            }
            // documentgetelementsbytagnameNS01.xml
            #[test]
            fn test_documentgetelementsbytagname_n_s01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                dom_impl = doc.implementation(); // <implementation var="domImpl" obj="doc"/>
                new_doc = dom_impl.create_document(None, Some("root"), None).unwrap(); // <createDocument var="newDoc" obj="domImpl" namespaceURI="nullNS" qualifiedName="&quot;root&quot;" doctype="docType"/>
                r#child_list = r#new_doc.get_elements_by_tag_name_ns(Some("*"), "*"); // <getElementsByTagNameNS var="childList" obj="newDoc" namespaceURI="&quot;*&quot;" localName="&quot;*&quot;" interface="Document"/>
                assert_eq!(child_list.length(), 1); // <assertSize size="1" collection="childList" id="documentgetelementsbytagnameNS01"/>
            }
            // nodesetprefix03.xml
            #[test]
            fn test_nodesetprefix03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element = r#doc.create_element("address".to_string()).unwrap(); // <createElement var="element" obj="doc" tagName="&quot;address&quot;"/>
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <prefix obj="element" value="&quot;test&quot;"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    element
                        .set_prefix(Some("test"))
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // nodeissupported01.xml
            #[test]
            fn test_nodeissupported01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#version = ""; // type: DOMString // <var name="version" type="DOMString" value="&quot;&quot;"/>
                let mut r#version1 = "1.0"; // type: DOMString // <var name="version1" type="DOMString" value="&quot;1.0&quot;"/>
                let mut r#version2 = "2.0"; // type: DOMString // <var name="version2" type="DOMString" value="&quot;2.0&quot;"/>
                let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                let mut r#features_xml = vec!["XML", "xmL"]; // type: List // <var name="featuresXML" type="List"><member>"XML"</member><member>"xmL"</member></var>
                let mut r#features_core = vec!["Core", "CORE"]; // type: List // <var name="featuresCore" type="List"><member>"Core"</member><member>"CORE"</member></var>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="element"/>
                // <for-each collection="featuresXML" member="featureXML">
                //  <isSupported obj="element" var="success" feature="featureXML" version="version"/>
                //  <assertTrue actual="success" id="nodeissupported01_XML1"/>
                //  <isSupported obj="element" var="success" feature="featureXML" version="version1"/>
                //  <assertTrue actual="success" id="nodeissupported01_XML2"/>
                // </for-each>
                for feature_xml in features_xml {
                    success = element.is_supported(feature_xml, Some(version));
                    assert!(success);
                    success = element.is_supported(feature_xml, Some(version1));
                    assert!(success);
                }
                // <for-each collection="featuresCore" member="featureCore">
                //  <isSupported obj="element" var="success" feature="featureCore" version="version"/>
                //  <assertTrue actual="success" id="nodeissupported01_Core1"/>
                //  <!--   isSupported("Core", "1.0") is unspecified since "Core" was not defined in L1  -->
                //  <isSupported obj="element" var="success" feature="featureCore" version="version1"/>
                //  <isSupported obj="element" var="success" feature="featureCore" version="version2"/>
                //  <assertTrue actual="success" id="nodeissupported01_Core3"/>
                // </for-each>
                for feature_core in features_core {
                    success = element.is_supported(feature_core, Some(version));
                    assert!(success);
                    success = element.is_supported(feature_core, Some(version1));
                    success = element.is_supported(feature_core, Some(version2));
                    assert!(success);
                }
            }
            // documentimportnode05.xml
            #[test]
            fn test_documentimportnode05() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_imported: DocumentRef; // <var name="docImported" type="Document"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#imported_attr; // type: Node // <var name="importedAttr" type="Node"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_imported = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="docImported" href="staff" willBeModified="true"/>
                r#attr = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Test"), "a_:b0".as_ref())
                    .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;a_:b0&quot;"/>
                r#imported_attr = r#doc_imported.import_node(r#attr.into(), false).unwrap(); // <importNode var="importedAttr" obj="docImported" importedNode="attr" deep="false"/>
                r#node_name = r#imported_attr.node_name().to_string(); // <nodeName var="nodeName" obj="importedAttr"/>
                r#node_value = r#imported_attr.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="importedAttr"/>
                r#node_type = r#imported_attr.node_type(); // <nodeType var="nodeType" obj="importedAttr"/>
                r#namespace_uri = r#imported_attr.namespace_uri().unwrap().to_string(); // <namespaceURI var="namespaceURI" obj="importedAttr"/>
                assert_eq!(r#node_name, "a_:b0"); // <assertEquals expected="&quot;a_:b0&quot;" actual="nodeName" id="documentimportnode05_nodeName" ignoreCase="false"/>
                assert_eq!(r#node_type as i32, 2); // <assertEquals expected="2" actual="nodeType" id="documentimportnode05_nodeType" ignoreCase="false"/>
                assert_eq!(r#node_value, ""); // <assertEquals expected="&quot;&quot;" actual="nodeValue" id="documentimportnode05_nodeValue" ignoreCase="false"/>
                assert_eq!(r#namespace_uri, "http://www.w3.org/DOM/Test"); // <assertEquals expected="&quot;http://www.w3.org/DOM/Test&quot;" actual="namespaceURI" id="documentimportnode05_namespaceURI" ignoreCase="false"/>
            }
            // documentcreateattributeNS02.xml
            #[test]
            fn test_documentcreateattribute_n_s02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attribute1; // type: Attr // <var name="attribute1" type="Attr"/>
                let mut r#attribute2; // type: Attr // <var name="attribute2" type="Attr"/>
                let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#attribute1 = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/XML/1998/namespace"),
                        "xml:xml".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS obj="doc" var="attribute1" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:xml&quot;"/>
                r#name = r#attribute1.name().to_string(); // <name var="name" obj="attribute1" interface="Attr"/>
                r#node_name = r#attribute1.node_name().to_string(); // <nodeName var="nodeName" obj="attribute1"/>
                r#node_value = r#attribute1.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="attribute1"/>
                r#prefix = r#attribute1.prefix().unwrap().to_string(); // <prefix var="prefix" obj="attribute1"/>
                r#namespace_uri = r#attribute1.namespace_uri().unwrap().to_string(); // <namespaceURI var="namespaceURI" obj="attribute1"/>
                assert_eq!(r#name, "xml:xml"); // <assertEquals actual="name" expected="&quot;xml:xml&quot;" id="documentcreateattributeNS02_att1_name" ignoreCase="false"/>
                assert_eq!(r#node_name, "xml:xml"); // <assertEquals actual="nodeName" expected="&quot;xml:xml&quot;" id="documentcreateattributeNS02_att1_nodeName" ignoreCase="false"/>
                assert_eq!(r#node_value, ""); // <assertEquals actual="nodeValue" expected="&quot;&quot;" id="documentcreateattributeNS02_att1_nodeValue" ignoreCase="false"/>
                assert_eq!(r#prefix, "xml"); // <assertEquals actual="prefix" expected="&quot;xml&quot;" id="documentcreateattributeNS02_att1_prefix" ignoreCase="false"/>
                assert_eq!(r#namespace_uri, "http://www.w3.org/XML/1998/namespace"); // <assertEquals actual="namespaceURI" expected="&quot;http://www.w3.org/XML/1998/namespace&quot;" id="documentcreateattributeNS02_att1_namespaceURI" ignoreCase="false"/>
                r#attribute2 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/2000/xmlns/"), "xmlns".as_ref())
                    .unwrap(); // <createAttributeNS obj="doc" var="attribute2" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" qualifiedName="&quot;xmlns&quot;"/>
                r#name = r#attribute2.name().to_string(); // <name var="name" obj="attribute2" interface="Attr"/>
                r#node_name = r#attribute2.node_name().to_string(); // <nodeName var="nodeName" obj="attribute2"/>
                r#node_value = r#attribute2.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="attribute2"/>
                // r#prefix = r#attribute2.prefix(); // <prefix var="prefix" obj="attribute2"/>
                r#namespace_uri = r#attribute2.namespace_uri().unwrap().to_string(); // <namespaceURI var="namespaceURI" obj="attribute2"/>
                assert_eq!(r#name, "xmlns"); // <assertEquals actual="name" expected="&quot;xmlns&quot;" id="documentcreateattributeNS02_att2_name" ignoreCase="false"/>
                assert_eq!(r#node_name, "xmlns"); // <assertEquals actual="nodeName" expected="&quot;xmlns&quot;" id="documentcreateattributeNS02_att2_nodeName" ignoreCase="false"/>
                assert_eq!(r#node_value, ""); // <assertEquals actual="nodeValue" expected="&quot;&quot;" id="documentcreateattributeNS02_att2_nodeValue" ignoreCase="false"/>
                assert_eq!(r#namespace_uri, "http://www.w3.org/2000/xmlns/"); // <assertEquals actual="namespaceURI" expected="&quot;http://www.w3.org/2000/xmlns/&quot;" id="documentcreateattributeNS02_att2_namespaceURI" ignoreCase="false"/>
            }
            // isSupported02.xml
            #[test]
            fn test_is_supported02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                state = root_node.is_supported("XML", Some("9.0")); // <isSupported obj="rootNode" feature="&quot;XML&quot;" version="&quot;9.0&quot;" var="state"/>
                assert!(!r#state); // <assertFalse actual="state" id="throw_False"/>
            }
            // createAttributeNS05.xml
            #[test]
            fn test_create_attribute_n_s05() {
                let mut r#namespace_uri = "http://www.ecommerce.org/"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.ecommerce.org/&quot;"/>
                let mut r#qualified_name = "econm:local"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;econm:local&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#new_attr = r#doc
                    .create_attribute_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                    .unwrap(); // <createAttributeNS obj="doc" var="newAttr" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                r#attr_name = r#new_attr.name().to_string(); // <name interface="Attr" obj="newAttr" var="attrName"/>
                assert_eq!(r#attr_name, qualified_name); // <assertEquals actual="attrName" expected="qualifiedName" id="throw_Equals" ignoreCase="false"/>
            }
            // removeNamedItemNS03.xml
            #[test]
            fn test_remove_named_item_n_s03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#namespace_uri = "http://www.w3.org/2000/xmlns/"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/2000/xmlns/&quot;"/>
                let mut r#local_name = "local1"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;local1&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#n_list; // type: NodeList // <var name="nList" type="NodeList"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#n2_list; // type: NodeList // <var name="n2List" type="NodeList"/>
                let mut r#child2; // type: Node // <var name="child2" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;gender&quot;"/>
                r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                r#n_list = r#test_address.child_nodes(); // <childNodes obj="testAddress" var="nList"/>
                r#child = r#n_list.item(0).unwrap(); // <item interface="NodeList" obj="nList" var="child" index="0"/>
                r#node_type = r#child.node_type(); // <nodeType var="nodeType" obj="child"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="child" name="&quot;ent4&quot;" obj="doc"/>
                //  <assertNotNull actual="child" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    child = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#n2_list = r#child.child_nodes(); // <childNodes obj="child" var="n2List"/>
                r#child2 = r#n2_list.item(0).unwrap(); // <item interface="NodeList" obj="n2List" var="child2" index="0"/>
                // unimplemented: // <assertNotNull actual="child2" id="notnull"/>
                r#attributes = r#child2.attributes().unwrap(); // <attributes obj="child2" var="attributes"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <removeNamedItemNS var="removedNode" interface="NamedNodeMap" obj="attributes" namespaceURI="namespaceURI" localName="localName"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .remove_named_item_ns(Some(namespace_uri), local_name)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // importNode01.xml
            #[test]
            fn test_import_node01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                let mut r#imported_child; // type: Text // <var name="importedChild" type="Text"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                let mut r#specified; // type: boolean // <var name="specified" type="boolean"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_value; // type: DOMString // <var name="childValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                r#new_attr = r#a_new_doc
                    .create_attribute("elem:attr1".to_string())
                    .unwrap(); // <createAttribute obj="aNewDoc" var="newAttr" name="&quot;elem:attr1&quot;"/>
                r#imported_child = r#a_new_doc.create_text_node("importedText"); // <createTextNode obj="aNewDoc" var="importedChild" data="&quot;importedText&quot;"/>
                r#a_node = r#new_attr.append_child(imported_child.into()).unwrap(); // <appendChild obj="newAttr" var="aNode" newChild="importedChild"/>
                let r#a_node = r#doc
                    .import_node(r#new_attr.into(), false)
                    .unwrap()
                    .as_attribute()
                    .unwrap(); // <importNode obj="doc" var="aNode" importedNode="newAttr" deep="false"/>
                r#owner_document = r#a_node.owner_document().unwrap(); // <ownerDocument obj="aNode" var="ownerDocument"/>
                r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>
                // unimplemented: // <assertNotNull actual="aNode" id="aNode"/>
                assert_eq!(system, "staffNS.dtd"); // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="systemId"/>
                let r#attr_owner_element = r#a_node.owner_element(); // <ownerElement obj="aNode" var="attrOwnerElement"/>
                assert!(attr_owner_element.is_none()); // <assertNull actual="attrOwnerElement" id="ownerElement"/>
                r#specified = r#a_node.specified(); // <specified obj="aNode" var="specified"/>
                assert!(r#specified); // <assertTrue actual="specified" id="specified"/>
                r#child_list = r#a_node.child_nodes(); // <childNodes obj="aNode" var="childList"/>
                assert_eq!(child_list.length(), 1); // <assertSize collection="childList" size="1" id="childList"/>
                r#node_name = r#a_node.node_name().to_string(); // <nodeName obj="aNode" var="nodeName"/>
                assert_eq!(r#node_name, "elem:attr1"); // <assertEquals actual="nodeName" id="nodeName" ignoreCase="false" expected="&quot;elem:attr1&quot;"/>
                r#child = r#a_node.first_child().unwrap(); // <firstChild interface="Node" obj="aNode" var="child"/>
                r#child_value = r#child.node_value().unwrap().to_string(); // <nodeValue obj="child" var="childValue"/>
                assert_eq!(r#child_value, "importedText"); // <assertEquals actual="childValue" id="childValue" ignoreCase="false" expected="&quot;importedText&quot;"/>
            }
            // nodesetprefix04.xml
            #[test]
            fn test_nodesetprefix04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:employee"); // <getElementsByTagName var="elementList" obj="doc" tagname="&quot;emp:employee&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                // unimplemented: // <assertNotNull actual="element" id="empEmployeeNotNull"/>
                r#attribute = r#element
                    .get_attribute_node_ns(None, "defaultAttr")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attribute" obj="element" namespaceURI="nullNS" localName="&quot;defaultAttr&quot;"/>
                // <assertDOMException id="nodesetprefix04">
                //  <NAMESPACE_ERR>
                //      <prefix obj="attribute" value="&quot;test&quot;"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
                assert!(
                    attribute
                        .set_prefix(Some("test"))
                        .is_err_and(|err| err == DOMException::NamespaceErr)
                );
            }
            // documentimportnode14.xml
            #[test]
            fn test_documentimportnode14() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#imported; // type: Node // <var name="imported" type="Node"/>
                let mut r#employee_elem; // type: Node // <var name="employeeElem" type="Node"/>
                let mut r#attr_node; // type: Attr // <var name="attrNode" type="Attr"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#child_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "employee"); // <getElementsByTagNameNS var="childList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;employee&quot;" interface="Document"/>
                r#employee_elem = r#child_list.item(3).unwrap().clone(); // <item var="employeeElem" obj="childList" index="3" interface="NodeList"/>
                dom_impl = DOM_IMPLEMENTATION_REGISTRY
                    .get_dom_implementation("XML")
                    .unwrap(); // <implementation var="domImpl"/>
                new_doc = dom_impl.create_document(None, Some("staff"), None).unwrap(); // <createDocument var="newDoc" obj="domImpl" namespaceURI="nullNS" qualifiedName="&quot;staff&quot;" doctype="nullDocType"/>
                r#imported = r#new_doc
                    .import_node(r#employee_elem.into(), true)
                    .unwrap()
                    .as_element()
                    .unwrap(); // <importNode var="imported" obj="newDoc" importedNode="employeeElem" deep="true"/>
                r#attr_node = r#imported
                    .get_attribute_node_ns(None, "defaultAttr")
                    .unwrap(); // <getAttributeNodeNS var="attrNode" obj="imported" namespaceURI="nullNS" localName="&quot;defaultAttr&quot;"/>
                assert!(attr_node.is_none()); // <assertNull actual="attrNode" id="defaultAttrNotImported"/>
                r#attr_value = r#imported
                    .get_attribute_ns(Some("http://www.w3.org/2000/xmlns/"), "emp")
                    .unwrap(); // <getAttributeNS var="attrValue" obj="imported" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" localName="&quot;emp&quot;"/>
                assert_eq!(r#attr_value, "http://www.nist.gov"); // <assertEquals actual="attrValue" expected="&quot;http://www.nist.gov&quot;" ignoreCase="false" id="explicitAttrImported"/>
            }
            // documentgetelementsbytagnameNS05.xml
            #[test]
            fn test_documentgetelementsbytagname_n_s05() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#child_list = r#doc.get_elements_by_tag_name_ns(Some("null"), "elementId"); // <getElementsByTagNameNS var="childList" obj="doc" namespaceURI="&quot;null&quot;" localName="&quot;elementId&quot;" interface="Document"/>
                assert_eq!(child_list.length(), 0); // <assertSize size="0" collection="childList" id="documentgetelementsbytagnameNS05"/>
            }
            // nodesetprefix09.xml
            #[test]
            fn test_nodesetprefix09() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#value = "#$%&amp;'()@"; // type: DOMString // <var name="value" type="DOMString" value="&quot;#$%&amp;'()@&quot;"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test/L2"), "dom:elem".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/L2&quot;" qualifiedName="&quot;dom:elem&quot;"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <prefix obj="element" value="value"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    element
                        .set_prefix(Some(value))
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // getElementsByTagNameNS14.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s14() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#element_list = r#doc_elem
                    .get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address")
                    .unwrap(); // <getElementsByTagNameNS interface="Element" obj="docElem" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;" var="elementList"/>
                assert_eq!(element_list.length(), 3); // <assertSize collection="elementList" size="3" id="addresses"/>
            }
        }
    }
}
