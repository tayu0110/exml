#![allow(unused)]
#![allow(unused_variables)]
#![allow(unreachable_code)]
#[cfg(test)]
mod dom_test_suite {
    use exml::dom::{
        attlistdecl::*, character_data::*, document::*, document_type::*, elementdecl::*,
        entity::*, node::*, *,
    };

    // fn load_xml<const SAX2: bool>(doc: &str) -> DocumentRef {
    //     let mut handler = XmlSAXHandler::default();
    //     fn downgrade_user_data(data: Option<GenericErrorContext>) -> (DocumentRef, NodeRef) {
    //         data.unwrap()
    //             .lock()
    //             .downcast_ref::<(DocumentRef, NodeRef)>()
    //             .unwrap()
    //             .clone()
    //     }
    //     if SAX2 {
    //         handler.start_element = None;
    //         handler.end_element = None;
    //         fn start_element_ns(
    //             ctxt: &mut XmlParserCtxt,
    //             localname: &str,
    //             prefix: Option<&str>,
    //             orig_uri: Option<&str>,
    //             namespaces: &[(Option<String>, String)],
    //             nb_defaulted: usize,
    //             attributes: &[(String, Option<String>, Option<String>, String)],
    //         ) {
    //             let (mut doc, mut node) = downgrade_user_data(ctxt.user_data.clone());
    //             let mut element = doc
    //                 .create_element_ns(
    //                     orig_uri,
    //                     &prefix.map_or_else(
    //                         || localname.to_owned(),
    //                         |pre| format!("{pre}:{localname}"),
    //                     ),
    //                 )
    //                 .unwrap();
    //             node.append_child(element.clone().into()).unwrap();
    //             for (local_name, prefix, namespace, value) in
    //                 attributes.iter().take(attributes.len() - nb_defaulted)
    //             {
    //                 let qname = build_qname(local_name, prefix.as_deref());
    //                 element
    //                     .set_attribute_ns(
    //                         namespace.as_deref().map(|ns| ns.into()),
    //                         qname.into(),
    //                         value.as_str(),
    //                     )
    //                     .unwrap();
    //             }
    //             ctxt.user_data = Some(GenericErrorContext::new((doc, NodeRef::from(element))));
    //             xml_sax2_start_element_ns(
    //                 ctxt,
    //                 localname,
    //                 prefix,
    //                 orig_uri,
    //                 namespaces,
    //                 nb_defaulted,
    //                 attributes,
    //             );
    //         }
    //         fn end_element_ns(
    //             ctxt: &mut XmlParserCtxt,
    //             _localname: &str,
    //             _prefix: Option<&str>,
    //             _uri: Option<&str>,
    //         ) {
    //             let (mut doc, mut node) = downgrade_user_data(ctxt.user_data.clone());
    //             ctxt.user_data = Some(GenericErrorContext::new((doc, node.parent_node().unwrap())));
    //             xml_sax2_end_element_ns(ctxt, _localname, _prefix, _uri);
    //         }
    //         handler.start_element_ns = Some(start_element_ns);
    //         handler.end_element_ns = Some(end_element_ns);
    //         handler.serror = None;
    //         handler.initialized = XML_SAX2_MAGIC as _;
    //     } else {
    //         fn start_element(
    //             ctxt: &mut XmlParserCtxt,
    //             fullname: &str,
    //             atts: &[(String, Option<String>)],
    //         ) {
    //             let (mut doc, mut node) = downgrade_user_data(ctxt.user_data.clone());
    //             let mut element = doc.create_element(fullname).unwrap();
    //             eprintln!(
    //                 "node: {}, element: {}",
    //                 node.node_name(),
    //                 element.node_name()
    //             );
    //             node.append_child(element.clone().into()).unwrap();
    //             for (name, value) in atts {
    //                 if let Some(value) = value.as_deref() {
    //                     element.set_attribute(name.as_str(), value).unwrap();
    //                 }
    //             }
    //             ctxt.user_data = Some(GenericErrorContext::new((doc, NodeRef::from(element))));
    //             xml_sax2_start_element(ctxt, fullname, atts);
    //         }
    //         fn end_element(ctxt: &mut XmlParserCtxt, _name: &str) {
    //             let (mut doc, mut node) = downgrade_user_data(ctxt.user_data.clone());
    //             ctxt.user_data = Some(GenericErrorContext::new((doc, node.parent_node().unwrap())));
    //             xml_sax2_end_element(ctxt, _name);
    //         }
    //         handler.start_element = Some(start_element);
    //         handler.end_element = Some(end_element);
    //         handler.initialized = 1;
    //     }
    //     fn internal_subset(
    //         ctxt: &mut XmlParserCtxt,
    //         name: Option<&str>,
    //         external_id: Option<&str>,
    //         system_id: Option<&str>,
    //     ) {
    //         let (mut doc, mut node) = downgrade_user_data(ctxt.user_data.clone());
    //         if doc.doctype().is_none() {
    //             let doctype = doc
    //                 .implementation()
    //                 .create_document_type(name.unwrap(), external_id, system_id)
    //                 .unwrap();
    //             doc.append_child(doctype.into()).unwrap();
    //         }
    //         xml_sax2_internal_subset(ctxt, name, external_id, system_id);
    //     }
    //     fn external_subset(
    //         ctxt: &mut XmlParserCtxt,
    //         name: Option<&str>,
    //         external_id: Option<&str>,
    //         system_id: Option<&str>,
    //     ) {
    //         let (mut doc, mut node) = downgrade_user_data(ctxt.user_data.clone());
    //         if doc.doctype().is_none() {
    //             let doctype = doc
    //                 .implementation()
    //                 .create_document_type(name.unwrap(), external_id, system_id)
    //                 .unwrap();
    //             doc.append_child(doctype.into()).unwrap();
    //         }
    //         xml_sax2_external_subset(ctxt, name, external_id, system_id);
    //     }
    //     fn entity_decl(
    //         ctxt: &mut XmlParserCtxt,
    //         name: &str,
    //         typ: XmlEntityType,
    //         public_id: Option<&str>,
    //         system_id: Option<&str>,
    //         content: Option<&str>,
    //     ) {
    //         let (mut doc, mut node) = downgrade_user_data(ctxt.user_data.clone());
    //         let mut doctype = doc.doctype().unwrap();
    //         let mut entity = match typ {
    //             XmlEntityType::XmlExternalGeneralParsedEntity => doctype
    //                 .create_entity(name, EntityType::ExternalGeneralParsedEntity)
    //                 .unwrap(),
    //             XmlEntityType::XmlExternalGeneralUnparsedEntity => doctype
    //                 .create_entity(name, EntityType::ExternalGeneralUnparsedEntity)
    //                 .unwrap(),
    //             XmlEntityType::XmlExternalParameterEntity => doctype
    //                 .create_entity(name, EntityType::ExternalParameterEntity)
    //                 .unwrap(),
    //             XmlEntityType::XmlInternalGeneralEntity => doctype
    //                 .create_entity(name, EntityType::InternalGeneralEntity)
    //                 .unwrap(),
    //             XmlEntityType::XmlInternalParameterEntity => doctype
    //                 .create_entity(name, EntityType::InternalParameterEntity)
    //                 .unwrap(),
    //             XmlEntityType::XmlInternalPredefinedEntity => doctype
    //                 .create_entity(name, EntityType::InternalPredefinedEntity)
    //                 .unwrap(),
    //         };
    //         entity.set_public_id(public_id);
    //         entity.set_system_id(system_id);
    //         if ctxt.in_subset == 1 {
    //             doctype.add_entity::<false>(entity).ok();
    //         } else {
    //             doctype.add_entity::<true>(entity).ok();
    //         };
    //         xml_sax2_entity_decl(ctxt, name, typ, public_id, system_id, content);
    //     }
    //     fn attribute_decl(
    //         ctxt: &mut XmlParserCtxt,
    //         elem: &str,
    //         fullname: &str,
    //         typ: XmlAttributeType,
    //         def: XmlAttributeDefault,
    //         default_value: Option<&str>,
    //         mut tree: Option<Box<XmlEnumeration>>,
    //     ) {
    //         let (mut doc, mut node) = downgrade_user_data(ctxt.user_data.clone());
    //         let mut doctype = doc.doctype().unwrap();
    //         let mut enumeration = vec![];
    //         let mut now = tree.as_deref();
    //         while let Some(t) = now {
    //             enumeration.push(t.name.clone().into());
    //             now = t.next.as_deref();
    //         }
    //         let att_type = match typ {
    //             XmlAttributeType::XmlAttributeCDATA => AttType::CDATA,
    //             XmlAttributeType::XmlAttributeEntities => AttType::Entities,
    //             XmlAttributeType::XmlAttributeEntity => AttType::Entity,
    //             XmlAttributeType::XmlAttributeEnumeration => AttType::Enumeration(enumeration),
    //             XmlAttributeType::XmlAttributeID => AttType::ID,
    //             XmlAttributeType::XmlAttributeIDREF => AttType::IDREF,
    //             XmlAttributeType::XmlAttributeIDREFS => AttType::IDREFS,
    //             XmlAttributeType::XmlAttributeNmtoken => AttType::Nmtoken,
    //             XmlAttributeType::XmlAttributeNmtokens => AttType::Nmtokens,
    //             XmlAttributeType::XmlAttributeNotation => AttType::Notation(enumeration),
    //         };
    //         let default_decl = match def {
    //             XmlAttributeDefault::XmlAttributeFixed => {
    //                 DefaultDecl::Fixed(default_value.unwrap().into())
    //             }
    //             XmlAttributeDefault::XmlAttributeImplied => DefaultDecl::Implied,
    //             XmlAttributeDefault::XmlAttributeNone => {
    //                 DefaultDecl::None(default_value.unwrap().into())
    //             }
    //             XmlAttributeDefault::XmlAttributeRequired => DefaultDecl::Required,
    //         };
    //         let attlist = doctype
    //             .create_attlist_decl(elem, fullname, att_type, default_decl)
    //             .unwrap();
    //         if ctxt.in_subset == 1 {
    //             doctype.add_attlist_decl::<false>(attlist);
    //         } else {
    //             doctype.add_attlist_decl::<true>(attlist);
    //         }
    //         xml_sax2_attribute_decl(ctxt, elem, fullname, typ, def, default_value, tree);
    //     }
    //     fn element_decl(
    //         ctxt: &mut XmlParserCtxt,
    //         name: &str,
    //         typ: Option<XmlElementTypeVal>,
    //         content: Option<Rc<RefCell<XmlElementContent>>>,
    //     ) {
    //         let (mut doc, mut node) = downgrade_user_data(ctxt.user_data.clone());
    //         let mut doctype = doc.doctype().unwrap();
    //         fn make_content_tree(
    //             content: Option<Rc<RefCell<XmlElementContent>>>,
    //         ) -> Option<Rc<ElementContent>> {
    //             let content = content?;
    //             let occur = match content.borrow().ocur {
    //                 XmlElementContentOccur::XmlElementContentMult => ElementContentOccur::Mult,
    //                 XmlElementContentOccur::XmlElementContentOnce => ElementContentOccur::Once,
    //                 XmlElementContentOccur::XmlElementContentOpt => ElementContentOccur::Opt,
    //                 XmlElementContentOccur::XmlElementContentPlus => ElementContentOccur::Plus,
    //             };
    //             let new = match content.borrow().typ {
    //                 XmlElementContentType::XmlElementContentElement => ElementContent::new_element(
    //                     occur,
    //                     content.borrow().name.as_deref().unwrap(),
    //                 ),
    //                 XmlElementContentType::XmlElementContentOr => ElementContent::new_or(occur),
    //                 XmlElementContentType::XmlElementContentPCDATA => {
    //                     ElementContent::new_pcdata(occur)
    //                 }
    //                 XmlElementContentType::XmlElementContentSeq => ElementContent::new_seq(occur),
    //             };
    //             new.set_first_child(make_content_tree(content.borrow().c1.clone()));
    //             new.set_second_child(make_content_tree(content.borrow().c2.clone()));
    //             Some(new)
    //         }
    //         let contentspec = match typ {
    //             Some(XmlElementTypeVal::XmlElementTypeAny) => ContentSpec::Any,
    //             Some(XmlElementTypeVal::XmlElementTypeEmpty) => ContentSpec::Empty,
    //             Some(XmlElementTypeVal::XmlElementTypeElement) => {
    //                 ContentSpec::Children(make_content_tree(content.clone()).unwrap())
    //             }
    //             Some(XmlElementTypeVal::XmlElementTypeMixed) => {
    //                 ContentSpec::Mixed(make_content_tree(content.clone()).unwrap())
    //             }
    //             _ => {
    //                 xml_sax2_element_decl(ctxt, name, typ, content);
    //                 return;
    //             }
    //         };
    //         let mut elem_decl = doctype.create_element_decl(name, contentspec).unwrap();
    //         if ctxt.in_subset == 1 {
    //             doctype.add_element_decl::<false>(elem_decl).unwrap();
    //         } else {
    //             doctype.add_element_decl::<true>(elem_decl).unwrap();
    //         }
    //         xml_sax2_element_decl(ctxt, name, typ, content);
    //     }
    //     fn notation_decl(
    //         ctxt: &mut XmlParserCtxt,
    //         name: &str,
    //         public_id: Option<&str>,
    //         system_id: Option<&str>,
    //     ) {
    //         let (mut doc, mut node) = downgrade_user_data(ctxt.user_data.clone());
    //         let mut doctype = doc.doctype().unwrap();
    //         let id = if let Some(system_id) = system_id {
    //             NotationIdentifier::ExternalID {
    //                 public_id: public_id.map(|id| id.into()),
    //                 system_id: system_id.into(),
    //             }
    //         } else {
    //             NotationIdentifier::PublicID {
    //                 public_id: public_id.unwrap().into(),
    //             }
    //         };
    //         let notation = doctype.create_notation(name, id).unwrap();
    //         if ctxt.in_subset == 1 {
    //             doctype.add_notation::<false>(notation).unwrap();
    //         } else {
    //             doctype.add_notation::<true>(notation).unwrap();
    //         }
    //         xml_sax2_notation_decl(ctxt, name, public_id, system_id);
    //     }
    //     fn unparsed_entity_decl(
    //         ctxt: &mut XmlParserCtxt,
    //         name: &str,
    //         public_id: Option<&str>,
    //         system_id: Option<&str>,
    //         notation_name: Option<&str>,
    //     ) {
    //         let (mut doc, mut node) = downgrade_user_data(ctxt.user_data.clone());
    //         let mut doctype = doc.doctype().unwrap();
    //         let mut entity = doctype
    //             .create_entity(name, EntityType::ExternalGeneralUnparsedEntity)
    //             .unwrap();
    //         entity.set_public_id(public_id);
    //         entity.set_system_id(system_id);
    //         entity.set_notation_name(notation_name);
    //         if ctxt.in_subset == 1 {
    //             doctype.add_entity::<false>(entity).unwrap();
    //         } else {
    //             doctype.add_entity::<true>(entity).unwrap();
    //         };
    //         xml_sax2_unparsed_entity_decl(ctxt, name, public_id, system_id, notation_name);
    //     }
    //     fn reference(ctxt: &mut XmlParserCtxt, name: &str) {
    //         let (mut doc, mut node) = downgrade_user_data(ctxt.user_data.clone());
    //         let mut entref = doc.create_entity_reference(name).unwrap();
    //         if entref.first_child().is_none() {
    //             let mut ent = xml_get_doc_entity(ctxt.my_doc, name).unwrap();
    //             let doctype = doc.doctype().unwrap();
    //             let entity = doctype.get_entity(name).unwrap();
    //             fn make_entity_tree(now: XmlGenericNodePtr, mut node: NodeRef) {
    //                 let mut doc = node.owner_document().unwrap();
    //                 let mut children = now.children();
    //                 while let Some(child) = children {
    //                     match child.element_type() {
    //                         XmlElementType::XmlCDATASectionNode => {
    //                             let cdata = doc
    //                                 .create_cdata_section(child.get_content().unwrap())
    //                                 .unwrap();
    //                             node.append_child(cdata.into()).unwrap();
    //                         }
    //                         XmlElementType::XmlCommentNode => {
    //                             let comment = doc.create_comment(child.get_content().unwrap());
    //                             node.append_child(comment.into()).unwrap();
    //                         }
    //                         XmlElementType::XmlElementNode => {
    //                             let elem = XmlNodePtr::try_from(child).unwrap();
    //                             let mut attrs = elem.properties;
    //                             let mut element = if let Some(ns) = split_qname2(&elem.name)
    //                                 .and_then(|(pre, _)| {
    //                                     child.search_ns(child.document(), Some(pre))
    //                                 }) {
    //                                 doc.create_element_ns(ns.href.as_deref(), &elem.name)
    //                                     .unwrap()
    //                             } else {
    //                                 doc.create_element(elem.name.as_ref()).unwrap()
    //                             };
    //                             node.append_child(element.clone().into()).unwrap();
    //                             while let Some(attr) = attrs {
    //                                 if let Some(ns) = attr.ns {
    //                                     element.set_attribute_ns(
    //                                         ns.href.as_deref().map(|href| href.into()),
    //                                         attr.name.clone().into(),
    //                                         attr.get_content().unwrap(),
    //                                     );
    //                                 } else {
    //                                     element.set_attribute(
    //                                         attr.name.clone(),
    //                                         attr.get_content().unwrap(),
    //                                     );
    //                                 }
    //                                 attrs = attr.next;
    //                             }
    //                             make_entity_tree(child, element.into());
    //                         }
    //                         XmlElementType::XmlPINode => {
    //                             let pi = doc
    //                                 .create_processing_instruction(
    //                                     child.name().unwrap(),
    //                                     child.get_content(),
    //                                 )
    //                                 .unwrap();
    //                             node.append_child(pi.into()).unwrap();
    //                         }
    //                         XmlElementType::XmlTextNode => {
    //                             let text = doc.create_text_node(child.get_content().unwrap());
    //                             node.append_child(text.into()).unwrap();
    //                         }
    //                         _ => {}
    //                     }
    //                     children = child.next();
    //                 }
    //             }

    //             make_entity_tree(ent.into(), entity.clone().into());
    //             entref = doc.create_entity_reference(name).unwrap();
    //         }
    //         node.append_child(entref.into()).unwrap();
    //         xml_sax2_reference(ctxt, name);
    //     }
    //     fn characters(ctxt: &mut XmlParserCtxt, ch: &str) {
    //         let (mut doc, mut node) = downgrade_user_data(ctxt.user_data.clone());
    //         let text = doc.create_text_node(ch);
    //         node.append_child(text.into()).unwrap();
    //         xml_sax2_characters(ctxt, ch);
    //     }
    //     fn cdata_block(ctxt: &mut XmlParserCtxt, value: &str) {
    //         let (mut doc, mut node) = downgrade_user_data(ctxt.user_data.clone());
    //         let cdata = doc.create_cdata_section(value).unwrap();
    //         node.append_child(cdata.into()).unwrap();
    //         xml_sax2_cdata_block(ctxt, value);
    //     }
    //     fn processing_instruction(ctxt: &mut XmlParserCtxt, target: &str, data: Option<&str>) {
    //         let (mut doc, mut node) = downgrade_user_data(ctxt.user_data.clone());
    //         let pi = doc.create_processing_instruction(target, data).unwrap();
    //         node.append_child(pi.into()).unwrap();
    //         xml_sax2_processing_instruction(ctxt, target, data);
    //     }
    //     fn comment(ctxt: &mut XmlParserCtxt, value: &str) {
    //         let (mut doc, mut node) = downgrade_user_data(ctxt.user_data.clone());
    //         let comment = doc.create_comment(value);
    //         node.append_child(comment.into()).unwrap();
    //         xml_sax2_comment(ctxt, value);
    //     }
    //     handler.internal_subset = Some(internal_subset);
    //     handler.external_subset = Some(external_subset);
    //     handler.is_standalone = Some(xml_sax2_is_standalone);
    //     handler.has_internal_subset = Some(xml_sax2_has_internal_subset);
    //     handler.has_external_subset = Some(xml_sax2_has_external_subset);
    //     handler.resolve_entity = Some(xml_sax2_resolve_entity);
    //     handler.get_entity = Some(xml_sax2_get_entity);
    //     handler.get_parameter_entity = Some(xml_sax2_get_parameter_entity);
    //     handler.entity_decl = Some(entity_decl);
    //     handler.attribute_decl = Some(attribute_decl);
    //     handler.element_decl = Some(element_decl);
    //     handler.notation_decl = Some(notation_decl);
    //     handler.unparsed_entity_decl = Some(unparsed_entity_decl);
    //     handler.set_document_locator = Some(xml_sax2_set_document_locator);
    //     handler.start_document = Some(xml_sax2_start_document);
    //     handler.end_document = Some(xml_sax2_end_document);
    //     handler.reference = Some(reference);
    //     handler.characters = Some(characters);
    //     handler.cdata_block = Some(cdata_block);
    //     handler.ignorable_whitespace = Some(characters);
    //     handler.processing_instruction = Some(processing_instruction);
    //     handler.comment = Some(comment);

    //     let mut domimpl = DOM_IMPLEMENTATION_REGISTRY
    //         .get_dom_implementation("XML")
    //         .unwrap();
    //     let mut document = domimpl.create_document(None, None, None).unwrap();
    //     document.disable_read_only_check();
    //     let mut ctxt = XmlParserCtxt::new_sax_parser(
    //         Some(Box::new(handler)),
    //         Some(GenericErrorContext::new((
    //             document.clone(),
    //             NodeRef::from(document.clone()),
    //         ))),
    //     )
    //     .unwrap();
    //     xml_ctxt_read_file(
    //         &mut ctxt,
    //         doc,
    //         None,
    //         XmlParserOption::XmlParseDTDLoad as i32,
    //     );
    //     document.enable_read_only_check();
    //     document
    // }

    mod level1 {
        use super::*;

        mod core {
            use exml::dom::{
                named_node_map::NamedNodeMap, node_list::NodeList, notation::NotationIdentifier,
            };

            use super::*;

            const STAFF_XML: &str = "resources/DOM-Test-Suite/tests/level1/core/files/staff.xml";
            const HC_STAFF_XML: &str =
                "resources/DOM-Test-Suite/tests/level1/core/files/hc_staff.xml";
            const HC_NODTDSTAFF_XML: &str =
                "resources/DOM-Test-Suite/tests/level1/core/files/hc_nodtdstaff.xml";

            #[rustfmt::skip]
            fn staff_xml(_doc: &str) -> Result<DocumentRef, DOMException> {
                let doctype = DocumentTypeRef::new("staff", None, Some("staff.dtd")).unwrap();
                let mut doc = DocumentRef::new(None, Some("staff"), Some(doctype)).unwrap();

                let mut doctype = doc.doctype().unwrap();
                // Internal Subset
                let mut ent = doctype.create_entity("ent1", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("es").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent2", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("1900 Dallas Road").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent3", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("Texas").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent4", EntityType::InternalGeneralEntity).unwrap();
                let mut ent_element = doc.create_element("entElement").unwrap();
                ent_element.set_attribute("domestic", "Yes").unwrap();
                ent_element.append_child(doc.create_text_node("Element data").into()).unwrap();
                ent.append_child(ent_element.into()).unwrap();
                ent.append_child(doc.create_processing_instruction("PItarget", Some("PIdata")).unwrap().into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent5", EntityType::ExternalGeneralUnparsedEntity).unwrap();
                ent.set_public_id(Some("entityURI"));
                ent.set_system_id(Some("entityFile"));
                ent.set_notation_name(Some("notation1"));
                doctype.add_entity::<false>(ent).unwrap();
                assert!(doctype.add_entity::<false>(doctype.create_entity("ent1", EntityType::InternalGeneralEntity).unwrap()).is_err());
                doctype.add_notation::<false>(doctype.create_notation("notation1",NotationIdentifier::PublicID { public_id: "notation1File".into() }).unwrap()).unwrap();
                doctype.add_notation::<false>(doctype.create_notation("notation2",NotationIdentifier::ExternalID { public_id: None, system_id: "notation2File".into() }).unwrap(),).unwrap();
                // External Subset
                doctype.add_element_decl::<true>(doctype.create_element_decl("employeeId",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("name",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("position",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("salary",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("address",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("entElement",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                let mut or = ElementContent::new_or(ElementContentOccur::Mult);
                or.set_first_child(Some(ElementContent::new_pcdata(ElementContentOccur::Once)));
                or.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"entElement")));
                doctype.add_element_decl::<true>(doctype.create_element_decl("gender", ContentSpec::Mixed(or)).unwrap()).unwrap();
                let mut seq1 = ElementContent::new_seq(ElementContentOccur::Once);
                seq1.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"employeeId")));
                let mut seq2 = ElementContent::new_seq(ElementContentOccur::Once);
                seq2.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"name")));
                let mut seq3 = ElementContent::new_seq(ElementContentOccur::Once);
                seq3.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"position")));
                let mut seq4 = ElementContent::new_seq(ElementContentOccur::Once);
                seq4.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"salary")));
                let mut seq5 = ElementContent::new_seq(ElementContentOccur::Once);
                seq5.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"gender")));
                seq5.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"address")));
                seq4.set_second_child(Some(seq5));
                seq3.set_second_child(Some(seq4));
                seq2.set_second_child(Some(seq3));
                seq1.set_second_child(Some(seq2));
                doctype.add_element_decl::<true>(doctype.create_element_decl("employee", ContentSpec::Children(seq1)).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("staff",ContentSpec::Children(ElementContent::new_element(ElementContentOccur::Plus,"employee"))).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("entElement","attr1",AttType::CDATA,DefaultDecl::None("Attr".into())).unwrap(),).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("address","domestic",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("address","street",AttType::CDATA,DefaultDecl::None("Yes".into())).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("entElement","domestic",AttType::CDATA,DefaultDecl::None("MALE".into())).unwrap()).unwrap();

                doc.insert_before(doc.create_processing_instruction("TEST-STYLE", Some("PIDATA")).unwrap().into(),Some(doctype.into())).unwrap();

                let mut root = doc.document_element().unwrap();
                assert!(root.parent_node().is_some());
                let comment = doc.create_comment(" This is comment number 1.").into();
                doc.insert_before(comment, Some(root.clone().into())).unwrap();

                let mut employee = root.append_child(doc.create_element("employee").unwrap().into()).unwrap();
                let mut employee_id = employee.append_child(doc.create_element("employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0001").into()).unwrap();
                let mut name = employee.append_child(doc.create_element("name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Margaret Martin").into()).unwrap();
                let mut position = employee.append_child(doc.create_element("position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Accountant").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element("salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("56,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element("gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("Female").into()).unwrap();
                let mut address = employee.append_child(doc.create_element("address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("1230 North Ave. Dallas, Texas 98551").into())?;
                address.set_attribute("domestic", "Yes").unwrap();

                let mut employee = root.append_child(doc.create_element("employee").unwrap().into()).unwrap();
                let mut employee_id = employee.append_child(doc.create_element("employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0002").into()).unwrap();
                let mut name = employee.append_child(doc.create_element("name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Martha Raynolds").into()).unwrap();
                name.append_child(doc.create_cdata_section("This is a CDATASection with EntityReference number 2 &ent2;").unwrap().into())?;
                name.append_child(doc.create_text_node("\n").into()).unwrap();
                name.append_child(doc.create_cdata_section("This is an adjacent CDATASection with a reference to a tab &tab;").unwrap().into())?;
                let mut position = employee.append_child(doc.create_element("position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Secretary").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element("salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("35,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element("gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("Female").into()).unwrap();
                let mut address = employee.append_child(doc.create_element("address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_entity_reference("ent2").unwrap().into()).unwrap();
                address.append_child(doc.create_text_node(" Dallas, ").into()).unwrap();
                address.append_child(doc.create_entity_reference("ent3").unwrap().into()).unwrap();
                address.append_child(doc.create_text_node("\n 98554").into()).unwrap();
                address.set_attribute("domestic", "Yes").unwrap();
                address.set_attribute("street", "Yes").unwrap();

                let mut employee = root.append_child(doc.create_element("employee").unwrap().into()).unwrap();
                let mut employee_id = employee.append_child(doc.create_element("employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0003").into()).unwrap();
                let mut name = employee.append_child(doc.create_element("name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Roger\n Jones").into()).unwrap();
                let mut position = employee.append_child(doc.create_element("position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Department Manager").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element("salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("100,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element("gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_entity_reference("ent4").unwrap().into()).unwrap();
                let mut address = employee.append_child(doc.create_element("address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("PO Box 27 Irving, texas 98553").into()).unwrap();
                address.set_attribute("domestic", "Yes").unwrap();
                address.set_attribute("street", "No").unwrap();

                let mut employee = root.append_child(doc.create_element("employee").unwrap().into()).unwrap();
                let mut employee_id = employee.append_child(doc.create_element("employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0004").into()).unwrap();
                let mut name = employee.append_child(doc.create_element("name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Jeny Oconnor").into()).unwrap();
                let mut position = employee.append_child(doc.create_element("position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Personnel Director").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element("salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("95,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element("gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("Female").into()).unwrap();
                let mut address = employee.append_child(doc.create_element("address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("PO Box 27 Irving, texas 98553").into()).unwrap();
                address.set_attribute("domestic", "Yes")?;
                address.set_attribute("street", "Y")?;
                let mut street = address.get_attribute_node("street").unwrap();
                street.append_child(doc.create_entity_reference("ent1").unwrap().into()).unwrap();

                let mut employee = root.append_child(doc.create_element("employee").unwrap().into()).unwrap();
                let mut employee_id = employee.append_child(doc.create_element("employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0005").into()).unwrap();
                let mut name = employee.append_child(doc.create_element("name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Robert Myers").into()).unwrap();
                let mut position = employee.append_child(doc.create_element("position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Computer Specialist").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element("salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("90,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element("gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("male").into()).unwrap();
                let mut address = employee.append_child(doc.create_element("address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("1821 Nordic. Road, Irving Texas 98558").into())?;
                address.set_attribute("street", "Yes").unwrap();

                doc.enable_read_only_check();
                Ok(doc)
                // Ok(load_xml::<false>(doc))
            }
            #[rustfmt::skip]
            fn hc_staff_xml(_doc: &str) -> Result<DocumentRef, DOMException> {
                let doctype = DocumentTypeRef::new("html",Some("-//W3C//DTD HTML 4.01//EN"),Some("http://www.w3.org/TR/html4/strict.dtd")).unwrap();
                let mut doc = DocumentRef::new(None, Some("html"), Some(doctype)).unwrap();
                let mut doctype = doc.doctype().unwrap();

                let mut ent = doctype.create_entity("alpha", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B1}").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("beta", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B2}").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("gamma", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B3}").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("delta", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B4}").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("epsilon", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B5}").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("alpha", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B6}").into()).unwrap();
                assert!(doctype.add_entity::<false>(ent).is_err());
                doctype.add_notation::<false>(doctype.create_notation("notation1",NotationIdentifier::PublicID { public_id: "notation1File".into() }).unwrap()).unwrap();
                doctype.add_notation::<false>(doctype.create_notation("notation2",NotationIdentifier::ExternalID { public_id: None, system_id: "notation2File".into() }).unwrap()).unwrap();

                // TODO: add external subset
                let mut seq = ElementContent::new_seq(ElementContentOccur::Once);
                seq.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"head")));
                seq.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"body")));
                doctype.add_element_decl::<true>(doctype.create_element_decl("html", ContentSpec::Children(seq)).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("html","xmlns",AttType::CDATA,DefaultDecl::Implied,).unwrap()).unwrap();
                let mut seq = ElementContent::new_seq(ElementContentOccur::Once);
                seq.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"meta")));
                let seq2 = ElementContent::new_seq(ElementContentOccur::Once);
                seq.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"title")));
                seq.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Mult,"script")));
                seq.set_second_child(Some(seq2));
                doctype.add_element_decl::<true>(doctype.create_element_decl("head", ContentSpec::Children(seq)).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("meta", ContentSpec::Empty).unwrap()).unwrap();
                doctype.create_attlist_decl("meta", "http-equiv", AttType::CDATA, DefaultDecl::Implied).unwrap();
                doctype.create_attlist_decl("meta", "content", AttType::CDATA, DefaultDecl::Implied).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("title",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("body",ContentSpec::Children(ElementContent::new_element(ElementContentOccur::Mult,"p"))).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("body","onload",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                let mut or = ElementContent::new_or(ElementContentOccur::Mult);
                or.set_first_child(Some(ElementContent::new_pcdata(ElementContentOccur::Once)));
                let mut or2 = ElementContent::new_or(ElementContentOccur::Once);
                or2.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"em")));
                let mut or3 = ElementContent::new_or(ElementContentOccur::Once);
                or3.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"strong")));
                let mut or4 = ElementContent::new_or(ElementContentOccur::Once);
                or4.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"code")));
                let mut or5 = ElementContent::new_or(ElementContentOccur::Once);
                or5.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"sup")));
                let mut or6 = ElementContent::new_or(ElementContentOccur::Once);
                or6.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"var")));
                let mut or7 = ElementContent::new_or(ElementContentOccur::Once);
                or7.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"acronym")));
                or7.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"abbr")));
                or6.set_second_child(Some(or7));
                or5.set_second_child(Some(or6));
                or4.set_second_child(Some(or5));
                or3.set_second_child(Some(or4));
                or2.set_second_child(Some(or3));
                or.set_second_child(Some(or2));
                doctype.add_element_decl::<true>(doctype.create_element_decl("p", ContentSpec::Mixed(or)).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("p","xmlns:dmstc",AttType::CDATA,DefaultDecl::Implied,).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("p","xmlns:nm",AttType::CDATA,DefaultDecl::Implied,).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("p","xmlns:emp2",AttType::CDATA,DefaultDecl::Implied,).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("p", "id", AttType::ID, DefaultDecl::Implied).unwrap()).unwrap();

                doctype.add_element_decl::<true>(doctype.create_element_decl("em",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("span",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("strong",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("code",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("sup",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                let mut or = ElementContent::new_or(ElementContentOccur::Mult);
                or.set_first_child(Some(ElementContent::new_pcdata(ElementContentOccur::Once)));
                or.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"span")));
                doctype.add_element_decl::<true>(doctype.create_element_decl("var", ContentSpec::Mixed(or)).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("acronym",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("acronym","title",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("acronym","class",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("acronym", "id", AttType::ID, DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("abbr",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("abbr","title",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("abbr","class",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("abbr", "id", AttType::ID, DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("script",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("script","type",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("script","src",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("script","charset",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();

                doc.insert_before(doc.create_processing_instruction("TEST-STYLE", Some("PIDATA")).unwrap().into(),Some(doctype.into())).unwrap();

                let mut root = doc.document_element().unwrap();
                assert!(root.parent_node().is_some());
                let comment = doc.create_comment(" This is comment number 1.").into();
                doc.insert_before(comment, Some(root.clone().into())).unwrap();

                let mut head = root.append_child(doc.create_element("head").unwrap().into()).unwrap();
                let mut meta = head.append_child(doc.create_element("meta").unwrap().into()).unwrap().as_element().unwrap();
                meta.set_attribute("http-equiv", "Content-Type").unwrap();
                meta.set_attribute("content", "text/html; charset=UTF-8").unwrap();
                let mut title = head.append_child(doc.create_element("title").unwrap().into()).unwrap();
                title.append_child(doc.create_text_node("hc_staff").into()).unwrap();
                let mut script = head.append_child(doc.create_element("script").unwrap().into()).unwrap().as_element().unwrap();
                script.set_attribute("type", "text/javascript").unwrap();
                script.set_attribute("src", "svgunit.js").unwrap();
                let mut script = head.append_child(doc.create_element("script").unwrap().into()).unwrap().as_element().unwrap();
                script.set_attribute("charset", "UTF-8").unwrap();
                script.set_attribute("type", "text/javascript").unwrap();
                script.set_attribute("src", "svgtest.js").unwrap();
                let mut script = head.append_child(doc.create_element("script").unwrap().into()).unwrap().as_element().unwrap();
                script.set_attribute("type", "text/javascript").unwrap();
                script.append_child(doc.create_text_node("function loadComplete() { startTest(); }").into(),).unwrap();

                let mut body = root.append_child(doc.create_element("body").unwrap().into()).unwrap().as_element().unwrap();
                body.set_attribute("onload", "parent.loadComplete()").unwrap();

                let mut p = body.append_child(doc.create_element("p").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut em = p.append_child(doc.create_element("em").unwrap().into()).unwrap();
                em.append_child(doc.create_text_node("EMP0001").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p.append_child(doc.create_element("strong").unwrap().into()).unwrap();
                strong.append_child(doc.create_text_node("Margaret Martin").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p.append_child(doc.create_element("code").unwrap().into()).unwrap();
                code.append_child(doc.create_text_node("Accountant").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p.append_child(doc.create_element("sup").unwrap().into()).unwrap();
                sup.append_child(doc.create_text_node("56,000").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p.append_child(doc.create_element("var").unwrap().into()).unwrap();
                var.append_child(doc.create_text_node("Female").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p.append_child(doc.create_element("acronym").unwrap().into()).unwrap().as_element().unwrap();
                acronym.append_child(doc.create_text_node("1230 North Ave. Dallas, Texas 98551").into())?;
                acronym.set_attribute("title", "Yes").unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();

                let mut p = body.append_child(doc.create_element("p").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut em = p.append_child(doc.create_element("em").unwrap().into()).unwrap();
                em.append_child(doc.create_text_node("EMP0002").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p.append_child(doc.create_element("strong").unwrap().into()).unwrap();
                strong.append_child(doc.create_text_node("Martha RaynoldsThis is a CDATASection with EntityReference number 2 &ent2;\nThis is an adjacent CDATASection with a reference to a tab &tab;").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p.append_child(doc.create_element("code").unwrap().into()).unwrap();
                code.append_child(doc.create_text_node("Secretary").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p.append_child(doc.create_element("sup").unwrap().into()).unwrap();
                sup.append_child(doc.create_text_node("35,000").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p.append_child(doc.create_element("var").unwrap().into()).unwrap();
                var.append_child(doc.create_text_node("Female").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p.append_child(doc.create_element("acronym").unwrap().into()).unwrap().as_element().unwrap();
                acronym.append_child(doc.create_entity_reference("beta").unwrap().into()).unwrap();
                acronym.append_child(doc.create_text_node(" Dallas, ").into()).unwrap();
                acronym.append_child(doc.create_entity_reference("gamma").unwrap().into()).unwrap();
                acronym.append_child(doc.create_text_node("\n 98554").into()).unwrap();
                acronym.set_attribute("title", "Yes").unwrap();
                acronym.set_attribute("class", "Yes").unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();

                let mut p = body.append_child(doc.create_element("p").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut em = p.append_child(doc.create_element("em").unwrap().into()).unwrap();
                em.append_child(doc.create_text_node("EMP0003").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p.append_child(doc.create_element("strong").unwrap().into()).unwrap();
                strong.append_child(doc.create_text_node("Roger\n Jones").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p.append_child(doc.create_element("code").unwrap().into()).unwrap();
                code.append_child(doc.create_text_node("Department Manager").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p.append_child(doc.create_element("sup").unwrap().into()).unwrap();
                sup.append_child(doc.create_text_node("100,000").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p.append_child(doc.create_element("var").unwrap().into()).unwrap();
                var.append_child(doc.create_entity_reference("delta").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p.append_child(doc.create_element("acronym").unwrap().into()).unwrap().as_element().unwrap();
                acronym.append_child(doc.create_text_node("PO Box 27 Irving, texas 98553").into()).unwrap();
                acronym.set_attribute("title", "Yes").unwrap();
                acronym.set_attribute("class", "No").unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();

                let mut p = body.append_child(doc.create_element("p").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut em = p.append_child(doc.create_element("em").unwrap().into()).unwrap();
                em.append_child(doc.create_text_node("EMP0004").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p.append_child(doc.create_element("strong").unwrap().into()).unwrap();
                strong.append_child(doc.create_text_node("Jeny Oconnor").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p.append_child(doc.create_element("code").unwrap().into()).unwrap();
                code.append_child(doc.create_text_node("Personnel Director").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p.append_child(doc.create_element("sup").unwrap().into()).unwrap();
                sup.append_child(doc.create_text_node("95,000").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p.append_child(doc.create_element("var").unwrap().into()).unwrap();
                var.append_child(doc.create_text_node("Female").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p.append_child(doc.create_element("acronym").unwrap().into()).unwrap().as_element().unwrap();
                acronym.append_child(doc.create_text_node("PO Box 27 Irving, texas 98553").into()).unwrap();
                acronym.set_attribute("title", "Yes")?;
                acronym.set_attribute("class", "Y")?;
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut class = acronym.get_attribute_node("class").unwrap();
                class.append_child(doc.create_entity_reference("alpha").unwrap().into()).unwrap();

                let mut p = body.append_child(doc.create_element("p").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut em = p.append_child(doc.create_element("em").unwrap().into()).unwrap();
                em.append_child(doc.create_text_node("EMP0005").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p.append_child(doc.create_element("strong").unwrap().into()).unwrap();
                strong.append_child(doc.create_text_node("Robert Myers").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p.append_child(doc.create_element("code").unwrap().into()).unwrap();
                code.append_child(doc.create_text_node("Computer Specialist").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p.append_child(doc.create_element("sup").unwrap().into()).unwrap();
                sup.append_child(doc.create_text_node("90,000").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p.append_child(doc.create_element("var").unwrap().into()).unwrap();
                var.append_child(doc.create_text_node("male").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p.append_child(doc.create_element("acronym").unwrap().into()).unwrap().as_element().unwrap();
                acronym.append_child(doc.create_text_node("1821 Nordic. Road, Irving Texas 98558").into(),)?;
                acronym.set_attribute("title", "Yes").unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();

                doc.enable_read_only_check();
                Ok(doc)
            }
            fn hc_nodtdstaff_xml(_doc: &str) -> Result<DocumentRef, DOMException> {
                let mut doc = DocumentRef::new(None, Some("html"), None).unwrap();
                let mut root = doc.document_element().unwrap();
                assert!(root.parent_node().is_some());

                let mut head = root
                    .append_child(doc.create_element("head").unwrap().into())
                    .unwrap();
                let mut meta = head
                    .append_child(doc.create_element("meta").unwrap().into())
                    .unwrap()
                    .as_element()
                    .unwrap();
                meta.set_attribute("http-equiv", "Content-Type").unwrap();
                meta.set_attribute("content", "text/html; charset=UTF-8")
                    .unwrap();
                let mut title = head
                    .append_child(doc.create_element("title").unwrap().into())
                    .unwrap();
                title
                    .append_child(doc.create_text_node("hc_nodtdstaff").into())
                    .unwrap();

                let mut body = root
                    .append_child(doc.create_element("body").unwrap().into())
                    .unwrap()
                    .as_element()
                    .unwrap();
                body.set_attribute("onload", "parent.loadComplete()")
                    .unwrap();

                let mut p = body
                    .append_child(doc.create_element("p").unwrap().into())
                    .unwrap();
                let mut em = p
                    .append_child(doc.create_element("em").unwrap().into())
                    .unwrap();
                em.append_child(doc.create_text_node("EMP0001").into())
                    .unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p
                    .append_child(doc.create_element("strong").unwrap().into())
                    .unwrap();
                strong
                    .append_child(doc.create_text_node("Margaret Martin").into())
                    .unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p
                    .append_child(doc.create_element("code").unwrap().into())
                    .unwrap();
                code.append_child(doc.create_text_node("Accountant").into())
                    .unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p
                    .append_child(doc.create_element("sup").unwrap().into())
                    .unwrap();
                sup.append_child(doc.create_text_node("56,000").into())
                    .unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p
                    .append_child(doc.create_element("var").unwrap().into())
                    .unwrap();
                var.append_child(doc.create_text_node("Female").into())
                    .unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p
                    .append_child(doc.create_element("acronym").unwrap().into())
                    .unwrap()
                    .as_element()
                    .unwrap();
                acronym.append_child(
                    doc.create_text_node("1230 North Ave. Dallas, Texas 98551")
                        .into(),
                )?;
                acronym.set_attribute("title", "Yes").unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();

                doc.enable_read_only_check();
                Ok(doc)
            }
            // hc_elementretrieveattrvalue.xml
            #[test]
            fn test_hc_elementretrieveattrvalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                let r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testAddress"/>
                let r#attr_value = r#test_address.get_attribute("class"); // <getAttribute obj="testAddress" var="attrValue" name="&quot;class&quot;"/>
                assert_eq!(r#attr_value, "No"); // <assertEquals actual="attrValue" expected="&quot;No&quot;" id="attrValue" ignoreCase="false"/>
            }
            // hc_nodevalue07.xml
            #[test]
            fn test_hc_nodevalue07() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // let mut r#new_value; // type: DOMString // <var name="newValue" type="DOMString"/>
                // let mut r#node_map; // type: NamedNodeMap // <var name="nodeMap" type="NamedNodeMap"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>

                // // unimplemented:
                // // <if><not><contentType type="text/html"/></not>
                // //      <assertNotNull actual="docType" id="docTypeNotNull"/>
                // //      <entities obj="docType" var="nodeMap"/>
                // //      <assertNotNull actual="nodeMap" id="entitiesNotNull"/>
                // //      <getNamedItem obj="nodeMap" name="&quot;alpha&quot;" var="newNode"/>
                // //      <assertNotNull actual="newNode" id="entityNotNull"/>
                // //      <nodeValue obj="newNode" var="newValue"/>
                // //      <assertNull actual="newValue" id="initiallyNull"/>
                // //      <!--   attempt to change the value and make sure that it stays null  -->
                // //      <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                // //      <nodeValue obj="newNode" var="newValue"/>
                // //      <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
                // // </if>
            }
            // hc_attrinsertbefore1.xml
            #[test]
            fn test_hc_attrinsertbefore1() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                let r#text_node = r#doc.create_text_node("terday"); // <createTextNode var="textNode" obj="doc" data="&quot;terday&quot;"/>
                let r#retval = r#title_attr.insert_before(text_node.into(), None).unwrap(); // <insertBefore var="retval" obj="titleAttr" newChild="textNode" refChild="refChild"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrNodeValue" ignoreCase="false"/>
                r#value = r#retval.node_value().unwrap().to_string(); // <nodeValue obj="retval" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="retvalValue" ignoreCase="false"/>
                let r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                r#value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="firstChildValue" ignoreCase="false"/>
                let r#last_child = r#title_attr.last_child().unwrap(); // <lastChild var="lastChild" obj="titleAttr" interface="Node"/>
                r#value = r#last_child.node_value().unwrap().to_string(); // <nodeValue obj="lastChild" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="lastChildValue" ignoreCase="false"/>
            }
            // hc_nodegetownerdocument.xml
            #[test]
            fn test_hc_nodegetownerdocument() {
                let mut r#element_name; // type: DOMString // <var name="elementName" type="DOMString"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#doc_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="docNode"/>
                let r#owner_document: DocumentRef = r#doc_node.owner_document().unwrap(); // <ownerDocument obj="docNode" var="ownerDocument"/>
                let r#doc_element = r#owner_document.document_element().unwrap(); // <documentElement obj="ownerDocument" var="docElement"/>
                r#element_name = r#doc_element.node_name().to_string(); // <nodeName obj="docElement" var="elementName"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //      <assertEquals actual="elementName" expected="&quot;svg&quot;" id="svgNodeName" ignoreCase="false"/>
                // <else>
                //      <assertEquals actual="elementName" expected="&quot;html&quot;" id="ownerDocElemTagName" ignoreCase="auto"/>
                // </else>
                // </if>
            }
            // nodeentitysetnodevalue.xml
            #[test]
            fn test_nodeentitysetnodevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                let mut r#entity_node; // type: Node // <var name="entityNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                entities = doc_type.entities(); // <entities obj="docType" var="entities"/>
                // unimplemented: // <assertNotNull actual="entities" id="entitiesNotNull"/>
                r#entity_node = r#entities.get_named_item("ent1").unwrap(); // <getNamedItem obj="entities" name="&quot;ent1&quot;" var="entityNode"/>
                // unimplemented: // <assertNotNull actual="entityNode" id="ent1NotNull"/>
                r#entity_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="entityNode" value="&quot;This should have no effect&quot;"/>
                let r#entity_value = r#entity_node.node_value(); // <nodeValue obj="entityNode" var="entityValue"/>
                assert!(entity_value.is_none()); // <assertNull actual="entityValue" id="nodeValueNull"/>
            }
            // hc_nodedocumentfragmentnodevalue.xml
            #[test]
            fn test_hc_nodedocumentfragmentnodevalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="docFragment"/>
                let r#attr_list = r#doc_fragment.attributes(); // <attributes obj="docFragment" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="attributesNull"/>
                let r#value = r#doc_fragment.node_value(); // <nodeValue obj="docFragment" var="value"/>
                assert!(value.is_none()); // <assertNull actual="value" id="initiallyNull"/>
            }
            // documentcreateattribute.xml
            #[test]
            fn test_documentcreateattribute() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#new_attr_node = r#doc.create_attribute("district".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttrNode" name="&quot;district&quot;"/>
                let r#attr_value = r#new_attr_node.node_value().unwrap().to_string(); // <nodeValue obj="newAttrNode" var="attrValue"/>
                assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" ignoreCase="false" id="value"/>
                let r#attr_name = r#new_attr_node.node_name().to_string(); // <nodeName obj="newAttrNode" var="attrName"/>
                assert_eq!(r#attr_name, "district"); // <assertEquals actual="attrName" expected="&quot;district&quot;" ignoreCase="false" id="name"/>
                let r#attr_type = r#new_attr_node.node_type(); // <nodeType obj="newAttrNode" var="attrType"/>
                assert_eq!(r#attr_type as i32, 2); // <assertEquals actual="attrType" expected="2" ignoreCase="false" id="type"/>
            }
            // hc_nodedocumentnodeattribute.xml
            #[test]
            fn test_hc_nodedocumentnodeattribute() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#attr_list = r#doc.attributes(); // <attributes obj="doc" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="doc_attributes_is_null"/>
            }
            // nodedocumentnodename.xml
            #[test]
            fn test_nodedocumentnodename() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#document_name = r#doc.node_name().to_string(); // <nodeName obj="doc" var="documentName"/>
                assert_eq!(r#document_name, "#document"); // <assertEquals actual="documentName" expected="&quot;#document&quot;" id="documentNodeName" ignoreCase="false"/>
            }
            // hc_elementwrongdocumenterr.xml
            #[test]
            fn test_hc_elementwrongdocumenterr() {
                let r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#address_element_list; // type: NodeList // <var name="addressElementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                r#doc1 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc1" href="hc_staff" willBeModified="true"/>
                r#doc2 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc2" href="hc_staff" willBeModified="false"/>
                r#new_attribute = r#doc2.create_attribute("newAttribute".to_string()).unwrap(); // <createAttribute obj="doc2" var="newAttribute" name="&quot;newAttribute&quot;"/>
                r#address_element_list = r#doc1.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc1" tagname="&quot;acronym&quot;" var="addressElementList"/>
                r#test_address = r#address_element_list.item(4).unwrap(); // <item interface="NodeList" obj="addressElementList" index="4" var="testAddress"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //      <WRONG_DOCUMENT_ERR>
                //          <setAttributeNode obj="testAddress" newAttr="newAttribute" var="attrAddress"/>
                //      </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                let r#attr_address = test_address.set_attribute_node(new_attribute);
                assert!(attr_address.is_err_and(|err| err == DOMException::WrongDocumentErr));
            }
            // elementgettagname.xml
            #[test]
            fn test_elementgettagname() {
                let mut r#tagname; // type: DOMString // <var name="tagname" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#root = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="root"/>
                r#tagname = r#root.tag_name().to_string(); // <tagName obj="root" var="tagname"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //      <assertEquals actual="tagname" expected="&quot;svg&quot;" id="svgTagName" ignoreCase="false"/>
                // <else>
                //      <assertEquals actual="tagname" expected="&quot;staff&quot;" id="elementGetTagNameAssert" ignoreCase="false"/>
                // </else>
                // </if>
            }
            // namednodemapsetnameditemwithnewvalue.xml
            #[test]
            fn test_namednodemapsetnameditemwithnewvalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                r#new_attribute = r#doc.create_attribute("district".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;district&quot;"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                let r#new_node = r#attributes.set_named_item(r#new_attribute).unwrap(); // <setNamedItem interface="NamedNodeMap" obj="attributes" var="newNode" arg="newAttribute"/>
                assert!(new_node.is_none()); // <assertNull actual="newNode" id="returnedNodeNull"/>
            }
            // hc_attrinsertbefore4.xml
            #[test]
            fn test_hc_attrinsertbefore4() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let r#ter_node; // type: Text // <var name="terNode" type="Text"/>
                let r#day_node; // type: Text // <var name="dayNode" type="Text"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                let r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                let r#last_child; // type: Node // <var name="lastChild" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#ter_node = r#doc.create_text_node("ter"); // <createTextNode var="terNode" obj="doc" data="&quot;ter&quot;"/>
                r#day_node = r#doc.create_text_node("day"); // <createTextNode var="dayNode" obj="doc" data="&quot;day&quot;"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#retval = r#doc_frag.append_child(ter_node.into()).unwrap(); // <appendChild var="retval" obj="docFrag" newChild="terNode"/>
                r#retval = r#doc_frag.append_child(day_node.into()).unwrap(); // <appendChild var="retval" obj="docFrag" newChild="dayNode"/>
                let r#ref_child = r#title_attr.first_child().unwrap(); // <firstChild var="refChild" obj="titleAttr" interface="Node"/>
                r#retval = r#title_attr
                    .insert_before(doc_frag.into(), ref_child.into())
                    .unwrap(); // <insertBefore var="retval" obj="titleAttr" newChild="docFrag" refChild="refChild"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "terdayYes"); // <assertEquals actual="value" expected="&quot;terdayYes&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "terdayYes"); // <assertEquals actual="value" expected="&quot;terdayYes&quot;" id="attrNodeValue" ignoreCase="false"/>
                let r#value = r#retval.node_value(); // <nodeValue obj="retval" var="value"/>
                assert!(value.is_none()); // <assertNull actual="value" id="retvalValue"/>
                r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                let r#value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="value"/>
                assert_eq!(r#value, "ter"); // <assertEquals actual="value" expected="&quot;ter&quot;" id="firstChildValue" ignoreCase="false"/>
                r#last_child = r#title_attr.last_child().unwrap(); // <lastChild var="lastChild" obj="titleAttr" interface="Node"/>
                let r#value = r#last_child.node_value().unwrap().to_string(); // <nodeValue obj="lastChild" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="lastChildValue" ignoreCase="false"/>
            }
            // hc_namednodemapwrongdocumenterr.xml
            #[test]
            fn test_hc_namednodemapwrongdocumenterr() {
                let r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc1 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc1" href="hc_staff" willBeModified="true"/>
                r#doc2 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc2" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc1.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc1" var="elementList" tagname="&quot;acronym&quot;"/>
                r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                let r#new_attribute = r#doc2.create_attribute("newAttribute".to_string()).unwrap(); // <createAttribute obj="doc2" var="newAttribute" name="&quot;newAttribute&quot;"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //      <WRONG_DOCUMENT_ERR>
                //          <setNamedItem var="setNode" obj="attributes" arg="newAttribute"/>
                //      </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                let r#set_node = attributes.set_named_item(new_attribute);
                assert!(set_node.is_err_and(|err| err == DOMException::WrongDocumentErr));
            }
            // characterdatareplacedatanomodificationallowederr.xml
            #[test]
            fn test_characterdatareplacedatanomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let r#ent_element; // type: Node // <var name="entElement" type="Node"/>
                let r#ent_element_content; // type: Node // <var name="entElementContent" type="Node"/>
                let mut r#ent_reference; // type: Node // <var name="entReference" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" index="2" var="genderNode"/>
                r#ent_reference = r#gender_node.first_child().unwrap(); // <firstChild interface="Node" var="entReference" obj="genderNode"/>
                // unimplemented: // <assertNotNull actual="entReference" id="entReferenceNotNull"/>
                let r#node_type = r#ent_reference.node_type(); // <nodeType var="nodeType" obj="entReference"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //      <createEntityReference var="entReference" obj="doc" name="&quot;ent4&quot;"/>
                //      <assertNotNull actual="entReference" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    ent_reference = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#ent_element = r#ent_reference.first_child().unwrap(); // <firstChild var="entElement" obj="entReference" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#ent_element_content = r#ent_element.first_child().unwrap(); // <firstChild var="entElementContent" obj="entElement" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElementContent" id="entElementContentNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //      <NO_MODIFICATION_ALLOWED_ERR>
                //          <replaceData obj="entElementContent" offset="1" count="3" arg="&quot;newArg&quot;"/>
                //      </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element_content
                        .as_text_node()
                        .unwrap()
                        .replace_data(1, 3, "newArg")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // elementinuseattributeerr.xml
            #[test]
            fn test_elementinuseattributeerr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#address_element_list; // type: NodeList // <var name="addressElementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                let mut r#new_element; // type: Element // <var name="newElement" type="Element"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#set_attr1; // type: Attr // <var name="setAttr1" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#address_element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="addressElementList"/>
                r#test_address = r#address_element_list.item(1).unwrap(); // <item interface="NodeList" obj="addressElementList" index="1" var="testAddress"/>
                r#new_element = r#doc.create_element("newElement".to_string()).unwrap(); // <createElement obj="doc" var="newElement" tagName="&quot;newElement&quot;"/>
                r#appended_child = r#test_address
                    .append_child(new_element.clone().into())
                    .unwrap(); // <appendChild var="appendedChild" obj="testAddress" newChild="newElement"/>
                r#new_attribute = r#doc.create_attribute("newAttribute".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;newAttribute&quot;"/>
                r#set_attr1 = r#new_element
                    .set_attribute_node(r#new_attribute.clone())
                    .unwrap(); // <setAttributeNode var="setAttr1" obj="newElement" newAttr="newAttribute"/>
                // <assertDOMException id="throw_INUSE_ATTRIBUTE_ERR">
                //      <INUSE_ATTRIBUTE_ERR>
                //          <setAttributeNode var="setAttr2" obj="testAddress" newAttr="newAttribute"/>
                //      </INUSE_ATTRIBUTE_ERR>
                // </assertDOMException>
                assert!(
                    test_address
                        .set_attribute_node(new_attribute)
                        .is_err_and(|err| { err == DOMException::InuseAttributeErr })
                );
            }
            // nodeelementnodename.xml
            #[test]
            fn test_nodeelementnodename() {
                let mut r#element_name; // type: DOMString // <var name="elementName" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="elementNode"/>
                r#element_name = r#element_node.node_name().to_string(); // <nodeName obj="elementNode" var="elementName"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //      <assertEquals actual="elementName" expected="&quot;svg&quot;" id="svgNodeName" ignoreCase="false"/>
                // <else>
                //      <assertEquals actual="elementName" expected="&quot;staff&quot;" id="nodeElementNodeNameAssert1" ignoreCase="false"/>
                // </else>
                // </if>
            }
            // hc_nodedocumentnodename.xml
            #[test]
            fn test_hc_nodedocumentnodename() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#document_name = r#doc.node_name().to_string(); // <nodeName obj="doc" var="documentName"/>
                assert_eq!(r#document_name, "#document"); // <assertEquals actual="documentName" expected="&quot;#document&quot;" id="documentNodeName" ignoreCase="false"/>
            }
            // nodedocumenttypenodevalue.xml
            #[test]
            fn test_nodedocumenttypenodevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#attr_list = r#doc_type.attributes(); // <attributes obj="docType" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="doctypeAttributesNull"/>
            }
            // hc_commentgetcomment.xml
            #[test]
            fn test_hc_commentgetcomment() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#child_value; // type: DOMString // <var name="childValue" type="DOMString"/>
                let mut r#comment_count = 0; // type: int // <var name="commentCount" type="int" value="0"/>
                let mut r#child_type; // type: int // <var name="childType" type="int"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#element_list = r#doc.child_nodes(); // <childNodes obj="doc" var="elementList"/>
                // <for-each collection="elementList" member="child">
                //      <nodeType obj="child" var="childType"/>
                //      <if><equals actual="childType" expected="8" ignoreCase="false"/>
                //          <nodeName obj="child" var="childName"/>
                //          <assertEquals actual="childName" expected="&quot;#comment&quot;" ignoreCase="false" id="nodeName"/>
                //          <nodeValue obj="child" var="childValue"/>
                //          <assertEquals actual="childValue" expected="&quot; This is comment number 1.&quot;" id="nodeValue" ignoreCase="false"/>
                //          <attributes var="attributes" obj="child"/>
                //          <assertNull actual="attributes" id="attributes"/>
                //          <increment var="commentCount" value="1"/>
                //      </if>
                // </for-each>
                let len = element_list.length();
                for i in 0..len {
                    child = element_list.item(i).unwrap();
                    child_type = child.node_type();
                    if child_type as i32 == 8 {
                        child_name = child.node_name();
                        assert_eq!(child_name.as_ref(), "#comment");
                        child_value = child.node_value().unwrap();
                        assert_eq!(child_value.as_ref(), " This is comment number 1.");
                        assert!(child.attributes().is_none());
                        comment_count += 1;
                    }
                }
                // <assertTrue id="atMostOneComment">
                //      <less actual="commentCount" expected="2"/>
                // </assertTrue>
                assert!(comment_count < 2);
            }
            // documenttypegetentitiestype.xml
            #[test]
            fn test_documenttypegetentitiestype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let r#entity_list; // type: NamedNodeMap // <var name="entityList" type="NamedNodeMap"/>
                let mut r#entity; // type: Node // <var name="entity" type="Node"/>
                let mut r#entity_type; // type: int // <var name="entityType" type="int"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                entity_list = doc_type.entities(); // <entities obj="docType" var="entityList"/>
                // unimplemented: // <assertNotNull actual="entityList" id="entitiesNotNull"/>
                // <for-each collection="entityList" member="entity">
                //  <nodeType obj="entity" var="entityType"/>
                //  <assertEquals actual="entityType" expected="6" id="documenttypeGetEntitiesTypeAssert" ignoreCase="false"/>
                // </for-each>
                for i in 0..entity_list.length() {
                    entity = entity_list.item(i).unwrap();
                    entity_type = entity.node_type();
                    assert_eq!(entity_type as i32, 6);
                }
            }
            // namednodemapsetnameditem.xml
            #[test]
            fn test_namednodemapsetnameditem() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let r#district_node; // type: Attr // <var name="districtNode" type="Attr"/>
                let mut r#set_node; // type: Node // <var name="setNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="1"/>
                r#new_attribute = r#doc.create_attribute("district".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;district&quot;"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                r#set_node = r#attributes.set_named_item(r#new_attribute).unwrap(); // <setNamedItem var="setNode" obj="attributes" arg="newAttribute"/>
                r#district_node = r#attributes.get_named_item("district").unwrap(); // <getNamedItem obj="attributes" var="districtNode" name="&quot;district&quot;"/>
                let r#attr_name = r#district_node.node_name().to_string(); // <nodeName obj="districtNode" var="attrName"/>
                assert_eq!(r#attr_name, "district"); // <assertEquals actual="attrName" expected="&quot;district&quot;" id="namednodemapSetNamedItemAssert" ignoreCase="false"/>
            }
            // nodereplacechildnodeancestor.xml
            #[test]
            fn test_nodereplacechildnodeancestor() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_child = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="newChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#old_child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="oldChild"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //      <HIERARCHY_REQUEST_ERR>
                //          <replaceChild var="replacedNode" obj="employeeNode" newChild="newChild" oldChild="oldChild"/>
                //      </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    employee_node
                        .replace_child(new_child.into(), old_child)
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // hc_nodereplacechildnewchildexists.xml
            #[test]
            fn test_hc_nodereplacechildnewchildexists() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node" isNull="true"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#actual = vec![]; // type: List // <var name="actual" type="List"/>
                let r#expected = vec!["strong", "code", "sup", "var", "em"]; // type: List // <var name="expected" type="List"><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"em"</member></var>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.get_elements_by_tag_name("*"); // <getElementsByTagName interface="Element" obj="employeeNode" var="childList" tagname="&quot;*&quot;"/>
                let r#new_child = r#child_list.item(0).unwrap(); // <item interface="NodeList" obj="childList" index="0" var="newChild"/>
                r#old_child = r#child_list.item(5).unwrap(); // <item interface="NodeList" obj="childList" index="5" var="oldChild"/>
                let r#replaced_child = r#employee_node
                    .replace_child(new_child.into(), old_child.clone().into())
                    .unwrap(); // <replaceChild var="replacedChild" obj="employeeNode" newChild="newChild" oldChild="oldChild"/>
                replaced_child.is_same_node(&old_child.into()); // <assertSame actual="replacedChild" expected="oldChild" id="return_value_same"/>
                // <for-each collection="childList" member="childNode">
                //      <nodeName var="childName" obj="childNode"/>
                //      <nodeType var="nodeType" obj="childNode"/>
                //      <if><equals actual="nodeType" expected="1"/>
                //          <append collection="actual" item="childName"/>
                //      <else>
                //          <assertEquals actual="nodeType" expected="3" id="textNodeType" ignoreCase="false"/>
                //          <assertEquals actual="childName" expected="&quot;#text&quot;" id="textNodeName" ignoreCase="false"/>
                //      </else>
                //      </if>
                // </for-each>
                for i in 0..child_list.length() {
                    let child_node = child_list.item(i).unwrap();
                    child_name = child_node.node_name();
                    node_type = child_node.node_type();
                    if node_type as i32 == 1 {
                        actual.push(child_name.to_string());
                    } else {
                        assert_eq!(node_type as i32, 3);
                        assert_eq!(child_name.as_ref(), "#text");
                    }
                }
                assert_eq!(actual.len(), expected.len());
                assert!(r#actual.into_iter().zip(expected).all(|(a, e)| a == e)); // <assertEquals actual="actual" expected="expected" id="childNames" ignoreCase="auto"/>
            }
            // characterdataindexsizeerrinsertdataoffsetnegative.xml
            #[test]
            fn test_characterdataindexsizeerrinsertdataoffsetnegative() {
                // unimplemented: // <implementationAttribute name="signed" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // unimplemented:
                // <assertDOMException id="throws_INDEX_SIZE_ERR">
                //      <INDEX_SIZE_ERR>
                //          <insertData obj="child" offset="-5" arg="&quot;ABC&quot;"/>
                //      </INDEX_SIZE_ERR>
                // </assertDOMException>
            }
            // hc_nodereplacechildnodeancestor.xml
            #[test]
            fn test_hc_nodereplacechildnodeancestor() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#new_child = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="newChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#old_child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="oldChild"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //      <HIERARCHY_REQUEST_ERR>
                //          <replaceChild var="replacedNode" obj="employeeNode" newChild="newChild" oldChild="oldChild"/>
                //      </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    employee_node
                        .replace_child(new_child.into(), old_child)
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // characterdataindexsizeerrdeletedataoffsetnegative.xml
            #[test]
            fn test_characterdataindexsizeerrdeletedataoffsetnegative() {
                // unimplemented: // <implementationAttribute name="signed" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                // unimplemented:
                // <assertDOMException id="throws_INDEX_SIZE_ERR">
                //      <INDEX_SIZE_ERR>
                //          <deleteData obj="child" offset="-5" count="3"/>
                //      </INDEX_SIZE_ERR>
                // </assertDOMException>
            }
            // hc_elementgetelementempty.xml
            #[test]
            fn test_hc_elementgetelementempty() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let mut r#domestic_attr; // type: Attr // <var name="domesticAttr" type="Attr"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#new_attribute = r#doc.create_attribute("lang".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;lang&quot;"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(3).unwrap(); // <item interface="NodeList" obj="elementList" index="3" var="testEmployee"/>
                r#domestic_attr = r#test_employee.set_attribute_node(r#new_attribute).unwrap(); // <setAttributeNode obj="testEmployee" var="domesticAttr" newAttr="newAttribute"/>
                let r#attr_value = r#test_employee.get_attribute("lang"); // <getAttribute obj="testEmployee" var="attrValue" name="&quot;lang&quot;"/>
                assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" id="elementGetElementEmptyAssert" ignoreCase="false"/>
            }
            // characterdatagetdata.xml
            #[test]
            fn test_characterdatagetdata() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                let r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Margaret Martin"); // <assertEquals actual="childData" expected="&quot;Margaret Martin&quot;" id="characterdataGetDataAssert" ignoreCase="false"/>
            }
            // characterdataindexsizeerrsubstringnegativeoffset.xml
            #[test]
            fn test_characterdataindexsizeerrsubstringnegativeoffset() {
                // unimplemented: // <implementationAttribute name="signed" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                // unimplemented:
                // <assertDOMException id="throws_INDEX_SIZE_ERR">
                //      <INDEX_SIZE_ERR>
                //          <substringData var="badString" obj="child" offset="-5" count="3"/>
                //      </INDEX_SIZE_ERR>
                // </assertDOMException>
            }
            // hc_nodeinsertbeforerefchildnull.xml
            #[test]
            fn test_hc_nodeinsertbeforerefchildnull() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#inserted_node; // type: Node // <var name="insertedNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#new_child = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="newChild"/>
                r#inserted_node = r#employee_node
                    .insert_before(new_child.into(), None)
                    .unwrap(); // <insertBefore var="insertedNode" obj="employeeNode" newChild="newChild" refChild="refChild"/>
                r#child = r#employee_node.last_child().unwrap(); // <lastChild interface="Node" obj="employeeNode" var="child"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                assert_eq!(r#child_name, "br"); // <assertEquals actual="childName" expected="&quot;br&quot;" id="nodeName" ignoreCase="auto"/>
            }
            // characterdataappenddatanomodificationallowederrEE.xml
            #[test]
            fn test_characterdataappenddatanomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let mut r#ent_text; // type: Node // <var name="entText" type="Node"/>
                let r#ent_reference; // type: EntityReference // <var name="entReference" type="EntityReference"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" index="2" var="genderNode"/>
                r#ent_reference = r#doc.create_entity_reference("ent3".to_string()).unwrap(); // <createEntityReference var="entReference" obj="doc" name="&quot;ent3&quot;"/>
                // unimplemented: // <assertNotNull actual="entReference" id="createdEntRefNotNull"/>
                r#appended_child = r#gender_node
                    .append_child(ent_reference.clone().into())
                    .unwrap(); // <appendChild obj="genderNode" newChild="entReference" var="appendedChild"/>
                r#ent_text = r#ent_reference
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild var="entText" obj="entReference" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entText" id="entTextNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //      <NO_MODIFICATION_ALLOWED_ERR>
                //          <appendData obj="entText" arg="&quot;newString&quot;"/>
                //      </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_text
                        .append_data("newString")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // entitygetpublicid.xml
            #[test]
            fn test_entitygetpublicid() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#entity_list = doc_type.entities(); // <entities obj="docType" var="entityList"/>
                // unimplemented: // <assertNotNull actual="entityList" id="entitiesNotNull"/>
                let r#entity_node = r#entity_list.get_named_item("ent5").unwrap(); // <getNamedItem obj="entityList" var="entityNode" name="&quot;ent5&quot;"/>
                let r#public_id = r#entity_node.public_id().unwrap().to_string(); // <publicId interface="Entity" obj="entityNode" var="publicId"/>
                assert_eq!(r#public_id, "entityURI"); // <assertEquals actual="publicId" expected="&quot;entityURI&quot;" id="publicId" ignoreCase="false"/>
                let r#system_id = r#entity_node.system_id().unwrap().to_string(); // <systemId interface="Entity" obj="entityNode" var="systemId"/>
                assert_eq!(system_id, "entityFile"); // <assertURIEquals actual="systemId" file="&quot;entityFile&quot;" id="systemId"/>
                let r#notation = r#entity_node.notation_name().unwrap().to_string(); // <notationName interface="Entity" obj="entityNode" var="notation"/>
                assert_eq!(r#notation, "notation1"); // <assertEquals actual="notation" expected="&quot;notation1&quot;" id="notation" ignoreCase="false"/>
            }
            // nodelistindexgetlengthofemptylist.xml
            #[test]
            fn test_nodelistindexgetlengthofemptylist() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#child_node = r#employee_list.item(1).unwrap().clone(); // <item interface="NodeList" obj="employeeList" var="childNode" index="1"/>
                let r#text_node = r#child_node.first_child().unwrap(); // <firstChild interface="Node" obj="childNode" var="textNode"/>
                let r#text_list = r#text_node.child_nodes(); // <childNodes obj="textNode" var="textList"/>
                assert_eq!(text_list.length(), 0); // <assertSize collection="textList" size="0" id="nodelistIndexGetLengthOfEmptyListAssert"/>
            }
            // nodedocumentfragmentnodevalue.xml
            #[test]
            fn test_nodedocumentfragmentnodevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="docFragment"/>
                let r#attr_list = r#doc_fragment.attributes(); // <attributes obj="docFragment" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="attributesNull"/>
                let r#value = r#doc_fragment.node_value(); // <nodeValue obj="docFragment" var="value"/>
                assert!(value.is_none()); // <assertNull actual="value" id="initiallyNull"/>
            }
            // hc_attrcreatetextnode2.xml
            #[test]
            fn test_hc_attrcreatetextnode2() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#address_list; // type: NodeList // <var name="addressList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#street_attr; // type: Attr // <var name="streetAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#address_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#address_list.item(3).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#street_attr = r#attributes.get_named_item("class").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;class&quot;"/>
                r#street_attr.set_node_value("Y&ent1;").unwrap(); // <nodeValue obj="streetAttr" value="&quot;Y&amp;ent1;&quot;"/>
                r#value = r#street_attr.value().to_string(); // <value interface="Attr" obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Y&ent1;"); // <assertEquals actual="value" expected="&quot;Y&amp;ent1;&quot;" id="value" ignoreCase="false"/>
                r#value = r#street_attr.node_value().unwrap().to_string(); // <nodeValue obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Y&ent1;"); // <assertEquals actual="value" expected="&quot;Y&amp;ent1;&quot;" id="nodeValue" ignoreCase="false"/>
            }
            // nodevalue03.xml
            #[test]
            fn test_nodevalue03() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_node = r#doc.create_entity_reference("ent1".to_string()).unwrap(); // <createEntityReference obj="doc" var="newNode" name="&quot;ent1&quot;"/>
                // unimplemented: // <assertNotNull actual="newNode" id="createdEntRefNotNull"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="initiallyNull"/>
                r#new_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
            }
            // nodereplacechildnewchilddiffdocument.xml
            #[test]
            fn test_nodereplacechildnewchilddiffdocument() {
                let r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc1 = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc1" href="staff" willBeModified="false"/>
                r#doc2 = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc2" href="staff" willBeModified="true"/>
                r#new_child = r#doc1.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc1" tagName="&quot;newChild&quot;" var="newChild"/>
                r#element_list = r#doc2.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc2" tagname="&quot;employee&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                r#old_child = r#element_node.first_child().unwrap(); // <firstChild obj="elementNode" var="oldChild" interface="Node"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //      <WRONG_DOCUMENT_ERR>
                //          <replaceChild var="replacedChild" obj="elementNode" newChild="newChild" oldChild="oldChild"/>
                //      </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .replace_child(new_child.into(), old_child)
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // hc_nodetextnodeattribute.xml
            #[test]
            fn test_hc_nodetextnodeattribute() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#text_node = r#test_addr.first_child().unwrap(); // <firstChild interface="Node" obj="testAddr" var="textNode"/>
                let r#attr_list = r#text_node.attributes(); // <attributes obj="textNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="text_attributes_is_null"/>
            }
            // nodeprocessinginstructionnodetype.xml
            #[test]
            fn test_nodeprocessinginstructionnodetype() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#test_list = r#doc.child_nodes(); // <childNodes obj="doc" var="testList"/>
                let r#pi_node = r#test_list
                    .item(0)
                    .unwrap()
                    .clone()
                    .as_processing_instruction()
                    .unwrap(); // <item interface="NodeList" obj="testList" var="piNode" index="0"/>
                let r#node_type = r#pi_node.node_type(); // <nodeType obj="piNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 7); // <assertEquals actual="nodeType" expected="7" id="nodeProcessingInstructionNodeTypeAssert1" ignoreCase="false"/>
            }
            // nodegetownerdocumentnull.xml
            #[test]
            fn test_nodegetownerdocumentnull() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#owner_document = r#doc.owner_document(); // <ownerDocument obj="doc" var="ownerDocument"/>
                assert!(owner_document.is_none()); // <assertNull actual="ownerDocument" id="documentOwnerDocumentNull"/>
            }
            // elementsetattributenodenomodificationallowederr.xml
            #[test]
            fn test_elementsetattributenodenomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender; // type: Node // <var name="gender" type="Node"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                let mut r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#ent_ref = r#gender.first_child().unwrap(); // <firstChild interface="Node" var="entRef" obj="gender"/>
                // unimplemented: // <assertNotNull actual="entRef" id="entRefNotNull"/>
                let r#node_type = r#ent_ref.node_type(); // <nodeType var="nodeType" obj="entRef"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //      <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                //      <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    ent_ref = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#ent_element = r#ent_ref.first_child().unwrap().as_element().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                let r#new_attr = r#doc.create_attribute("newAttr".to_string()).unwrap();
                // <createAttribute obj="doc" var="newAttr" name="&quot;newAttr&quot;"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //      <NO_MODIFICATION_ALLOWED_ERR>
                //          <setAttributeNode var="badAttr" obj="entElement" newAttr="newAttr"/>
                //      </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element
                        .set_attribute_node(new_attr)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodenotationnodevalue.xml
            #[test]
            fn test_nodenotationnodevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#notations = doc_type.notations(); // <notations obj="docType" var="notations"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                let r#notation_node = r#notations.get_named_item("notation1").unwrap(); // <getNamedItem obj="notations" name="&quot;notation1&quot;" var="notationNode"/>
                // unimplemented: // <assertNotNull actual="notationNode" id="notationNotNull"/>
                let r#notation_value = r#notation_node.node_value();
                // <nodeValue obj="notationNode" var="notationValue"/>
                assert!(notation_value.is_none()); // <assertNull actual="notationValue" id="nodeValue"/>
            }
            // textindexsizeerrnegativeoffset.xml
            #[test]
            fn test_textindexsizeerrnegativeoffset() {
                // unimplemented: // <implementationAttribute name="signed" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;name&quot;"/>
                r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                r#text_node = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="textNode"/>

                // unimplemented:
                // <assertDOMException id="throws_INDEX_SIZE_ERR">
                //      <INDEX_SIZE_ERR>
                //          <splitText obj="textNode" var="splitNode" offset="-69"/>
                //      </INDEX_SIZE_ERR>
                // </assertDOMException>
            }
            // documentcreatecomment.xml
            #[test]
            fn test_documentcreatecomment() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#new_comment_node = r#doc.create_comment("This is a new Comment node"); // <createComment obj="doc" var="newCommentNode" data="&quot;This is a new Comment node&quot;"/>
                let r#new_comment_value = r#new_comment_node.node_value().unwrap().to_string(); // <nodeValue obj="newCommentNode" var="newCommentValue"/>
                assert_eq!(r#new_comment_value, "This is a new Comment node"); // <assertEquals actual="newCommentValue" expected="&quot;This is a new Comment node&quot;" ignoreCase="false" id="value"/>
                let r#new_comment_name = r#new_comment_node.node_name().to_string(); // <nodeName obj="newCommentNode" var="newCommentName"/>
                assert_eq!(r#new_comment_name, "#comment"); // <assertEquals actual="newCommentName" expected="&quot;#comment&quot;" ignoreCase="false" id="name"/>
                let r#new_comment_type = r#new_comment_node.node_type(); // <nodeType obj="newCommentNode" var="newCommentType"/>
                assert_eq!(r#new_comment_type as i32, 8); // <assertEquals actual="newCommentType" expected="8" ignoreCase="false" id="type"/>
            }
            // characterdatainsertdatanomodificationallowederrEE.xml
            #[test]
            fn test_characterdatainsertdatanomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let mut r#ent_text; // type: CharacterData // <var name="entText" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" index="2" var="genderNode"/>
                let r#ent_reference = r#doc.create_entity_reference("ent3".to_string()).unwrap(); // <createEntityReference var="entReference" obj="doc" name="&quot;ent3&quot;"/>
                // unimplemented: // <assertNotNull actual="entReference" id="createdEntRefNotNull"/>
                r#ent_text = r#ent_reference
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild var="entText" obj="entReference" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entText" id="entTextNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //      <NO_MODIFICATION_ALLOWED_ERR>
                //          <insertData obj="entText" offset="1" arg="&quot;newArg&quot;"/>
                //      </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_text
                        .insert_data(1, "newArg")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodevalue01.xml
            #[test]
            fn test_nodevalue01() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_node; // type: Element // <var name="newNode" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_node = r#doc.create_element("address".to_string()).unwrap(); // <createElement obj="doc" var="newNode" tagName="&quot;address&quot;"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="initiallyNull"/>
                r#new_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
            }
            // hc_characterdataindexsizeerrreplacedataoffsetgreater.xml
            #[test]
            fn test_hc_characterdataindexsizeerrreplacedataoffsetgreater() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                // <assertDOMException id="throw_INDEX_SIZE_ERR">
                //      <INDEX_SIZE_ERR>
                //          <deleteData obj="child" offset="40" count="3"/>
                //      </INDEX_SIZE_ERR>
                // </assertDOMException>
                assert!(
                    child
                        .delete_data(40, 3)
                        .is_err_and(|err| err == DOMException::IndexSizeErr)
                );
            }
            // hc_documentinvalidcharacterexceptioncreateattribute1.xml
            #[test]
            fn test_hc_documentinvalidcharacterexceptioncreateattribute1() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //      <INVALID_CHARACTER_ERR>
                //          <createAttribute var="createdAttr" obj="doc" name="&quot;&quot;"/>
                //      </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_attribute("")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // hc_namednodemapsetnameditemreturnvalue.xml
            #[test]
            fn test_hc_namednodemapsetnameditemreturnvalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                r#new_attribute = r#doc.create_attribute("class".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;class&quot;"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                let r#new_node = r#attributes
                    .set_named_item(r#new_attribute)
                    .unwrap()
                    .unwrap(); // <setNamedItem interface="NamedNodeMap" obj="attributes" var="newNode" arg="newAttribute"/>
                // unimplemented: // <assertNotNull actual="newNode" id="previousAttrNotNull"/>
                let r#attr_value = r#new_node.node_value().unwrap().to_string(); // <nodeValue obj="newNode" var="attrValue"/>
                assert_eq!(r#attr_value, "No"); // <assertEquals actual="attrValue" expected="&quot;No&quot;" id="previousAttrValue" ignoreCase="false"/>
            }
            // hc_characterdatainsertdatamiddle.xml
            #[test]
            fn test_hc_characterdatainsertdatamiddle() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.insert_data(9, "Ann ").unwrap(); // <insertData obj="child" offset="9" arg="&quot;Ann &quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Margaret Ann Martin"); // <assertEquals actual="childData" expected="&quot;Margaret Ann Martin&quot;" id="characterdataInsertDataMiddleAssert" ignoreCase="false"/>
            }
            // characterdatareplacedatanomodificationallowederrEE.xml
            #[test]
            fn test_characterdatareplacedatanomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let mut r#ent_text; // type: CharacterData // <var name="entText" type="CharacterData"/>
                let r#ent_reference; // type: EntityReference // <var name="entReference" type="EntityReference"/>
                let mut r#appended_node; // type: Node // <var name="appendedNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" index="2" var="genderNode"/>
                r#ent_reference = r#doc.create_entity_reference("ent3".to_string()).unwrap(); // <createEntityReference var="entReference" obj="doc" name="&quot;ent3&quot;"/>
                // unimplemented: // <assertNotNull actual="entReference" id="createdEntRefNotNull"/>
                r#appended_node = r#gender_node
                    .append_child(ent_reference.clone().into())
                    .unwrap(); // <appendChild obj="genderNode" newChild="entReference" var="appendedNode"/>
                r#ent_text = r#ent_reference
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild var="entText" obj="entReference" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entText" id="entTextNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //      <NO_MODIFICATION_ALLOWED_ERR>
                //          <replaceData obj="entText" offset="1" count="3" arg="&quot;newArg&quot;"/>
                //      </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_text
                        .replace_data(1, 3, "newArg")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodetextnodetype.xml
            #[test]
            fn test_nodetextnodetype() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#text_node = r#test_addr.first_child().unwrap(); // <firstChild interface="Node" obj="testAddr" var="textNode"/>
                let r#node_type = r#text_node.node_type(); // <nodeType obj="textNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 3); // <assertEquals actual="nodeType" expected="3" id="nodeTextNodeTypeAssert1" ignoreCase="false"/>
            }
            // hc_nodedocumentnodetype.xml
            #[test]
            fn test_hc_nodedocumentnodetype() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#node_type = r#doc.node_type(); // <nodeType obj="doc" var="nodeType"/>
                assert_eq!(r#node_type as i32, 9); // <assertEquals actual="nodeType" expected="9" id="nodeDocumentNodeTypeAssert1" ignoreCase="false"/>
            }
            // notationgetpublicid.xml
            #[test]
            fn test_notationgetpublicid() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#notations = doc_type.notations(); // <notations obj="docType" var="notations"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                let r#notation_node = r#notations.get_named_item("notation1").unwrap(); // <getNamedItem obj="notations" var="notationNode" name="&quot;notation1&quot;"/>
                let r#public_id = r#notation_node.public_id().unwrap().to_string(); // <publicId interface="Notation" obj="notationNode" var="publicId"/>
                assert_eq!(r#public_id, "notation1File"); // <assertEquals actual="publicId" expected="&quot;notation1File&quot;" id="publicId" ignoreCase="false"/>
            }
            // hc_characterdatadeletedatabegining.xml
            #[test]
            fn test_hc_characterdatadeletedatabegining() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.delete_data(0, 16).unwrap(); // <deleteData obj="child" offset="0" count="16"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Dallas, Texas 98551"); // <assertEquals actual="childData" expected="&quot;Dallas, Texas 98551&quot;" id="data" ignoreCase="false"/>
            }
            // nodevalue04.xml
            #[test]
            fn test_nodevalue04() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_node = r#doc.doctype().unwrap(); // <doctype obj="doc" var="newNode"/>
                // unimplemented: // <assertNotNull actual="newNode" id="docTypeNotNull"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="initiallyNull"/>
                r#new_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
            }
            // nodegetfirstchild.xml
            #[test]
            fn test_nodegetfirstchild() {
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#fchild_node = r#employee_node.first_child().unwrap(); // <firstChild interface="Node" obj="employeeNode" var="fchildNode"/>
                r#child_name = r#fchild_node.node_name().to_string(); // <nodeName obj="fchildNode" var="childName"/>
                // <if><equals actual="childName" expected="&quot;#text&quot;" ignoreCase="false"/>
                //      <nextSibling var="fchildNode" obj="fchildNode" interface="Node"/>
                //      <nodeName obj="fchildNode" var="childName"/>
                // </if>
                if child_name == "#text" {
                    child_name = fchild_node.next_sibling().unwrap().node_name().to_string();
                }
                assert_eq!(r#child_name, "employeeId"); // <assertEquals actual="childName" expected="&quot;employeeId&quot;" id="nodeName" ignoreCase="false"/>
            }
            // hc_elementassociatedattribute.xml
            #[test]
            fn test_hc_elementassociatedattribute() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                let r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;title&quot;"/>
                let r#specified = r#domestic_attr.specified(); // <specified obj="domesticAttr" var="specified"/>
                assert!(r#specified); // <assertTrue actual="specified" id="acronymTitleSpecified"/>
            }
            // nodeelementnodevalue.xml
            #[test]
            fn test_nodeelementnodevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="elementNode"/>
                let r#element_value = r#element_node.node_value(); // <nodeValue obj="elementNode" var="elementValue"/>
                assert!(element_value.is_none()); // <assertNull actual="elementValue" id="elementNodeValueNull"/>
            }
            // textsplittextfour.xml
            #[test]
            fn test_textsplittextfour() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#address_node; // type: Node // <var name="addressNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#address_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="addressNode" index="0"/>
                r#text_node = r#address_node
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild interface="Node" obj="addressNode" var="textNode"/>
                let r#split_node = r#text_node.split_text(30).unwrap(); // <splitText obj="textNode" var="splitNode" offset="30"/>
                let r#value = r#split_node.node_value().unwrap().to_string(); // <nodeValue obj="splitNode" var="value"/>
                assert_eq!(r#value, "98551"); // <assertEquals actual="value" expected="&quot;98551&quot;" id="textSplitTextFourAssert" ignoreCase="false"/>
            }
            // hc_nodeappendchilddocfragment.xml
            #[test]
            fn test_hc_nodeappendchilddocfragment() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#newdoc_fragment; // type: DocumentFragment // <var name="newdocFragment" type="DocumentFragment"/>
                let r#new_child1; // type: Node // <var name="newChild1" type="Node"/>
                let r#new_child2; // type: Node // <var name="newChild2" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let r#expected = vec!["em", "strong", "code", "sup", "var", "acronym", "br", "b"]; // type: List // <var name="expected" type="List"><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member><member>"br"</member><member>"b"</member></var>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#newdoc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="newdocFragment"/>
                r#new_child1 = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="newChild1"/>
                r#new_child2 = r#doc.create_element("b".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;b&quot;" var="newChild2"/>
                r#appended_child = r#newdoc_fragment.append_child(new_child1.into()).unwrap(); // <appendChild var="appendedChild" obj="newdocFragment" newChild="newChild1"/>
                r#appended_child = r#newdoc_fragment.append_child(new_child2.into()).unwrap(); // <appendChild var="appendedChild" obj="newdocFragment" newChild="newChild2"/>
                r#appended_child = r#employee_node
                    .append_child(newdoc_fragment.into())
                    .unwrap(); // <appendChild var="appendedChild" obj="employeeNode" newChild="newdocFragment"/>
                // <for-each collection="childList" member="child">
                //      <nodeType var="nodeType" obj="child"/>
                //      <if><equals actual="nodeType" expected="1"/>
                //          <nodeName var="childName" obj="child"/>
                //          <append collection="result" item="childName"/>
                //      </if>
                // </for-each>
                let len = child_list.length();
                for i in 0..len {
                    let child = child_list.item(i).unwrap();
                    node_type = child.node_type();
                    if node_type as i32 == 1 {
                        child_name = child.node_name();
                        result.push(child_name.to_string());
                    }
                }
                assert_eq!(r#result, expected); // <assertEquals actual="result" expected="expected" ignoreCase="auto" id="nodeNames"/>
            }
            // attrreplacechild1.xml
            #[test]
            fn test_attrreplacechild1() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                let mut r#attr_node; // type: Node // <var name="attrNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference obj="doc" var="entRef" name="&quot;ent4&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                r#ent_element = r#ent_ref.first_child().unwrap().as_element().unwrap(); // <firstChild var="entElement" obj="entRef" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#attr_node = r#ent_element.get_attribute_node("domestic").unwrap(); // <getAttributeNode var="attrNode" obj="entElement" name="&quot;domestic&quot;"/>
                let r#text_node = r#attr_node.first_child().unwrap(); // <firstChild var="textNode" obj="attrNode" interface="Node"/>
                // unimplemented: // <assertNotNull actual="textNode" id="attrChildNotNull"/>
                let r#new_child = r#doc.create_text_node("Yesterday"); // <createTextNode var="newChild" obj="doc" data="&quot;Yesterday&quot;"/>
                // <assertDOMException id="setValue_throws_NO_MODIFICATION_ERR">
                //      <NO_MODIFICATION_ALLOWED_ERR>
                //          <replaceChild obj="attrNode" oldChild="textNode" var="removedNode" newChild="newChild"/>
                //      </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    attr_node
                        .replace_child(new_child.into(), text_node)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_elementinuseattributeerr.xml
            #[test]
            fn test_hc_elementinuseattributeerr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#address_element_list; // type: NodeList // <var name="addressElementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                let mut r#new_element; // type: Element // <var name="newElement" type="Element"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#set_attr1; // type: Attr // <var name="setAttr1" type="Attr"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#address_element_list = r#doc.get_elements_by_tag_name("body"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;body&quot;" var="addressElementList"/>
                r#test_address = r#address_element_list.item(0).unwrap(); // <item interface="NodeList" obj="addressElementList" index="0" var="testAddress"/>
                r#new_element = r#doc.create_element("p".to_string()).unwrap(); // <createElement obj="doc" var="newElement" tagName="&quot;p&quot;"/>
                r#appended_child = r#test_address
                    .append_child(new_element.clone().into())
                    .unwrap(); // <appendChild var="appendedChild" obj="testAddress" newChild="newElement"/>
                r#new_attribute = r#doc.create_attribute("title".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;title&quot;"/>
                r#set_attr1 = r#new_element
                    .set_attribute_node(r#new_attribute.clone())
                    .unwrap(); // <setAttributeNode var="setAttr1" obj="newElement" newAttr="newAttribute"/>
                // <assertDOMException id="throw_INUSE_ATTRIBUTE_ERR">
                //      <INUSE_ATTRIBUTE_ERR>
                //          <setAttributeNode var="setAttr2" obj="testAddress" newAttr="newAttribute"/>
                //      </INUSE_ATTRIBUTE_ERR>
                // </assertDOMException>
                assert!(
                    test_address
                        .set_attribute_node(new_attribute)
                        .is_err_and(|err| err == DOMException::InuseAttributeErr)
                );
            }
            // nodeappendchildnomodificationallowederrEE.xml
            #[test]
            fn test_nodeappendchildnomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                let r#created_node = r#doc.create_element("text3".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;text3&quot;" var="createdNode"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //      <NO_MODIFICATION_ALLOWED_ERR>
                //          <appendChild var="appendedNode" obj="entRef" newChild="createdNode"/>
                //      </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_ref
                        .append_child(created_node.into())
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodeappendchildnomodificationallowederr.xml
            #[test]
            fn test_nodeappendchildnomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                let mut r#ent_element; // type: Node // <var name="entElement" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item obj="genderList" index="2" var="genderNode" interface="NodeList"/>
                r#ent_ref = r#gender_node.first_child().unwrap(); // <firstChild interface="Node" var="entRef" obj="genderNode"/>
                // unimplemented: // <assertNotNull actual="entRef" id="entRefNotNull"/>
                let r#node_type = r#ent_ref.node_type(); // <nodeType var="nodeType" obj="entRef"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    ent_ref = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#ent_element = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                let r#created_node = r#doc.create_element("text3".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;text3&quot;" var="createdNode"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <appendChild var="appendedNode" obj="entElement" newChild="createdNode"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element
                        .append_child(created_node.into())
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // namednodemapreturnnull.xml
            #[test]
            fn test_namednodemapreturnnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="1"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#district_node = r#attributes.get_named_item("district"); // <getNamedItem obj="attributes" var="districtNode" name="&quot;district&quot;"/>
                assert!(district_node.is_none()); // <assertNull actual="districtNode" id="namednodemapReturnNullAssert"/>
            }
            // hc_nodegetownerdocumentnull.xml
            #[test]
            fn test_hc_nodegetownerdocumentnull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#owner_document = r#doc.owner_document(); // <ownerDocument obj="doc" var="ownerDocument"/>
                assert!(owner_document.is_none()); // <assertNull actual="ownerDocument" id="nodeGetOwnerDocumentNullAssert1"/>
            }
            // namednodemapchildnoderange.xml
            #[test]
            fn test_namednodemapchildnoderange() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="2"/>
                r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#length = r#attributes.length(); // <length var="length" obj="attributes" interface="NamedNodeMap"/>
                assert_eq!(r#length, 2); // <assertEquals actual="length" expected="2" id="length" ignoreCase="false"/>
                r#child = r#attributes.item(0).unwrap(); // <item var="child" index="0" obj="attributes" interface="NamedNodeMap"/>
                r#child = r#attributes.item(1).unwrap(); // <item var="child" index="1" obj="attributes" interface="NamedNodeMap"/>
            }
            // documenttypegetentitieslength.xml
            #[test]
            fn test_documenttypegetentitieslength() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#entity_list; // type: NamedNodeMap // <var name="entityList" type="NamedNodeMap"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                entity_list = doc_type.entities(); // <entities obj="docType" var="entityList"/>
                // unimplemented: // <assertNotNull actual="entityList" id="entitiesNotNull"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //  <assertSize collection="entityList" size="7" id="entitySizeSVG"/>
                // <else>
                //  <assertSize collection="entityList" size="5" id="entitySize"/>
                // </else>
                // </if>
            }
            // hc_noderemovechild.xml
            #[test]
            fn test_hc_noderemovechild() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Element // <var name="rootNode" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                let r#child_list = r#root_node.child_nodes(); // <childNodes obj="rootNode" var="childList"/>
                let r#child_to_remove = r#child_list.item(1).unwrap().clone(); // <item interface="NodeList" obj="childList" index="1" var="childToRemove"/>
                let r#removed_child = r#root_node.remove_child(child_to_remove).unwrap(); // <removeChild obj="rootNode" var="removedChild" oldChild="childToRemove"/>
                let r#parent_node = r#removed_child.parent_node(); // <parentNode interface="Node" obj="removedChild" var="parentNode"/>
                assert!(parent_node.is_none()); // <assertNull actual="parentNode" id="parentNodeNull"/>
            }
            // hc_attrname.xml
            #[test]
            fn test_hc_attrname() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;acronym&quot;"/>
                let r#test_node = r#address_list.item(1).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="1"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#street_attr = r#attributes.get_named_item("class").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;class&quot;"/>
                let r#strong1 = r#street_attr.node_name().to_string(); // <nodeName obj="streetAttr" var="strong1"/>
                let r#strong2 = r#street_attr.name().to_string(); // <name obj="streetAttr" var="strong2" interface="Attr"/>
                assert_eq!(r#strong1, "class"); // <assertEquals actual="strong1" expected="&quot;class&quot;" id="nodeName" ignoreCase="auto" context="attribute"/>
                assert_eq!(r#strong2, "class"); // <assertEquals actual="strong2" expected="&quot;class&quot;" id="name" ignoreCase="auto" context="attribute"/>
            }
            // hc_characterdataappenddata.xml
            #[test]
            fn test_hc_characterdataappenddata() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.append_data(", Esquire").unwrap(); // <appendData obj="child" arg="&quot;, Esquire&quot;"/>
                let r#child_value = r#child.data().to_string(); // <data obj="child" var="childValue" interface="CharacterData"/>
                let r#child_length = r#child_value.len(); // <length obj="childValue" var="childLength" interface="DOMString"/>
                assert_eq!(r#child_length, 24); // <assertEquals actual="childLength" expected="24" ignoreCase="false" id="characterdataAppendDataAssert"/>
            }
            // elementsetattributenomodificationallowederrEE.xml
            #[test]
            fn test_elementsetattributenomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender; // type: Node // <var name="gender" type="Node"/>
                let r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                r#appended_child = r#gender.append_child(ent_ref.clone().into()).unwrap(); // <appendChild obj="gender" newChild="entRef" var="appendedChild"/>
                r#ent_element = r#ent_ref.first_child().unwrap().as_element().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <setAttribute obj="entElement" name="&quot;newAttr&quot;" value="&quot;newValue&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element
                        .set_attribute("newAttr", "newValue")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_characterdatareplacedatamiddle.xml
            #[test]
            fn test_hc_characterdatareplacedatamiddle() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.replace_data(5, 5, "South").unwrap(); // <replaceData obj="child" offset="5" count="5" arg="&quot;South&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230 South Ave. Dallas, Texas 98551"); // <assertEquals actual="childData" expected="&quot;1230 South Ave. Dallas, Texas 98551&quot;" id="characterdataReplaceDataMiddleAssert" ignoreCase="false"/>
            }
            // hc_elementinvalidcharacterexception1.xml
            #[test]
            fn test_hc_elementinvalidcharacterexception1() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_address = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddress"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <setAttribute obj="testAddress" name="&quot;&quot;" value="&quot;value&quot;"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    test_address
                        .set_attribute("", "value")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // elementgetelementsbytagname.xml
            #[test]
            fn test_elementgetelementsbytagname() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                assert_eq!(element_list.length(), 5); // <assertSize collection="elementList" size="5" id="elementGetElementsByTagNameAssert"/>
            }
            // noderemovechildoldchildnonexistent.xml
            #[test]
            fn test_noderemovechildoldchildnonexistent() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#old_child = r#doc.create_element("oldChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;oldChild&quot;" var="oldChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <removeChild var="removedChild" obj="elementNode" oldChild="oldChild"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .remove_child(old_child.into())
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // noderemovechildnode.xml
            #[test]
            fn test_noderemovechildnode() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                let r#child; // type: Node // <var name="child" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#old_child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="oldChild"/>
                let r#removed_child = r#employee_node.remove_child(old_child).unwrap(); // <removeChild var="removedChild" obj="employeeNode" oldChild="oldChild"/>
                let r#removed_name = r#removed_child.node_name().to_string(); // <nodeName obj="removedChild" var="removedName"/>
                r#child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="child"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                let r#length = r#child_list.length(); // <length interface="NodeList" obj="childList" var="length"/>
                // <if><equals actual="length" expected="5" ignoreCase="false"/>
                //  <assertEquals actual="removedName" expected="&quot;employeeId&quot;" ignoreCase="false" id="removedNameNoWhitespace"/>
                //  <assertEquals actual="childName" expected="&quot;name&quot;" ignoreCase="false" id="childNameNoWhitespace"/>
                // <else>
                //  <assertEquals actual="removedName" expected="&quot;#text&quot;" ignoreCase="false" id="removedName"/>
                //  <assertEquals actual="childName" expected="&quot;employeeId&quot;" ignoreCase="false" id="childName"/>
                //  <assertEquals actual="length" expected="12" ignoreCase="false" id="length"/>
                // </else>
                // </if>
                if length == 5 {
                    assert_eq!(removed_name, "employeeId");
                    assert_eq!(child_name, "name");
                } else {
                    assert_eq!(removed_name, "#text");
                    assert_eq!(child_name, "employeeId");
                    assert_eq!(length, 12);
                }
            }
            // hc_characterdatareplacedataexceedslengthofdata.xml
            #[test]
            fn test_hc_characterdatareplacedataexceedslengthofdata() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.replace_data(0, 50, "2600").unwrap(); // <replaceData obj="child" offset="0" count="50" arg="&quot;2600&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "2600"); // <assertEquals actual="childData" expected="&quot;2600&quot;" id="characterdataReplaceDataExceedsLengthOfDataAssert" ignoreCase="false"/>
            }
            // nodeappendchild.xml
            #[test]
            fn test_nodeappendchild() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#created_node; // type: Node // <var name="createdNode" type="Node"/>
                let r#lchild; // type: Node // <var name="lchild" type="Node"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#created_node = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="createdNode"/>
                r#appended_child = r#employee_node.append_child(created_node.into()).unwrap(); // <appendChild var="appendedChild" obj="employeeNode" newChild="createdNode"/>
                r#lchild = r#employee_node.last_child().unwrap(); // <lastChild interface="Node" obj="employeeNode" var="lchild"/>
                let r#child_name = r#lchild.node_name().to_string(); // <nodeName obj="lchild" var="childName"/>
                assert_eq!(r#child_name, "newChild"); // <assertEquals actual="childName" expected="&quot;newChild&quot;" id="nodeAppendChildAssert1" ignoreCase="false"/>
            }
            // attrremovechild1.xml
            #[test]
            fn test_attrremovechild1() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                let mut r#attr_node; // type: Node // <var name="attrNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference obj="doc" var="entRef" name="&quot;ent4&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                r#ent_element = r#ent_ref.first_child().unwrap().as_element().unwrap(); // <firstChild var="entElement" obj="entRef" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#attr_node = r#ent_element.get_attribute_node("domestic").unwrap(); // <getAttributeNode var="attrNode" obj="entElement" name="&quot;domestic&quot;"/>
                let r#text_node = r#attr_node.first_child().unwrap(); // <firstChild var="textNode" obj="attrNode" interface="Node"/>
                // unimplemented: // <assertNotNull actual="textNode" id="attrChildNotNull"/>
                // <assertDOMException id="setValue_throws_NO_MODIFICATION_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <removeChild obj="attrNode" oldChild="textNode" var="removedNode"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    attr_node
                        .remove_child(text_node)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_namednodemapremovenameditem.xml
            #[test]
            fn test_hc_namednodemapremovenameditem() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let r#street_attr; // type: Attr // <var name="streetAttr" type="Attr"/>
                let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                r#removed_node = r#attributes.remove_named_item("class").unwrap(); // <removeNamedItem var="removedNode" interface="NamedNodeMap" obj="attributes" name="&quot;class&quot;"/>
                r#street_attr = r#attributes.get_named_item("class"); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;class&quot;"/>
                assert!(street_attr.is_none()); // <assertNull actual="streetAttr" id="isnull"/>
            }
            // domimplementationfeaturenull.xml
            #[test]
            fn test_domimplementationfeaturenull() {
                // unimplemented: // <implementationAttribute name="hasNullString" value="true"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                let r#state = dom_impl.has_feature("XML", None); // <hasFeature obj="domImpl" var="state" feature="&quot;XML&quot;" version="nullVersion"/>
                assert!(r#state); // <assertTrue actual="state" id="hasXMLnull"/>
            }
            // hc_elementgettagname.xml
            #[test]
            fn test_hc_elementgettagname() {
                let mut r#tagname; // type: DOMString // <var name="tagname" type="DOMString"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#root = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="root"/>
                r#tagname = r#root.tag_name().to_string(); // <tagName obj="root" var="tagname"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //  <assertEquals actual="tagname" expected="&quot;svg&quot;" id="svgTagname" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="tagname" expected="&quot;html&quot;" id="tagname" ignoreCase="auto"/>
                // </else>
                // </if>
            }
            // notationgetsystemidnull.xml
            #[test]
            fn test_notationgetsystemidnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#notations = doc_type.notations(); // <notations obj="docType" var="notations"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                let r#notation_node = r#notations.get_named_item("notation1").unwrap(); // <getNamedItem obj="notations" var="notationNode" name="&quot;notation1&quot;"/>
                let r#system_id = r#notation_node.system_id(); // <systemId interface="Notation" obj="notationNode" var="systemId"/>
                assert!(system_id.is_none()); // <assertNull actual="systemId" id="systemId"/>
            }
            // nodevalue08.xml
            #[test]
            fn test_nodevalue08() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                let mut r#new_value; // type: DOMString // <var name="newValue" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#node_map = doc_type.notations(); // <notations obj="docType" var="nodeMap"/>
                // unimplemented: // <assertNotNull actual="nodeMap" id="notationsNotNull"/>
                r#new_node = r#node_map.get_named_item("notation1").unwrap(); // <getNamedItem obj="nodeMap" name="&quot;notation1&quot;" var="newNode"/>
                // unimplemented: // <assertNotNull actual="newNode" id="notationNotNull"/>
                r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="initiallyNull"/>
                r#new_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
            }
            // documentcreatedocumentfragment.xml
            #[test]
            fn test_documentcreatedocumentfragment() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#new_doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="newDocFragment"/>
                let r#children = r#new_doc_fragment.child_nodes(); // <childNodes obj="newDocFragment" var="children"/>
                let r#length = r#children.length(); // <length interface="NodeList" obj="children" var="length"/>
                assert_eq!(r#length, 0); // <assertEquals actual="length" expected="0" ignoreCase="false" id="length"/>
                let r#new_doc_fragment_name = r#new_doc_fragment.node_name().to_string(); // <nodeName obj="newDocFragment" var="newDocFragmentName"/>
                assert_eq!(r#new_doc_fragment_name, "#document-fragment"); // <assertEquals actual="newDocFragmentName" expected="&quot;#document-fragment&quot;" ignoreCase="false" id="name"/>
                let r#new_doc_fragment_type = r#new_doc_fragment.node_type(); // <nodeType obj="newDocFragment" var="newDocFragmentType"/>
                assert_eq!(r#new_doc_fragment_type as i32, 11); // <assertEquals actual="newDocFragmentType" expected="11" ignoreCase="false" id="type"/>
                let r#new_doc_fragment_value = r#new_doc_fragment.node_value(); // <nodeValue obj="newDocFragment" var="newDocFragmentValue"/>
                assert!(new_doc_fragment_value.is_none()); // <assertNull actual="newDocFragmentValue" id="value"/>
            }
            // attrcreatedocumentfragment.xml
            #[test]
            fn test_attrcreatedocumentfragment() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_fragment; // type: DocumentFragment // <var name="docFragment" type="DocumentFragment"/>
                let mut r#new_one; // type: Element // <var name="newOne" type="Element"/>
                let r#domestic_node; // type: Node // <var name="domesticNode" type="Node"/>
                let r#domestic_attr; // type: NamedNodeMap // <var name="domesticAttr" type="NamedNodeMap"/>
                let r#attrs; // type: Attr // <var name="attrs" type="Attr"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="docFragment"/>
                r#new_one = r#doc.create_element("newElement".to_string()).unwrap(); // <createElement obj="doc" var="newOne" tagName="&quot;newElement&quot;"/>
                r#new_one.set_attribute("newdomestic", "Yes").unwrap(); // <setAttribute obj="newOne" name="&quot;newdomestic&quot;" value="&quot;Yes&quot;"/>
                r#appended_child = r#doc_fragment.append_child(new_one.into()).unwrap(); // <appendChild var="appendedChild" obj="docFragment" newChild="newOne"/>
                r#domestic_node = r#doc_fragment.first_child().unwrap(); // <firstChild interface="Node" obj="docFragment" var="domesticNode"/>
                r#domestic_attr = r#domestic_node.attributes().unwrap(); // <attributes obj="domesticNode" var="domesticAttr"/>
                r#attrs = r#domestic_attr.item(0).unwrap(); // <item interface="NamedNodeMap" obj="domesticAttr" var="attrs" index="0"/>
                let r#attr_name = r#attrs.name().to_string(); // <name interface="Attr" obj="attrs" var="attrName"/>
                assert_eq!(r#attr_name, "newdomestic"); // <assertEquals actual="attrName" expected="&quot;newdomestic&quot;" id="attrCreateDocumentFragmentAssert" ignoreCase="false"/>
            }
            // hc_elementnotfounderr.xml
            #[test]
            fn test_hc_elementnotfounderr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#old_attribute; // type: Attr // <var name="oldAttribute" type="Attr"/>
                let r#address_element_list; // type: NodeList // <var name="addressElementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#address_element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="addressElementList"/>
                r#test_address = r#address_element_list.item(4).unwrap(); // <item interface="NodeList" obj="addressElementList" index="4" var="testAddress"/>
                r#old_attribute = r#doc.create_attribute("title".to_string()).unwrap(); // <createAttribute obj="doc" var="oldAttribute" name="&quot;title&quot;"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <removeAttributeNode obj="testAddress" oldAttr="oldAttribute" var="attrAddress"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    test_address
                        .remove_attribute_node(old_attribute)
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // elementgetelementsbytagnameaccessnodelist.xml
            #[test]
            fn test_elementgetelementsbytagnameaccessnodelist() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(3).unwrap(); // <item interface="NodeList" obj="elementList" index="3" var="testEmployee"/>
                r#child = r#test_employee.first_child().unwrap(); // <firstChild interface="Node" obj="testEmployee" var="child"/>
                let r#child_type = r#child.node_type(); // <nodeType var="childType" obj="child"/>
                // <if><equals actual="childType" expected="3" ignoreCase="false"/>
                //  <nextSibling var="child" obj="child" interface="Node"/>
                // </if>
                if child_type as i32 == 3 {
                    child = child.next_sibling().unwrap();
                }
                let r#child_name = r#child.node_name().to_string(); // <nodeName var="childName" obj="child" interface="Node"/>
                assert_eq!(r#child_name, "employeeId"); // <assertEquals actual="childName" expected="&quot;employeeId&quot;" id="nodename" ignoreCase="false"/>
                r#child = r#child.first_child().unwrap(); // <firstChild var="child" obj="child" interface="Node"/>
                let r#child_value = r#child.node_value().unwrap().to_string(); // <nodeValue var="childValue" obj="child"/>
                assert_eq!(r#child_value, "EMP0004"); // <assertEquals actual="childValue" expected="&quot;EMP0004&quot;" ignoreCase="false" id="emp0004"/>
            }
            // hc_attrchildnodes2.xml
            #[test]
            fn test_hc_attrchildnodes2() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let r#text_node; // type: Text // <var name="textNode" type="Text"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                let r#child_nodes = r#title_attr.child_nodes(); // <childNodes var="childNodes" obj="titleAttr"/>
                r#text_node = r#doc.create_text_node("terday"); // <createTextNode var="textNode" obj="doc" data="&quot;terday&quot;"/>
                r#title_attr.append_child(text_node.into()).unwrap(); // <appendChild var="retval" obj="titleAttr" newChild="textNode"/>
                assert_eq!(child_nodes.length(), 2); // <assertSize size="2" collection="childNodes" id="childNodesSize"/>
                let r#text_node = r#child_nodes.item(0).unwrap().clone(); // <item var="textNode" obj="childNodes" index="0" interface="NodeList"/>
                r#value = r#text_node.node_value().unwrap().to_string(); // <nodeValue var="value" obj="textNode"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="child1IsYes" ignoreCase="false"/>
                let r#text_node = r#child_nodes.item(1).unwrap().clone(); // <item var="textNode" obj="childNodes" index="1" interface="NodeList"/>
                r#value = r#text_node.node_value().unwrap().to_string(); // <nodeValue var="value" obj="textNode"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="child2IsTerday" ignoreCase="false"/>
                let r#text_node = r#child_nodes.item(2); // <item var="textNode" obj="childNodes" index="2" interface="NodeList"/>
                assert!(text_node.is_none()); // <assertNull actual="textNode" id="thirdItemIsNull"/>
            }
            // hc_noderemovechildgetnodename.xml
            #[test]
            fn test_hc_noderemovechildgetnodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#old_child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="oldChild"/>
                let r#old_name = r#old_child.node_name().to_string(); // <nodeName obj="oldChild" var="oldName"/>
                let r#removed_child = r#employee_node.remove_child(old_child).unwrap(); // <removeChild obj="employeeNode" oldChild="oldChild" var="removedChild"/>
                // unimplemented: // <assertNotNull actual="removedChild" id="notnull"/>
                let r#child_name = r#removed_child.node_name().to_string(); // <nodeName obj="removedChild" var="childName"/>
                assert_eq!(r#child_name, old_name); // <assertEquals actual="childName" expected="oldName" id="nodeName" ignoreCase="false"/>
            }
            // hc_nodeinsertbeforenewchilddiffdocument.xml
            #[test]
            fn test_hc_nodeinsertbeforenewchilddiffdocument() {
                let r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc1 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc1" href="hc_staff" willBeModified="false"/>
                r#doc2 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc2" href="hc_staff" willBeModified="true"/>
                r#new_child = r#doc1.create_element("br".to_string()).unwrap(); // <createElement obj="doc1" tagName="&quot;br&quot;" var="newChild"/>
                r#element_list = r#doc2.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc2" tagname="&quot;p&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                r#ref_child = r#element_node.first_child().unwrap(); // <firstChild var="refChild" obj="elementNode" interface="Node"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <insertBefore var="insertedNode" obj="elementNode" newChild="newChild" refChild="refChild"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .insert_before(new_child.into(), Some(ref_child))
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // hc_characterdataindexsizeerrdeletedataoffsetnegative.xml
            #[test]
            fn test_hc_characterdataindexsizeerrdeletedataoffsetnegative() {
                // unimplemented: // <implementationAttribute name="signed" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // unimplemented:
                // <assertDOMException id="throws_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <deleteData obj="child" offset="-5" count="3"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
            }
            // hc_nodeelementnodename.xml
            #[test]
            fn test_hc_nodeelementnodename() {
                let mut r#element_name; // type: DOMString // <var name="elementName" type="DOMString"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="elementNode"/>
                r#element_name = r#element_node.node_name().to_string(); // <nodeName obj="elementNode" var="elementName"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //  <assertEquals actual="elementName" expected="&quot;svg&quot;" id="svgNodeName" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="elementName" expected="&quot;html&quot;" id="nodeName" ignoreCase="auto"/>
                // </else>
                // </if>
            }
            // nodeentityreferencenodetype.xml
            #[test]
            fn test_nodeentityreferencenodetype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#ent_ref_addr; // type: Element // <var name="entRefAddr" type="Element"/>
                let mut r#ent_ref_node; // type: Node // <var name="entRefNode" type="Node"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#ent_ref_addr = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="entRefAddr"/>
                r#ent_ref_node = r#ent_ref_addr.first_child().unwrap(); // <firstChild interface="Node" obj="entRefAddr" var="entRefNode"/>
                r#node_type = r#ent_ref_node.node_type(); // <nodeType obj="entRefNode" var="nodeType"/>
                // <if><equals actual="nodeType" expected="3" ignoreCase="false"/>
                //  <createEntityReference var="entRefNode" obj="doc" name="&quot;ent2&quot;"/>
                //  <assertNotNull actual="entRefNode" id="createdEntRefNotNull"/>
                //  <nodeType obj="entRefNode" var="nodeType"/>
                // </if>
                if node_type as i32 == 3 {
                    ent_ref_node = doc.create_entity_reference("ent2").unwrap().into();
                    node_type = ent_ref_node.node_type();
                }
                assert_eq!(r#node_type as i32, 5); // <assertEquals actual="nodeType" expected="5" id="entityNodeType" ignoreCase="false"/>
            }
            // hc_documentinvalidcharacterexceptioncreateelement1.xml
            #[test]
            fn test_hc_documentinvalidcharacterexceptioncreateelement1() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <createElement var="badElement" obj="doc" tagName="&quot;&quot;"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_element("")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // elementgetelementsbytagnamespecialvalue.xml
            #[test]
            fn test_elementgetelementsbytagnamespecialvalue() {
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let r#expected_result = vec![
                    "employeeId",
                    "name",
                    "position",
                    "salary",
                    "gender",
                    "address",
                ]; // type: List // <var name="expectedResult" type="List"><member>"employeeId"</member><member>"name"</member><member>"position"</member><member>"salary"</member><member>"gender"</member><member>"address"</member></var>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#last_employee = r#element_list.item(4).unwrap(); // <item interface="NodeList" obj="elementList" index="4" var="lastEmployee"/>
                let r#lastemp_list = r#last_employee.get_elements_by_tag_name("*"); // <getElementsByTagName interface="Element" obj="lastEmployee" var="lastempList" tagname="&quot;*&quot;"/>
                // <for-each collection="lastempList" member="child">
                //  <nodeName obj="child" var="childName"/>
                //  <append collection="result" item="childName"/>
                // </for-each>
                for i in 0..lastemp_list.length() {
                    let child = lastemp_list.item(i).unwrap();
                    child_name = child.node_name().to_string();
                    result.push(child_name);
                }
                assert_eq!(r#result, expected_result); // <assertEquals actual="result" expected="expectedResult" id="tagNames" ignoreCase="false"/>
            }
            // cdatasectionnormalize.xml
            #[test]
            fn test_cdatasectionnormalize() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#name_list; // type: NodeList // <var name="nameList" type="NodeList"/>
                let mut r#l_child; // type: Element // <var name="lChild" type="Element"/>
                let r#child_nodes; // type: NodeList // <var name="childNodes" type="NodeList"/>
                let mut r#cdata_n; // type: CDATASection // <var name="cdataN" type="CDATASection"/>
                let mut r#data; // type: DOMString // <var name="data" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#name_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="nameList" tagname="&quot;name&quot;"/>
                r#l_child = r#name_list.item(1).unwrap(); // <item interface="NodeList" obj="nameList" var="lChild" index="1"/>
                r#l_child.normalize(); // <normalize obj="lChild"/>
                r#child_nodes = r#l_child.child_nodes(); // <childNodes obj="lChild" var="childNodes"/>
                r#cdata_n = r#child_nodes
                    .item(1)
                    .unwrap()
                    .clone()
                    .as_cdata_section()
                    .unwrap(); // <item interface="NodeList" obj="childNodes" var="cdataN" index="1"/>
                // unimplemented: // <assertNotNull actual="cdataN" id="firstCDATASection"/>
                r#data = r#cdata_n.data().to_string(); // <data interface="CharacterData" obj="cdataN" var="data"/>
                assert_eq!(
                    r#data,
                    "This is a CDATASection with EntityReference number 2 &ent2;"
                ); // <assertEquals actual="data" expected="&quot;This is a CDATASection with EntityReference number 2 &amp;ent2;&quot;" ignoreCase="false" id="data1"/>
                r#cdata_n = r#child_nodes
                    .item(3)
                    .unwrap()
                    .clone()
                    .as_cdata_section()
                    .unwrap(); // <item interface="NodeList" obj="childNodes" var="cdataN" index="3"/>
                // unimplemented: // <assertNotNull actual="cdataN" id="secondCDATASection"/>
                r#data = r#cdata_n.data().to_string(); // <data interface="CharacterData" obj="cdataN" var="data"/>
                assert_eq!(
                    r#data,
                    "This is an adjacent CDATASection with a reference to a tab &tab;"
                ); // <assertEquals actual="data" expected="&quot;This is an adjacent CDATASection with a reference to a tab &amp;tab;&quot;" ignoreCase="false" id="data3"/>
            }
            // hc_documentcreateelementcasesensitive.xml
            #[test]
            fn test_hc_documentcreateelementcasesensitive() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_element1; // type: Element // <var name="newElement1" type="Element"/>
                let mut r#new_element2; // type: Element // <var name="newElement2" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#new_element1 = r#doc.create_element("ACRONYM".to_string()).unwrap(); // <createElement obj="doc" var="newElement1" tagName="&quot;ACRONYM&quot;"/>
                r#new_element2 = r#doc.create_element("acronym".to_string()).unwrap(); // <createElement obj="doc" var="newElement2" tagName="&quot;acronym&quot;"/>
                r#new_element1.set_attribute("lang", "EN").unwrap(); // <setAttribute obj="newElement1" name="&quot;lang&quot;" value="&quot;EN&quot;"/>
                r#new_element2.set_attribute("title", "Dallas").unwrap(); // <setAttribute obj="newElement2" name="&quot;title&quot;" value="&quot;Dallas&quot;"/>
                let r#attribute1 = r#new_element1.get_attribute("lang"); // <getAttribute obj="newElement1" var="attribute1" name="&quot;lang&quot;"/>
                let r#attribute2 = r#new_element2.get_attribute("title"); // <getAttribute obj="newElement2" var="attribute2" name="&quot;title&quot;"/>
                assert_eq!(r#attribute1, "EN"); // <assertEquals actual="attribute1" expected="&quot;EN&quot;" ignoreCase="false" id="attrib1"/>
                assert_eq!(r#attribute2, "Dallas"); // <assertEquals actual="attribute2" expected="&quot;Dallas&quot;" ignoreCase="false" id="attrib2"/>
                let r#node_name1 = r#new_element1.node_name().to_string(); // <nodeName var="nodeName1" obj="newElement1"/>
                let r#node_name2 = r#new_element2.node_name().to_string(); // <nodeName var="nodeName2" obj="newElement2"/>
                assert_eq!(r#node_name1, "ACRONYM"); // <assertEquals actual="nodeName1" expected="&quot;ACRONYM&quot;" ignoreCase="auto" id="nodeName1"/>
                assert_eq!(r#node_name2, "acronym"); // <assertEquals actual="nodeName2" expected="&quot;acronym&quot;" ignoreCase="auto" id="nodeName2"/>
            }
            // hc_elementretrievetagname.xml
            #[test]
            fn test_hc_elementretrievetagname() {
                let mut r#strong; // type: DOMString // <var name="strong" type="DOMString"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("code"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;code&quot;" var="elementList"/>
                let r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="testEmployee"/>
                r#strong = r#test_employee.node_name().to_string(); // <nodeName obj="testEmployee" var="strong"/>
                assert_eq!(r#strong, "code"); // <assertEquals actual="strong" expected="&quot;code&quot;" id="nodename" ignoreCase="auto"/>
                r#strong = r#test_employee.tag_name().to_string(); // <tagName obj="testEmployee" var="strong"/>
                assert_eq!(r#strong, "code"); // <assertEquals actual="strong" expected="&quot;code&quot;" id="tagname" ignoreCase="auto"/>
            }
            // hc_attrnormalize.xml
            #[test]
            fn test_hc_attrnormalize() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let mut r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#text_node = r#doc.create_text_node("terday"); // <createTextNode var="textNode" obj="doc" data="&quot;terday&quot;"/>
                r#retval = r#title_attr.append_child(text_node.into()).unwrap(); // <appendChild var="retval" obj="titleAttr" newChild="textNode"/>
                r#text_node = r#doc.create_text_node(""); // <createTextNode var="textNode" obj="doc" data="&quot;&quot;"/>
                r#retval = r#title_attr.append_child(text_node.into()).unwrap(); // <appendChild var="retval" obj="titleAttr" newChild="textNode"/>
                r#test_node.normalize(); // <normalize obj="testNode"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrNodeValue" ignoreCase="false"/>
                let r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                r#value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="firstChildValue" ignoreCase="false"/>
                let r#second_child = r#first_child.next_sibling(); // <nextSibling var="secondChild" obj="firstChild" interface="Node"/>
                assert!(second_child.is_none()); // <assertNull actual="secondChild" id="secondChildIsNull"/>
            }
            // hc_nodeappendchildchildexists.xml
            #[test]
            fn test_hc_nodeappendchildchildexists() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#child_node; // type: Node // <var name="childNode" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let mut r#member_name; // type: DOMString // <var name="memberName" type="DOMString"/>
                let mut r#refreshed_actual = vec![]; // type: List // <var name="refreshedActual" type="List"/>
                let mut r#actual = vec![]; // type: List // <var name="actual" type="List"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let r#expected = vec!["strong", "code", "sup", "var", "acronym", "em"]; // type: List // <var name="expected" type="List"><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member><member>"em"</member></var>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#child_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="childNode"/>
                r#child_list = r#child_node.get_elements_by_tag_name("*"); // <getElementsByTagName interface="Element" obj="childNode" var="childList" tagname="&quot;*&quot;"/>
                r#new_child = r#child_list.item(0).unwrap(); // <item interface="NodeList" obj="childList" index="0" var="newChild"/>
                r#appended_child = r#child_node.append_child(new_child.clone().into()).unwrap(); // <appendChild var="appendedChild" obj="childNode" newChild="newChild"/>
                // <for-each collection="childList" member="memberNode">
                //  <nodeName var="memberName" obj="memberNode"/>
                //  <append collection="actual" item="memberName"/>
                // </for-each>
                for i in 0..child_list.length() {
                    let member_node = child_list.item(i).unwrap();
                    member_name = member_node.node_name().to_string();
                    actual.push(member_name);
                }
                assert_eq!(r#actual, expected); // <assertEquals id="liveByTagName" actual="actual" expected="expected" ignoreCase="auto"/>
                let r#child_list = r#child_node.child_nodes(); // <childNodes var="childList" obj="childNode"/>
                // <for-each collection="childList" member="memberNode">
                //  <nodeType var="nodeType" obj="memberNode"/>
                //  <if><equals actual="nodeType" expected="1"/>
                //      <nodeName var="memberName" obj="memberNode"/>
                //      <append collection="refreshedActual" item="memberName"/>
                //  </if>
                // </for-each>
                let len = child_list.length();
                for i in 0..len {
                    let member_node = child_list.item(i).unwrap();
                    node_type = member_node.node_type();
                    if node_type as i32 == 1 {
                        member_name = member_node.node_name().to_string();
                        refreshed_actual.push(member_name);
                    }
                }
                assert_eq!(r#refreshed_actual, expected); // <assertEquals id="refreshedChildNodes" actual="refreshedActual" expected="expected" ignoreCase="auto"/>
            }
            // namednodemapinuseattributeerr.xml
            #[test]
            fn test_namednodemapinuseattributeerr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#first_node; // type: Element // <var name="firstNode" type="Element"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#domestic_attr; // type: Attr // <var name="domesticAttr" type="Attr"/>
                let mut r#set_attr; // type: Attr // <var name="setAttr" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#first_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="firstNode" index="0"/>
                r#domestic_attr = r#doc.create_attribute("domestic".to_string()).unwrap(); // <createAttribute obj="doc" var="domesticAttr" name="&quot;domestic&quot;"/>
                r#domestic_attr.set_value("Yes").unwrap(); // <value interface="Attr" obj="domesticAttr" value="&quot;Yes&quot;"/>
                r#set_attr = r#first_node
                    .set_attribute_node(r#domestic_attr.clone())
                    .unwrap()
                    .unwrap(); // <setAttributeNode var="setAttr" obj="firstNode" newAttr="domesticAttr"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="2"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                // <assertDOMException id="throw_INUSE_ATTRIBUTE_ERR">
                //  <INUSE_ATTRIBUTE_ERR>
                //      <setNamedItem var="setNode" interface="NamedNodeMap" obj="attributes" arg="domesticAttr"/>
                //  </INUSE_ATTRIBUTE_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .set_named_item(domestic_attr)
                        .is_err_and(|err| err == DOMException::InuseAttributeErr)
                );
            }
            // nodehaschildnodes.xml
            #[test]
            fn test_nodehaschildnodes() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#state = r#employee_node.has_child_nodes(); // <hasChildNodes obj="employeeNode" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="nodeHasChildAssert1"/>
            }
            // processinginstructiongettarget.xml
            #[test]
            fn test_processinginstructiongettarget() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#child_nodes = r#doc.child_nodes(); // <childNodes obj="doc" var="childNodes"/>
                let r#pi_node = r#child_nodes
                    .item(0)
                    .unwrap()
                    .clone()
                    .as_processing_instruction()
                    .unwrap(); // <item interface="NodeList" obj="childNodes" var="piNode" index="0"/>
                let r#target = r#pi_node.target().to_string(); // <target obj="piNode" var="target" interface="ProcessingInstruction"/>
                assert_eq!(r#target, "TEST-STYLE"); // <assertEquals actual="target" expected="&quot;TEST-STYLE&quot;" id="processinginstructionGetTargetAssert" ignoreCase="false"/>
            }
            // nodecommentnodevalue.xml
            #[test]
            fn test_nodecommentnodevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#comment_node; // type: Node // <var name="commentNode" type="Node"/>
                let mut r#comment_name; // type: DOMString // <var name="commentName" type="DOMString"/>
                let mut r#comment_value; // type: DOMString // <var name="commentValue" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.child_nodes(); // <childNodes obj="doc" var="elementList"/>
                // <for-each collection="elementList" member="commentNode">
                //  <nodeName obj="commentNode" var="commentName"/>
                //  <if><equals actual="commentName" expected="&quot;#comment&quot;" ignoreCase="false"/>
                //      <nodeValue obj="commentNode" var="commentValue"/>
                //      <assertEquals actual="commentValue" expected="&quot; This is comment number 1.&quot;" id="value" ignoreCase="false"/>
                //  </if>
                // </for-each>
                let len = element_list.length();
                for i in 0..len {
                    comment_node = element_list.item(i).unwrap();
                    comment_name = comment_node.node_name().to_string();
                    if comment_name == "#comment" {
                        comment_value = comment_node.node_value().unwrap().to_string();
                        assert_eq!(comment_value, " This is comment number 1.");
                    }
                }
            }
            // characterdatadeletedataexceedslength.xml
            #[test]
            fn test_characterdatadeletedataexceedslength() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.delete_data(4, 50).unwrap(); // <deleteData obj="child" offset="4" count="50"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230"); // <assertEquals actual="childData" expected="&quot;1230&quot;" id="characterdataDeleteDataExceedsLengthAssert" ignoreCase="false"/>
            }
            // nodereplacechildnomodificationallowederrEE.xml
            #[test]
            fn test_nodereplacechildnomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                let r#ent_text = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" var="entText" obj="entRef"/>
                let r#created_node = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="createdNode"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <replaceChild var="replacedChild" obj="entRef" newChild="createdNode" oldChild="entText"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_ref
                        .replace_child(created_node.into(), ent_text)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // textsplittextnomodificationallowederr.xml
            #[test]
            fn test_textsplittextnomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender; // type: Node // <var name="gender" type="Node"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                let r#ent_element; // type: Node // <var name="entElement" type="Node"/>
                let mut r#ent_element_text; // type: Node // <var name="entElementText" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#ent_ref = r#gender.first_child().unwrap(); // <firstChild interface="Node" var="entRef" obj="gender"/>
                // unimplemented: // <assertNotNull actual="entRef" id="entRefNotNull"/>
                let r#node_type = r#ent_ref.node_type(); // <nodeType var="nodeType" obj="entRef"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    ent_ref = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#ent_element = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#ent_element_text = r#ent_element.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" var="entElementText" obj="entElement"/>
                // unimplemented: // <assertNotNull actual="entElementText" id="entElementTextNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <splitText var="splitNode" obj="entElementText" offset="2"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element_text
                        .split_text(2)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodelistreturnfirstitem.xml
            #[test]
            fn test_nodelistreturnfirstitem() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#child = r#employee_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="employeeList" var="child" index="0"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                let r#length = r#employee_list.length(); // <length var="length" obj="employeeList" interface="NodeList"/>
                // <if><equals actual="length" expected="6" ignoreCase="false"/>
                //  <assertEquals actual="childName" expected="&quot;employeeId&quot;" ignoreCase="true" id="firstChildNoWhitespace"/>
                // <else>
                //  <assertEquals actual="childName" expected="&quot;#text&quot;" ignoreCase="true" id="firstChildWithWhitespace"/>
                // </else>
                // </if>
                if length == 6 {
                    assert_eq!(child_name, "employeeId");
                } else {
                    assert_eq!(child_name, "#text");
                }
            }
            // hc_nodereplacechildnodename.xml
            #[test]
            fn test_hc_nodereplacechildnodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.get_elements_by_tag_name("em"); // <getElementsByTagName obj="employeeNode" var="childList" interface="Element" tagname="&quot;em&quot;"/>
                let r#old_child = r#child_list.item(0).unwrap(); // <item interface="NodeList" obj="childList" index="0" var="oldChild"/>
                let r#new_child = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="newChild"/>
                let r#replaced_node = r#employee_node
                    .replace_child(new_child.into(), old_child.into())
                    .unwrap(); // <replaceChild obj="employeeNode" newChild="newChild" oldChild="oldChild" var="replacedNode"/>
                let r#child_name = r#replaced_node.node_name().to_string(); // <nodeName obj="replacedNode" var="childName"/>
                assert_eq!(r#child_name, "em"); // <assertEquals actual="childName" expected="&quot;em&quot;" id="replacedNodeName" ignoreCase="auto"/>
            }
            // nodeclonegetparentnull.xml
            #[test]
            fn test_nodeclonegetparentnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#cloned_node = r#employee_node.clone_node(false); // <cloneNode obj="employeeNode" deep="false" var="clonedNode"/>
                let r#parent_node = r#cloned_node.parent_node(); // <parentNode interface="Node" obj="clonedNode" var="parentNode"/>
                assert!(parent_node.is_none()); // <assertNull actual="parentNode" id="nodeCloneGetParentNullAssert1"/>
            }
            // hc_nodecommentnodevalue.xml
            #[test]
            fn test_hc_nodecommentnodevalue() {
                let mut r#comment_name; // type: DOMString // <var name="commentName" type="DOMString"/>
                let mut r#comment_value; // type: DOMString // <var name="commentValue" type="DOMString"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.child_nodes(); // <childNodes obj="doc" var="elementList"/>
                // <for-each collection="elementList" member="commentNode">
                //  <nodeName obj="commentNode" var="commentName"/>
                //  <if><equals actual="commentName" expected="&quot;#comment&quot;" ignoreCase="false"/>
                //      <nodeValue obj="commentNode" var="commentValue"/>
                //      <assertEquals actual="commentValue" expected="&quot; This is comment number 1.&quot;" id="value" ignoreCase="false"/>
                //  </if>
                // </for-each>
                let len = element_list.length();
                for i in 0..len {
                    let comment_node = element_list.item(i).unwrap();
                    comment_name = comment_node.node_name().to_string();
                    if comment_name == "#comment" {
                        comment_value = comment_node.node_value().unwrap().to_string();
                        assert_eq!(comment_value, " This is comment number 1.");
                    }
                }
                let r#comment_node = r#doc.create_comment(" This is a comment"); // <createComment var="commentNode" obj="doc" data="&quot; This is a comment&quot;"/>
                r#comment_value = r#comment_node.node_value().unwrap().to_string(); // <nodeValue obj="commentNode" var="commentValue"/>
                assert_eq!(r#comment_value, " This is a comment"); // <assertEquals actual="commentValue" expected="&quot; This is a comment&quot;" id="createdCommentNodeValue" ignoreCase="false"/>
            }
            // textparseintolistofelements.xml
            #[test]
            fn test_textparseintolistofelements() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#address_node; // type: Node // <var name="addressNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let mut r#grand_child; // type: Node // <var name="grandChild" type="Node"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let r#expected_normal = vec!["1900 Dallas Road", " Dallas, ", "Texas", "\n 98554"]; // type: List // <var name="expectedNormal" type="List"><member>"1900 Dallas Road"</member><member>" Dallas, "</member><member>"Texas"</member><member>"\n 98554"</member></var>
                let r#expected_expanded = vec!["1900 Dallas Road Dallas, Texas\n 98554"]; // type: List // <var name="expectedExpanded" type="List"><member>"1900 Dallas Road Dallas, Texas\n 98554"</member></var>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#address_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="addressNode" index="1"/>
                r#child_list = r#address_node.child_nodes(); // <childNodes obj="addressNode" var="childList"/>
                let r#length = r#child_list.length(); // <length var="length" obj="childList" interface="NodeList"/>
                // <for-each collection="childList" member="child">
                //  <nodeValue obj="child" var="value"/>
                //  <if><isNull obj="value"/>
                //      <firstChild interface="Node" obj="child" var="grandChild"/>
                //      <assertNotNull actual="grandChild" id="grandChildNotNull"/>
                //      <nodeValue obj="grandChild" var="value"/>
                //      <append collection="result" item="value"/>
                //  <else>
                //      <append collection="result" item="value"/>
                //  </else>
                //  </if>
                // </for-each>
                for i in 0..length {
                    child = child_list.item(i).unwrap();
                    value = child.node_value();
                    if let Some(value) = value {
                        result.push(value.to_string());
                    } else {
                        grand_child = child.first_child().unwrap();
                        let value = grand_child.node_value().unwrap().to_string();
                        result.push(value);
                    }
                }
                // <if><equals actual="length" expected="4" ignoreCase="false"/>
                //  <assertEquals actual="result" expected="expectedNormal" ignoreCase="false" id="assertEqNormal"/>
                // <else>
                //  <assertEquals actual="result" expected="expectedExpanded" ignoreCase="false" id="assertEqCoalescing"/>
                // </else>
                // </if>
                if length == 4 {
                    assert_eq!(result, expected_normal);
                } else {
                    assert_eq!(result, expected_expanded);
                }
            }
            // hc_textparseintolistofelements.xml
            #[test]
            fn test_hc_textparseintolistofelements() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#address_node; // type: Node // <var name="addressNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let mut r#grand_child; // type: Node // <var name="grandChild" type="Node"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let r#expected_normal = vec!["", " Dallas, ", "", "\n 98554"]; // type: List // <var name="expectedNormal" type="List"><member>""</member><member>" Dallas, "</member><member>""</member><member>"\n 98554"</member></var>
                let r#expected_expanded = vec![" Dallas, \n 98554"]; // type: List // <var name="expectedExpanded" type="List"><member>" Dallas, \n 98554"</member></var>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                r#address_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="addressNode" index="1"/>
                r#child_list = r#address_node.child_nodes(); // <childNodes obj="addressNode" var="childList"/>
                let r#length = r#child_list.length(); // <length var="length" obj="childList" interface="NodeList"/>
                // <for-each collection="childList" member="child">
                //  <nodeValue obj="child" var="value"/>
                //  <if><isNull obj="value"/>
                //      <firstChild interface="Node" obj="child" var="grandChild"/>
                //      <assertNotNull actual="grandChild" id="grandChildNotNull"/>
                //      <nodeValue obj="grandChild" var="value"/>
                //      <append collection="result" item="value"/>
                //  <else>
                //      <append collection="result" item="value"/>
                //  </else>
                //  </if>
                // </for-each>
                for i in 0..length {
                    let child = child_list.item(i).unwrap();
                    value = child.node_value();
                    if let Some(value) = value {
                        result.push(value.to_string());
                    } else {
                        grand_child = child.first_child().unwrap();
                        result.push(grand_child.node_value().unwrap().to_string());
                    }
                }
                // <if><equals actual="length" expected="1" ignoreCase="false"/>
                //  <assertEquals actual="result" expected="expectedExpanded" ignoreCase="false" id="assertEqCoalescing"/>
                // <else>
                //  <assertEquals actual="result" expected="expectedNormal" ignoreCase="false" id="assertEqNormal"/>
                // </else>
                // </if>
                if length == 1 {
                    assert_eq!(result, expected_expanded);
                } else {
                    assert_eq!(result, expected_normal);
                }
            }
            // nodeinsertbeforenewchildexists.xml
            #[test]
            fn test_nodeinsertbeforenewchildexists() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#inserted_node; // type: Node // <var name="insertedNode" type="Node"/>
                let r#expected_whitespace = vec![
                    "#text",
                    "#text",
                    "name",
                    "#text",
                    "position",
                    "#text",
                    "salary",
                    "#text",
                    "gender",
                    "#text",
                    "employeeId",
                    "address",
                    "#text",
                ]; // type: List // <var name="expectedWhitespace" type="List"><member>"#text"</member><member>"#text"</member><member>"name"</member><member>"#text"</member><member>"position"</member><member>"#text"</member><member>"salary"</member><member>"#text"</member><member>"gender"</member><member>"#text"</member><member>"employeeId"</member><member>"address"</member><member>"#text"</member></var>
                let r#expected_no_whitespace = vec![
                    "name",
                    "position",
                    "salary",
                    "gender",
                    "employeeId",
                    "address",
                ]; // type: List // <var name="expectedNoWhitespace" type="List"><member>"name"</member><member>"position"</member><member>"salary"</member><member>"gender"</member><member>"employeeId"</member><member>"address"</member></var>
                let r#expected; // type: List // <var name="expected" type="List"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#length = r#child_list.length(); // <length var="length" obj="childList" interface="NodeList"/>
                // <if><equals actual="length" expected="6" ignoreCase="false"/>
                //  <assign var="expected" value="expectedNoWhitespace"/>
                //  <item interface="NodeList" obj="childList" index="5" var="refChild"/>
                //  <item interface="NodeList" obj="childList" index="0" var="newChild"/>
                // <else>
                //  <assign var="expected" value="expectedWhitespace"/>
                //  <item interface="NodeList" obj="childList" index="11" var="refChild"/>
                //  <item interface="NodeList" obj="childList" index="1" var="newChild"/>
                // </else>
                // </if>
                if length == 6 {
                    expected = expected_no_whitespace.clone();
                    ref_child = child_list.item(5).unwrap();
                    new_child = child_list.item(0).unwrap();
                } else {
                    expected = expected_whitespace.clone();
                    ref_child = child_list.item(11).unwrap();
                    new_child = child_list.item(1).unwrap();
                }
                r#inserted_node = r#employee_node
                    .insert_before(new_child, Some(ref_child))
                    .unwrap(); // <insertBefore var="insertedNode" obj="employeeNode" newChild="newChild" refChild="refChild"/>
                // <for-each collection="childList" member="child">
                //  <nodeName obj="child" var="childName"/>
                //  <append collection="result" item="childName"/>
                // </for-each>
                let len = child_list.length();
                for i in 0..len {
                    child = child_list.item(i).unwrap();
                    child_name = child.node_name().to_string();
                    result.push(child_name);
                }
                assert_eq!(r#result, expected); // <assertEquals id="childNames" actual="result" expected="expected" ignoreCase="false"/>
            }
            // characterdatasetdatanomodificationallowederr.xml
            #[test]
            fn test_characterdatasetdatanomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let r#ent_element; // type: Node // <var name="entElement" type="Node"/>
                let mut r#ent_element_content; // type: Node // <var name="entElementContent" type="Node"/>
                let mut r#ent_reference; // type: Node // <var name="entReference" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" index="2" var="genderNode"/>
                r#ent_reference = r#gender_node.first_child().unwrap(); // <firstChild var="entReference" obj="genderNode" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entReference" id="entReferenceNotNull"/>
                let r#node_type = r#ent_reference.node_type(); // <nodeType var="nodeType" obj="entReference"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="entReference" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="entReference" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    ent_reference = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#ent_element = r#ent_reference.first_child().unwrap(); // <firstChild var="entElement" obj="entReference" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#ent_element_content =
                    r#ent_element.first_child().unwrap().as_text_node().unwrap(); // <firstChild var="entElementContent" obj="entElement" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElementContent" id="entElementContentNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <data interface="CharacterData" obj="entElementContent" value="&quot;newData&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element_content
                        .set_data("newData")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // attrcreatetextnode2.xml
            #[test]
            fn test_attrcreatetextnode2() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#address_list; // type: NodeList // <var name="addressList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#street_attr; // type: Attr // <var name="streetAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                r#test_node = r#address_list.item(3).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                r#street_attr.set_node_value("Y&ent1;").unwrap(); // <nodeValue obj="streetAttr" value="&quot;Y&amp;ent1;&quot;"/>
                r#value = r#street_attr.value().to_string(); // <value interface="Attr" obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Y&ent1;"); // <assertEquals actual="value" expected="&quot;Y&amp;ent1;&quot;" id="value" ignoreCase="false"/>
                r#value = r#street_attr.node_value().unwrap().to_string(); // <nodeValue obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Y&ent1;"); // <assertEquals actual="value" expected="&quot;Y&amp;ent1;&quot;" id="nodeValue" ignoreCase="false"/>
            }
            // textsplittextthree.xml
            #[test]
            fn test_textsplittextthree() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;name&quot;"/>
                r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                r#text_node = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="textNode"/>
                let r#split_node = r#text_node.split_text(6).unwrap(); // <splitText obj="textNode" var="splitNode" offset="6"/>
                let r#value = r#split_node.node_value().unwrap().to_string(); // <nodeValue obj="splitNode" var="value"/>
                assert_eq!(r#value, " Jones"); // <assertEquals actual="value" expected="&quot; Jones&quot;" id="textSplitTextThreeAssert" ignoreCase="false"/>
            }
            // documentinvalidcharacterexceptioncreatepi1.xml
            #[test]
            fn test_documentinvalidcharacterexceptioncreatepi1() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#bad_pi; // type: ProcessingInstruction // <var name="badPI" type="ProcessingInstruction"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // unimplemented:
                // <if><contentType type="text/html"/>
                //  <assertDOMException id="throw_NOT_SUPPORTED_ERR">
                //      <NOT_SUPPORTED_ERR>
                //          <createProcessingInstruction var="badPI" obj="doc" target="&quot;foo&quot;" data="&quot;data&quot;"/>
                //      </NOT_SUPPORTED_ERR>
                //  </assertDOMException>
                // <else>
                //  <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //      <INVALID_CHARACTER_ERR>
                //          <createProcessingInstruction var="badPI" obj="doc" target="&quot;&quot;" data="&quot;data&quot;"/>
                //      </INVALID_CHARACTER_ERR>
                //  </assertDOMException>
                // </else>
                // </if>
            }
            // nodeappendchilddocfragment.xml
            #[test]
            fn test_nodeappendchilddocfragment() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#newdoc_fragment; // type: DocumentFragment // <var name="newdocFragment" type="DocumentFragment"/>
                let r#new_child1; // type: Node // <var name="newChild1" type="Node"/>
                let r#new_child2; // type: Node // <var name="newChild2" type="Node"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let r#expected = vec![
                    "employeeId",
                    "name",
                    "position",
                    "salary",
                    "gender",
                    "address",
                    "newChild1",
                    "newChild2",
                ]; // type: List // <var name="expected" type="List"><member>"employeeId"</member><member>"name"</member><member>"position"</member><member>"salary"</member><member>"gender"</member><member>"address"</member><member>"newChild1"</member><member>"newChild2"</member></var>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#newdoc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="newdocFragment"/>
                r#new_child1 = r#doc.create_element("newChild1".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild1&quot;" var="newChild1"/>
                r#new_child2 = r#doc.create_element("newChild2".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild2&quot;" var="newChild2"/>
                r#appended_child = r#newdoc_fragment.append_child(new_child1.into()).unwrap(); // <appendChild var="appendedChild" obj="newdocFragment" newChild="newChild1"/>
                r#appended_child = r#newdoc_fragment.append_child(new_child2.into()).unwrap(); // <appendChild var="appendedChild" obj="newdocFragment" newChild="newChild2"/>
                r#appended_child = r#employee_node
                    .append_child(newdoc_fragment.into())
                    .unwrap(); // <appendChild var="appendedChild" obj="employeeNode" newChild="newdocFragment"/>
                // <for-each collection="childList" member="child">
                //  <nodeType var="nodeType" obj="child"/>
                //  <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //      <nodeName var="childName" obj="child"/>
                //      <append collection="result" item="childName"/>
                //  </if>
                // </for-each>
                let len = child_list.length();
                for i in 0..len {
                    child = child_list.item(i).unwrap();
                    node_type = child.node_type();
                    if node_type as i32 == 1 {
                        child_name = child.node_name().to_string();
                        result.push(child_name);
                    }
                }
                assert_eq!(r#result, expected); // <assertEquals actual="result" expected="expected" ignoreCase="false" id="elementNames"/>
            }
            // characterdatareplacedataend.xml
            #[test]
            fn test_characterdatareplacedataend() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.replace_data(30, 5, "98665").unwrap(); // <replaceData obj="child" offset="30" count="5" arg="&quot;98665&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230 North Ave. Dallas, Texas 98665"); // <assertEquals actual="childData" expected="&quot;1230 North Ave. Dallas, Texas 98665&quot;" id="characterdataReplaceDataEndAssert" ignoreCase="false"/>
            }
            // hc_nodegetnextsibling.xml
            #[test]
            fn test_hc_nodegetnextsibling() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;em&quot;" var="elementList"/>
                let r#em_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="emNode"/>
                let r#ns_node = r#em_node.next_sibling().unwrap(); // <nextSibling interface="Node" obj="emNode" var="nsNode"/>
                let r#ns_name = r#ns_node.node_name().to_string(); // <nodeName obj="nsNode" var="nsName"/>
                assert_eq!(r#ns_name, "#text"); // <assertEquals actual="nsName" expected="&quot;#text&quot;" id="whitespace" ignoreCase="false"/>
            }
            // hc_nodeelementnodetype.xml
            #[test]
            fn test_hc_nodeelementnodetype() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                let r#node_type = r#root_node.node_type(); // <nodeType obj="rootNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 1); // <assertEquals actual="nodeType" expected="1" id="nodeElementNodeTypeAssert1" ignoreCase="false"/>
            }
            // textsplittextnomodificationallowederrEE.xml
            #[test]
            fn test_textsplittextnomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                let mut r#ent_text; // type: Node // <var name="entText" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#ent_ref = r#doc.create_entity_reference("ent3".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent3&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                r#ent_text = r#ent_ref.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" var="entText" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entText" id="entTextNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <splitText var="splitNode" obj="entText" offset="2"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_text
                        .split_text(2)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodenotationnodename.xml
            #[test]
            fn test_nodenotationnodename() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#notations = doc_type.notations(); // <notations obj="docType" var="notations"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                let r#notation_node = r#notations.get_named_item("notation1").unwrap(); // <getNamedItem obj="notations" name="&quot;notation1&quot;" var="notationNode"/>
                // unimplemented: // <assertNotNull actual="notationNode" id="notationNotNull"/>
                let r#notation_name = r#notation_node.node_name().to_string(); // <nodeName obj="notationNode" var="notationName"/>
                assert_eq!(r#notation_name, "notation1"); // <assertEquals actual="notationName" expected="&quot;notation1&quot;" id="nodeName" ignoreCase="false"/>
            }
            // hc_attrcreatedocumentfragment.xml
            #[test]
            fn test_hc_attrcreatedocumentfragment() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_fragment; // type: DocumentFragment // <var name="docFragment" type="DocumentFragment"/>
                let mut r#new_one; // type: Element // <var name="newOne" type="Element"/>
                let r#domestic_node; // type: Node // <var name="domesticNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#lang_attr_count = 0; // type: int // <var name="langAttrCount" type="int" value="0"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="docFragment"/>
                r#new_one = r#doc.create_element("html".to_string()).unwrap(); // <createElement obj="doc" var="newOne" tagName="&quot;html&quot;"/>
                r#new_one.set_attribute("lang", "EN").unwrap(); // <setAttribute obj="newOne" name="&quot;lang&quot;" value="&quot;EN&quot;"/>
                r#appended_child = r#doc_fragment.append_child(new_one.into()).unwrap(); // <appendChild var="appendedChild" obj="docFragment" newChild="newOne"/>
                r#domestic_node = r#doc_fragment.first_child().unwrap(); // <firstChild interface="Node" obj="docFragment" var="domesticNode"/>
                r#attributes = r#domestic_node.attributes().unwrap(); // <attributes obj="domesticNode" var="attributes"/>
                // <for-each collection="attributes" member="attribute">
                //  <nodeName var="attrName" obj="attribute"/>
                //  <if><equals expected="&quot;lang&quot;" actual="attrName" ignoreCase="auto" context="attribute"/>
                //      <increment var="langAttrCount" value="1"/>
                //  </if>
                // </for-each>
                for i in 0..attributes.length() {
                    attribute = attributes.item(i).unwrap();
                    attr_name = attribute.node_name().to_string();
                    if attr_name == "lang" {
                        lang_attr_count += 1;
                    }
                }
                assert_eq!(r#lang_attr_count, 1); // <assertEquals expected="1" actual="langAttrCount" id="hasLangAttr" ignoreCase="false"/>
            }
            // nodeattributenodevalue.xml
            #[test]
            fn test_nodeattributenodevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#addr_attr = r#test_addr.get_attribute_node("domestic").unwrap(); // <getAttributeNode obj="testAddr" name="&quot;domestic&quot;" var="addrAttr"/>
                let r#attr_value = r#addr_attr.node_value().unwrap().to_string(); // <nodeValue obj="addrAttr" var="attrValue"/>
                assert_eq!(r#attr_value, "Yes"); // <assertEquals actual="attrValue" expected="&quot;Yes&quot;" id="nodeAttributeNodeValueAssert1" ignoreCase="false"/>
            }
            // nodereplacechildoldchildnonexistent.xml
            #[test]
            fn test_nodereplacechildoldchildnonexistent() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_child = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="newChild"/>
                r#old_child = r#doc.create_element("oldChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;oldChild&quot;" var="oldChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <replaceChild var="replacedNode" obj="elementNode" newChild="newChild" oldChild="oldChild"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .replace_child(new_child.into(), old_child.into())
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // hc_elementgetattributenodenull.xml
            #[test]
            fn test_hc_elementgetattributenodenull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                let r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                let r#domestic_attr = r#test_employee.get_attribute_node("invalidAttribute"); // <getAttributeNode obj="testEmployee" var="domesticAttr" name="&quot;invalidAttribute&quot;"/>
                assert!(domestic_attr.is_none()); // <assertNull actual="domesticAttr" id="elementGetAttributeNodeNullAssert"/>
            }
            // namednodemapreturnlastitem.xml
            #[test]
            fn test_namednodemapreturnlastitem() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="1"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#child = r#attributes.item(1).unwrap(); // <item interface="NamedNodeMap" obj="attributes" var="child" index="1"/>
                let r#name = r#child.node_name().to_string(); // <nodeName obj="child" var="name"/>
                // <assertTrue id="namednodemapReturnLastItemAssert">
                //  <or>
                //      <equals actual="name" expected="&quot;domestic&quot;" ignoreCase="false"/>
                //      <equals actual="name" expected="&quot;street&quot;" ignoreCase="false"/>
                //  </or>
                // </assertTrue>
                assert!(name == "domestic" || name == "street")
            }
            // hc_attrremovechild1.xml
            #[test]
            fn test_hc_attrremovechild1() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                let r#text_node = r#title_attr.first_child().unwrap(); // <firstChild var="textNode" obj="titleAttr" interface="Node"/>
                // unimplemented: // <assertNotNull actual="textNode" id="attrChildNotNull"/>
                let r#retval = r#title_attr.remove_child(text_node).unwrap(); // <removeChild var="retval" obj="titleAttr" oldChild="textNode"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, ""); // <assertEquals actual="value" expected="&quot;&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, ""); // <assertEquals actual="value" expected="&quot;&quot;" id="attrNodeValue" ignoreCase="false"/>
                r#value = r#retval.node_value().unwrap().to_string(); // <nodeValue obj="retval" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="retvalValue" ignoreCase="false"/>
                let r#first_child = r#title_attr.first_child(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                assert!(first_child.is_none()); // <assertNull actual="firstChild" id="firstChildNull"/>
            }
            // hc_elementreplaceexistingattributegevalue.xml
            #[test]
            fn test_hc_elementreplaceexistingattributegevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                let r#new_attribute = r#doc.create_attribute("class".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;class&quot;"/>
                let r#street_attr = r#test_employee
                    .set_attribute_node(r#new_attribute)
                    .unwrap()
                    .unwrap(); // <setAttributeNode obj="testEmployee" var="streetAttr" newAttr="newAttribute"/>
                // unimplemented: // <assertNotNull actual="streetAttr" id="previousAttrNotNull"/>
                let r#value = r#street_attr.value().to_string(); // <value interface="Attr" obj="streetAttr" var="value"/>
                assert_eq!(r#value, "No"); // <assertEquals actual="value" expected="&quot;No&quot;" id="previousAttrValue" ignoreCase="false"/>
            }
            // nodeinsertbeforerefchildnonexistent.xml
            #[test]
            fn test_nodeinsertbeforerefchildnonexistent() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_child = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="newChild"/>
                r#ref_child = r#doc.create_element("refChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;refChild&quot;" var="refChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <insertBefore var="insertedNode" obj="elementNode" newChild="newChild" refChild="refChild"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .insert_before(new_child.into(), Some(ref_child.into()))
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // hc_entitiesremovenameditem1.xml
            #[test]
            fn test_hc_entitiesremovenameditem1() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented:
                // // <if><not><contentType type="text/html"/></not>
                // //  <assertNotNull actual="docType" id="docTypeNotNull"/>
                // //  <entities var="entities" obj="docType"/>
                // //  <assertNotNull actual="entities" id="entitiesNotNull"/>
                // //  <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                // //      <NO_MODIFICATION_ALLOWED_ERR>
                // //          <removeNamedItem var="retval" obj="entities" name="&quot;alpha&quot;"/>
                // //      </NO_MODIFICATION_ALLOWED_ERR>
                // //  </assertDOMException>
                // // </if>
            }
            // hc_namednodemapgetnameditem.xml
            #[test]
            fn test_hc_namednodemapgetnameditem() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                let r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="1"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;title&quot;"/>
                let r#attr_name = r#domestic_attr.node_name().to_string(); // <nodeName obj="domesticAttr" var="attrName"/>
                assert_eq!(r#attr_name, "title"); // <assertEquals actual="attrName" expected="&quot;title&quot;" id="nodeName" ignoreCase="auto" context="attribute"/>
            }
            // hc_nodeinsertbeforenewchildexists.xml
            #[test]
            fn test_hc_nodeinsertbeforenewchildexists() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#inserted_node; // type: Node // <var name="insertedNode" type="Node"/>
                let r#expected = vec!["strong", "code", "sup", "var", "em", "acronym"]; // type: List // <var name="expected" type="List"><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"em"</member><member>"acronym"</member></var>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.get_elements_by_tag_name("*"); // <getElementsByTagName interface="Element" obj="employeeNode" tagname="&quot;*&quot;" var="childList"/>
                r#ref_child = r#child_list.item(5).unwrap(); // <item interface="NodeList" obj="childList" index="5" var="refChild"/>
                r#new_child = r#child_list.item(0).unwrap(); // <item interface="NodeList" obj="childList" index="0" var="newChild"/>
                r#inserted_node = r#employee_node
                    .insert_before(new_child.into(), Some(ref_child.into()))
                    .unwrap(); // <insertBefore var="insertedNode" obj="employeeNode" newChild="newChild" refChild="refChild"/>
                // <for-each collection="childList" member="child">
                //  <nodeType obj="child" var="nodeType"/>
                //  <if><equals actual="nodeType" expected="1"/>
                //      <nodeName obj="child" var="childName"/>
                //      <append collection="result" item="childName"/>
                //  </if>
                // </for-each>
                for i in 0..child_list.length() {
                    let child = child_list.item(i).unwrap();
                    node_type = child.node_type();
                    if node_type as i32 == 1 {
                        child_name = child.node_name().to_string();
                        result.push(child_name);
                    }
                }
                assert_eq!(r#result, expected); // <assertEquals id="childNames" actual="result" expected="expected" ignoreCase="auto"/>
            }
            // hc_nodeattributenodeattribute.xml
            #[test]
            fn test_hc_nodeattributenodeattribute() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#addr_attr = r#test_addr.attributes(); // <attributes obj="testAddr" var="addrAttr"/>
                let r#attr_node = r#addr_attr.item(0).unwrap(); // <item interface="NamedNodeMap" obj="addrAttr" var="attrNode" index="0"/>
                let r#attr_list = r#attr_node.attributes(); // <attributes obj="attrNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="nodeAttributeNodeAttributeAssert1"/>
            }
            // hc_nodeclonenodefalse.xml
            #[test]
            fn test_hc_nodeclonenodefalse() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#cloned_node = r#employee_node.clone_node(false); // <cloneNode obj="employeeNode" deep="false" var="clonedNode"/>
                let r#clone_name = r#cloned_node.node_name().to_string(); // <nodeName obj="clonedNode" var="cloneName"/>
                assert_eq!(r#clone_name, "p"); // <assertEquals actual="cloneName" expected="&quot;p&quot;" ignoreCase="auto" id="strong"/>
                let r#clone_children = r#cloned_node.child_nodes(); // <childNodes obj="clonedNode" var="cloneChildren"/>
                let r#length = r#clone_children.length(); // <length interface="NodeList" obj="cloneChildren" var="length"/>
                assert_eq!(r#length, 0); // <assertEquals actual="length" expected="0" ignoreCase="false" id="length"/>
            }
            // nodeentitynodevalue.xml
            #[test]
            fn test_nodeentitynodevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#entities = doc_type.entities(); // <entities obj="docType" var="entities"/>
                // unimplemented: // <assertNotNull actual="entities" id="entitiesNotNull"/>
                let r#entity_node = r#entities.get_named_item("ent1").unwrap(); // <getNamedItem obj="entities" name="&quot;ent1&quot;" var="entityNode"/>
                // unimplemented: // <assertNotNull actual="entityNode" id="ent1NotNull"/>
                let r#entity_value = r#entity_node.node_value(); // <nodeValue obj="entityNode" var="entityValue"/>
                assert!(entity_value.is_none()); // <assertNull actual="entityValue" id="entityNodeValue"/>
            }
            // elementsetattributenodenull.xml
            #[test]
            fn test_elementsetattributenodenull() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                let r#new_attribute = r#doc.create_attribute("district".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;district&quot;"/>
                let r#district_attr = r#test_employee.set_attribute_node(r#new_attribute).unwrap(); // <setAttributeNode obj="testEmployee" var="districtAttr" newAttr="newAttribute"/>
                assert!(district_attr.is_none()); // <assertNull actual="districtAttr" id="elementSetAttributeNodeNullAssert"/>
            }
            // nodeentityreferencenodename.xml
            #[test]
            fn test_nodeentityreferencenodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#ent_ref_addr; // type: Element // <var name="entRefAddr" type="Element"/>
                let mut r#ent_ref_node; // type: Node // <var name="entRefNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#ent_ref_addr = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="entRefAddr"/>
                r#ent_ref_node = r#ent_ref_addr.first_child().unwrap(); // <firstChild interface="Node" obj="entRefAddr" var="entRefNode"/>
                let r#node_type = r#ent_ref_node.node_type(); // <nodeType var="nodeType" obj="entRefNode"/>
                // <if><notEquals actual="nodeType" expected="5" ignoreCase="false"/>
                //  <createEntityReference var="entRefNode" obj="doc" name="&quot;ent2&quot;"/>
                //  <assertNotNull actual="entRefNode" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 5 {
                    ent_ref_node = doc.create_entity_reference("ent2").unwrap().into();
                }
                let r#ent_ref_name = r#ent_ref_node.node_name().to_string(); // <nodeName obj="entRefNode" var="entRefName"/>
                assert_eq!(r#ent_ref_name, "ent2"); // <assertEquals actual="entRefName" expected="&quot;ent2&quot;" id="nodeEntityReferenceNodeNameAssert1" ignoreCase="false"/>
            }
            // nodeparentnode.xml
            #[test]
            fn test_nodeparentnode() {
                let mut r#parent_name; // type: DOMString // <var name="parentName" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#parent_node = r#employee_node.parent_node().unwrap(); // <parentNode interface="Node" obj="employeeNode" var="parentNode"/>
                r#parent_name = r#parent_node.node_name().to_string(); // <nodeName obj="parentNode" var="parentName"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //  <assertEquals actual="parentName" expected="&quot;svg&quot;" id="svgTagName" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="parentName" expected="&quot;staff&quot;" id="nodeParentNodeAssert1" ignoreCase="false"/>
                // </else>
                // </if>
            }
            // hc_documentgetimplementation.xml
            #[test]
            fn test_hc_documentgetimplementation() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_impl; // type: DOMImplementation // <var name="docImpl" type="DOMImplementation"/>
                // let mut r#xmlstate; // type: boolean // <var name="xmlstate" type="boolean"/>
                // let mut r#htmlstate; // type: boolean // <var name="htmlstate" type="boolean"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="docImpl"/>

                // // unimplemented: // <hasFeature obj="docImpl" var="xmlstate" feature="&quot;XML&quot;" version="&quot;1.0&quot;"/>

                // // unimplemented: // <hasFeature obj="docImpl" var="htmlstate" feature="&quot;HTML&quot;" version="&quot;1.0&quot;"/>

                // // unimplemented: // <if><contentType type="text/html"/><assertTrue actual="htmlstate" id="supports_HTML_1.0"/><else><assertTrue actual="xmlstate" id="supports_XML_1.0"/></else></if>
            }
            // documentcreateelementcasesensitive.xml
            #[test]
            fn test_documentcreateelementcasesensitive() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_element1; // type: Element // <var name="newElement1" type="Element"/>
                let mut r#new_element2; // type: Element // <var name="newElement2" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_element1 = r#doc.create_element("ADDRESS".to_string()).unwrap(); // <createElement obj="doc" var="newElement1" tagName="&quot;ADDRESS&quot;"/>
                r#new_element2 = r#doc.create_element("address".to_string()).unwrap(); // <createElement obj="doc" var="newElement2" tagName="&quot;address&quot;"/>
                r#new_element1
                    .set_attribute("district", "Fort Worth")
                    .unwrap(); // <setAttribute obj="newElement1" name="&quot;district&quot;" value="&quot;Fort Worth&quot;"/>
                r#new_element2.set_attribute("county", "Dallas").unwrap(); // <setAttribute obj="newElement2" name="&quot;county&quot;" value="&quot;Dallas&quot;"/>
                let r#attribute1 = r#new_element1.get_attribute("district"); // <getAttribute obj="newElement1" var="attribute1" name="&quot;district&quot;"/>
                let r#attribute2 = r#new_element2.get_attribute("county"); // <getAttribute obj="newElement2" var="attribute2" name="&quot;county&quot;"/>
                assert_eq!(r#attribute1, "Fort Worth"); // <assertEquals actual="attribute1" expected="&quot;Fort Worth&quot;" ignoreCase="false" id="attrib1"/>
                assert_eq!(r#attribute2, "Dallas"); // <assertEquals actual="attribute2" expected="&quot;Dallas&quot;" ignoreCase="false" id="attrib2"/>
            }
            // hc_nodetextnodevalue.xml
            #[test]
            fn test_hc_nodetextnodevalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#text_node = r#test_addr.first_child().unwrap(); // <firstChild interface="Node" obj="testAddr" var="textNode"/>
                let r#text_value = r#text_node.node_value().unwrap().to_string(); // <nodeValue obj="textNode" var="textValue"/>
                assert_eq!(r#text_value, "1230 North Ave. Dallas, Texas 98551"); // <assertEquals actual="textValue" expected="&quot;1230 North Ave. Dallas, Texas 98551&quot;" id="textNodeValue" ignoreCase="false"/>
            }
            // characterdatagetlength.xml
            #[test]
            fn test_characterdatagetlength() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                let r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                let r#child_value = r#child.data().to_string(); // <data var="childValue" obj="child" interface="CharacterData"/>
                let r#child_length = r#child_value.len(); // <length var="childLength" obj="childValue" interface="DOMString"/>
                assert_eq!(r#child_length, 15); // <assertEquals actual="childLength" expected="15" ignoreCase="false" id="characterdataGetLengthAssert"/>
            }
            // hc_nodeclonegetparentnull.xml
            #[test]
            fn test_hc_nodeclonegetparentnull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#cloned_node = r#employee_node.clone_node(false); // <cloneNode obj="employeeNode" deep="false" var="clonedNode"/>
                let r#parent_node = r#cloned_node.parent_node(); // <parentNode interface="Node" obj="clonedNode" var="parentNode"/>
                assert!(parent_node.is_none()); // <assertNull actual="parentNode" id="nodeCloneGetParentNullAssert1"/>
            }
            // nodeentitynodename.xml
            #[test]
            fn test_nodeentitynodename() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#entities = doc_type.entities(); // <entities obj="docType" var="entities"/>
                // unimplemented: // <assertNotNull actual="entities" id="entitiesNotNull"/>
                let r#entity_node = r#entities.get_named_item("ent1").unwrap(); // <getNamedItem obj="entities" name="&quot;ent1&quot;" var="entityNode"/>
                // unimplemented: // <assertNotNull actual="entityNode" id="entityNodeNotNull"/>
                let r#entity_name = r#entity_node.node_name().to_string(); // <nodeName obj="entityNode" var="entityName"/>
                assert_eq!(r#entity_name, "ent1"); // <assertEquals actual="entityName" expected="&quot;ent1&quot;" id="entityNodeName" ignoreCase="false"/>
            }
            // characterdatadeletedatanomodificationallowederr.xml
            #[test]
            fn test_characterdatadeletedatanomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let r#ent_element; // type: Node // <var name="entElement" type="Node"/>
                let mut r#ent_element_content; // type: Node // <var name="entElementContent" type="Node"/>
                let mut r#ent_reference; // type: Node // <var name="entReference" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" index="2" var="genderNode"/>
                r#ent_reference = r#gender_node.first_child().unwrap(); // <firstChild var="entReference" obj="genderNode" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entReference" id="entReferenceNotNull"/>
                let r#node_type = r#ent_reference.node_type(); // <nodeType var="nodeType" obj="entReference"/>
                // <if><equals actual="nodeType" expected="3"/>
                //  <createEntityReference var="entReference" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="entReference" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 3 {
                    ent_reference = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#ent_element = r#ent_reference.first_child().unwrap(); // <firstChild var="entElement" obj="entReference" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#ent_element_content =
                    r#ent_element.first_child().unwrap().as_text_node().unwrap(); // <firstChild var="entElementContent" obj="entElement" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElementContent" id="entElementContentNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <deleteData obj="entElementContent" offset="1" count="3"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element_content
                        .delete_data(1, 3)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodegetnextsiblingnull.xml
            #[test]
            fn test_nodegetnextsiblingnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#lc_node = r#employee_node.last_child().unwrap(); // <lastChild interface="Node" obj="employeeNode" var="lcNode"/>
                let r#ns_node = r#lc_node.next_sibling(); // <nextSibling interface="Node" obj="lcNode" var="nsNode"/>
                assert!(ns_node.is_none()); // <assertNull actual="nsNode" id="nodeGetNextSiblingNullAssert1"/>
            }
            // hc_domimplementationfeaturenoversion.xml
            #[test]
            fn test_hc_domimplementationfeaturenoversion() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <if><contentType type="text/html"/><hasFeature obj="domImpl" var="state" feature="&quot;HTML&quot;" version="&quot;&quot;"/><else><hasFeature obj="domImpl" var="state" feature="&quot;XML&quot;" version="&quot;&quot;"/></else></if>
                // assert!(r#state); // <assertTrue actual="state" id="hasFeatureBlank"/>
            }
            // elementaddnewattribute.xml
            #[test]
            fn test_elementaddnewattribute() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(4).unwrap(); // <item interface="NodeList" obj="elementList" index="4" var="testEmployee"/>
                r#test_employee.set_attribute("district", "dallas").unwrap(); // <setAttribute obj="testEmployee" name="&quot;district&quot;" value="&quot;dallas&quot;"/>
                let r#attr_value = r#test_employee.get_attribute("district"); // <getAttribute obj="testEmployee" var="attrValue" name="&quot;district&quot;"/>
                assert_eq!(r#attr_value, "dallas"); // <assertEquals actual="attrValue" expected="&quot;dallas&quot;" id="elementAddNewAttributeAssert" ignoreCase="false"/>
            }
            // hc_attrspecifiedvaluechanged.xml
            #[test]
            fn test_hc_attrspecifiedvaluechanged() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#address_list; // type: NodeList // <var name="addressList" type="NodeList"/>
                let mut r#test_node; // type: Node // <var name="testNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#address_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#address_list.item(2).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="2"/>
                r#test_node.set_attribute("class", "Y").unwrap(); // <setAttribute obj="testNode" name="&quot;class&quot;" value="&quot;Y&quot;"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#street_attr = r#attributes.get_named_item("class").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;class&quot;"/>
                let r#state = r#street_attr.specified(); // <specified obj="streetAttr" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="acronymClassSpecified"/>
            }
            // hc_characterdatareplacedataend.xml
            #[test]
            fn test_hc_characterdatareplacedataend() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.replace_data(30, 5, "98665").unwrap(); // <replaceData obj="child" offset="30" count="5" arg="&quot;98665&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230 North Ave. Dallas, Texas 98665"); // <assertEquals actual="childData" expected="&quot;1230 North Ave. Dallas, Texas 98665&quot;" id="characterdataReplaceDataEndAssert" ignoreCase="false"/>
            }
            // hc_characterdatadeletedatagetlengthanddata.xml
            #[test]
            fn test_hc_characterdatadeletedatagetlengthanddata() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.delete_data(30, 5).unwrap(); // <deleteData obj="child" offset="30" count="5"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230 North Ave. Dallas, Texas "); // <assertEquals actual="childData" expected="&quot;1230 North Ave. Dallas, Texas &quot;" ignoreCase="false" id="data"/>
                let r#child_length = r#child.length(); // <length interface="CharacterData" obj="child" var="childLength"/>
                assert_eq!(r#child_length, 30); // <assertEquals actual="childLength" expected="30" ignoreCase="false" id="length"/>
            }
            // attrsetvaluenomodificationallowederr.xml
            #[test]
            fn test_attrsetvaluenomodificationallowederr() {
                // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender; // type: Node // <var name="gender" type="Node"/>
                let r#gen_list; // type: NodeList // <var name="genList" type="NodeList"/>
                let r#gen; // type: Node // <var name="gen" type="Node"/>
                let r#g_list; // type: NodeList // <var name="gList" type="NodeList"/>
                let r#g; // type: Node // <var name="g" type="Node"/>
                let r#attr_list; // type: NamedNodeMap // <var name="attrList" type="NamedNodeMap"/>
                let mut r#attr_node; // type: Attr // <var name="attrNode" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                // unimplemented: // <assertNotNull actual="gender" id="genderNotNull"/>
                r#gen_list = r#gender.child_nodes(); // <childNodes obj="gender" var="genList"/>
                r#gen = r#gen_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="genList" var="gen" index="0"/>
                // unimplemented: // <assertNotNull actual="gen" id="genderFirstChildNotNull"/>
                r#g_list = r#gen.child_nodes(); // <childNodes obj="gen" var="gList"/>
                r#g = r#g_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="gList" var="g" index="0"/>
                // unimplemented: // <assertNotNull actual="g" id="genderFirstGrandchildNotNull"/>
                r#attr_list = r#g.attributes().unwrap(); // <attributes obj="g" var="attrList"/>
                // unimplemented: // <assertNotNull actual="attrList" id="attributesNotNull"/>
                r#attr_node = r#attr_list.get_named_item("domestic").unwrap(); // <getNamedItem obj="attrList" var="attrNode" name="&quot;domestic&quot;"/>
                // unimplemented: // <assertNotNull actual="attrNode" id="attrNotNull"/>
                // <assertDOMException id="setValue_throws_NO_MODIFICATION">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <value interface="Attr" obj="attrNode" value="&quot;newvalue&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    attr_node
                        .set_value("newValue")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
                // <assertDOMException id="setNodeValue_throws_NO_MODIFICATION">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <nodeValue interface="Node" obj="attrNode" value="&quot;newvalue2&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    attr_node
                        .set_node_value("newValue")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // textindexsizeerroffsetoutofbounds.xml
            #[test]
            fn test_textindexsizeerroffsetoutofbounds() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;name&quot;"/>
                r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                r#text_node = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="textNode"/>
                // <assertDOMException id="throw_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <splitText obj="textNode" var="splitNode" offset="300"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
                assert!(
                    text_node
                        .split_text(300)
                        .is_err_and(|err| err == DOMException::IndexSizeErr)
                );
            }
            // elementwrongdocumenterr.xml
            #[test]
            fn test_elementwrongdocumenterr() {
                let r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#address_element_list; // type: NodeList // <var name="addressElementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                r#doc1 = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc1" href="staff" willBeModified="true"/>
                r#doc2 = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc2" href="staff" willBeModified="false"/>
                r#new_attribute = r#doc2.create_attribute("newAttribute".to_string()).unwrap(); // <createAttribute obj="doc2" var="newAttribute" name="&quot;newAttribute&quot;"/>
                r#address_element_list = r#doc1.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc1" tagname="&quot;address&quot;" var="addressElementList"/>
                r#test_address = r#address_element_list.item(4).unwrap(); // <item interface="NodeList" obj="addressElementList" index="4" var="testAddress"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <setAttributeNode obj="testAddress" newAttr="newAttribute" var="attrAddress"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    test_address
                        .set_attribute_node(new_attribute)
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // documentcreateentityreference.xml
            #[test]
            fn test_documentcreateentityreference() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#new_ent_ref_node = r#doc.create_entity_reference("ent1".to_string()).unwrap(); // <createEntityReference obj="doc" var="newEntRefNode" name="&quot;ent1&quot;"/>
                // unimplemented: // <assertNotNull actual="newEntRefNode" id="createdEntRefNotNull"/>
                let r#ent_ref_value = r#new_ent_ref_node.node_value(); // <nodeValue obj="newEntRefNode" var="entRefValue"/>
                assert!(ent_ref_value.is_none()); // <assertNull actual="entRefValue" id="value"/>
                let r#ent_ref_name = r#new_ent_ref_node.node_name().to_string(); // <nodeName obj="newEntRefNode" var="entRefName"/>
                assert_eq!(r#ent_ref_name, "ent1"); // <assertEquals actual="entRefName" expected="&quot;ent1&quot;" ignoreCase="false" id="name"/>
                let r#ent_ref_type = r#new_ent_ref_node.node_type(); // <nodeType obj="newEntRefNode" var="entRefType"/>
                assert_eq!(r#ent_ref_type as i32, 5); // <assertEquals actual="entRefType" expected="5" ignoreCase="false" id="type"/>
            }
            // nodeinsertbeforeinvalidnodetype.xml
            #[test]
            fn test_nodeinsertbeforeinvalidnodetype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Element // <var name="rootNode" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                let r#new_child = r#doc.create_attribute("newAttribute".to_string()).unwrap(); // <createAttribute obj="doc" name="&quot;newAttribute&quot;" var="newChild"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#ref_child = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="refChild"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <insertBefore var="insertedNode" obj="rootNode" newChild="newChild" refChild="refChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    root_node
                        .insert_before(new_child.into(), Some(ref_child.into()))
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // elementsetattributenomodificationallowederr.xml
            #[test]
            fn test_elementsetattributenomodificationallowederr() {
                // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender; // type: Node // <var name="gender" type="Node"/>
                let r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                assert_eq!(gender.node_type(), NodeType::Element);
                assert_eq!(gender.node_name().as_ref(), "gender");
                r#ent_ref = r#gender.first_child().unwrap(); // <firstChild interface="Node" var="entRef" obj="gender"/>
                assert_eq!(gender.last_child().unwrap().node_name().as_ref(), "ent4");
                assert_eq!(ent_ref.node_name().as_ref(), "ent4");
                assert_eq!(ent_ref.node_type(), NodeType::EntityReference);
                // unimplemented: // <assertNotNull actual="entRef" id="entRefNotNull"/>
                r#ent_element = r#ent_ref.first_child().unwrap().as_element().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <setAttribute obj="entElement" name="&quot;newAttr&quot;" value="&quot;newValue&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element
                        .set_attribute("newAttr", "newValue")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_nodegetfirstchild.xml
            #[test]
            fn test_hc_nodegetfirstchild() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#fchild_node = r#employee_node.first_child().unwrap(); // <firstChild interface="Node" obj="employeeNode" var="fchildNode"/>
                let r#child_name = r#fchild_node.node_name().to_string(); // <nodeName obj="fchildNode" var="childName"/>
                // <if><equals expected="&quot;#text&quot;" actual="childName"/>
                //  <assertEquals actual="childName" expected="&quot;#text&quot;" id="firstChild_w_whitespace" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="childName" expected="&quot;em&quot;" id="firstChild_wo_whitespace" ignoreCase="auto"/>
                // </else>
                // </if>
                if child_name == "#text" {
                    assert_eq!(child_name, "#text");
                } else {
                    assert_eq!(child_name, "em");
                }
            }
            // documentcreatetextnode.xml
            #[test]
            fn test_documentcreatetextnode() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#new_text_node = r#doc.create_text_node("This is a new Text node"); // <createTextNode obj="doc" var="newTextNode" data="&quot;This is a new Text node&quot;"/>
                let r#new_text_value = r#new_text_node.node_value().unwrap().to_string(); // <nodeValue obj="newTextNode" var="newTextValue"/>
                assert_eq!(r#new_text_value, "This is a new Text node"); // <assertEquals actual="newTextValue" expected="&quot;This is a new Text node&quot;" ignoreCase="false" id="value"/>
                let r#new_text_name = r#new_text_node.node_name().to_string(); // <nodeName obj="newTextNode" var="newTextName"/>
                assert_eq!(r#new_text_name, "#text"); // <assertEquals actual="newTextName" expected="&quot;#text&quot;" ignoreCase="false" id="name"/>
                let r#new_text_type = r#new_text_node.node_type(); // <nodeType obj="newTextNode" var="newTextType"/>
                assert_eq!(r#new_text_type as i32, 3); // <assertEquals actual="newTextType" expected="3" ignoreCase="false" id="type"/>
            }
            // hc_nodereplacechildinvalidnodetype.xml
            #[test]
            fn test_hc_nodereplacechildinvalidnodetype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Element // <var name="rootNode" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#new_child = r#doc.create_attribute("lang".to_string()).unwrap(); // <createAttribute obj="doc" name="&quot;lang&quot;" var="newChild"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#old_child = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="oldChild"/>
                r#root_node = r#old_child.parent_node().unwrap(); // <parentNode var="rootNode" obj="oldChild" interface="Node"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <replaceChild var="replacedChild" obj="rootNode" newChild="newChild" oldChild="oldChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    root_node
                        .replace_child(new_child.into(), old_child.into())
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // nodeinsertbeforenomodificationallowederr.xml
            #[test]
            fn test_nodeinsertbeforenomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                let mut r#ent_element; // type: Node // <var name="entElement" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item obj="genderList" index="2" var="genderNode" interface="NodeList"/>
                r#ent_ref = r#gender_node.first_child().unwrap(); // <firstChild interface="Node" var="entRef" obj="genderNode"/>
                // unimplemented: // <assertNotNull actual="entRef" id="entRefNotNull"/>
                let r#node_type = r#ent_ref.node_type(); // <nodeType var="nodeType" obj="entRef"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    ent_ref = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#ent_element = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                let r#created_node = r#doc.create_element("text3".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;text3&quot;" var="createdNode"/>
                // <assertDOMException id="throw_NOT_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <insertBefore var="insertedNode" obj="entElement" newChild="createdNode" refChild="refChild"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element
                        .insert_before(created_node.into(), None)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_nodegetprevioussiblingnull.xml
            #[test]
            fn test_hc_nodegetprevioussiblingnull() {
                // <var name="doc" type="Document"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="employeeNode"/>
                let r#fc_node = r#employee_node.first_child().unwrap(); // <firstChild interface="Node" obj="employeeNode" var="fcNode"/>
                let r#ps_node = r#fc_node.previous_sibling(); // <previousSibling interface="Node" obj="fcNode" var="psNode"/>
                assert!(ps_node.is_none()); // <assertNull actual="psNode" id="nodeGetPreviousSiblingNullAssert1"/>
            }
            // nodeprocessinginstructionnodename.xml
            #[test]
            fn test_nodeprocessinginstructionnodename() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#test_list = r#doc.child_nodes(); // <childNodes obj="doc" var="testList"/>
                let r#pi_node = r#test_list
                    .item(0)
                    .unwrap()
                    .clone()
                    .as_processing_instruction()
                    .unwrap(); // <item interface="NodeList" obj="testList" index="0" var="piNode"/>
                let r#pi_name = r#pi_node.node_name().to_string(); // <nodeName obj="piNode" var="piName"/>
                assert_eq!(r#pi_name, "TEST-STYLE"); // <assertEquals actual="piName" expected="&quot;TEST-STYLE&quot;" id="nodeProcessingInstructionNodeNameAssert1" ignoreCase="false"/>
            }
            // nodelistreturnlastitem.xml
            #[test]
            fn test_nodelistreturnlastitem() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#employee_list; // type: NodeList // <var name="employeeList" type="NodeList"/>
                let r#child; // type: Node // <var name="child" type="Node"/>
                let r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#length = r#employee_list.length(); // <length var="length" obj="employeeList" interface="NodeList"/>
                // <if><equals actual="length" expected="6" ignoreCase="false"/>
                //  <item interface="NodeList" obj="employeeList" var="child" index="5"/>
                //  <nodeName obj="child" var="childName"/>
                //  <assertEquals actual="childName" expected="&quot;address&quot;" id="nodeName1" ignoreCase="false"/>
                // <else>
                //  <item interface="NodeList" obj="employeeList" var="child" index="12"/>
                //  <nodeName obj="child" var="childName"/>
                //  <assertEquals actual="childName" expected="&quot;#text&quot;" id="nodeName2" ignoreCase="false"/>
                // </else>
                // </if>
                if length == 6 {
                    child = employee_list.item(5).unwrap();
                    child_name = child.node_name().to_string();
                    assert_eq!(child_name, "address");
                } else {
                    child = employee_list.item(12).unwrap();
                    child_name = child.node_name().to_string();
                    assert_eq!(child_name, "#text");
                }
            }
            // hc_attrappendchild4.xml
            #[test]
            fn test_hc_attrappendchild4() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                // let mut r#test_node; // type: Node // <var name="testNode" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                // let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                // let mut r#text_node; // type: Node // <var name="textNode" type="Node"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#last_child; // type: Node // <var name="lastChild" type="Node"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                // r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                // r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                // r#title_attr = r#attributes.get_named_item("title").unwrap();
                // // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>

                // unimplemented:
                // <if><contentType type="text/html"/>
                //  <assertDOMException id="throw_NOT_SUPPORTED_ERR">
                //      <NOT_SUPPORTED_ERR>
                //          <createCDATASection var="textNode" obj="doc" data="&quot;terday&quot;"/>
                //      </NOT_SUPPORTED_ERR>
                //  </assertDOMException>
                // <else>
                //  <createCDATASection var="textNode" obj="doc" data="&quot;terday&quot;"/>
                //  <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //      <HIERARCHY_REQUEST_ERR>
                //          <appendChild var="retval" obj="titleAttr" newChild="textNode"/>
                //      </HIERARCHY_REQUEST_ERR>
                //  </assertDOMException>
                // </else>
                // </if>
            }
            // nodeinsertbeforenomodificationallowederrEE.xml
            #[test]
            fn test_nodeinsertbeforenomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                let r#created_node = r#doc.create_element("text3".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;text3&quot;" var="createdNode"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <insertBefore var="insertedNode" obj="entRef" newChild="createdNode" refChild="refChild"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_ref
                        .insert_before(created_node.into(), None)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_attrhaschildnodes.xml
            #[test]
            fn test_hc_attrhaschildnodes() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                let r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                let r#has_child_nodes = r#title_attr.has_child_nodes(); // <hasChildNodes var="hasChildNodes" obj="titleAttr"/>
                assert!(r#has_child_nodes); // <assertTrue actual="hasChildNodes" id="hasChildrenIsTrue"/>
            }
            // nodevalue02.xml
            #[test]
            fn test_nodevalue02() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                let mut r#new_value; // type: DOMString // <var name="newValue" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_node = r#doc.create_comment("This is a new Comment node"); // <createComment obj="doc" var="newNode" data="&quot;This is a new Comment node&quot;"/>
                r#new_value = r#new_node.node_value().unwrap().to_string(); // <nodeValue obj="newNode" var="newValue"/>
                assert_eq!(r#new_value, "This is a new Comment node"); // <assertEquals actual="newValue" expected="&quot;This is a new Comment node&quot;" ignoreCase="false" id="initial"/>
                r#new_node
                    .set_node_value("This should have an effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have an effect&quot;"/>
                r#new_value = r#new_node.node_value().unwrap().to_string(); // <nodeValue obj="newNode" var="newValue"/>
                assert_eq!(r#new_value, "This should have an effect"); // <assertEquals actual="newValue" expected="&quot;This should have an effect&quot;" id="afterChange" ignoreCase="false"/>
            }
            // hc_attrappendchild5.xml
            #[test]
            fn test_hc_attrappendchild5() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let r#text_node; // type: Node // <var name="textNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#other_doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="otherDoc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#text_node = r#other_doc.create_text_node("terday"); // <createTextNode var="textNode" obj="otherDoc" data="&quot;terday&quot;"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <appendChild var="retval" obj="titleAttr" newChild="textNode"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    title_attr
                        .append_child(text_node.into())
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // characterdataindexsizeerrreplacedataoffsetnegative.xml
            #[test]
            fn test_characterdataindexsizeerrreplacedataoffsetnegative() {
                // unimplemented: // <implementationAttribute name="signed" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // unimplemented:
                // <assertDOMException id="throws_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <replaceData obj="child" offset="-5" count="3" arg="&quot;ABC&quot;"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
            }
            // namednodemapremovenameditemreturnnodevalue.xml
            #[test]
            fn test_namednodemapremovenameditemreturnnodevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                let r#removed_node = r#attributes.remove_named_item("street").unwrap(); // <removeNamedItem interface="NamedNodeMap" obj="attributes" var="removedNode" name="&quot;street&quot;"/>
                let r#value = r#removed_node.node_value().unwrap().to_string(); // <nodeValue obj="removedNode" var="value"/>
                assert_eq!(r#value, "No"); // <assertEquals actual="value" expected="&quot;No&quot;" id="namednodemapRemoveNamedItemReturnNodeValueAssert" ignoreCase="false"/>
            }
            // hc_nodevalue08.xml
            #[test]
            fn test_hc_nodevalue08() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // let mut r#new_value; // type: DOMString // <var name="newValue" type="DOMString"/>
                // let mut r#node_map; // type: NamedNodeMap // <var name="nodeMap" type="NamedNodeMap"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>

                // unimplemented:
                // <if><not><contentType type="text/html"/></not>
                //  <assertNotNull actual="docType" id="docTypeNotNull"/>
                //  <notations obj="docType" var="nodeMap"/>
                //  <assertNotNull actual="nodeMap" id="notationsNotNull"/>
                //  <getNamedItem obj="nodeMap" name="&quot;notation1&quot;" var="newNode"/>
                //  <assertNotNull actual="newNode" id="notationNotNull"/>
                //  <nodeValue obj="newNode" var="newValue"/>
                //  <assertNull actual="newValue" id="initiallyNull"/>
                //  <!--   attempt to change the value and make sure that it stays null  -->
                //  <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                //  <nodeValue obj="newNode" var="newValue"/>
                //  <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
                // </if>
            }
            // nodeentitynodeattributes.xml
            #[test]
            fn test_nodeentitynodeattributes() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#entities = doc_type.entities(); // <entities obj="docType" var="entities"/>
                // unimplemented: // <assertNotNull actual="entities" id="entitiesNotNull"/>
                let r#entity_node = r#entities.get_named_item("ent1").unwrap(); // <getNamedItem obj="entities" name="&quot;ent1&quot;" var="entityNode"/>
                // unimplemented: // <assertNotNull actual="entityNode" id="ent1NotNull"/>
                let r#attr_list = r#entity_node.attributes(); // <attributes obj="entityNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="entityAttributesNull"/>
            }
            // elementassociatedattribute.xml
            #[test]
            fn test_elementassociatedattribute() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                let r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("domestic").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;domestic&quot;"/>
                let r#specified = r#domestic_attr.specified(); // <specified obj="domesticAttr" var="specified"/>
                assert!(r#specified); // <assertTrue actual="specified" id="domesticSpecified"/>
            }
            // hc_elementremoveattributenode.xml
            #[test]
            fn test_hc_elementremoveattributenode() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                let r#street_attr = r#test_employee.get_attribute_node("class").unwrap(); // <getAttributeNode obj="testEmployee" var="streetAttr" name="&quot;class&quot;"/>
                let r#removed_attr = r#test_employee
                    .remove_attribute_node(r#street_attr)
                    .unwrap(); // <removeAttributeNode obj="testEmployee" var="removedAttr" oldAttr="streetAttr"/>
                // unimplemented: // <assertNotNull actual="removedAttr" id="removedAttrNotNull"/>
                let r#removed_value = r#removed_attr.value().to_string(); // <value interface="Attr" obj="removedAttr" var="removedValue"/>
                assert_eq!(r#removed_value, "No"); // <assertEquals actual="removedValue" expected="&quot;No&quot;" id="elementRemoveAttributeNodeAssert" ignoreCase="false"/>
            }
            // hc_nodetextnodename.xml
            #[test]
            fn test_hc_nodetextnodename() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#text_node = r#test_addr.first_child().unwrap(); // <firstChild interface="Node" obj="testAddr" var="textNode"/>
                let r#text_name = r#text_node.node_name().to_string(); // <nodeName obj="textNode" var="textName"/>
                assert_eq!(r#text_name, "#text"); // <assertEquals actual="textName" expected="&quot;#text&quot;" id="textNodeName" ignoreCase="false"/>
            }
            // nodedocumenttypenodetype.xml
            #[test]
            fn test_nodedocumenttypenodetype() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#document_type_node = r#doc.doctype().unwrap(); // <doctype obj="doc" var="documentTypeNode"/>
                // unimplemented: // <assertNotNull actual="documentTypeNode" id="doctypeNotNull"/>
                let r#node_type = r#document_type_node.node_type(); // <nodeType obj="documentTypeNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 10); // <assertEquals actual="nodeType" expected="10" id="nodeType" ignoreCase="false"/>
            }
            // hc_textwithnomarkup.xml
            #[test]
            fn test_hc_textwithnomarkup() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;strong&quot;"/>
                let r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                let r#node_v = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="nodeV"/>
                let r#value = r#node_v.node_value().unwrap().to_string(); // <nodeValue obj="nodeV" var="value"/>
                assert_eq!(r#value, "Roger\n Jones"); // <assertEquals actual="value" expected="&quot;Roger\n Jones&quot;" id="textWithNoMarkupAssert" ignoreCase="false"/>
            }
            // elementremoveattributenomodificationallowederrEE.xml
            #[test]
            fn test_elementremoveattributenomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender; // type: Node // <var name="gender" type="Node"/>
                let r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference obj="doc" var="entRef" name="&quot;ent4&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                r#appended_child = r#gender.append_child(ent_ref.clone().into()).unwrap(); // <appendChild obj="gender" newChild="entRef" var="appendedChild"/>
                r#ent_element = r#ent_ref.first_child().unwrap().as_element().unwrap(); // <firstChild obj="entRef" var="entElement" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <removeAttribute obj="entElement" name="&quot;domestic&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element
                        .remove_attribute("domestic")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodecommentnodename.xml
            #[test]
            fn test_nodecommentnodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#comment_node; // type: Node // <var name="commentNode" type="Node"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#comment_node_name; // type: DOMString // <var name="commentNodeName" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.child_nodes(); // <childNodes obj="doc" var="elementList"/>
                // <for-each collection="elementList" member="commentNode">
                //  <nodeType obj="commentNode" var="nodeType"/>
                //  <if><equals actual="nodeType" expected="8" ignoreCase="false"/>
                //      <nodeName obj="commentNode" var="commentNodeName"/>
                //      <assertEquals actual="commentNodeName" expected="&quot;#comment&quot;" id="commentNodeName" ignoreCase="false"/>
                //  </if>
                // </for-each>
                for i in 0..element_list.length() {
                    comment_node = element_list.item(i).unwrap();
                    node_type = comment_node.node_type();
                    if node_type as i32 == 8 {
                        comment_node_name = comment_node.node_name().to_string();
                        assert_eq!(comment_node_name, "#comment");
                    }
                }
            }
            // namednodemapremovenameditem.xml
            #[test]
            fn test_namednodemapremovenameditem() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let r#street_attr; // type: Attr // <var name="streetAttr" type="Attr"/>
                let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                // unimplemented: // <assertNotNull actual="attributes" id="attributesNotNull"/>
                r#removed_node = r#attributes.remove_named_item("street").unwrap(); // <removeNamedItem var="removedNode" interface="NamedNodeMap" obj="attributes" name="&quot;street&quot;"/>
                r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                // unimplemented: // <assertNotNull actual="streetAttr" id="streetAttrNotNull"/>
                let r#specified = r#street_attr.specified(); // <specified obj="streetAttr" var="specified"/>
                assert!(!r#specified); // <assertFalse actual="specified" id="attrNotSpecified"/>
            }
            // noderemovechildnomodificationallowederrEE.xml
            #[test]
            fn test_noderemovechildnomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                let r#ent_text = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" var="entText" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entText" id="entTextNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <removeChild var="removedNode" obj="entRef" oldChild="entText"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_ref
                        .remove_child(ent_text)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // attreffectivevalue.xml
            #[test]
            fn test_attreffectivevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("domestic").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;domestic&quot;"/>
                let r#value = r#domestic_attr.node_value().unwrap().to_string(); // <nodeValue obj="domesticAttr" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="attrEffectiveValueAssert" ignoreCase="false"/>
            }
            // attrprevioussiblingnull.xml
            #[test]
            fn test_attrprevioussiblingnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("domestic").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;domestic&quot;"/>
                let r#s = r#domestic_attr.previous_sibling(); // <previousSibling interface="Node" obj="domesticAttr" var="s"/>
                assert!(s.is_none()); // <assertNull actual="s" id="attrPreviousSiblingNullAssert"/>
            }
            // hc_nodeparentnode.xml
            #[test]
            fn test_hc_nodeparentnode() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#parent_node = r#employee_node.parent_node().unwrap(); // <parentNode interface="Node" obj="employeeNode" var="parentNode"/>
                let r#parent_name = r#parent_node.node_name().to_string(); // <nodeName obj="parentNode" var="parentName"/>
                assert_eq!(r#parent_name, "body"); // <assertEquals actual="parentName" expected="&quot;body&quot;" id="parentNodeName" ignoreCase="auto"/>
            }
            // hc_characterdataindexsizeerrinsertdataoffsetgreater.xml
            #[test]
            fn test_hc_characterdataindexsizeerrinsertdataoffsetgreater() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                // <assertDOMException id="throw_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <deleteData obj="child" offset="40" count="3"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
                assert!(
                    child
                        .delete_data(40, 3)
                        .is_err_and(|err| err == DOMException::IndexSizeErr)
                );
            }
            // nodeclonetruecopytext.xml
            #[test]
            fn test_nodeclonetruecopytext() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("salary"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;salary&quot;" var="elementList"/>
                let r#child_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="childNode"/>
                let r#cloned_node = r#child_node.clone_node(true); // <cloneNode obj="childNode" deep="true" var="clonedNode"/>
                let r#last_child_node = r#cloned_node.last_child().unwrap(); // <lastChild interface="Node" obj="clonedNode" var="lastChildNode"/>
                let r#child_value = r#last_child_node.node_value().unwrap().to_string(); // <nodeValue obj="lastChildNode" var="childValue"/>
                assert_eq!(r#child_value, "35,000"); // <assertEquals actual="childValue" expected="&quot;35,000&quot;" id="nodeCloneTrueCopyTextAssert1" ignoreCase="false"/>
            }
            // hc_namednodemapreturnlastitem.xml
            #[test]
            fn test_hc_namednodemapreturnlastitem() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#html_expected; // type: Collection // <var name="htmlExpected" type="Collection">    <member>"title"</member>    <member>"class"</member></var>
                // let mut r#expected; // type: Collection // <var name="expected" type="Collection">    <member>"title"</member>    <member>"class"</member>    <member>"dir"</member></var>
                // let mut r#actual; // type: Collection // <var name="actual" type="Collection"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                // r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="1"/>
                // r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>

                // // unimplemented: // <for-each collection="attributes" member="child"><nodeName obj="child" var="nodeName"/><append collection="actual" item="nodeName"/></for-each>

                // // unimplemented: // <if><contentType type="text/html"/><assertEquals id="attrName_html" actual="actual" expected="htmlExpected" ignoreCase="true"/><else><assertEquals id="attrName" actual="actual" expected="expected" ignoreCase="false"/></else></if>
            }
            // nodeinsertbeforenewchilddiffdocument.xml
            #[test]
            fn test_nodeinsertbeforenewchilddiffdocument() {
                let r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc1 = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc1" href="staff" willBeModified="false"/>
                r#doc2 = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc2" href="staff" willBeModified="true"/>
                r#new_child = r#doc1.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc1" tagName="&quot;newChild&quot;" var="newChild"/>
                r#element_list = r#doc2.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc2" tagname="&quot;employee&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                r#ref_child = r#element_node.first_child().unwrap(); // <firstChild var="refChild" obj="elementNode" interface="Node"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <insertBefore var="insertedNode" obj="elementNode" newChild="newChild" refChild="refChild"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .insert_before(new_child.into(), Some(ref_child))
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // hc_nodedocumentfragmentnodetype.xml
            #[test]
            fn test_hc_nodedocumentfragmentnodetype() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#document_fragment_node = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="documentFragmentNode"/>
                let r#node_type = r#document_fragment_node.node_type(); // <nodeType obj="documentFragmentNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 11); // <assertEquals actual="nodeType" expected="11" id="nodeDocumentFragmentNodeTypeAssert1" ignoreCase="false"/>
            }
            // elementremoveattributerestoredefaultvalue.xml
            #[test]
            fn test_elementremoveattributerestoredefaultvalue() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let r#street_attr; // type: Attr // <var name="streetAttr" type="Attr"/>
                let mut r#removed_attr; // type: Attr // <var name="removedAttr" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                r#street_attr = r#test_employee.get_attribute_node("street").unwrap(); // <getAttributeNode obj="testEmployee" var="streetAttr" name="&quot;street&quot;"/>
                r#removed_attr = r#test_employee
                    .remove_attribute_node(r#street_attr)
                    .unwrap(); // <removeAttributeNode var="removedAttr" obj="testEmployee" oldAttr="streetAttr"/>
                let r#attribute = r#test_employee.get_attribute("street"); // <getAttribute obj="testEmployee" var="attribute" name="&quot;street&quot;"/>
                assert_eq!(r#attribute, "Yes"); // <assertEquals actual="attribute" expected="&quot;Yes&quot;" id="streetYes" ignoreCase="false"/>
            }
            // attrcreatetextnode.xml
            #[test]
            fn test_attrcreatetextnode() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#address_list; // type: NodeList // <var name="addressList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#street_attr; // type: Attr // <var name="streetAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                r#test_node = r#address_list.item(3).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                r#street_attr.set_value("Y&ent1;").unwrap(); // <value interface="Attr" obj="streetAttr" value="&quot;Y&amp;ent1;&quot;"/>
                r#value = r#street_attr.value().to_string(); // <value interface="Attr" obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Y&ent1;"); // <assertEquals actual="value" expected="&quot;Y&amp;ent1;&quot;" id="value" ignoreCase="false"/>
                r#value = r#street_attr.node_value().unwrap().to_string(); // <nodeValue obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Y&ent1;"); // <assertEquals actual="value" expected="&quot;Y&amp;ent1;&quot;" id="nodeValue" ignoreCase="false"/>
            }
            // elementgetattributenodenull.xml
            #[test]
            fn test_elementgetattributenodenull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                let r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                let r#domestic_attr = r#test_employee.get_attribute_node("invalidAttribute"); // <getAttributeNode obj="testEmployee" var="domesticAttr" name="&quot;invalidAttribute&quot;"/>
                assert!(domestic_attr.is_none()); // <assertNull actual="domesticAttr" id="elementGetAttributeNodeNullAssert"/>
            }
            // hc_textsplittextthree.xml
            #[test]
            fn test_hc_textsplittextthree() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;strong&quot;"/>
                r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                r#text_node = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="textNode"/>
                let r#split_node = r#text_node.split_text(6).unwrap(); // <splitText obj="textNode" var="splitNode" offset="6"/>
                let r#value = r#split_node.node_value().unwrap().to_string(); // <nodeValue obj="splitNode" var="value"/>
                assert_eq!(r#value, " Jones"); // <assertEquals actual="value" expected="&quot; Jones&quot;" id="textSplitTextThreeAssert" ignoreCase="false"/>
            }
            // elementretrieveattrvalue.xml
            #[test]
            fn test_elementretrieveattrvalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                let r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testAddress"/>
                let r#attr_value = r#test_address.get_attribute("street"); // <getAttribute obj="testAddress" var="attrValue" name="&quot;street&quot;"/>
                assert_eq!(r#attr_value, "No"); // <assertEquals actual="attrValue" expected="&quot;No&quot;" id="attrValue" ignoreCase="false"/>
            }
            // hc_elementremoveattribute.xml
            #[test]
            fn test_hc_elementremoveattribute() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(3).unwrap(); // <item interface="NodeList" obj="elementList" index="3" var="testEmployee"/>
                r#test_employee.remove_attribute("class").unwrap(); // <removeAttribute obj="testEmployee" name="&quot;class&quot;"/>
                let r#attr_value = r#test_employee.get_attribute("class"); // <getAttribute obj="testEmployee" var="attrValue" name="&quot;class&quot;"/>
                assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" id="attrValue" ignoreCase="false"/>
            }
            // hc_attrappendchild1.xml
            #[test]
            fn test_hc_attrappendchild1() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                let r#text_node = r#doc.create_text_node("terday"); // <createTextNode var="textNode" obj="doc" data="&quot;terday&quot;"/>
                let r#retval = r#title_attr.append_child(text_node.into()).unwrap(); // <appendChild var="retval" obj="titleAttr" newChild="textNode"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrNodeValue" ignoreCase="false"/>
                r#value = r#retval.node_value().unwrap().to_string(); // <nodeValue obj="retval" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="retvalValue" ignoreCase="false"/>
                let r#last_child = r#title_attr.last_child().unwrap(); // <lastChild var="lastChild" obj="titleAttr" interface="Node"/>
                r#value = r#last_child.node_value().unwrap().to_string(); // <nodeValue obj="lastChild" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="lastChildValue" ignoreCase="false"/>
            }
            // documenttypegetentities.xml
            #[test]
            fn test_documenttypegetentities() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entity_list; // type: NamedNodeMap // <var name="entityList" type="NamedNodeMap"/>
                // let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                // let mut r#expected_result; // type: Collection // <var name="expectedResult" type="Collection"><member>"ent1"</member><member>"ent2"</member><member>"ent3"</member><member>"ent4"</member><member>"ent5"</member></var>
                // let mut r#expected_result_svg; // type: Collection // <var name="expectedResultSVG" type="Collection"><member>"ent1"</member><member>"ent2"</member><member>"ent3"</member><member>"ent4"</member><member>"ent5"</member><member>"svgunit"</member><member>"svgtest"</member></var>
                // let mut r#name_list; // type: Collection // <var name="nameList" type="Collection"/>
                // let mut r#entity; // type: Node // <var name="entity" type="Node"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>

                // // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>

                // // unimplemented: // <entities obj="docType" var="entityList"/>

                // // unimplemented: // <assertNotNull actual="entityList" id="entitiesNotNull"/>

                // // unimplemented: // <for-each collection="entityList" member="entity">	<nodeName obj="entity" var="name"/>	<append collection="nameList" item="name"/></for-each>

                // // unimplemented: // <if><contentType type="image/svg+xml"/>	<assertEquals actual="nameList" expected="expectedResultSVG" id="entityNamesSVG" ignoreCase="false"/>	<else>		<assertEquals actual="nameList" expected="expectedResult" id="entityNames" ignoreCase="false"/>	</else></if>
            }
            // characterdataappenddata.xml
            #[test]
            fn test_characterdataappenddata() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.append_data(", Esquire").unwrap(); // <appendData obj="child" arg="&quot;, Esquire&quot;"/>
                let r#child_value = r#child.data().to_string(); // <data obj="child" var="childValue" interface="CharacterData"/>
                let r#child_length = r#child_value.len(); // <length obj="childValue" var="childLength" interface="DOMString"/>
                assert_eq!(r#child_length, 24); // <assertEquals actual="childLength" expected="24" ignoreCase="false" id="characterdataAppendDataAssert"/>
            }
            // characterdatasubstringexceedsvalue.xml
            #[test]
            fn test_characterdatasubstringexceedsvalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                let r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                let r#substring = child.substring_data(9, 10).unwrap(); // <substringData obj="child" var="substring" offset="9" count="10"/>
                assert_eq!(r#substring, "Martin"); // <assertEquals actual="substring" expected="&quot;Martin&quot;" id="characterdataSubStringExceedsValueAssert" ignoreCase="false"/>
            }
            // documentgetelementsbytagnamevalue.xml
            #[test]
            fn test_documentgetelementsbytagnamevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#name_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="nameList" tagname="&quot;name&quot;"/>
                let r#name_node = r#name_list.item(3).unwrap(); // <item interface="NodeList" obj="nameList" var="nameNode" index="3"/>
                let r#first_child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="firstChild"/>
                let r#child_value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="childValue"/>
                assert_eq!(r#child_value, "Jeny Oconnor"); // <assertEquals actual="childValue" expected="&quot;Jeny Oconnor&quot;" id="documentGetElementsByTagNameValueAssert" ignoreCase="false"/>
            }
            // characterdatainsertdatamiddle.xml
            #[test]
            fn test_characterdatainsertdatamiddle() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.insert_data(9, "Ann ").unwrap(); // <insertData obj="child" offset="9" arg="&quot;Ann &quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Margaret Ann Martin"); // <assertEquals actual="childData" expected="&quot;Margaret Ann Martin&quot;" id="characterdataInsertDataMiddleAssert" ignoreCase="false"/>
            }
            // namednodemapnotfounderr.xml
            #[test]
            fn test_namednodemapnotfounderr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="2"/>
                r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <removeNamedItem var="removedNode" interface="NamedNodeMap" obj="attributes" name="&quot;district&quot;"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .remove_named_item("district")
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // nodeinsertbefore.xml
            #[test]
            fn test_nodeinsertbefore() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#inserted_node; // type: Node // <var name="insertedNode" type="Node"/>
                let mut r#actual = vec![]; // type: List // <var name="actual" type="List"/>
                let r#expected_with_whitespace = vec![
                    "#text",
                    "employeeId",
                    "#text",
                    "name",
                    "#text",
                    "position",
                    "#text",
                    "newChild",
                    "salary",
                    "#text",
                    "gender",
                    "#text",
                    "address",
                    "#text",
                ]; // type: List // <var name="expectedWithWhitespace" type="List"><member>"#text"</member><member>"employeeId"</member><member>"#text"</member><member>"name"</member><member>"#text"</member><member>"position"</member><member>"#text"</member><member>"newChild"</member><member>"salary"</member><member>"#text"</member><member>"gender"</member><member>"#text"</member><member>"address"</member><member>"#text"</member></var>
                let r#expected_without_whitespace = vec![
                    "employeeId",
                    "name",
                    "position",
                    "newChild",
                    "salary",
                    "gender",
                    "address",
                ]; // type: List // <var name="expectedWithoutWhitespace" type="List"><member>"employeeId"</member><member>"name"</member><member>"position"</member><member>"newChild"</member><member>"salary"</member><member>"gender"</member><member>"address"</member></var>
                let r#expected; // type: List // <var name="expected" type="List"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#length = r#child_list.length(); // <length var="length" obj="childList" interface="NodeList"/>
                // <if><equals actual="length" expected="6" ignoreCase="false"/>
                //  <item interface="NodeList" obj="childList" index="3" var="refChild"/>
                //  <assign var="expected" value="expectedWithoutWhitespace"/>
                // <else>
                //  <item interface="NodeList" obj="childList" index="7" var="refChild"/>
                //  <assign var="expected" value="expectedWithWhitespace"/>
                // </else>
                // </if>
                if length == 6 {
                    ref_child = child_list.item(3).unwrap();
                    expected = expected_without_whitespace;
                } else {
                    ref_child = child_list.item(7).unwrap();
                    expected = expected_with_whitespace;
                }
                r#new_child = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="newChild"/>
                r#inserted_node = r#employee_node
                    .insert_before(new_child.into(), Some(ref_child))
                    .unwrap(); // <insertBefore var="insertedNode" obj="employeeNode" newChild="newChild" refChild="refChild"/>
                // <for-each collection="childList" member="child">
                //  <nodeName obj="child" var="childName"/>
                //  <append collection="actual" item="childName"/>
                // </for-each>
                for i in 0..child_list.length() {
                    child = child_list.item(i).unwrap();
                    child_name = child.node_name().to_string();
                    actual.push(child_name);
                }
                assert_eq!(r#actual, expected); // <assertEquals actual="actual" expected="expected" id="nodeNames" ignoreCase="false"/>
            }
            // characterdataappenddatagetdata.xml
            #[test]
            fn test_characterdataappenddatagetdata() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.append_data(", Esquire").unwrap(); // <appendData obj="child" arg="&quot;, Esquire&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Margaret Martin, Esquire"); // <assertEquals actual="childData" expected="&quot;Margaret Martin, Esquire&quot;" id="characterdataAppendDataGetDataAssert" ignoreCase="false"/>
            }
            // hc_nodeappendchildnewchilddiffdocument.xml
            #[test]
            fn test_hc_nodeappendchildnewchilddiffdocument() {
                let r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc1 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc1" href="hc_staff" willBeModified="false"/>
                r#doc2 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc2" href="hc_staff" willBeModified="true"/>
                r#new_child = r#doc1.create_element("br".to_string()).unwrap(); // <createElement obj="doc1" tagName="&quot;br&quot;" var="newChild"/>
                r#element_list = r#doc2.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc2" tagname="&quot;p&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <appendChild var="appendedChild" obj="elementNode" newChild="newChild"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .append_child(new_child.into())
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // documentgetimplementation.xml
            #[test]
            fn test_documentgetimplementation() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_impl = doc.implementation(); // <implementation obj="doc" var="docImpl"/>
                let r#state = doc_impl.has_feature("XML", Some("1.0")); // <hasFeature obj="docImpl" var="state" feature="&quot;XML&quot;" version="&quot;1.0&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="documentGetImplementationAssert"/>
            }
            // hc_nodeinsertbeforedocfragment.xml
            #[test]
            fn test_hc_nodeinsertbeforedocfragment() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                let mut r#newdoc_fragment; // type: DocumentFragment // <var name="newdocFragment" type="DocumentFragment"/>
                let r#new_child1; // type: Node // <var name="newChild1" type="Node"/>
                let r#new_child2; // type: Node // <var name="newChild2" type="Node"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#inserted_node; // type: Node // <var name="insertedNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#ref_child = r#child_list.item(3).unwrap().clone(); // <item interface="NodeList" obj="childList" index="3" var="refChild"/>
                r#newdoc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="newdocFragment"/>
                r#new_child1 = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="newChild1"/>
                r#new_child2 = r#doc.create_element("b".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;b&quot;" var="newChild2"/>
                r#appended_child = r#newdoc_fragment.append_child(new_child1.into()).unwrap(); // <appendChild var="appendedChild" obj="newdocFragment" newChild="newChild1"/>
                r#appended_child = r#newdoc_fragment.append_child(new_child2.into()).unwrap(); // <appendChild var="appendedChild" obj="newdocFragment" newChild="newChild2"/>
                r#inserted_node = r#employee_node
                    .insert_before(newdoc_fragment.into(), ref_child.into())
                    .unwrap(); // <insertBefore var="insertedNode" obj="employeeNode" newChild="newdocFragment" refChild="refChild"/>
                r#child = r#child_list.item(3).unwrap().clone(); // <item interface="NodeList" obj="childList" index="3" var="child"/>
                r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                assert_eq!(r#child_name, "br"); // <assertEquals actual="childName" expected="&quot;br&quot;" ignoreCase="auto" id="childName3"/>
                r#child = r#child_list.item(4).unwrap().clone(); // <item interface="NodeList" obj="childList" index="4" var="child"/>
                r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                assert_eq!(r#child_name, "b"); // <assertEquals actual="childName" expected="&quot;b&quot;" ignoreCase="auto" id="childName4"/>
            }
            // hc_elementreplaceexistingattribute.xml
            #[test]
            fn test_hc_elementreplaceexistingattribute() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#set_attr; // type: Attr // <var name="setAttr" type="Attr"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                r#new_attribute = r#doc.create_attribute("class".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;class&quot;"/>
                r#set_attr = r#test_employee
                    .set_attribute_node(r#new_attribute)
                    .unwrap()
                    .unwrap(); // <setAttributeNode var="setAttr" obj="testEmployee" newAttr="newAttribute"/>
                let r#strong = r#test_employee.get_attribute("class"); // <getAttribute obj="testEmployee" var="strong" name="&quot;class&quot;"/>
                assert_eq!(r#strong, ""); // <assertEquals actual="strong" expected="&quot;&quot;" id="replacedValue" ignoreCase="false"/>
            }
            // hc_namednodemapsetnameditemwithnewvalue.xml
            #[test]
            fn test_hc_namednodemapsetnameditemwithnewvalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                r#new_attribute = r#doc.create_attribute("lang".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;lang&quot;"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                let r#new_node = r#attributes.set_named_item(r#new_attribute).unwrap(); // <setNamedItem interface="NamedNodeMap" obj="attributes" var="newNode" arg="newAttribute"/>
                assert!(new_node.is_none()); // <assertNull actual="newNode" id="prevValueNull"/>
            }
            // nodeclonenodetrue.xml
            #[test]
            fn test_nodeclonenodetrue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#cloned_node; // type: Node // <var name="clonedNode" type="Node"/>
                let r#cloned_list; // type: NodeList // <var name="clonedList" type="NodeList"/>
                let mut r#cloned_child; // type: Node // <var name="clonedChild" type="Node"/>
                let mut r#cloned_child_name; // type: DOMString // <var name="clonedChildName" type="DOMString"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let mut r#expected_whitespace = vec![
                    "#text",
                    "employeeId",
                    "#text",
                    "name",
                    "#text",
                    "position",
                    "#text",
                    "salary",
                    "#text",
                    "gender",
                    "#text",
                    "address",
                    "#text",
                ]; // type: List // <var name="expectedWhitespace" type="List"><member>"#text"</member><member>"employeeId"</member><member>"#text"</member><member>"name"</member><member>"#text"</member><member>"position"</member><member>"#text"</member><member>"salary"</member><member>"#text"</member><member>"gender"</member><member>"#text"</member><member>"address"</member><member>"#text"</member></var>
                let r#expected_no_whitespace = vec![
                    "employeeId",
                    "name",
                    "position",
                    "salary",
                    "gender",
                    "address",
                ]; // type: List // <var name="expectedNoWhitespace" type="List"><member>"employeeId"</member><member>"name"</member><member>"position"</member><member>"salary"</member><member>"gender"</member><member>"address"</member></var>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes var="childList" obj="employeeNode"/>
                let r#length = r#child_list.length(); // <length var="length" obj="childList" interface="NodeList"/>
                r#cloned_node = r#employee_node.clone_node(true); // <cloneNode obj="employeeNode" deep="true" var="clonedNode"/>
                r#cloned_list = r#cloned_node.child_nodes(); // <childNodes obj="clonedNode" var="clonedList"/>
                // <for-each collection="clonedList" member="clonedChild">
                //  <nodeName obj="clonedChild" var="clonedChildName"/>
                //  <append collection="result" item="clonedChildName"/>
                // </for-each>
                for i in 0..cloned_list.length() {
                    cloned_child = cloned_list.item(i).unwrap();
                    cloned_child_name = cloned_child.node_name().to_string();
                    result.push(cloned_child_name);
                }
                // <if><equals actual="length" expected="6" ignoreCase="false"/>
                //  <assertEquals actual="result" expected="expectedNoWhitespace" id="nowhitespace" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="result" expected="expectedWhitespace" id="whitespace" ignoreCase="false"/>
                // </else>
                // </if>
                if length == 6 {
                    assert_eq!(result, expected_no_whitespace);
                } else {
                    assert_eq!(result, expected_whitespace);
                }
            }
            // hc_characterdataindexsizeerrdeletedatacountnegative.xml
            #[test]
            fn test_hc_characterdataindexsizeerrdeletedatacountnegative() {
                // // unimplemented: // <implementationAttribute name="signed" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                // let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                // let mut r#child_substring; // type: DOMString // <var name="childSubstring" type="DOMString"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                // r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                // r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // // unimplemented:
                // // <assertDOMException id="throws_INDEX_SIZE_ERR">
                // //  <INDEX_SIZE_ERR>
                // //      <substringData var="childSubstring" obj="child" offset="10" count="-3"/>
                // //  </INDEX_SIZE_ERR>
                // // </assertDOMException>
            }
            // nodeentityreferencenodevalue.xml
            #[test]
            fn test_nodeentityreferencenodevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#ent_ref_addr; // type: Element // <var name="entRefAddr" type="Element"/>
                let mut r#ent_ref_node; // type: Node // <var name="entRefNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#ent_ref_addr = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="entRefAddr"/>
                r#ent_ref_node = r#ent_ref_addr.first_child().unwrap(); // <firstChild interface="Node" obj="entRefAddr" var="entRefNode"/>
                let r#node_type = r#ent_ref_node.node_type(); // <nodeType var="nodeType" obj="entRefNode"/>
                // <if><equals actual="nodeType" expected="3" ignoreCase="false"/>
                //  <createEntityReference var="entRefNode" obj="doc" name="&quot;ent2&quot;"/>
                //  <assertNotNull actual="entRefNode" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 3 {
                    ent_ref_node = doc.create_entity_reference("ent2").unwrap().into();
                }
                let r#ent_ref_value = r#ent_ref_node.node_value(); // <nodeValue obj="entRefNode" var="entRefValue"/>
                assert!(ent_ref_value.is_none()) // <assertNull actual="entRefValue" id="entRefNodeValue"/>
            }
            // elementgetelementsbytagnamenomatch.xml
            #[test]
            fn test_elementgetelementsbytagnamenomatch() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("noMatch"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;noMatch&quot;" var="elementList"/>
                assert_eq!(element_list.length(), 0) // <assertSize collection="elementList" size="0" id="elementGetElementsByTagNameNoMatchNoMatchAssert"/>
            }
            // nodeinsertbeforenodeancestor.xml
            #[test]
            fn test_nodeinsertbeforenodeancestor() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_child = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="newChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#ref_child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="refChild"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <insertBefore var="insertedNode" obj="employeeNode" newChild="newChild" refChild="refChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    employee_node
                        .insert_before(new_child.into(), Some(ref_child))
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // hc_characterdataindexsizeerrsubstringcountnegative.xml
            #[test]
            fn test_hc_characterdataindexsizeerrsubstringcountnegative() {
                // // unimplemented: // <implementationAttribute name="signed" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                // let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                // let mut r#bad_substring; // type: DOMString // <var name="badSubstring" type="DOMString"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                // r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                // r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // // unimplemented:
                // // <assertDOMException id="throws_INDEX_SIZE_ERR">
                // //  <INDEX_SIZE_ERR>
                // //      <substringData var="badSubstring" obj="child" offset="10" count="-3"/>
                // //  </INDEX_SIZE_ERR>
                // // </assertDOMException>
            }
            // hc_nodecommentnodeattributes.xml
            #[test]
            fn test_hc_nodecommentnodeattributes() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#comment_node; // type: Node // <var name="commentNode" type="Node"/>
                let r#node_list; // type: NodeList // <var name="nodeList" type="NodeList"/>
                let mut r#attr_list; // type: NamedNodeMap // <var name="attrList" type="NamedNodeMap"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#node_list = r#doc.child_nodes(); // <childNodes obj="doc" var="nodeList"/>
                // <for-each collection="nodeList" member="commentNode">
                //  <nodeType obj="commentNode" var="nodeType"/>
                //  <if><equals actual="nodeType" expected="8" ignoreCase="false"/>
                //      <attributes obj="commentNode" var="attrList"/>
                //      <assertNull actual="attrList" id="existingCommentAttributesNull"/>
                //  </if>
                // </for-each>
                for i in 0..node_list.length() {
                    comment_node = node_list.item(i).unwrap();
                    node_type = comment_node.node_type();
                    if node_type as i32 == 8 {
                        attr_list = comment_node.attributes();
                        assert!(attr_list.is_none());
                    }
                }
                let r#comment_node = r#doc.create_comment("This is a comment"); // <createComment var="commentNode" obj="doc" data="&quot;This is a comment&quot;"/>
                r#attr_list = r#comment_node.attributes(); // <attributes obj="commentNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="createdCommentAttributesNull"/>
            }
            // hc_elementgetelementsbytagnamespecialvalue.xml
            #[test]
            fn test_hc_elementgetelementsbytagnamespecialvalue() {
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let r#expected_result = vec!["em", "strong", "code", "sup", "var", "acronym"]; // type: List // <var name="expectedResult" type="List"><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member></var>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#last_employee = r#element_list.item(4).unwrap(); // <item interface="NodeList" obj="elementList" index="4" var="lastEmployee"/>
                let r#lastemp_list = r#last_employee.get_elements_by_tag_name("*"); // <getElementsByTagName interface="Element" obj="lastEmployee" var="lastempList" tagname="&quot;*&quot;"/>
                // <for-each collection="lastempList" member="child">
                //  <nodeName obj="child" var="childName"/>
                //  <append collection="result" item="childName"/>
                // </for-each>
                for i in 0..lastemp_list.length() {
                    let child = lastemp_list.item(i).unwrap();
                    child_name = child.node_name().to_string();
                    result.push(child_name);
                }
                assert_eq!(r#result, expected_result); // <assertEquals actual="result" expected="expectedResult" id="tagNames" ignoreCase="auto"/>
            }
            // nodelistindexgetlength.xml
            #[test]
            fn test_nodelistindexgetlength() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#length = r#employee_list.length(); // <length var="length" obj="employeeList" interface="NodeList"/>
                // <assertTrue id="lengthIs6or13">
                //  <or>
                //      <equals actual="length" expected="6" ignoreCase="false"/>
                //      <equals actual="length" expected="13" ignoreCase="false"/>
                //  </or>
                // </assertTrue>
                assert!(length == 6 || length == 13);
            }
            // nodeinsertbeforerefchildnull.xml
            #[test]
            fn test_nodeinsertbeforerefchildnull() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#inserted_node; // type: Node // <var name="insertedNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#new_child = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="newChild"/>
                r#inserted_node = r#employee_node
                    .insert_before(new_child.into(), None)
                    .unwrap(); // <insertBefore var="insertedNode" obj="employeeNode" newChild="newChild" refChild="refChild"/>
                r#child = r#employee_node.last_child().unwrap(); // <lastChild interface="Node" obj="employeeNode" var="child"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                assert_eq!(r#child_name, "newChild"); // <assertEquals actual="childName" expected="&quot;newChild&quot;" id="nodeInsertBeforeRefChildNullAssert1" ignoreCase="false"/>
            }
            // hc_nodevalue01.xml
            #[test]
            fn test_hc_nodevalue01() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_node; // type: Element // <var name="newNode" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#new_node = r#doc.create_element("acronym".to_string()).unwrap(); // <createElement obj="doc" var="newNode" tagName="&quot;acronym&quot;"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="initiallyNull"/>
                r#new_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
            }
            // namednodemapwrongdocumenterr.xml
            #[test]
            fn test_namednodemapwrongdocumenterr() {
                let r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc1 = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc1" href="staff" willBeModified="true"/>
                r#doc2 = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc2" href="staff" willBeModified="true"/>
                r#element_list = r#doc1.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc1" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                let r#new_attribute = r#doc2.create_attribute("newAttribute".to_string()).unwrap(); // <createAttribute obj="doc2" var="newAttribute" name="&quot;newAttribute&quot;"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <setNamedItem var="setNode" obj="attributes" arg="newAttribute"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .set_named_item(new_attribute)
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // hc_nodetextnodetype.xml
            #[test]
            fn test_hc_nodetextnodetype() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#text_node = r#test_addr.first_child().unwrap(); // <firstChild interface="Node" obj="testAddr" var="textNode"/>
                let r#node_type = r#text_node.node_type(); // <nodeType obj="textNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 3); // <assertEquals actual="nodeType" expected="3" id="nodeTextNodeTypeAssert1" ignoreCase="false"/>
            }
            // characterdatareplacedataexceedslengthofarg.xml
            #[test]
            fn test_characterdatareplacedataexceedslengthofarg() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.replace_data(0, 4, "260030").unwrap(); // <replaceData obj="child" offset="0" count="4" arg="&quot;260030&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "260030 North Ave. Dallas, Texas 98551"); // <assertEquals actual="childData" expected="&quot;260030 North Ave. Dallas, Texas 98551&quot;" id="characterdataReplaceDataExceedsLengthOfArgAssert" ignoreCase="false"/>
            }
            // nodeclonenodefalse.xml
            #[test]
            fn test_nodeclonenodefalse() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#cloned_node = r#employee_node.clone_node(false); // <cloneNode obj="employeeNode" deep="false" var="clonedNode"/>
                let r#clone_name = r#cloned_node.node_name().to_string(); // <nodeName obj="clonedNode" var="cloneName"/>
                assert_eq!(r#clone_name, "employee"); // <assertEquals actual="cloneName" expected="&quot;employee&quot;" ignoreCase="false" id="name"/>
                let r#clone_children = r#cloned_node.child_nodes(); // <childNodes obj="clonedNode" var="cloneChildren"/>
                let r#length = r#clone_children.length(); // <length interface="NodeList" obj="cloneChildren" var="length"/>
                assert_eq!(r#length, 0); // <assertEquals actual="length" expected="0" ignoreCase="false" id="length"/>
            }
            // documenttypegetnotations.xml
            #[test]
            fn test_documenttypegetnotations() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let r#notation_list; // type: NamedNodeMap // <var name="notationList" type="NamedNodeMap"/>
                let mut r#notation; // type: Node // <var name="notation" type="Node"/>
                let mut r#notation_name; // type: DOMString // <var name="notationName" type="DOMString"/>
                let mut r#actual = vec![]; // type: Collection // <var name="actual" type="Collection"/>
                let r#expected = vec!["notation1", "notation2"]; // type: Collection // <var name="expected" type="Collection"><member>"notation1"</member><member>"notation2"</member></var>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                notation_list = doc_type.notations(); // <notations obj="docType" var="notationList"/>
                // unimplemented: // <assertNotNull actual="notationList" id="notationsNotNull"/>
                // <for-each collection="notationList" member="notation">
                //  <nodeName obj="notation" var="notationName"/>
                //  <append collection="actual" item="notationName"/>
                // </for-each>
                for i in 0..notation_list.length() {
                    notation = notation_list.item(i).unwrap();
                    notation_name = notation.node_name().to_string();
                    actual.push(notation_name);
                }
                assert_eq!(r#actual, expected); // <assertEquals actual="actual" expected="expected" id="names" ignoreCase="false"/>
            }
            // nodevalue06.xml
            #[test]
            fn test_nodevalue06() {
                let mut r#new_node: DocumentRef; // <var name="newNode" type="Document"/>
                r#new_node = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="newNode" href="staff" willBeModified="true"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="initiallyNull"/>
                r#new_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
            }
            // hc_notationsremovenameditem1.xml
            #[test]
            fn test_hc_notationsremovenameditem1() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // unimplemented:
                // <if><not><contentType type="text/html"/></not>
                //  <assertNotNull actual="docType" id="docTypeNotNull"/>
                //  <notations var="notations" obj="docType"/>
                //  <assertNotNull actual="notations" id="notationsNotNull"/>
                //  <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //      <NO_MODIFICATION_ALLOWED_ERR>
                //          <removeNamedItem var="retval" obj="notations" name="&quot;notation1&quot;"/>
                //      </NO_MODIFICATION_ALLOWED_ERR>
                //  </assertDOMException>
                // </if>
            }
            // nodeattributenodeattribute.xml
            #[test]
            fn test_nodeattributenodeattribute() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#addr_attr = r#test_addr.attributes(); // <attributes obj="testAddr" var="addrAttr"/>
                let r#attr_node = r#addr_attr.item(0).unwrap(); // <item interface="NamedNodeMap" obj="addrAttr" var="attrNode" index="0"/>
                let r#attr_list = r#attr_node.attributes(); // <attributes obj="attrNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="nodeAttributeNodeAttributeAssert1"/>
            }
            // hc_characterdataindexsizeerrsubstringoffsetgreater.xml
            #[test]
            fn test_hc_characterdataindexsizeerrsubstringoffsetgreater() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                let r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                // <assertDOMException id="throw_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <substringData var="badString" obj="child" offset="40" count="3"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
                assert!(
                    child
                        .substring_data(40, 3)
                        .is_err_and(|err| err == DOMException::IndexSizeErr)
                );
            }
            // hc_attrappendchild6.xml
            #[test]
            fn test_hc_attrappendchild6() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#title_attr = r#doc.create_attribute("title".to_string()).unwrap(); // <createAttribute var="titleAttr" obj="doc" name="&quot;title&quot;"/>
                let r#text_node = r#doc.create_text_node("Yesterday"); // <createTextNode var="textNode" obj="doc" data="&quot;Yesterday&quot;"/>
                let r#retval = r#title_attr.append_child(text_node.into()).unwrap(); // <appendChild var="retval" obj="titleAttr" newChild="textNode"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrNodeValue" ignoreCase="false"/>
                r#value = r#retval.node_value().unwrap().to_string(); // <nodeValue obj="retval" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="retvalValue" ignoreCase="false"/>
                let r#last_child = r#title_attr.last_child().unwrap(); // <lastChild var="lastChild" obj="titleAttr" interface="Node"/>
                r#value = r#last_child.node_value().unwrap().to_string(); // <nodeValue obj="lastChild" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="lastChildValue" ignoreCase="false"/>
            }
            // namednodemapnumberofnodes.xml
            #[test]
            fn test_namednodemapnumberofnodes() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="2"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#length = r#attributes.length(); // <length var="length" obj="attributes" interface="NamedNodeMap"/>
                assert_eq!(r#length, 2); // <assertEquals actual="length" expected="2" id="length" ignoreCase="false"/>
            }
            // hc_attrprevioussiblingnull.xml
            #[test]
            fn test_hc_attrprevioussiblingnull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;acronym&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;title&quot;"/>
                let r#s = r#domestic_attr.previous_sibling(); // <previousSibling interface="Node" obj="domesticAttr" var="s"/>
                assert!(s.is_none()); // <assertNull actual="s" id="attrPreviousSiblingNullAssert"/>
            }
            // documentinvalidcharacterexceptioncreateentref.xml
            #[test]
            fn test_documentinvalidcharacterexceptioncreateentref() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#bad_entity_ref; // type: EntityReference // <var name="badEntityRef" type="EntityReference"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // unimplemented:
                // <if><contentType type="text/html"/>
                //  <assertDOMException id="throw_NOT_SUPPORTED_ERR">
                //      <NOT_SUPPORTED_ERR>
                //          <createEntityReference var="badEntityRef" obj="doc" name="&quot;foo&quot;"/>
                //      </NOT_SUPPORTED_ERR>
                //  </assertDOMException>
                // <else>
                //  <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //      <INVALID_CHARACTER_ERR>
                //          <createEntityReference var="badEntityRef" obj="doc" name="&quot;invalid^Name&quot;"/>
                //      </INVALID_CHARACTER_ERR>
                //  </assertDOMException>
                // </else>
                // </if>
            }
            // hc_attrclonenode1.xml
            #[test]
            fn test_hc_attrclonenode1() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                let r#last_child; // type: Node // <var name="lastChild" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#text_node = r#doc.create_text_node("terday"); // <createTextNode var="textNode" obj="doc" data="&quot;terday&quot;"/>
                r#retval = r#title_attr.append_child(text_node.clone().into()).unwrap(); // <appendChild var="retval" obj="titleAttr" newChild="textNode"/>
                let r#cloned_title = r#title_attr.clone_node(false).as_attribute().unwrap(); // <cloneNode var="clonedTitle" obj="titleAttr" deep="false"/>
                r#text_node.set_node_value("text_node_not_cloned").unwrap(); // <nodeValue obj="textNode" value="&quot;text_node_not_cloned&quot;"/>
                r#value = r#cloned_title.value().to_string(); // <value interface="Attr" obj="clonedTitle" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#cloned_title.node_value().unwrap().to_string(); // <nodeValue obj="clonedTitle" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrNodeValue" ignoreCase="false"/>
                r#last_child = r#cloned_title.last_child().unwrap(); // <lastChild var="lastChild" obj="clonedTitle" interface="Node"/>
                r#value = r#last_child.node_value().unwrap().to_string(); // <nodeValue obj="lastChild" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="lastChildValue" ignoreCase="false"/>
            }
            // documentgetrootnode.xml
            #[test]
            fn test_documentgetrootnode() {
                let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#root = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="root"/>
                r#root_name = r#root.node_name().to_string(); // <nodeName obj="root" var="rootName"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //  <assertEquals actual="rootName" expected="&quot;svg&quot;" id="svgRootNode" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="rootName" expected="&quot;staff&quot;" id="documentGetRootNodeAssert" ignoreCase="false"/>
                // </else>
                // </if>
            }
            // hc_nodeinsertbefore.xml
            #[test]
            fn test_hc_nodeinsertbefore() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#inserted_node; // type: Node // <var name="insertedNode" type="Node"/>
                let mut r#actual = vec![]; // type: List // <var name="actual" type="List"/>
                let r#expected = vec!["em", "strong", "code", "br", "sup", "var", "acronym"]; // type: List // <var name="expected" type="List"><member>"em"</member><member>"strong"</member><member>"code"</member><member>"br"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member></var>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("sup"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;sup&quot;" var="elementList"/>
                r#ref_child = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="refChild"/>
                r#employee_node = r#ref_child.parent_node().unwrap(); // <parentNode interface="Node" var="employeeNode" obj="refChild"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes var="childList" obj="employeeNode"/>
                r#new_child = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="newChild"/>
                r#inserted_node = r#employee_node
                    .insert_before(new_child.into(), Some(ref_child.into()))
                    .unwrap(); // <insertBefore var="insertedNode" obj="employeeNode" newChild="newChild" refChild="refChild"/>
                // <for-each collection="childList" member="child">
                //  <nodeType var="nodeType" obj="child"/>
                //  <if><equals actual="nodeType" expected="1"/>
                //      <nodeName obj="child" var="childName"/>
                //      <append collection="actual" item="childName"/>
                //  </if>
                // </for-each>
                for i in 0..child_list.length() {
                    child = child_list.item(i).unwrap();
                    node_type = child.node_type();
                    if node_type as i32 == 1 {
                        child_name = child.node_name().to_string();
                        actual.push(child_name);
                    }
                }
                assert_eq!(r#actual, expected); // <assertEquals actual="actual" expected="expected" id="nodeNames" ignoreCase="auto"/>
            }
            // documentinvalidcharacterexceptioncreateattribute.xml
            #[test]
            fn test_documentinvalidcharacterexceptioncreateattribute() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <createAttribute var="createdAttr" obj="doc" name="&quot;invalid^Name&quot;"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_attribute("invalid^Name")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // hc_textsplittextfour.xml
            #[test]
            fn test_hc_textsplittextfour() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#address_node; // type: Node // <var name="addressNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                r#address_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="addressNode" index="0"/>
                r#text_node = r#address_node
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild interface="Node" obj="addressNode" var="textNode"/>
                let r#split_node = r#text_node.split_text(30).unwrap(); // <splitText obj="textNode" var="splitNode" offset="30"/>
                let r#value = r#split_node.node_value().unwrap().to_string(); // <nodeValue obj="splitNode" var="value"/>
                assert_eq!(r#value, "98551"); // <assertEquals actual="value" expected="&quot;98551&quot;" id="textSplitTextFourAssert" ignoreCase="false"/>
            }
            // hc_characterdataindexsizeerrinsertdataoffsetnegative.xml
            #[test]
            fn test_hc_characterdataindexsizeerrinsertdataoffsetnegative() {
                // unimplemented: // <implementationAttribute name="signed" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // unimplemented:
                // <assertDOMException id="throws_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <replaceData obj="child" offset="-5" arg="&quot;ABC&quot;" count="3"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
            }
            // documentgetelementsbytagnametotallength.xml
            #[test]
            fn test_documentgetelementsbytagnametotallength() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#name_list; // type: NodeList // <var name="nameList" type="NodeList"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#name_list = r#doc.get_elements_by_tag_name("*"); // <getElementsByTagName interface="Document" obj="doc" var="nameList" tagname="&quot;*&quot;"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //  <assertSize collection="nameList" size="39" id="elementCountSVG"/>
                // <else>
                //  <assertSize collection="nameList" size="37" id="documentGetElementsByTagNameTotalLengthAssert"/>
                // </else>
                // </if>
            }
            // nodetextnodevalue.xml
            #[test]
            fn test_nodetextnodevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#text_node = r#test_addr.first_child().unwrap(); // <firstChild interface="Node" obj="testAddr" var="textNode"/>
                let r#text_value = r#text_node.node_value().unwrap().to_string(); // <nodeValue obj="textNode" var="textValue"/>
                assert_eq!(r#text_value, "1230 North Ave. Dallas, Texas 98551"); // <assertEquals actual="textValue" expected="&quot;1230 North Ave. Dallas, Texas 98551&quot;" id="nodeTextNodeValueAssert1" ignoreCase="false"/>
            }
            // hc_characterdatadeletedatamiddle.xml
            #[test]
            fn test_hc_characterdatadeletedatamiddle() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.delete_data(16, 8).unwrap(); // <deleteData obj="child" offset="16" count="8"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230 North Ave. Texas 98551"); // <assertEquals actual="childData" expected="&quot;1230 North Ave. Texas 98551&quot;" id="characterdataDeleteDataMiddleAssert" ignoreCase="false"/>
            }
            // hc_attrgetvalue2.xml
            #[test]
            fn test_hc_attrgetvalue2() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                // let mut r#test_node; // type: Node // <var name="testNode" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                // let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                // let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                // let mut r#alpha_ref; // type: EntityReference // <var name="alphaRef" type="EntityReference"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                // r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                // r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                // r#title_attr = r#attributes.get_named_item("class").unwrap();
                // // <getNamedItem obj="attributes" var="titleAttr" name="&quot;class&quot;"/>

                // unimplemented:
                // <if><contentType type="text/html"/>
                //  <assertDOMException id="throw_NOT_SUPPORTED_ERR">
                //      <NOT_SUPPORTED_ERR>
                //          <createEntityReference var="alphaRef" obj="doc" name="&quot;alpha&quot;"/>
                //      </NOT_SUPPORTED_ERR>
                //  </assertDOMException>
                // <else>
                //  <!--  create an alpha entity reference and place it first -->
                //  <createEntityReference var="alphaRef" obj="doc" name="&quot;alpha&quot;"/>
                //  <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                //  <insertBefore var="retval" obj="titleAttr" newChild="alphaRef" refChild="firstChild"/>
                //  <!--  check that Attr.value gives expected result   -->
                //  <value interface="Attr" obj="titleAttr" var="value"/>
                //  <assertEquals actual="value" expected="&quot;Y&quot;" id="attrValue1" ignoreCase="false"/>
                // </else>
                // </if>
            }
            // characterdatasetnodevalue.xml
            #[test]
            fn test_characterdatasetnodevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.set_node_value("Marilyn Martin").unwrap(); // <nodeValue obj="child" value="&quot;Marilyn Martin&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Marilyn Martin"); // <assertEquals actual="childData" expected="&quot;Marilyn Martin&quot;" id="data" ignoreCase="false"/>
                let r#child_value = r#child.node_value().unwrap().to_string(); // <nodeValue obj="child" var="childValue"/>
                assert_eq!(r#child_value, "Marilyn Martin"); // <assertEquals actual="childValue" expected="&quot;Marilyn Martin&quot;" id="value" ignoreCase="false"/>
            }
            // nodecommentnodetype.xml
            #[test]
            fn test_nodecommentnodetype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#test_list; // type: NodeList // <var name="testList" type="NodeList"/>
                let mut r#comment_node; // type: Node // <var name="commentNode" type="Node"/>
                let mut r#comment_node_name; // type: DOMString // <var name="commentNodeName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#test_list = r#doc.child_nodes(); // <childNodes obj="doc" var="testList"/>
                // <for-each collection="testList" member="commentNode">
                //  <nodeName obj="commentNode" var="commentNodeName"/>
                //  <if><equals actual="commentNodeName" expected="&quot;#comment&quot;" ignoreCase="false"/>
                //      <nodeType obj="commentNode" var="nodeType"/>
                //      <assertEquals actual="nodeType" expected="8" id="nodeCommentNodeTypeAssert1" ignoreCase="false"/>
                //  </if>
                // </for-each>
                for i in 0..test_list.length() {
                    comment_node = test_list.item(i).unwrap();
                    comment_node_name = comment_node.node_name().to_string();
                    if comment_node_name == "#comment" {
                        node_type = comment_node.node_type();
                        assert_eq!(node_type as i32, 8);
                    }
                }
            }
            // hc_documentcreateelement.xml
            #[test]
            fn test_hc_documentcreateelement() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#new_element = r#doc.create_element("acronym".to_string()).unwrap(); // <createElement obj="doc" var="newElement" tagName="&quot;acronym&quot;"/>
                let r#new_element_name = r#new_element.node_name().to_string(); // <nodeName obj="newElement" var="newElementName"/>
                assert_eq!(r#new_element_name, "acronym"); // <assertEquals actual="newElementName" expected="&quot;acronym&quot;" ignoreCase="auto" id="strong"/>
                let r#new_element_type = r#new_element.node_type(); // <nodeType obj="newElement" var="newElementType"/>
                assert_eq!(r#new_element_type as i32, 1); // <assertEquals actual="newElementType" expected="1" ignoreCase="false" id="type"/>
                let r#new_element_value = r#new_element.node_value(); // <nodeValue obj="newElement" var="newElementValue"/>
                assert!(new_element_value.is_none()); // <assertNull actual="newElementValue" id="valueInitiallyNull"/>
            }
            // namednodemapreturnfirstitem.xml
            #[test]
            fn test_namednodemapreturnfirstitem() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_address = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="1"/>
                let r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                let r#child = r#attributes.item(0).unwrap(); // <item interface="NamedNodeMap" obj="attributes" var="child" index="0"/>
                let r#name = r#child.node_name().to_string(); // <nodeName obj="child" var="name"/>
                // <assertTrue id="namednodemapReturnFirstItemAssert">
                //  <or>
                //      <equals actual="name" expected="&quot;domestic&quot;" ignoreCase="false"/>
                //      <equals actual="name" expected="&quot;street&quot;" ignoreCase="false"/>
                //  </or>
                // </assertTrue>
                assert!(name == "domestic" || name == "street");
            }
            // characterdatainsertdatabeginning.xml
            #[test]
            fn test_characterdatainsertdatabeginning() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.insert_data(0, "Mss. ").unwrap(); // <insertData obj="child" offset="0" arg="&quot;Mss. &quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Mss. Margaret Martin"); // <assertEquals actual="childData" expected="&quot;Mss. Margaret Martin&quot;" id="characterdataInsertDataBeginningAssert" ignoreCase="false"/>
            }
            // nodereplacechildnewchildexists.xml
            #[test]
            fn test_nodereplacechildnewchildexists() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node" isNull="true"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node" isNull="true"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#child_node; // type: Node // <var name="childNode" type="Node"/>
                let mut r#actual = vec![]; // type: List // <var name="actual" type="List"/>
                let r#expected; // type: List // <var name="expected" type="List"/>
                let r#expected_without_whitespace =
                    vec!["name", "position", "salary", "gender", "employeeId"]; // type: List // <var name="expectedWithoutWhitespace" type="List"><member>"name"</member><member>"position"</member><member>"salary"</member><member>"gender"</member><member>"employeeId"</member></var>
                let mut r#expected_with_whitespace = vec![
                    "#text",
                    "#text",
                    "name",
                    "#text",
                    "position",
                    "#text",
                    "salary",
                    "#text",
                    "gender",
                    "#text",
                    "employeeId",
                    "#text",
                ]; // type: List // <var name="expectedWithWhitespace" type="List"><member>"#text"</member><member>"#text"</member><member>"name"</member><member>"#text"</member><member>"position"</member><member>"#text"</member><member>"salary"</member><member>"#text"</member><member>"gender"</member><member>"#text"</member><member>"employeeId"</member><member>"#text"</member></var>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#length = r#child_list.length(); // <length var="length" obj="childList" interface="NodeList"/>
                // <if><equals actual="length" expected="13" ignoreCase="false"/>
                //  <item interface="NodeList" obj="childList" index="1" var="newChild"/>
                //  <item interface="NodeList" obj="childList" index="11" var="oldChild"/>
                //  <assign var="expected" value="expectedWithWhitespace"/>
                // <else>
                //  <item interface="NodeList" obj="childList" index="0" var="newChild"/>
                //  <item interface="NodeList" obj="childList" index="5" var="oldChild"/>
                //  <assign var="expected" value="expectedWithoutWhitespace"/>
                // </else>
                // </if>
                if length == 13 {
                    new_child = child_list.item(1).unwrap();
                    old_child = child_list.item(11).unwrap();
                    expected = expected_with_whitespace;
                } else {
                    new_child = child_list.item(0).unwrap();
                    old_child = child_list.item(5).unwrap();
                    expected = expected_without_whitespace;
                }
                let r#replaced_child = r#employee_node
                    .replace_child(new_child, old_child.clone())
                    .unwrap(); // <replaceChild var="replacedChild" obj="employeeNode" newChild="newChild" oldChild="oldChild"/>

                assert!(replaced_child.is_same_node(&old_child)); // <assertSame actual="replacedChild" expected="oldChild" id="return_value_same"/>
                // <for-each collection="childList" member="childNode">
                //  <nodeName var="childName" obj="childNode"/>
                //  <append collection="actual" item="childName"/>
                // </for-each>
                for i in 0..child_list.length() {
                    child_node = child_list.item(i).unwrap();
                    child_name = child_node.node_name().to_string();
                    actual.push(child_name);
                }
                assert_eq!(r#actual, expected); // <assertEquals actual="actual" expected="expected" id="childNames" ignoreCase="false"/>
            }
            // characterdatasetdatanomodificationallowederrEE.xml
            #[test]
            fn test_characterdatasetdatanomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let mut r#ent_text; // type: Node // <var name="entText" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(4).unwrap(); // <item interface="NodeList" obj="genderList" index="4" var="genderNode"/>
                let r#ent_reference = r#doc.create_entity_reference("ent3".to_string()).unwrap(); // <createEntityReference var="entReference" obj="doc" name="&quot;ent3&quot;"/>
                // unimplemented: // <assertNotNull actual="entReference" id="createdEntRefNotNull"/>
                r#ent_text = r#ent_reference
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild var="entText" obj="entReference" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entText" id="entTextNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <data interface="CharacterData" obj="entText" value="&quot;newData&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_text
                        .set_data("newData")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_nodeinsertbeforeinvalidnodetype.xml
            #[test]
            fn test_hc_nodeinsertbeforeinvalidnodetype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Element // <var name="rootNode" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#new_child = r#doc.create_attribute("title".to_string()).unwrap(); // <createAttribute obj="doc" name="&quot;title&quot;" var="newChild"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#ref_child = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="refChild"/>
                r#root_node = r#ref_child.parent_node().unwrap(); // <parentNode var="rootNode" obj="refChild" interface="Node"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <insertBefore var="insertedNode" obj="rootNode" newChild="newChild" refChild="refChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    root_node
                        .insert_before(new_child.into(), Some(ref_child.into()))
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // elementremoveattributenodenomodificationallowederr.xml
            #[test]
            fn test_elementremoveattributenodenomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender; // type: Node // <var name="gender" type="Node"/>
                let r#gen_list; // type: NodeList // <var name="genList" type="NodeList"/>
                let mut r#gen; // type: Node // <var name="gen" type="Node"/>
                let r#g_list; // type: NodeList // <var name="gList" type="NodeList"/>
                let mut r#gen_element; // type: Element // <var name="genElement" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#gen_list = r#gender.child_nodes(); // <childNodes obj="gender" var="genList"/>
                r#gen = r#gen_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="genList" var="gen" index="0"/>
                // unimplemented: // <assertNotNull actual="gen" id="genNotNull"/>
                let r#node_type = r#gen.node_type(); // <nodeType var="nodeType" obj="gen"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="gen" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="gen" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    r#gen = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#g_list = r#gen.child_nodes(); // <childNodes obj="gen" var="gList"/>
                r#gen_element = r#g_list.item(0).unwrap().clone().as_element().unwrap(); // <item interface="NodeList" obj="gList" var="genElement" index="0"/>
                // unimplemented: // <assertNotNull actual="genElement" id="genElementNotNull"/>
                let r#attr_list = r#gen_element.attributes(); // <attributes obj="genElement" var="attrList"/>
                let r#attr_node = r#attr_list.get_named_item("domestic").unwrap(); // <getNamedItem obj="attrList" var="attrNode" name="&quot;domestic&quot;"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <removeAttributeNode var="removedAttr" obj="genElement" oldAttr="attrNode"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    gen_element
                        .remove_attribute_node(attr_node)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_documentgetelementsbytagnametotallength.xml
            #[test]
            fn test_hc_documentgetelementsbytagnametotallength() {
                let mut r#expected_names = vec![
                    "html", "head", "meta", "title", "script", "script", "script", "body", "p",
                    "em", "strong", "code", "sup", "var", "acronym", "p", "em", "strong", "code",
                    "sup", "var", "acronym", "p", "em", "strong", "code", "sup", "var", "acronym",
                    "p", "em", "strong", "code", "sup", "var", "acronym", "p", "em", "strong",
                    "code", "sup", "var", "acronym",
                ]; // type: List // <var name="expectedNames" type="List"><member>"html"</member><member>"head"</member><member>"meta"</member><member>"title"</member><member>"script"</member><member>"script"</member><member>"script"</member><member>"body"</member><member>"p"</member><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member><member>"p"</member><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member> <member>"var"</member><member>"acronym"</member><member>"p"</member> <member>"em"</member> <member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member><member>"p"</member><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member><member>"p"</member><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member></var>
                let mut r#svg_expected_names = vec![
                    "svg", "rect", "script", "head", "meta", "title", "body", "p", "em", "strong",
                    "code", "sup", "var", "acronym", "p", "em", "strong", "code", "sup", "var",
                    "acronym", "p", "em", "strong", "code", "sup", "var", "acronym", "p", "em",
                    "strong", "code", "sup", "var", "acronym", "p", "em", "strong", "code", "sup",
                    "var", "acronym",
                ]; // type: List // <var name="svgExpectedNames" type="List"><member>"svg"</member><member>"rect"</member><member>"script"</member><member>"head"</member><member>"meta"</member><member>"title"</member><member>"body"</member><member>"p"</member><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member><member>"p"</member><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member><member>"p"</member><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member><member>"p"</member> <member>"em"</member> <member>"strong"</member> <member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member><member>"p"</member><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member></var>
                let mut r#actual_names = vec![]; // type: List // <var name="actualNames" type="List"/>
                let mut r#this_tag; // type: DOMString // <var name="thisTag" type="DOMString"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#name_list = r#doc.get_elements_by_tag_name("*"); // <getElementsByTagName interface="Document" obj="doc" var="nameList" tagname="&quot;*&quot;"/>
                // <for-each collection="nameList" member="thisElement">
                //  <tagName var="thisTag" obj="thisElement"/>
                //  <append collection="actualNames" item="thisTag"/>
                // </for-each>
                for i in 0..name_list.length() {
                    let this_element = name_list.item(i).unwrap();
                    this_tag = this_element.tag_name().to_string();
                    actual_names.push(this_tag);
                }

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //  <assertEquals expected="svgExpectedNames" actual="actualNames" ignoreCase="auto" id="svgTagNames"/>
                // <else>
                //  <assertEquals expected="expectedNames" actual="actualNames" ignoreCase="auto" id="tagNames"/>
                // </else>
                // </if>
            }
            // nodesetnodevaluenomodificationallowederrEE.xml
            #[test]
            fn test_nodesetnodevaluenomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#ent_text; // type: CharacterData // <var name="entText" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#ent_ref = r#doc.create_entity_reference("ent3".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent3&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                r#ent_text = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" var="entText" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entText" id="entTextNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <nodeValue obj="entText" value="&quot;newValue&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_text
                        .set_node_value("newValue")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // characterdatadeletedatanomodificationallowederrEE.xml
            #[test]
            fn test_characterdatadeletedatanomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let mut r#ent_text; // type: Node // <var name="entText" type="Node"/>
                let r#ent_reference; // type: EntityReference // <var name="entReference" type="EntityReference"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" index="2" var="genderNode"/>
                r#ent_reference = r#doc.create_entity_reference("ent3".to_string()).unwrap(); // <createEntityReference obj="doc" var="entReference" name="&quot;ent3&quot;"/>
                // unimplemented: // <assertNotNull actual="entReference" id="createdEntRefNotNull"/>
                r#appended_child = r#gender_node
                    .append_child(ent_reference.clone().into())
                    .unwrap(); // <appendChild obj="genderNode" newChild="entReference" var="appendedChild"/>
                r#ent_text = r#ent_reference
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild var="entText" obj="entReference" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entText" id="entTextNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <deleteData obj="entText" offset="1" count="3"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_text
                        .delete_data(1, 3)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodelistindexnotzero.xml
            #[test]
            fn test_nodelistindexnotzero() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#length = r#employee_list.length(); // <length var="length" obj="employeeList" interface="NodeList"/>
                // <if><equals actual="length" expected="6" ignoreCase="false"/>
                //  <item interface="NodeList" obj="employeeList" var="child" index="1"/>
                // <else>
                //  <item interface="NodeList" obj="employeeList" var="child" index="3"/>
                // </else>
                // </if>
                let child = if length == 6 {
                    employee_list.item(1).unwrap()
                } else {
                    employee_list.item(3).unwrap()
                };
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                assert_eq!(r#child_name, "name"); // <assertEquals actual="childName" expected="&quot;name&quot;" id="nodeName" ignoreCase="false"/>
            }
            // hc_characterdataindexsizeerrreplacedataoffsetnegative.xml
            #[test]
            fn test_hc_characterdataindexsizeerrreplacedataoffsetnegative() {
                // unimplemented: // <implementationAttribute name="signed" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // unimplemented:
                // <assertDOMException id="throws_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <replaceData obj="child" offset="-5" count="3" arg="&quot;ABC&quot;"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
            }
            // nodeentitynodetype.xml
            #[test]
            fn test_nodeentitynodetype() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#entities = doc_type.entities(); // <entities obj="docType" var="entities"/>
                // unimplemented: // <assertNotNull actual="entities" id="entitiesNotNull"/>
                let r#entity_node = r#entities.get_named_item("ent1").unwrap(); // <getNamedItem obj="entities" var="entityNode" name="&quot;ent1&quot;"/>
                // unimplemented: // <assertNotNull actual="entityNode" id="ent1NotNull"/>
                let r#node_type = r#entity_node.node_type(); // <nodeType obj="entityNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 6); // <assertEquals actual="nodeType" expected="6" id="entityNodeType" ignoreCase="false"/>
            }
            // hc_nodehaschildnodesfalse.xml
            #[test]
            fn test_hc_nodehaschildnodesfalse() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#em_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;em&quot;" var="emList"/>
                let r#em_node = r#em_list.item(0).unwrap(); // <item interface="NodeList" obj="emList" index="0" var="emNode"/>
                let r#em_text = r#em_node.first_child().unwrap(); // <firstChild var="emText" obj="emNode" interface="Node"/>
                let r#has_child = r#em_text.has_child_nodes(); // <hasChildNodes var="hasChild" obj="emText" interface="Node"/>
                assert!(!r#has_child); // <assertFalse actual="hasChild" id="hasChild"/>
            }
            // hc_characterdatasetnodevalue.xml
            #[test]
            fn test_hc_characterdatasetnodevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.set_node_value("Marilyn Martin").unwrap(); // <nodeValue obj="child" value="&quot;Marilyn Martin&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Marilyn Martin"); // <assertEquals actual="childData" expected="&quot;Marilyn Martin&quot;" id="data" ignoreCase="false"/>
                let r#child_value = r#child.node_value().unwrap().to_string(); // <nodeValue obj="child" var="childValue"/>
                assert_eq!(r#child_value, "Marilyn Martin"); // <assertEquals actual="childValue" expected="&quot;Marilyn Martin&quot;" id="value" ignoreCase="false"/>
            }
            // characterdataindexsizeerrdeletedataoffsetgreater.xml
            #[test]
            fn test_characterdataindexsizeerrdeletedataoffsetgreater() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                // <assertDOMException id="throw_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <deleteData obj="child" offset="40" count="3"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
                assert!(
                    child
                        .delete_data(40, 3)
                        .is_err_and(|err| err == DOMException::IndexSizeErr)
                );
            }
            // nodeattributenodetype.xml
            #[test]
            fn test_nodeattributenodetype() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#addr_attr = r#test_addr.get_attribute_node("domestic").unwrap(); // <getAttributeNode obj="testAddr" name="&quot;domestic&quot;" var="addrAttr"/>
                let r#node_type = r#addr_attr.node_type(); // <nodeType obj="addrAttr" var="nodeType"/>
                assert_eq!(r#node_type as i32, 2); // <assertEquals actual="nodeType" expected="2" id="nodeAttrNodeTypeAssert1" ignoreCase="false"/>
            }
            // hc_attrchildnodes1.xml
            #[test]
            fn test_hc_attrchildnodes1() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let r#text_node; // type: Text // <var name="textNode" type="Text"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                let r#child_nodes = r#title_attr.child_nodes(); // <childNodes var="childNodes" obj="titleAttr"/>
                assert_eq!(child_nodes.length(), 1); // <assertSize size="1" collection="childNodes" id="childNodesSize"/>
                r#text_node = r#child_nodes.item(0).unwrap().clone(); // <item var="textNode" obj="childNodes" index="0" interface="NodeList"/>
                let r#value = r#text_node.node_value().unwrap().to_string(); // <nodeValue var="value" obj="textNode"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="child1IsYes" ignoreCase="false"/>
                let r#text_node = r#child_nodes.item(1); // <item var="textNode" obj="childNodes" index="1" interface="NodeList"/>
                assert!(text_node.is_none()); // <assertNull actual="textNode" id="secondItemIsNull"/>
            }
            // elementreplaceexistingattribute.xml
            #[test]
            fn test_elementreplaceexistingattribute() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#set_attr; // type: Attr // <var name="setAttr" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                r#new_attribute = r#doc.create_attribute("street".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;street&quot;"/>
                r#set_attr = r#test_employee
                    .set_attribute_node(r#new_attribute)
                    .unwrap()
                    .unwrap(); // <setAttributeNode var="setAttr" obj="testEmployee" newAttr="newAttribute"/>
                let r#name = r#test_employee.get_attribute("street"); // <getAttribute obj="testEmployee" var="name" name="&quot;street&quot;"/>
                assert_eq!(r#name, ""); // <assertEquals actual="name" expected="&quot;&quot;" id="elementReplaceExistingAttributeAssert" ignoreCase="false"/>
            }
            // hc_elementcreatenewattribute.xml
            #[test]
            fn test_hc_elementcreatenewattribute() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#district_attr; // type: Attr // <var name="districtAttr" type="Attr"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_address = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddress"/>
                r#new_attribute = r#doc.create_attribute("lang".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;lang&quot;"/>
                let r#old_attr = r#test_address.set_attribute_node(r#new_attribute).unwrap(); // <setAttributeNode obj="testAddress" var="oldAttr" newAttr="newAttribute"/>
                assert!(old_attr.is_none()); // <assertNull actual="oldAttr" id="old_attr_doesnt_exist"/>
                r#district_attr = r#test_address.get_attribute_node("lang").unwrap(); // <getAttributeNode obj="testAddress" var="districtAttr" name="&quot;lang&quot;"/>
                // unimplemented: // <assertNotNull actual="districtAttr" id="new_district_accessible"/>
                let r#attr_val = r#test_address.get_attribute("lang"); // <getAttribute var="attrVal" obj="testAddress" name="&quot;lang&quot;"/>
                assert_eq!(r#attr_val, ""); // <assertEquals actual="attrVal" expected="&quot;&quot;" id="attr_value" ignoreCase="false"/>
            }
            // namednodemapremovenameditemgetvalue.xml
            #[test]
            fn test_namednodemapremovenameditemgetvalue() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let r#street_attr; // type: Attr // <var name="streetAttr" type="Attr"/>
                let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="2"/>
                r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                // unimplemented: // <assertNotNull actual="attributes" id="attributesNotNull"/>
                r#removed_node = r#attributes.remove_named_item("street").unwrap(); // <removeNamedItem var="removedNode" obj="attributes" name="&quot;street&quot;"/>
                r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                // unimplemented: // <assertNotNull actual="streetAttr" id="streetAttrNotNull"/>
                let r#value = r#street_attr.value().to_string(); // <value interface="Attr" obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="namednodemapRemoveNamedItemGetValueAssert" ignoreCase="false"/>
            }
            // elementsetattributenodenomodificationallowederrEE.xml
            #[test]
            fn test_elementsetattributenodenomodificationallowederr_ee() {
                // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender; // type: Node // <var name="gender" type="Node"/>
                let r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                let r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                r#appended_child = r#gender.append_child(ent_ref.clone().into()).unwrap(); // <appendChild obj="gender" newChild="entRef" var="appendedChild"/>
                r#ent_element = r#ent_ref.first_child().unwrap().as_element().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#new_attr = r#doc.create_attribute("newAttr".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttr" name="&quot;newAttr&quot;"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <setAttributeNode var="badAttr" obj="entElement" newAttr="newAttr"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element
                        .set_attribute_node(new_attr)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_nodechildnodes.xml
            #[test]
            fn test_hc_nodechildnodes() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let mut r#child_node; // type: Node // <var name="childNode" type="Node"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#actual = vec![]; // type: List // <var name="actual" type="List"/>
                let r#expected = vec!["em", "strong", "code", "sup", "var", "acronym"]; // type: List // <var name="expected" type="List"><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member></var>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_nodes = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childNodes"/>
                // <for-each collection="childNodes" member="childNode">
                //  <nodeType var="nodeType" obj="childNode"/>
                //  <nodeName var="childName" obj="childNode"/>
                //  <if><equals actual="nodeType" expected="1"/>
                //      <append collection="actual" item="childName"/>
                //  <else>
                //      <assertEquals actual="nodeType" expected="3" ignoreCase="false" id="textNodeType"/>
                //  </else>
                //  </if>
                // </for-each>
                for i in 0..child_nodes.length() {
                    child_node = child_nodes.item(i).unwrap();
                    node_type = child_node.node_type();
                    child_name = child_node.node_name().to_string();
                    if node_type as i32 == 1 {
                        actual.push(child_name);
                    } else {
                        assert_eq!(node_type as i32, 3);
                    }
                }
                assert_eq!(r#actual, expected); // <assertEquals actual="actual" expected="expected" id="elementNames" ignoreCase="auto"/>
            }
            // nodecdatasectionnodevalue.xml
            #[test]
            fn test_nodecdatasectionnodevalue() {
                // unimplemented: // <implementationAttribute name="coalescing" value="false"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;name&quot;"/>
                let r#cdata_name = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="cdataName"/>
                let r#child_list = r#cdata_name.child_nodes(); // <childNodes obj="cdataName" var="childList"/>
                let r#child = r#child_list.item(1).unwrap().clone(); // <item interface="NodeList" obj="childList" index="1" var="child"/>
                // <if><isNull obj="child"/>
                //  <createCDATASection var="child" obj="doc" data="&quot;This is a CDATASection with EntityReference number 2 &amp;ent2;&quot;"/>
                // </if>
                let r#cdata_node_value = r#child.node_value().unwrap().to_string(); // <nodeValue obj="child" var="cdataNodeValue"/>
                assert_eq!(
                    r#cdata_node_value,
                    "This is a CDATASection with EntityReference number 2 &ent2;"
                ); // <assertEquals actual="cdataNodeValue" expected="&quot;This is a CDATASection with EntityReference number 2 &amp;ent2;&quot;" id="value" ignoreCase="false"/>
            }
            // characterdataindexsizeerrreplacedatacountnegative.xml
            #[test]
            fn test_characterdataindexsizeerrreplacedatacountnegative() {
                // unimplemented: // <implementationAttribute name="signed" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // unimplemented:
                // <assertDOMException id="throws_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <replaceData obj="child" offset="10" count="-3" arg="&quot;ABC&quot;"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
            }
            // documenttypegetnotationstype.xml
            #[test]
            fn test_documenttypegetnotationstype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let r#notation_list; // type: NamedNodeMap // <var name="notationList" type="NamedNodeMap"/>
                let mut r#notation; // type: Node // <var name="notation" type="Node"/>
                let mut r#notation_type; // type: int // <var name="notationType" type="int"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                notation_list = doc_type.notations(); // <notations obj="docType" var="notationList"/>
                // unimplemented: // <assertNotNull actual="notationList" id="notationsNotNull"/>
                // <for-each collection="notationList" member="notation">
                //  <nodeType obj="notation" var="notationType"/>
                //  <assertEquals actual="notationType" expected="12" id="documenttypeGetNotationsTypeAssert" ignoreCase="false"/>
                // </for-each>
                for i in 0..notation_list.length() {
                    notation = notation_list.item(i).unwrap();
                    notation_type = notation.node_type();
                    assert_eq!(notation_type as i32, 12);
                }
            }
            // hc_characterdatainsertdataend.xml
            #[test]
            fn test_hc_characterdatainsertdataend() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.insert_data(15, ", Esquire").unwrap(); // <insertData obj="child" offset="15" arg="&quot;, Esquire&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Margaret Martin, Esquire"); // <assertEquals actual="childData" expected="&quot;Margaret Martin, Esquire&quot;" id="characterdataInsertDataEndAssert" ignoreCase="false"/>
            }
            // hc_nodevalue06.xml
            #[test]
            fn test_hc_nodevalue06() {
                let mut r#new_node: DocumentRef; // <var name="newNode" type="Document"/>
                r#new_node = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="newNode" href="hc_staff" willBeModified="true"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="initiallyNull"/>
                r#new_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
            }
            // hc_documentcreatetextnode.xml
            #[test]
            fn test_hc_documentcreatetextnode() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#new_text_node = r#doc.create_text_node("This is a new Text node"); // <createTextNode obj="doc" var="newTextNode" data="&quot;This is a new Text node&quot;"/>
                let r#new_text_value = r#new_text_node.node_value().unwrap().to_string(); // <nodeValue obj="newTextNode" var="newTextValue"/>
                assert_eq!(r#new_text_value, "This is a new Text node"); // <assertEquals actual="newTextValue" expected="&quot;This is a new Text node&quot;" ignoreCase="false" id="value"/>
                let r#new_text_name = r#new_text_node.node_name().to_string(); // <nodeName obj="newTextNode" var="newTextName"/>
                assert_eq!(r#new_text_name, "#text"); // <assertEquals actual="newTextName" expected="&quot;#text&quot;" ignoreCase="false" id="strong"/>
                let r#new_text_type = r#new_text_node.node_type(); // <nodeType obj="newTextNode" var="newTextType"/>
                assert_eq!(r#new_text_type as i32, 3); // <assertEquals actual="newTextType" expected="3" ignoreCase="false" id="type"/>
            }
            // hc_nodelistindexnotzero.xml
            #[test]
            fn test_hc_nodelistindexnotzero() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;p&quot;"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#child = r#employee_list.item(3).unwrap().clone(); // <item interface="NodeList" obj="employeeList" var="child" index="3"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                // <if><equals expected="&quot;#text&quot;" actual="childName"/>
                //  <assertEquals id="childName_space" actual="childName" expected="&quot;#text&quot;" ignoreCase="false"/>
                // <else>
                //  <assertEquals id="childName_strong" actual="childName" expected="&quot;strong&quot;" ignoreCase="auto"/>
                // </else>
                // </if>
                if child_name == "#text" {
                    assert_eq!(child_name, "#text");
                } else {
                    assert_eq!(child_name, "strong");
                }
            }
            // elementremoveattributeaftercreate.xml
            #[test]
            fn test_elementremoveattributeaftercreate() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#district_attr; // type: Attr // <var name="districtAttr" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                r#new_attribute = r#doc.create_attribute("district".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;district&quot;"/>
                r#district_attr = r#test_employee
                    .set_attribute_node(r#new_attribute.clone())
                    .unwrap(); // <setAttributeNode obj="testEmployee" var="districtAttr" newAttr="newAttribute"/>
                let r#district_attr = r#test_employee
                    .remove_attribute_node(r#new_attribute)
                    .unwrap(); // <removeAttributeNode obj="testEmployee" var="districtAttr" oldAttr="newAttribute"/>
                r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#district_attr = r#attributes.get_named_item("district"); // <getNamedItem obj="attributes" var="districtAttr" name="&quot;district&quot;"/>
                assert!(district_attr.is_none()); // <assertNull actual="districtAttr" id="elementRemoveAttributeAfterCreateAssert"/>
            }
            // hc_nodechildnodesappendchild.xml
            #[test]
            fn test_hc_nodechildnodesappendchild() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#created_node; // type: Node // <var name="createdNode" type="Node"/>
                let mut r#child_node; // type: Node // <var name="childNode" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#child_type; // type: int // <var name="childType" type="int"/>
                let mut r#actual = vec![]; // type: List // <var name="actual" type="List"/>
                let r#expected = vec!["em", "strong", "code", "sup", "var", "acronym", "br"]; // type: List // <var name="expected" type="List"><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member><member>"br"</member></var>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#created_node = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" var="createdNode" tagName="&quot;br&quot;"/>
                r#employee_node = r#employee_node
                    .append_child(created_node.into())
                    .unwrap()
                    .as_element()
                    .unwrap(); // <appendChild obj="employeeNode" newChild="createdNode" var="employeeNode"/>
                // <for-each collection="childList" member="childNode">
                //  <nodeName var="childName" obj="childNode"/>
                //  <nodeType var="childType" obj="childNode"/>
                //  <if><equals actual="childType" expected="1"/>
                //      <append collection="actual" item="childName"/>
                //  <else>
                //      <assertEquals id="textNodeType" actual="childType" expected="3" ignoreCase="false"/>
                //  </else>
                //  </if>
                // </for-each>
                for i in 0..child_list.length() {
                    child_node = child_list.item(i).unwrap();
                    child_name = child_node.node_name().to_string();
                    child_type = child_node.node_type();
                    if child_type as i32 == 1 {
                        actual.push(child_name);
                    } else {
                        assert_eq!(child_type as i32, 3);
                    }
                }
                assert_eq!(r#actual, expected); // <assertEquals actual="actual" expected="expected" id="childElements" ignoreCase="auto"/>
            }
            // nodeelementnodeattributes.xml
            #[test]
            fn test_nodeelementnodeattributes() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                let r#addr_attr; // type: NamedNodeMap // <var name="addrAttr" type="NamedNodeMap"/>
                let mut r#attr_node; // type: Node // <var name="attrNode" type="Node"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                let mut r#attr_list = vec![]; // type: Collection // <var name="attrList" type="Collection"/>
                let r#expected = vec!["domestic", "street"]; // type: Collection // <var name="expected" type="Collection"><member>"domestic"</member><member>"street"</member></var>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_addr = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testAddr"/>
                r#addr_attr = r#test_addr.attributes(); // <attributes obj="testAddr" var="addrAttr"/>
                // <for-each collection="addrAttr" member="attrNode">
                //  <nodeName obj="attrNode" var="attrName"/>
                //  <append collection="attrList" item="attrName"/>
                // </for-each>
                for i in 0..addr_attr.length() {
                    attr_node = addr_attr.item(i).unwrap();
                    attr_name = attr_node.node_name().to_string();
                    attr_list.push(attr_name);
                }
                attr_list.sort();
                assert_eq!(r#attr_list, expected); // <assertEquals actual="attrList" expected="expected" id="nodeElementNodeValueAssert1" ignoreCase="false"/>
            }
            // nodeappendchildchildexists.xml
            #[test]
            fn test_nodeappendchildchildexists() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#child_node; // type: Node // <var name="childNode" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#lchild; // type: Node // <var name="lchild" type="Node"/>
                let r#fchild; // type: Node // <var name="fchild" type="Node"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#child_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="childNode"/>
                r#new_child = r#child_node.first_child().unwrap(); // <firstChild interface="Node" obj="childNode" var="newChild"/>
                let r#initial_name = r#new_child.node_name().to_string(); // <nodeName var="initialName" obj="newChild"/>
                r#appended_child = r#child_node.append_child(new_child).unwrap(); // <appendChild var="appendedChild" obj="childNode" newChild="newChild"/>
                r#fchild = r#child_node.first_child().unwrap(); // <firstChild interface="Node" obj="childNode" var="fchild"/>
                let r#fchild_name = r#fchild.node_name().to_string(); // <nodeName obj="fchild" var="fchildName"/>
                r#lchild = r#child_node.last_child().unwrap(); // <lastChild interface="Node" obj="childNode" var="lchild"/>
                let r#lchild_name = r#lchild.node_name().to_string(); // <nodeName obj="lchild" var="lchildName"/>
                // <if><equals actual="initialName" expected="&quot;employeeId&quot;" ignoreCase="false"/>
                //  <assertEquals id="assert1_nowhitespace" actual="fchildName" expected="&quot;name&quot;" ignoreCase="false"/>
                //  <assertEquals id="assert2_nowhitespace" actual="lchildName" expected="&quot;employeeId&quot;" ignoreCase="false"/>
                // <else>
                //  <assertEquals id="assert1" actual="fchildName" expected="&quot;employeeId&quot;" ignoreCase="false"/>
                //  <assertEquals id="assert2" actual="lchildName" expected="&quot;#text&quot;" ignoreCase="false"/>
                // </else>
                // </if>
                if initial_name == "employeeId" {
                    assert_eq!(fchild_name, "name");
                    assert_eq!(lchild_name, "employeeId");
                } else {
                    assert_eq!(fchild_name, "employeeId");
                    assert_eq!(lchild_name, "#text");
                }
            }
            // attrsetvaluenomodificationallowederrEE.xml
            #[test]
            fn test_attrsetvaluenomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                let r#attr_list; // type: NamedNodeMap // <var name="attrList" type="NamedNodeMap"/>
                let mut r#attr_node; // type: Node // <var name="attrNode" type="Node"/>
                let mut r#gender; // type: Node // <var name="gender" type="Node"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                // unimplemented: // <assertNotNull actual="gender" id="genderNotNull"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference obj="doc" var="entRef" name="&quot;ent4&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="entRefNotNull"/>
                r#appended_child = r#gender.append_child(ent_ref.clone().into()).unwrap(); // <appendChild obj="gender" newChild="entRef" var="appendedChild"/>
                r#ent_element = r#ent_ref.first_child().unwrap(); // <firstChild obj="entRef" var="entElement" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#attr_list = r#ent_element.attributes().unwrap(); // <attributes obj="entElement" var="attrList"/>
                r#attr_node = r#attr_list.get_named_item("domestic").unwrap(); // <getNamedItem obj="attrList" var="attrNode" name="&quot;domestic&quot;"/>
                // <assertDOMException id="setValue_throws_NO_MODIFICATION">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <value interface="Attr" obj="attrNode" value="&quot;newvalue&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    attr_node
                        .set_value("newvalue")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
                // <assertDOMException id="setNodeValue_throws_NO_MODIFICATION">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <nodeValue interface="Node" obj="attrNode" value="&quot;newvalue2&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    attr_node
                        .set_node_value("newvalue2")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_nodecommentnodetype.xml
            #[test]
            fn test_hc_nodecommentnodetype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#test_list; // type: NodeList // <var name="testList" type="NodeList"/>
                let mut r#comment_node; // type: Node // <var name="commentNode" type="Node"/>
                let mut r#comment_node_name; // type: DOMString // <var name="commentNodeName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#test_list = r#doc.child_nodes(); // <childNodes obj="doc" var="testList"/>
                // <for-each collection="testList" member="commentNode">
                //  <nodeName obj="commentNode" var="commentNodeName"/>
                //  <if><equals actual="commentNodeName" expected="&quot;#comment&quot;" ignoreCase="false"/>
                //      <nodeType obj="commentNode" var="nodeType"/>
                //      <assertEquals actual="nodeType" expected="8" id="existingCommentNodeType" ignoreCase="false"/>
                //  </if>
                // </for-each>
                for i in 0..test_list.length() {
                    comment_node = test_list.item(i).unwrap();
                    comment_node_name = comment_node.node_name().to_string();
                    if comment_node_name == "#comment" {
                        node_type = comment_node.node_type();
                        assert_eq!(node_type as i32, 8);
                    }
                }
                let r#comment_node = r#doc.create_comment("This is a comment"); // <createComment var="commentNode" obj="doc" data="&quot;This is a comment&quot;"/>
                r#node_type = r#comment_node.node_type(); // <nodeType obj="commentNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 8); // <assertEquals actual="nodeType" expected="8" id="createdCommentNodeType" ignoreCase="false"/>
            }
            // hc_characterdataindexsizeerrreplacedatacountnegative.xml
            #[test]
            fn test_hc_characterdataindexsizeerrreplacedatacountnegative() {
                // // unimplemented: // <implementationAttribute name="signed" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                // let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                // let mut r#bad_string; // type: DOMString // <var name="badString" type="DOMString"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                // r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                // r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // // unimplemented:
                // // <assertDOMException id="throws_INDEX_SIZE_ERR">
                // //  <INDEX_SIZE_ERR>
                // //      <substringData var="badString" obj="child" offset="10" count="-3"/>
                // //  </INDEX_SIZE_ERR>
                // // </assertDOMException>
            }
            // hc_domimplementationfeaturexml.xml
            #[test]
            fn test_hc_domimplementationfeaturexml() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // unimplemented:
                // <if><contentType type="text/html"/>
                //  <hasFeature obj="domImpl" var="state" feature="&quot;html&quot;" version="&quot;1.0&quot;"/>
                //  <assertTrue actual="state" id="supports_html_1.0"/>
                // <else>
                //  <hasFeature obj="domImpl" var="state" feature="&quot;xml&quot;" version="&quot;1.0&quot;"/>
                //  <assertTrue actual="state" id="supports_xml_1.0"/>
                // </else>
                // </if>
            }
            // nodeattributenodename.xml
            #[test]
            fn test_nodeattributenodename() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#addr_attr = r#test_addr.get_attribute_node("domestic").unwrap(); // <getAttributeNode obj="testAddr" name="&quot;domestic&quot;" var="addrAttr"/>
                let r#attr_name = r#addr_attr.node_name().to_string(); // <nodeName obj="addrAttr" var="attrName"/>
                assert_eq!(r#attr_name, "domestic"); // <assertEquals actual="attrName" expected="&quot;domestic&quot;" id="nodeAttributeNodeNameAssert1" ignoreCase="false"/>
            }
            // noderemovechild.xml
            #[test]
            fn test_noderemovechild() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Element // <var name="rootNode" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                let r#child_list = r#root_node.child_nodes(); // <childNodes obj="rootNode" var="childList"/>
                let r#child_to_remove = r#child_list.item(1).unwrap().clone(); // <item interface="NodeList" obj="childList" index="1" var="childToRemove"/>
                let r#removed_child = r#root_node.remove_child(child_to_remove).unwrap(); // <removeChild obj="rootNode" var="removedChild" oldChild="childToRemove"/>
                let r#parent_node = r#removed_child.parent_node(); // <parentNode interface="Node" obj="removedChild" var="parentNode"/>
                assert!(parent_node.is_none()); // <assertNull actual="parentNode" id="nodeRemoveChildAssert1"/>
            }
            // nodedocumentfragmentnodetype.xml
            #[test]
            fn test_nodedocumentfragmentnodetype() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#document_fragment_node = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="documentFragmentNode"/>
                let r#node_type = r#document_fragment_node.node_type(); // <nodeType obj="documentFragmentNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 11); // <assertEquals actual="nodeType" expected="11" id="nodeDocumentFragmentNodeTypeAssert1" ignoreCase="false"/>
            }
            // attrname.xml
            #[test]
            fn test_attrname() {
                let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                let r#test_node = r#address_list.item(1).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="1"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                r#name = r#street_attr.node_name().to_string(); // <nodeName obj="streetAttr" var="name"/>
                assert_eq!(r#name, "street"); // <assertEquals actual="name" expected="&quot;street&quot;" id="nodeName" ignoreCase="false"/>
                r#name = r#street_attr.name().to_string(); // <name obj="streetAttr" var="name" interface="Attr"/>
                assert_eq!(r#name, "street"); // <assertEquals actual="name" expected="&quot;street&quot;" id="name" ignoreCase="false"/>
            }
            // nodesetnodevaluenomodificationallowederr.xml
            #[test]
            fn test_nodesetnodevaluenomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                let mut r#ent_element_text; // type: CharacterData // <var name="entElementText" type="CharacterData"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item obj="genderList" index="2" var="genderNode" interface="NodeList"/>
                r#ent_ref = r#gender_node.first_child().unwrap(); // <firstChild interface="Node" var="entRef" obj="genderNode"/>
                // unimplemented: // <assertNotNull actual="entRef" id="entRefNotNull"/>
                r#node_type = r#ent_ref.node_type(); // <nodeType var="nodeType" obj="entRef"/>
                // unimplemented: // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>	<createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>	<assertNotNull actual="entRef" id="createdEntRefNotNull"/></if>
                r#ent_element = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#ent_element_text = r#ent_element.first_child().unwrap(); // <firstChild interface="Node" var="entElementText" obj="entElement"/>
                // unimplemented: // <assertNotNull actual="entElementText" id="entElementTextNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <nodeValue obj="entElementText" value="&quot;newValue&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element_text
                        .set_node_value("newValue")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_documentinvalidcharacterexceptioncreateelement.xml
            #[test]
            fn test_hc_documentinvalidcharacterexceptioncreateelement() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <createElement var="badElement" obj="doc" tagName="&quot;invalid^Name&quot;"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_element("invalid^Name")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // documentcreateentityreferenceknown.xml
            #[test]
            fn test_documentcreateentityreferenceknown() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_ent_ref_node; // type: EntityReference // <var name="newEntRefNode" type="EntityReference"/>
                let mut r#new_ent_ref_list; // type: NodeList // <var name="newEntRefList" type="NodeList"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_ent_ref_node = r#doc.create_entity_reference("ent3".to_string()).unwrap(); // <createEntityReference obj="doc" var="newEntRefNode" name="&quot;ent3&quot;"/>
                // unimplemented: // <assertNotNull actual="newEntRefNode" id="createdEntRefNotNull"/>
                r#new_ent_ref_list = r#new_ent_ref_node.child_nodes(); // <childNodes obj="newEntRefNode" var="newEntRefList"/>
                // unimplemented: // <assertSize collection="newEntRefList" size="1" id="size"/>
                let r#child = r#new_ent_ref_node.first_child().unwrap(); // <firstChild interface="Node" obj="newEntRefNode" var="child"/>
                let r#name = r#child.node_name().to_string(); // <nodeName obj="child" var="name"/>
                assert_eq!(r#name, "#text"); // <assertEquals actual="name" expected="&quot;#text&quot;" ignoreCase="false" id="name"/>
                let r#value = r#child.node_value().unwrap().to_string(); // <nodeValue obj="child" var="value"/>
                assert_eq!(r#value, "Texas"); // <assertEquals actual="value" expected="&quot;Texas&quot;" ignoreCase="false" id="value"/>
            }
            // hc_documentgetelementsbytagnamevalue.xml
            #[test]
            fn test_hc_documentgetelementsbytagnamevalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#name_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" var="nameList" tagname="&quot;strong&quot;"/>
                let r#name_node = r#name_list.item(3).unwrap(); // <item interface="NodeList" obj="nameList" var="nameNode" index="3"/>
                let r#first_child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="firstChild"/>
                let r#child_value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="childValue"/>
                assert_eq!(r#child_value, "Jeny Oconnor"); // <assertEquals actual="childValue" expected="&quot;Jeny Oconnor&quot;" id="documentGetElementsByTagNameValueAssert" ignoreCase="false"/>
            }
            // nodevalue07.xml
            #[test]
            fn test_nodevalue07() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                let mut r#new_value; // type: DOMString // <var name="newValue" type="DOMString"/>
                let r#node_map; // type: NamedNodeMap // <var name="nodeMap" type="NamedNodeMap"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                node_map = doc_type.entities(); // <entities obj="docType" var="nodeMap"/>
                // unimplemented: // <assertNotNull actual="nodeMap" id="entitiesNotNull"/>
                r#new_node = r#node_map.get_named_item("ent1").unwrap(); // <getNamedItem obj="nodeMap" name="&quot;ent1&quot;" var="newNode"/>
                // unimplemented: // <assertNotNull actual="newNode" id="entityNotNull"/>
                r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="initiallyNull"/>
                r#new_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
            }
            // hc_characterdataappenddatagetdata.xml
            #[test]
            fn test_hc_characterdataappenddatagetdata() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.append_data(", Esquire").unwrap(); // <appendData obj="child" arg="&quot;, Esquire&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Margaret Martin, Esquire"); // <assertEquals actual="childData" expected="&quot;Margaret Martin, Esquire&quot;" id="characterdataAppendDataGetDataAssert" ignoreCase="false"/>
            }
            // hc_nodeattributenodename.xml
            #[test]
            fn test_hc_nodeattributenodename() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#addr_attr = r#test_addr.get_attribute_node("title").unwrap(); // <getAttributeNode obj="testAddr" name="&quot;title&quot;" var="addrAttr"/>
                let r#attr_name = r#addr_attr.node_name().to_string(); // <nodeName obj="addrAttr" var="attrName"/>
                assert_eq!(r#attr_name, "title"); // <assertEquals actual="attrName" expected="&quot;title&quot;" id="nodeName" ignoreCase="auto" context="attribute"/>
            }
            // namednodemapsetnameditemreturnvalue.xml
            #[test]
            fn test_namednodemapsetnameditemreturnvalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                r#new_attribute = r#doc.create_attribute("street".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;street&quot;"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                let r#new_node = r#attributes
                    .set_named_item(r#new_attribute)
                    .unwrap()
                    .unwrap(); // <setNamedItem interface="NamedNodeMap" obj="attributes" var="newNode" arg="newAttribute"/>
                let r#attr_value = r#new_node.node_value().unwrap().to_string(); // <nodeValue obj="newNode" var="attrValue"/>
                assert_eq!(r#attr_value, "No"); // <assertEquals actual="attrValue" expected="&quot;No&quot;" id="returnedNodeValue" ignoreCase="false"/>
            }
            // attrnextsiblingnull.xml
            #[test]
            fn test_attrnextsiblingnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("domestic").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;domestic&quot;"/>
                let r#s = r#domestic_attr.next_sibling(); // <nextSibling interface="Node" obj="domesticAttr" var="s"/>
                assert!(s.is_none()); // <assertNull actual="s" id="attrNextSiblingNullAssert"/>
            }
            // hc_characterdatainsertdatabeginning.xml
            #[test]
            fn test_hc_characterdatainsertdatabeginning() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.insert_data(0, "Mss. ").unwrap(); // <insertData obj="child" offset="0" arg="&quot;Mss. &quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Mss. Margaret Martin"); // <assertEquals actual="childData" expected="&quot;Mss. Margaret Martin&quot;" id="characterdataInsertDataBeginningAssert" ignoreCase="false"/>
            }
            // hc_documentgetdoctype.xml
            #[test]
            fn test_hc_documentgetdoctype() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#doc_type_name; // type: DOMString // <var name="docTypeName" type="DOMString"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>

                // // unimplemented: // <if><not><contentType type="text/html"/></not>	<assertNotNull actual="docType" id="docTypeNotNull"/></if>

                // // unimplemented: // <if><notNull obj="docType"/>		<name interface="DocumentType" obj="docType" var="docTypeName"/>		<if><contentType type="image/svg+xml"/>			<assertEquals actual="docTypeName" expected="&quot;svg&quot;" id="nodeNameSVG" ignoreCase="false"/>			<else>				<assertEquals actual="docTypeName" expected="&quot;html&quot;" id="nodeName" ignoreCase="false"/>			</else>		</if>		<nodeValue obj="docType" var="nodeValue"/>		<assertNull actual="nodeValue" id="nodeValue"/>		<attributes var="attributes" obj="docType"/>		<assertNull actual="attributes" id="attributes"/></if>
            }
            // hc_attrgetvalue1.xml
            #[test]
            fn test_hc_attrgetvalue1() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                let r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#title_attr = r#attributes.get_named_item("class").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;class&quot;"/>
                let r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Y"); // <assertEquals actual="value" expected="&quot;Y&quot;" id="attrValue1" ignoreCase="false"/>
            }
            // characterdataindexsizeerrdeletedatacountnegative.xml
            #[test]
            fn test_characterdataindexsizeerrdeletedatacountnegative() {
                // unimplemented: // <implementationAttribute name="signed" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // unimplemented:
                // <assertDOMException id="throws_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <deleteData obj="child" offset="10" count="-3"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
            }
            // hc_elementreplaceattributewithself.xml
            #[test]
            fn test_hc_elementreplaceattributewithself() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                let r#street_attr = r#test_employee.get_attribute_node("class").unwrap(); // <getAttributeNode var="streetAttr" obj="testEmployee" name="&quot;class&quot;"/>
                let r#replaced_attr = r#test_employee
                    .set_attribute_node(r#street_attr.clone())
                    .unwrap()
                    .unwrap(); // <setAttributeNode obj="testEmployee" var="replacedAttr" newAttr="streetAttr"/>

                assert!(replaced_attr.is_same_node(&street_attr.into())); // <assertSame actual="replacedAttr" expected="streetAttr" id="replacedAttr"/>
            }
            // nodeprocessinginstructionnodeattributes.xml
            #[test]
            fn test_nodeprocessinginstructionnodeattributes() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#test_list = r#doc.child_nodes(); // <childNodes obj="doc" var="testList"/>
                let r#pi_node = r#test_list
                    .item(0)
                    .unwrap()
                    .clone()
                    .as_processing_instruction()
                    .unwrap(); // <item interface="NodeList" obj="testList" index="0" var="piNode"/>
                let r#attr_list = r#pi_node.attributes(); // <attributes obj="piNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="nodeProcessingInstructionNodeAttrAssert1"/>
            }
            // elementreplaceexistingattributegevalue.xml
            #[test]
            fn test_elementreplaceexistingattributegevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                let r#new_attribute = r#doc.create_attribute("street".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;street&quot;"/>
                let r#street_attr = r#test_employee
                    .set_attribute_node(r#new_attribute)
                    .unwrap()
                    .unwrap(); // <setAttributeNode obj="testEmployee" var="streetAttr" newAttr="newAttribute"/>
                let r#value = r#street_attr.value().to_string(); // <value interface="Attr" obj="streetAttr" var="value"/>
                assert_eq!(r#value, "No"); // <assertEquals actual="value" expected="&quot;No&quot;" id="streetNo" ignoreCase="false"/>
            }
            // nodeinsertbeforenodename.xml
            #[test]
            fn test_nodeinsertbeforenodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#ref_child = r#child_list.item(3).unwrap().clone(); // <item interface="NodeList" obj="childList" index="3" var="refChild"/>
                let r#new_child = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="newChild"/>
                let r#inserted_node = r#employee_node
                    .insert_before(new_child.into(), Some(ref_child))
                    .unwrap(); // <insertBefore obj="employeeNode" newChild="newChild" refChild="refChild" var="insertedNode"/>
                let r#child_name = r#inserted_node.node_name().to_string(); // <nodeName obj="insertedNode" var="childName"/>
                assert_eq!(r#child_name, "newChild"); // <assertEquals actual="childName" expected="&quot;newChild&quot;" id="nodeInsertBeforeNodeNameAssert1" ignoreCase="false"/>
            }
            // hc_nodevalue03.xml
            #[test]
            fn test_hc_nodevalue03() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // let mut r#new_value; // type: DOMString // <var name="newValue" type="DOMString"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // // unimplemented: // <if><contentType type="text/html"/>	<assertDOMException id="throw_NOT_SUPPORTED_ERR">		<NOT_SUPPORTED_ERR>			<createEntityReference obj="doc" var="newNode" name="&quot;ent1&quot;"/>		</NOT_SUPPORTED_ERR>	</assertDOMException><else><createEntityReference obj="doc" var="newNode" name="&quot;ent1&quot;"/><assertNotNull actual="newNode" id="createdEntRefNotNull"/>	<nodeValue obj="newNode" var="newValue"/><assertNull actual="newValue" id="initiallyNull"/><!--   attempt to change the value and make sure that it stays null  --><nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/><nodeValue obj="newNode" var="newValue"/><assertNull actual="newValue" id="nullAfterAttemptedChange"/></else></if>
            }
            // nodeparentnodenull.xml
            #[test]
            fn test_nodeparentnodenull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#created_node = r#doc.create_element("employee".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;employee&quot;" var="createdNode"/>
                let r#parent_node = r#created_node.parent_node(); // <parentNode interface="Node" obj="createdNode" var="parentNode"/>
                assert!(parent_node.is_none()); // <assertNull actual="parentNode" id="parentNode"/>
            }
            // hc_nodeclonefalsenocopytext.xml
            #[test]
            fn test_hc_nodeclonefalsenocopytext() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#child_node = r#child_list.item(3).unwrap().clone(); // <item interface="NodeList" obj="childList" index="3" var="childNode"/>
                let r#cloned_node = r#child_node.clone_node(false); // <cloneNode obj="childNode" deep="false" var="clonedNode"/>
                let r#last_child_node = r#cloned_node.last_child(); // <lastChild interface="Node" obj="clonedNode" var="lastChildNode"/>
                assert!(last_child_node.is_none()); // <assertNull actual="lastChildNode" id="nodeCloneFalseNoCopyTextAssert1"/>
            }
            // hc_noderemovechildnode.xml
            #[test]
            fn test_hc_noderemovechildnode() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#em_list; // type: NodeList // <var name="emList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let r#expected = vec!["strong", "code", "sup", "var", "acronym"]; // type: List // <var name="expected" type="List"><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member></var>
                let mut r#actual = vec![]; // type: List // <var name="actual" type="List"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#em_list = r#employee_node.get_elements_by_tag_name("em"); // <getElementsByTagName interface="Element" var="emList" obj="employeeNode" tagname="&quot;em&quot;"/>
                r#old_child = r#em_list.item(0).unwrap(); // <item interface="NodeList" obj="emList" index="0" var="oldChild"/>
                let r#removed_child = r#employee_node.remove_child(old_child.into()).unwrap(); // <removeChild var="removedChild" obj="employeeNode" oldChild="oldChild"/>
                let r#removed_name = r#removed_child.node_name().to_string(); // <nodeName obj="removedChild" var="removedName"/>
                assert_eq!(r#removed_name, "em"); // <assertEquals actual="removedName" expected="&quot;em&quot;" ignoreCase="auto" id="removedName"/>
                // <for-each collection="childList" member="child">
                //  <nodeType var="nodeType" obj="child"/>
                //  <nodeName var="childName" obj="child"/>
                //  <if><equals expected="1" actual="nodeType"/>
                //      <append collection="actual" item="childName"/>
                //  <else>
                //      <assertEquals expected="3" actual="nodeType" id="textNodeType" ignoreCase="false"/>
                //      <assertEquals expected="&quot;#text&quot;" actual="childName" id="textNodeName" ignoreCase="false"/>
                //  </else>
                //  </if>
                // </for-each>
                for i in 0..child_list.length() {
                    child = child_list.item(i).unwrap();
                    node_type = child.node_type();
                    child_name = child.node_name().to_string();
                    if node_type as i32 == 1 {
                        actual.push(child_name);
                    } else {
                        assert_eq!(node_type as i32, 3);
                        assert_eq!(child_name, "#text");
                    }
                }
                assert_eq!(r#actual, expected); // <assertEquals actual="actual" expected="expected" ignoreCase="auto" id="childNames"/>
            }
            // hc_nodeattributenodetype.xml
            #[test]
            fn test_hc_nodeattributenodetype() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#addr_attr = r#test_addr.get_attribute_node("title").unwrap(); // <getAttributeNode obj="testAddr" name="&quot;title&quot;" var="addrAttr"/>
                let r#node_type = r#addr_attr.node_type(); // <nodeType obj="addrAttr" var="nodeType"/>
                assert_eq!(r#node_type as i32, 2); // <assertEquals actual="nodeType" expected="2" id="nodeAttrNodeTypeAssert1" ignoreCase="false"/>
            }
            // attrspecifiedvalue.xml
            #[test]
            fn test_attrspecifiedvalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("domestic").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;domestic&quot;"/>
                let r#state = r#domestic_attr.specified(); // <specified obj="domesticAttr" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="domesticSpecified"/>
            }
            // noderemovechildnomodificationallowederr.xml
            #[test]
            fn test_noderemovechildnomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item obj="genderList" index="2" var="genderNode" interface="NodeList"/>
                r#ent_ref = r#gender_node.first_child().unwrap(); // <firstChild interface="Node" var="entRef" obj="genderNode"/>
                // unimplemented: // <assertNotNull actual="entRef" id="entRefNotNull"/>
                let r#node_type = r#ent_ref.node_type(); // <nodeType var="nodeType" obj="entRef"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    ent_ref = doc.create_entity_reference("ent4").unwrap().into();
                }
                let r#ent_element = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <removeChild var="removedNode" obj="entRef" oldChild="entElement"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_ref
                        .remove_child(ent_element)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_attrcreatetextnode.xml
            #[test]
            fn test_hc_attrcreatetextnode() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#address_list; // type: NodeList // <var name="addressList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#street_attr; // type: Attr // <var name="streetAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#address_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#address_list.item(3).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#street_attr = r#attributes.get_named_item("class").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;class&quot;"/>
                r#street_attr.set_value("Y&ent1;").unwrap(); // <value interface="Attr" obj="streetAttr" value="&quot;Y&amp;ent1;&quot;"/>
                r#value = r#street_attr.value().to_string(); // <value interface="Attr" obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Y&ent1;"); // <assertEquals actual="value" expected="&quot;Y&amp;ent1;&quot;" id="value" ignoreCase="false"/>
                r#value = r#street_attr.node_value().unwrap().to_string(); // <nodeValue obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Y&ent1;"); // <assertEquals actual="value" expected="&quot;Y&amp;ent1;&quot;" id="nodeValue" ignoreCase="false"/>
            }
            // elementretrieveallattributes.xml
            #[test]
            fn test_elementretrieveallattributes() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="addressList"/>
                let r#test_address = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" index="0" var="testAddress"/>
                let r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                assert_eq!(attributes.length(), 2); // <assertSize collection="attributes" size="2" id="elementRetrieveAllAttributesAssert"/>
            }
            // documentgetdoctypenodtd.xml
            #[test]
            fn test_documentgetdoctypenodtd() {
                // unimplemented: // <implementationAttribute name="validating" value="false"/>
                let r#doc: DocumentRef = hc_nodtdstaff_xml(HC_NODTDSTAFF_XML).unwrap(); // hc_nodtdstaff.xml // <load var="doc" href="hc_nodtdstaff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype(); // <doctype obj="doc" var="docType"/>
                assert!(doc_type.is_none()); // <assertNull actual="docType" id="documentGetDocTypeNoDTDAssert"/>
            }
            // hc_attrappendchild3.xml
            #[test]
            fn test_hc_attrappendchild3() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let r#ter_node; // type: Text // <var name="terNode" type="Text"/>
                let r#day_node; // type: Text // <var name="dayNode" type="Text"/>
                let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                let r#last_child; // type: Node // <var name="lastChild" type="Node"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#ter_node = r#doc.create_text_node("ter"); // <createTextNode var="terNode" obj="doc" data="&quot;ter&quot;"/>
                r#day_node = r#doc.create_text_node("day"); // <createTextNode var="dayNode" obj="doc" data="&quot;day&quot;"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#retval = r#doc_frag.append_child(ter_node.into()).unwrap(); // <appendChild var="retval" obj="docFrag" newChild="terNode"/>
                r#retval = r#doc_frag.append_child(day_node.into()).unwrap(); // <appendChild var="retval" obj="docFrag" newChild="dayNode"/>
                r#retval = r#title_attr.append_child(doc_frag.into()).unwrap(); // <appendChild var="retval" obj="titleAttr" newChild="docFrag"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrNodeValue" ignoreCase="false"/>
                let r#value = r#retval.node_value(); // <nodeValue obj="retval" var="value"/>
                assert!(value.is_none()); // <assertNull actual="value" id="retvalValue"/>
                r#last_child = r#title_attr.last_child().unwrap(); // <lastChild var="lastChild" obj="titleAttr" interface="Node"/>
                let r#value = r#last_child.node_value().unwrap().to_string(); // <nodeValue obj="lastChild" var="value"/>
                assert_eq!(r#value, "day"); // <assertEquals actual="value" expected="&quot;day&quot;" id="lastChildValue" ignoreCase="false"/>
            }
            // characterdatadeletedatamiddle.xml
            #[test]
            fn test_characterdatadeletedatamiddle() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.delete_data(16, 8).unwrap(); // <deleteData obj="child" offset="16" count="8"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230 North Ave. Texas 98551"); // <assertEquals actual="childData" expected="&quot;1230 North Ave. Texas 98551&quot;" id="characterdataDeleteDataMiddleAssert" ignoreCase="false"/>
            }
            // nodegetnextsibling.xml
            #[test]
            fn test_nodegetnextsibling() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#employee_id_node; // type: Node // <var name="employeeIdNode" type="Node"/>
                let mut r#ns_node; // type: Node // <var name="nsNode" type="Node"/>
                let mut r#ns_name; // type: DOMString // <var name="nsName" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employeeId"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employeeId&quot;" var="elementList"/>
                r#employee_id_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeIdNode"/>
                r#ns_node = r#employee_id_node.next_sibling().unwrap(); // <nextSibling interface="Node" obj="employeeIdNode" var="nsNode"/>
                r#ns_name = r#ns_node.node_name().to_string(); // <nodeName obj="nsNode" var="nsName"/>
                // <if><equals actual="nsName" expected="&quot;#text&quot;" ignoreCase="false"/>
                //  <nextSibling interface="Node" obj="nsNode" var="nsNode"/>
                //  <nodeName obj="nsNode" var="nsName"/>
                // </if>
                if ns_name == "#text" {
                    ns_node = ns_node.next_sibling().unwrap();
                    ns_name = ns_node.node_name().to_string();
                }
                assert_eq!(r#ns_name, "name"); // <assertEquals actual="nsName" expected="&quot;name&quot;" id="nodeName" ignoreCase="false"/>
            }
            // hc_elementgetelementsbytagnameaccessnodelist.xml
            #[test]
            fn test_hc_elementgetelementsbytagnameaccessnodelist() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let mut r#first_c; // type: Node // <var name="firstC" type="Node"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(3).unwrap(); // <item interface="NodeList" obj="elementList" index="3" var="testEmployee"/>
                r#first_c = r#test_employee.first_child().unwrap(); // <firstChild interface="Node" obj="testEmployee" var="firstC"/>
                r#node_type = r#first_c.node_type(); // <nodeType var="nodeType" obj="firstC"/>
                // <while><equals actual="nodeType" expected="3"/>
                //  <nextSibling interface="Node" var="firstC" obj="firstC"/>
                //  <nodeType var="nodeType" obj="firstC"/>
                // </while>
                while node_type as i32 == 3 {
                    first_c = first_c.next_sibling().unwrap();
                    node_type = first_c.node_type();
                }
                let r#child_name = r#first_c.node_name().to_string(); // <nodeName obj="firstC" var="childName"/>
                assert_eq!(r#child_name, "em"); // <assertEquals actual="childName" expected="&quot;em&quot;" id="childName" ignoreCase="auto"/>
                let r#employee_id_node = r#first_c.first_child().unwrap(); // <firstChild interface="Node" var="employeeIDNode" obj="firstC"/>
                let r#employee_id = r#employee_id_node.node_value().unwrap().to_string(); // <nodeValue var="employeeID" obj="employeeIDNode"/>
                assert_eq!(r#employee_id, "EMP0004"); // <assertEquals actual="employeeID" expected="&quot;EMP0004&quot;" ignoreCase="false" id="employeeID"/>
            }
            // nodeentityreferencenodeattributes.xml
            #[test]
            fn test_nodeentityreferencenodeattributes() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#ent_ref_addr; // type: Element // <var name="entRefAddr" type="Element"/>
                let mut r#ent_ref_node; // type: Node // <var name="entRefNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#ent_ref_addr = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="entRefAddr"/>
                r#ent_ref_node = r#ent_ref_addr.first_child().unwrap(); // <firstChild interface="Node" obj="entRefAddr" var="entRefNode"/>
                let r#node_type = r#ent_ref_node.node_type(); // <nodeType var="nodeType" obj="entRefNode"/>
                // <if><notEquals actual="nodeType" expected="5" ignoreCase="false"/>
                //  <createEntityReference var="entRefNode" obj="doc" name="&quot;ent2&quot;"/>
                //  <assertNotNull actual="entRefNode" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 5 {
                    ent_ref_node = doc.create_entity_reference("ent2").unwrap().into();
                }
                let r#attr_list = r#ent_ref_node.attributes(); // <attributes obj="entRefNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="attrList"/>
            }
            // nodeelementnodetype.xml
            #[test]
            fn test_nodeelementnodetype() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                let r#node_type = r#root_node.node_type(); // <nodeType obj="rootNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 1); // <assertEquals actual="nodeType" expected="1" id="nodeElementNodeTypeAssert1" ignoreCase="false"/>
            }
            // documentcreateelement.xml
            #[test]
            fn test_documentcreateelement() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#new_element = r#doc.create_element("address".to_string()).unwrap(); // <createElement obj="doc" var="newElement" tagName="&quot;address&quot;"/>
                let r#new_element_name = r#new_element.node_name().to_string(); // <nodeName obj="newElement" var="newElementName"/>
                assert_eq!(r#new_element_name, "address"); // <assertEquals actual="newElementName" expected="&quot;address&quot;" ignoreCase="false" id="name"/>
                let r#new_element_type = r#new_element.node_type(); // <nodeType obj="newElement" var="newElementType"/>
                assert_eq!(r#new_element_type as i32, 1); // <assertEquals actual="newElementType" expected="1" ignoreCase="false" id="type"/>
                let r#new_element_value = r#new_element.node_value(); // <nodeValue obj="newElement" var="newElementValue"/>
                assert!(new_element_value.is_none()); // <assertNull actual="newElementValue" id="valueInitiallyNull"/>
            }
            // hc_entitiessetnameditem1.xml
            #[test]
            fn test_hc_entitiessetnameditem1() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <if><not><contentType type="text/html"/></not><assertNotNull actual="docType" id="docTypeNotNull"/><entities var="entities" obj="docType"/><assertNotNull actual="entities" id="entitiesNotNull"/><createElement var="elem" obj="doc" tagName="&quot;br&quot;"/><try>	<setNamedItem var="retval" obj="entities" arg="elem"/>	<fail id="throw_HIER_OR_NO_MOD_ERR"/>	<catch>		<DOMException code="HIERARCHY_REQUEST_ERR"/>		<DOMException code="NO_MODIFICATION_ALLOWED_ERR"/>	</catch></try> </if>
            }
            // textsplittextone.xml
            #[test]
            fn test_textsplittextone() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#split_node; // type: Text // <var name="splitNode" type="Text"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;name&quot;"/>
                r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                r#text_node = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="textNode"/>
                r#split_node = r#text_node.split_text(7).unwrap(); // <splitText obj="textNode" var="splitNode" offset="7"/>
                let r#second_part = r#text_node.next_sibling().unwrap(); // <nextSibling interface="Node" obj="textNode" var="secondPart"/>
                let r#value = r#second_part.node_value().unwrap().to_string(); // <nodeValue obj="secondPart" var="value"/>
                assert_eq!(r#value, "Jones"); // <assertEquals actual="value" expected="&quot;Jones&quot;" id="textSplitTextOneAssert" ignoreCase="false"/>
            }
            // attrspecifiedvaluechanged.xml
            #[test]
            fn test_attrspecifiedvaluechanged() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#address_list; // type: NodeList // <var name="addressList" type="NodeList"/>
                let mut r#test_node; // type: Node // <var name="testNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                r#test_node = r#address_list.item(2).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="2"/>
                r#test_node.set_attribute("street", "Yes").unwrap(); // <setAttribute obj="testNode" name="&quot;street&quot;" value="&quot;Yes&quot;"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                let r#state = r#street_attr.specified(); // <specified obj="streetAttr" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="streetSpecified"/>
            }
            // hc_nodegetfirstchildnull.xml
            #[test]
            fn test_hc_nodegetfirstchildnull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#em_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;em&quot;" var="emList"/>
                let r#em_node = r#em_list.item(0).unwrap(); // <item interface="NodeList" obj="emList" index="0" var="emNode"/>
                let r#em_text = r#em_node.first_child().unwrap(); // <firstChild var="emText" obj="emNode" interface="Node"/>
                let r#null_child = r#em_text.first_child(); // <firstChild var="nullChild" obj="emText" interface="Node"/>
                assert!(null_child.is_none()); // <assertNull actual="nullChild" id="nullChild"/>
            }
            // characterdatadeletedatabegining.xml
            #[test]
            fn test_characterdatadeletedatabegining() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.delete_data(0, 16).unwrap(); // <deleteData obj="child" offset="0" count="16"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Dallas, Texas 98551"); // <assertEquals actual="childData" expected="&quot;Dallas, Texas 98551&quot;" id="characterdataDeleteDataBeginingAssert" ignoreCase="false"/>
            }
            // hc_attrreplacechild2.xml
            #[test]
            fn test_hc_attrreplacechild2() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let r#ter_node; // type: Text // <var name="terNode" type="Text"/>
                let r#day_node; // type: Text // <var name="dayNode" type="Text"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                let mut r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#ter_node = r#doc.create_text_node("ter"); // <createTextNode var="terNode" obj="doc" data="&quot;ter&quot;"/>
                r#day_node = r#doc.create_text_node("day"); // <createTextNode var="dayNode" obj="doc" data="&quot;day&quot;"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#retval = r#doc_frag.append_child(ter_node.into()).unwrap(); // <appendChild var="retval" obj="docFrag" newChild="terNode"/>
                r#retval = r#doc_frag.append_child(day_node.into()).unwrap(); // <appendChild var="retval" obj="docFrag" newChild="dayNode"/>
                r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                // unimplemented: // <assertNotNull actual="firstChild" id="attrChildNotNull"/>
                r#retval = r#title_attr
                    .replace_child(doc_frag.into(), first_child)
                    .unwrap(); // <replaceChild var="retval" obj="titleAttr" newChild="docFrag" oldChild="firstChild"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="attrNodeValue" ignoreCase="false"/>
                r#value = r#retval.node_value().unwrap().to_string(); // <nodeValue obj="retval" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="retvalValue" ignoreCase="false"/>
                r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                r#value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="value"/>
                assert_eq!(r#value, "ter"); // <assertEquals actual="value" expected="&quot;ter&quot;" id="firstChildValue" ignoreCase="false"/>
            }
            // hc_documentcreatedocumentfragment.xml
            #[test]
            fn test_hc_documentcreatedocumentfragment() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#new_doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="newDocFragment"/>
                let r#children = r#new_doc_fragment.child_nodes(); // <childNodes obj="newDocFragment" var="children"/>
                let r#length = r#children.length(); // <length interface="NodeList" obj="children" var="length"/>
                assert_eq!(r#length, 0); // <assertEquals actual="length" expected="0" ignoreCase="false" id="length"/>
                let r#new_doc_fragment_name = r#new_doc_fragment.node_name().to_string(); // <nodeName obj="newDocFragment" var="newDocFragmentName"/>
                assert_eq!(r#new_doc_fragment_name, "#document-fragment"); // <assertEquals actual="newDocFragmentName" expected="&quot;#document-fragment&quot;" ignoreCase="false" id="strong"/>
                let r#new_doc_fragment_type = r#new_doc_fragment.node_type(); // <nodeType obj="newDocFragment" var="newDocFragmentType"/>
                assert_eq!(r#new_doc_fragment_type as i32, 11); // <assertEquals actual="newDocFragmentType" expected="11" ignoreCase="false" id="type"/>
                let r#new_doc_fragment_value = r#new_doc_fragment.node_value(); // <nodeValue obj="newDocFragment" var="newDocFragmentValue"/>
                assert!(new_doc_fragment_value.is_none()); // <assertNull actual="newDocFragmentValue" id="value"/>
            }
            // hc_attrspecifiedvalue.xml
            #[test]
            fn test_hc_attrspecifiedvalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;acronym&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;title&quot;"/>
                let r#state = r#domestic_attr.specified(); // <specified obj="domesticAttr" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="acronymTitleSpecified"/>
            }
            // elementgetelementempty.xml
            #[test]
            fn test_elementgetelementempty() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let mut r#domestic_attr; // type: Attr // <var name="domesticAttr" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_attribute = r#doc.create_attribute("district".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;district&quot;"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(3).unwrap(); // <item interface="NodeList" obj="elementList" index="3" var="testEmployee"/>
                r#domestic_attr = r#test_employee.set_attribute_node(r#new_attribute).unwrap(); // <setAttributeNode obj="testEmployee" var="domesticAttr" newAttr="newAttribute"/>
                let r#attr_value = r#test_employee.get_attribute("district"); // <getAttribute obj="testEmployee" var="attrValue" name="&quot;district&quot;"/>
                assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" id="elementGetElementEmptyAssert" ignoreCase="false"/>
            }
            // elementchangeattributevalue.xml
            #[test]
            fn test_elementchangeattributevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(3).unwrap(); // <item interface="NodeList" obj="elementList" index="3" var="testEmployee"/>
                r#test_employee.set_attribute("street", "Neither").unwrap(); // <setAttribute obj="testEmployee" name="&quot;street&quot;" value="&quot;Neither&quot;"/>
                let r#attr_value = r#test_employee.get_attribute("street"); // <getAttribute obj="testEmployee" var="attrValue" name="&quot;street&quot;"/>
                assert_eq!(r#attr_value, "Neither"); // <assertEquals actual="attrValue" expected="&quot;Neither&quot;" id="elementChangeAttributeValueAssert" ignoreCase="false"/>
            }
            // hc_nodedocumentnodevalue.xml
            #[test]
            fn test_hc_nodedocumentnodevalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#document_value = r#doc.node_value(); // <nodeValue obj="doc" var="documentValue"/>
                assert!(document_value.is_none()); // <assertNull actual="documentValue" id="documentNodeValue"/>
            }
            // hc_elementgetelementsbytagnamenomatch.xml
            #[test]
            fn test_hc_elementgetelementsbytagnamenomatch() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("noMatch"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;noMatch&quot;" var="elementList"/>
                assert_eq!(element_list.length(), 0); // <assertSize collection="elementList" size="0" id="elementGetElementsByTagNameNoMatchNoMatchAssert"/>
            }
            // elementinvalidcharacterexception.xml
            #[test]
            fn test_elementinvalidcharacterexception() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_address = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddress"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <setAttribute obj="testAddress" name="&quot;invalid^Name&quot;" value="&quot;value&quot;"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    test_address
                        .set_attribute("invalid^Name", "value")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // processinginstructionsetdatanomodificationallowederrEE.xml
            #[test]
            fn test_processinginstructionsetdatanomodificationallowederr_ee() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender; // type: Node // <var name="gender" type="Node"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                let mut r#pi_node; // type: ProcessingInstruction // <var name="piNode" type="ProcessingInstruction"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                r#appended_child = r#gender.append_child(ent_ref.into()).unwrap(); // <appendChild var="appendedChild" obj="gender" newChild="entRef"/>
                r#ent_ref = r#gender
                    .last_child()
                    .unwrap()
                    .as_entity_reference()
                    .unwrap(); // <lastChild interface="Node" var="entRef" obj="gender"/>
                // unimplemented: // <assertNotNull actual="entRef" id="entRefNotNull"/>
                r#pi_node = r#ent_ref
                    .last_child()
                    .unwrap()
                    .as_processing_instruction()
                    .unwrap(); // <lastChild interface="Node" var="piNode" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="piNode" id="piNodeNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR"
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <data interface="ProcessingInstruction" obj="piNode" value="&quot;newData&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    pi_node
                        .set_data("newData")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // domimplementationfeaturenoversion.xml
            #[test]
            fn test_domimplementationfeaturenoversion() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                let r#state = dom_impl.has_feature("XML", Some("")); // <hasFeature obj="domImpl" var="state" feature="&quot;XML&quot;" version="&quot;&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="hasXMLEmpty"/>
            }
            // hc_attrlastchild.xml
            #[test]
            fn test_hc_attrlastchild() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                let r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                let r#text_node = r#title_attr.first_child().unwrap(); // <firstChild var="textNode" obj="titleAttr" interface="Node"/>
                // unimplemented: // <assertNotNull actual="textNode" id="textNodeNotNull"/>
                let r#value = r#text_node.node_value().unwrap().to_string(); // <nodeValue var="value" obj="textNode"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="child1IsYes" ignoreCase="false"/>
                let r#other_child = r#text_node.next_sibling(); // <nextSibling var="otherChild" obj="textNode" interface="Node"/>
                assert!(other_child.is_none()); // <assertNull actual="otherChild" id="nextSiblingIsNull"/>
                let r#other_child = r#text_node.previous_sibling(); // <previousSibling var="otherChild" obj="textNode" interface="Node"/>
                assert!(other_child.is_none()); // <assertNull actual="otherChild" id="previousSiblingIsNull"/>
            }
            // nodereplacechildnodename.xml
            #[test]
            fn test_nodereplacechildnodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#length = r#child_list.length(); // <length var="length" obj="childList" interface="NodeList"/>
                let r#old_child = r#child_list.item(1).unwrap().clone(); // <item interface="NodeList" obj="childList" index="1" var="oldChild"/>
                let r#new_child = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="newChild"/>
                let r#replaced_node = r#employee_node
                    .replace_child(new_child.into(), old_child)
                    .unwrap(); // <replaceChild obj="employeeNode" newChild="newChild" oldChild="oldChild" var="replacedNode"/>
                let r#child_name = r#replaced_node.node_name().to_string(); // <nodeName obj="replacedNode" var="childName"/>
                // <if><equals actual="length" expected="6" ignoreCase="false"/>
                //  <assertEquals actual="childName" expected="&quot;name&quot;" id="nowhitespace" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="childName" expected="&quot;employeeId&quot;" id="whitespace" ignoreCase="false"/>
                // </else>
                // </if>
                if length == 6 {
                    assert_eq!(child_name, "name");
                } else {
                    assert_eq!(child_name, "employeeId");
                }
            }
            // nodecloneattributescopied.xml
            #[test]
            fn test_nodecloneattributescopied() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#address_node; // type: Node // <var name="addressNode" type="Node"/>
                let r#cloned_node; // type: Node // <var name="clonedNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#attribute_node; // type: Node // <var name="attributeNode" type="Node"/>
                let mut r#attribute_name; // type: DOMString // <var name="attributeName" type="DOMString"/>
                let mut r#result = vec![]; // type: Collection // <var name="result" type="Collection"/>
                let r#expected_result = vec!["domestic", "street"]; // type: Collection // <var name="expectedResult" type="Collection"><member>"domestic"</member><member>"street"</member></var>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#address_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="addressNode"/>
                r#cloned_node = r#address_node.clone_node(false); // <cloneNode obj="addressNode" deep="false" var="clonedNode"/>
                r#attributes = r#cloned_node.attributes().unwrap(); // <attributes obj="clonedNode" var="attributes"/>
                // <for-each collection="attributes" member="attributeNode">
                //  <nodeName obj="attributeNode" var="attributeName"/>
                //  <append collection="result" item="attributeName"/>
                // </for-each>
                for i in 0..attributes.length() {
                    attribute_node = attributes.item(i).unwrap();
                    attribute_name = attribute_node.node_name().to_string();
                    result.push(attribute_name);
                }
                result.sort();
                assert_eq!(r#result, expected_result); // <assertEquals actual="result" expected="expectedResult" id="nodeCloneAttributesCopiedAssert1" ignoreCase="false"/>
            }
            // attrdefaultvalue.xml
            #[test]
            fn test_attrdefaultvalue() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                let r#value = r#street_attr.node_value().unwrap().to_string(); // <nodeValue obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="attrDefaultValueAssert" ignoreCase="false"/>
            }
            // hc_attrremovechild2.xml
            #[test]
            fn test_hc_attrremovechild2() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                let r#text_node = r#doc.create_text_node("Yesterday"); // <createTextNode var="textNode" obj="doc" data="&quot;Yesterday&quot;"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <removeChild var="retval" obj="titleAttr" oldChild="textNode"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    title_attr
                        .remove_child(text_node.into())
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // nodeappendchildnewchilddiffdocument.xml
            #[test]
            fn test_nodeappendchildnewchilddiffdocument() {
                let r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc1 = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc1" href="staff" willBeModified="false"/>
                r#doc2 = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc2" href="staff" willBeModified="true"/>
                r#new_child = r#doc1.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc1" tagName="&quot;newChild&quot;" var="newChild"/>
                r#element_list = r#doc2.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc2" tagname="&quot;employee&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <appendChild var="appendedChild" obj="elementNode" newChild="newChild"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .append_child(new_child.into())
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // nodedocumentnodetype.xml
            #[test]
            fn test_nodedocumentnodetype() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#node_type = r#doc.node_type(); // <nodeType obj="doc" var="nodeType"/>
                assert_eq!(r#node_type as i32, 9); // <assertEquals actual="nodeType" expected="9" id="nodeDocumentNodeTypeAssert1" ignoreCase="false"/>
            }
            // nodereplacechildnomodificationallowederr.xml
            #[test]
            fn test_nodereplacechildnomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item obj="genderList" index="2" var="genderNode" interface="NodeList"/>
                r#ent_ref = r#gender_node.first_child().unwrap(); // <firstChild interface="Node" var="entRef" obj="genderNode"/>
                let r#node_type = r#ent_ref.node_type(); // <nodeType var="nodeType" obj="entRef"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    ent_ref = doc.create_entity_reference("ent4").unwrap().into();
                }
                let r#ent_element = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                let r#created_node = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="createdNode"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <replaceChild var="replacedChild" obj="entRef" newChild="createdNode" oldChild="entElement"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_ref
                        .replace_child(created_node.into(), ent_element)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_elementremoveattributeaftercreate.xml
            #[test]
            fn test_hc_elementremoveattributeaftercreate() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                r#new_attribute = r#doc.create_attribute("lang".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;lang&quot;"/>
                let r#district_attr = r#test_employee
                    .set_attribute_node(r#new_attribute.clone())
                    .unwrap(); // <setAttributeNode obj="testEmployee" var="districtAttr" newAttr="newAttribute"/>
                let r#district_attr = r#test_employee
                    .remove_attribute_node(r#new_attribute)
                    .unwrap(); // <removeAttributeNode obj="testEmployee" var="districtAttr" oldAttr="newAttribute"/>
                r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#district_attr = r#attributes.get_named_item("lang"); // <getNamedItem obj="attributes" var="districtAttr" name="&quot;lang&quot;"/>
                assert!(district_attr.is_none()); // <assertNull actual="districtAttr" id="removed_item_null"/>
            }
            // hc_nodeattributenodevalue.xml
            #[test]
            fn test_hc_nodeattributenodevalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#addr_attr = r#test_addr.get_attribute_node("title").unwrap(); // <getAttributeNode obj="testAddr" name="&quot;title&quot;" var="addrAttr"/>
                let r#attr_value = r#addr_attr.node_value().unwrap().to_string(); // <nodeValue obj="addrAttr" var="attrValue"/>
                assert_eq!(r#attr_value, "Yes"); // <assertEquals actual="attrValue" expected="&quot;Yes&quot;" id="nodeValue" ignoreCase="false"/>
            }
            // documentinvalidcharacterexceptioncreatepi.xml
            #[test]
            fn test_documentinvalidcharacterexceptioncreatepi() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#bad_pi; // type: ProcessingInstruction // <var name="badPI" type="ProcessingInstruction"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // // unimplemented: // <if><contentType type="text/html"/><assertDOMException id="throw_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><createProcessingInstruction var="badPI" obj="doc" target="&quot;foo&quot;" data="&quot;data&quot;"/></NOT_SUPPORTED_ERR></assertDOMException><else><assertDOMException id="throw_INVALID_CHARACTER_ERR"><INVALID_CHARACTER_ERR><createProcessingInstruction var="badPI" obj="doc" target="&quot;invalid^Name&quot;" data="&quot;data&quot;"/></INVALID_CHARACTER_ERR></assertDOMException></else></if>
            }
            // elementnormalize.xml
            #[test]
            fn test_elementnormalize() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root; // type: Element // <var name="root" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#root = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="root"/>
                r#root.normalize(); // <normalize obj="root"/>
                let r#element_list = r#root.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Element" obj="root" tagname="&quot;name&quot;" var="elementList"/>
                let r#test_name = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testName"/>
                let r#first_child = r#test_name.first_child().unwrap(); // <firstChild interface="Node" obj="testName" var="firstChild"/>
                let r#child_value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="childValue"/>
                assert_eq!(r#child_value, "Roger\n Jones"); // <assertEquals actual="childValue" expected="&quot;Roger\n Jones&quot;" id="elementNormalizeAssert" ignoreCase="false"/>
            }
            // hc_namednodemapchildnoderange.xml
            #[test]
            fn test_hc_namednodemapchildnoderange() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#strong; // type: DOMString // <var name="strong" type="DOMString"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                // r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="2"/>
                // r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                // r#length = r#attributes.len(); // <length var="length" obj="attributes" interface="NamedNodeMap"/>

                // // unimplemented: // <if><contentType type="text/html"/><assertEquals actual="length" expected="2" id="htmlLength" ignoreCase="false"/><else><assertEquals actual="length" expected="3" id="length" ignoreCase="false"/><item var="child" index="2" obj="attributes" interface="NamedNodeMap"/><assertNotNull actual="child" id="attr2"/></else></if>
                // r#child = r#attributes.item(0).unwrap(); // <item var="child" index="0" obj="attributes" interface="NamedNodeMap"/>

                // // unimplemented: // <assertNotNull actual="child" id="attr0"/>
                // r#child = r#attributes.item(1).unwrap(); // <item var="child" index="1" obj="attributes" interface="NamedNodeMap"/>

                // // unimplemented: // <assertNotNull actual="child" id="attr1"/>
                // r#child = r#attributes.item(3).unwrap(); // <item var="child" index="3" obj="attributes" interface="NamedNodeMap"/>

                // // unimplemented: // <assertNull actual="child" id="attr3"/>
            }
            // characterdatainsertdatanomodificationallowederr.xml
            #[test]
            fn test_characterdatainsertdatanomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let r#ent_element; // type: Node // <var name="entElement" type="Node"/>
                let mut r#ent_element_content; // type: Node // <var name="entElementContent" type="Node"/>
                let mut r#ent_reference; // type: Node // <var name="entReference" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" index="2" var="genderNode"/>
                r#ent_reference = r#gender_node.first_child().unwrap(); // <firstChild var="entReference" obj="genderNode" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entReference" id="entReferenceNotNull"/>
                let r#node_type = r#ent_reference.node_type(); // <nodeType var="nodeType" obj="entReference"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="entReference" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="entReference" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    ent_reference = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#ent_element = r#ent_reference.first_child().unwrap(); // <firstChild var="entElement" obj="entReference" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#ent_element_content =
                    r#ent_element.first_child().unwrap().as_text_node().unwrap(); // <firstChild var="entElementContent" obj="entElement" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElementContent" id="entElementContentNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <insertData obj="entElementContent" offset="1" arg="&quot;newArg&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element_content
                        .insert_data(1, "newArg")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // nodeappendchildinvalidnodetype.xml
            #[test]
            fn test_nodeappendchildinvalidnodetype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Element // <var name="rootNode" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                let r#new_child = r#doc.create_attribute("newAttribute".to_string()).unwrap(); // <createAttribute obj="doc" name="&quot;newAttribute&quot;" var="newChild"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <appendChild var="appendedChild" obj="rootNode" newChild="newChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    root_node
                        .append_child(new_child.into())
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // elementremoveattributenodenomodificationallowederrEE.xml
            #[test]
            fn test_elementremoveattributenodenomodificationallowederr_ee() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender; // type: Node // <var name="gender" type="Node"/>
                let r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                let r#attr_list; // type: NamedNodeMap // <var name="attrList" type="NamedNodeMap"/>
                let r#attr_node; // type: Attr // <var name="attrNode" type="Attr"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                r#appended_child = r#gender.append_child(ent_ref.clone().into()).unwrap(); // <appendChild obj="gender" newChild="entRef" var="appendedChild"/>
                r#ent_element = r#ent_ref.first_child().unwrap().as_element().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#attr_list = r#ent_element.attributes(); // <attributes obj="entElement" var="attrList"/>
                r#attr_node = r#attr_list.get_named_item("domestic").unwrap(); // <getNamedItem obj="attrList" var="attrNode" name="&quot;domestic&quot;"/>
                // unimplemented: // <assertNotNull actual="attrNode" id="attrNodeNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <removeAttributeNode var="removedAttr" obj="entElement" oldAttr="attrNode"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element
                        .remove_attribute_node(attr_node)
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // elementremoveattributenomodificationallowederr.xml
            #[test]
            fn test_elementremoveattributenomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender; // type: Node // <var name="gender" type="Node"/>
                let r#gen_list; // type: NodeList // <var name="genList" type="NodeList"/>
                let mut r#gen; // type: Node // <var name="gen" type="Node"/>
                let r#g_list; // type: NodeList // <var name="gList" type="NodeList"/>
                let mut r#gen_element; // type: Element // <var name="genElement" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#gen_list = r#gender.child_nodes(); // <childNodes obj="gender" var="genList"/>
                r#gen = r#gen_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="genList" var="gen" index="0"/>
                // unimplemented: // <assertNotNull actual="gen" id="genNotNull"/>
                let r#node_type = r#gen.node_type(); // <nodeType var="nodeType" obj="gen"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="gen" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="gen" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    r#gen = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#g_list = r#gen.child_nodes(); // <childNodes obj="gen" var="gList"/>
                r#gen_element = r#g_list.item(0).unwrap().as_element().unwrap(); // <item interface="NodeList" obj="gList" var="genElement" index="0"/>
                // unimplemented: // <assertNotNull actual="genElement" id="genElementNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <removeAttribute obj="genElement" name="&quot;domestic&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    gen_element
                        .remove_attribute("domestic")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_characterdatasubstringexceedsvalue.xml
            #[test]
            fn test_hc_characterdatasubstringexceedsvalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                let r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                let r#substring = child.substring_data(9, 10).unwrap(); // <substringData obj="child" var="substring" offset="9" count="10"/>
                assert_eq!(r#substring, "Martin"); // <assertEquals actual="substring" expected="&quot;Martin&quot;" id="characterdataSubStringExceedsValueAssert" ignoreCase="false"/>
            }
            // hc_textsplittexttwo.xml
            #[test]
            fn test_hc_textsplittexttwo() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#split_node; // type: Text // <var name="splitNode" type="Text"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;strong&quot;"/>
                r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                r#text_node = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="textNode"/>
                r#split_node = r#text_node.split_text(5).unwrap(); // <splitText obj="textNode" var="splitNode" offset="5"/>
                let r#value = r#text_node.node_value().unwrap().to_string(); // <nodeValue obj="textNode" var="value"/>
                assert_eq!(r#value, "Roger"); // <assertEquals actual="value" expected="&quot;Roger&quot;" id="textSplitTextTwoAssert" ignoreCase="false"/>
            }
            // documentinvalidcharacterexceptioncreateelement.xml
            #[test]
            fn test_documentinvalidcharacterexceptioncreateelement() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <createElement var="badElement" obj="doc" tagName="&quot;invalid^Name&quot;"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_element("invalid^Name")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // hc_attrsetvalue1.xml
            #[test]
            fn test_hc_attrsetvalue1() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let mut r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                // unimplemented: // <assertNotNull actual="firstChild" id="attrChildNotNull"/>
                r#title_attr.set_value("Tomorrow").unwrap(); // <value obj="titleAttr" value="&quot;Tomorrow&quot;" interface="Attr"/>
                r#first_child.set_node_value("impl reused node").unwrap(); // <nodeValue obj="firstChild" value="&quot;impl reused node&quot;"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Tomorrow"); // <assertEquals actual="value" expected="&quot;Tomorrow&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Tomorrow"); // <assertEquals actual="value" expected="&quot;Tomorrow&quot;" id="attrNodeValue" ignoreCase="false"/>
                r#first_child = r#title_attr.last_child().unwrap(); // <lastChild var="firstChild" obj="titleAttr" interface="Node"/>
                r#value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="value"/>
                assert_eq!(r#value, "Tomorrow"); // <assertEquals actual="value" expected="&quot;Tomorrow&quot;" id="firstChildValue" ignoreCase="false"/>
                let r#other_child = r#first_child.next_sibling(); // <nextSibling var="otherChild" obj="firstChild" interface="Node"/>
                assert!(other_child.is_none()); // <assertNull actual="otherChild" id="nextSiblingIsNull"/>
            }
            // hc_namednodemapsetnameditemthatexists.xml
            #[test]
            fn test_hc_namednodemapsetnameditemthatexists() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let r#district_node; // type: Attr // <var name="districtNode" type="Attr"/>
                let mut r#set_node; // type: Node // <var name="setNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                r#test_address = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="1"/>
                r#new_attribute = r#doc.create_attribute("class".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;class&quot;"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                r#set_node = r#attributes
                    .set_named_item(r#new_attribute)
                    .unwrap()
                    .unwrap(); // <setNamedItem var="setNode" obj="attributes" arg="newAttribute"/>
                r#district_node = r#attributes.get_named_item("class").unwrap(); // <getNamedItem obj="attributes" var="districtNode" name="&quot;class&quot;"/>
                let r#attr_value = r#district_node.node_value().unwrap().to_string(); // <nodeValue obj="districtNode" var="attrValue"/>
                assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" id="namednodemapSetNamedItemThatExistsAssert" ignoreCase="false"/>
            }
            // characterdataindexsizeerrinsertdataoffsetgreater.xml
            #[test]
            fn test_characterdataindexsizeerrinsertdataoffsetgreater() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                // <assertDOMException id="throw_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <insertData obj="child" offset="40" arg="&quot;ABC&quot;"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
                assert!(
                    child
                        .insert_data(40, "ABC")
                        .is_err_and(|err| err == DOMException::IndexSizeErr)
                );
            }
            // hc_attrinsertbefore2.xml
            #[test]
            fn test_hc_attrinsertbefore2() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let r#retval; // type: Node // <var name="retval" type="Node"/>
                let r#last_child; // type: Node // <var name="lastChild" type="Node"/>
                let r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#text_node = r#doc.create_text_node("terday"); // <createTextNode var="textNode" obj="doc" data="&quot;terday&quot;"/>
                let r#ref_child = r#title_attr.first_child().unwrap(); // <firstChild var="refChild" obj="titleAttr" interface="Node"/>
                r#retval = r#title_attr
                    .insert_before(text_node.into(), ref_child.into())
                    .unwrap(); // <insertBefore var="retval" obj="titleAttr" newChild="textNode" refChild="refChild"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "terdayYes"); // <assertEquals actual="value" expected="&quot;terdayYes&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "terdayYes"); // <assertEquals actual="value" expected="&quot;terdayYes&quot;" id="attrNodeValue" ignoreCase="false"/>
                r#value = r#retval.node_value().unwrap().to_string(); // <nodeValue obj="retval" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="retvalValue" ignoreCase="false"/>
                r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                r#value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="firstChildValue" ignoreCase="false"/>
                r#last_child = r#title_attr.last_child().unwrap(); // <lastChild var="lastChild" obj="titleAttr" interface="Node"/>
                r#value = r#last_child.node_value().unwrap().to_string(); // <nodeValue obj="lastChild" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="lastChildValue" ignoreCase="false"/>
            }
            // documentcreatecdatasection.xml
            #[test]
            fn test_documentcreatecdatasection() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#new_cdata_section_node = r#doc
                    .create_cdata_section("This is a new CDATASection node")
                    .unwrap(); // <createCDATASection obj="doc" var="newCDATASectionNode" data="&quot;This is a new CDATASection node&quot;"/>
                let r#new_cdata_section_value =
                    r#new_cdata_section_node.node_value().unwrap().to_string(); // <nodeValue obj="newCDATASectionNode" var="newCDATASectionValue"/>
                assert_eq!(r#new_cdata_section_value, "This is a new CDATASection node"); // <assertEquals id="nodeValue" actual="newCDATASectionValue" expected="&quot;This is a new CDATASection node&quot;" ignoreCase="false"/>
                let r#new_cdata_section_name = r#new_cdata_section_node.node_name().to_string(); // <nodeName obj="newCDATASectionNode" var="newCDATASectionName"/>
                assert_eq!(r#new_cdata_section_name, "#cdata-section"); // <assertEquals id="nodeName" actual="newCDATASectionName" expected="&quot;#cdata-section&quot;" ignoreCase="false"/>
                let r#new_cdata_section_type = r#new_cdata_section_node.node_type(); // <nodeType obj="newCDATASectionNode" var="newCDATASectionType"/>
                assert_eq!(r#new_cdata_section_type as i32, 4); // <assertEquals id="nodeType" actual="newCDATASectionType" expected="4" ignoreCase="false"/>
            }
            // hc_attrparentnodenull.xml
            #[test]
            fn test_hc_attrparentnodenull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;acronym&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;title&quot;"/>
                let r#s = r#domestic_attr.parent_node(); // <parentNode interface="Node" obj="domesticAttr" var="s"/>
                assert!(s.is_none()); // <assertNull actual="s" id="attrParentNodeNullAssert"/>
            }
            // hc_attrreplacechild1.xml
            #[test]
            fn test_hc_attrreplacechild1() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let r#retval; // type: Node // <var name="retval" type="Node"/>
                let mut r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#text_node = r#doc.create_text_node("terday"); // <createTextNode var="textNode" obj="doc" data="&quot;terday&quot;"/>
                r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                // unimplemented: // <assertNotNull actual="firstChild" id="attrChildNotNull"/>
                r#retval = r#title_attr
                    .replace_child(text_node.into(), first_child)
                    .unwrap(); // <replaceChild var="retval" obj="titleAttr" newChild="textNode" oldChild="firstChild"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="attrNodeValue" ignoreCase="false"/>
                r#value = r#retval.node_value().unwrap().to_string(); // <nodeValue obj="retval" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="retvalValue" ignoreCase="false"/>
                r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                r#value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="value"/>
                assert_eq!(r#value, "terday"); // <assertEquals actual="value" expected="&quot;terday&quot;" id="firstChildValue" ignoreCase="false"/>
            }
            // hc_nodeappendchild.xml
            #[test]
            fn test_hc_nodeappendchild() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#created_node; // type: Node // <var name="createdNode" type="Node"/>
                let r#lchild; // type: Node // <var name="lchild" type="Node"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#created_node = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="createdNode"/>
                r#appended_child = r#employee_node.append_child(created_node.into()).unwrap(); // <appendChild var="appendedChild" obj="employeeNode" newChild="createdNode"/>
                r#lchild = r#employee_node.last_child().unwrap(); // <lastChild interface="Node" obj="employeeNode" var="lchild"/>
                let r#child_name = r#lchild.node_name().to_string(); // <nodeName obj="lchild" var="childName"/>
                assert_eq!(r#child_name, "br"); // <assertEquals actual="childName" expected="&quot;br&quot;" id="nodeName" ignoreCase="auto"/>
            }
            // hc_nodeappendchildgetnodename.xml
            #[test]
            fn test_hc_nodeappendchildgetnodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#new_child = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="newChild"/>
                let r#append_node = r#employee_node.append_child(new_child.into()).unwrap(); // <appendChild obj="employeeNode" newChild="newChild" var="appendNode"/>
                let r#child_name = r#append_node.node_name().to_string(); // <nodeName obj="appendNode" var="childName"/>
                assert_eq!(r#child_name, "br"); // <assertEquals actual="childName" expected="&quot;br&quot;" id="nodeName" ignoreCase="auto"/>
            }
            // hc_documentinvalidcharacterexceptioncreateattribute.xml
            #[test]
            fn test_hc_documentinvalidcharacterexceptioncreateattribute() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <createAttribute var="createdAttr" obj="doc" name="&quot;invalid^Name&quot;"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    doc.create_attribute("invalid^Name")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // nodeprocessinginstructionsetnodevalue.xml
            #[test]
            fn test_nodeprocessinginstructionsetnodevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#test_list; // type: NodeList // <var name="testList" type="NodeList"/>
                let mut r#pi_node; // type: Node // <var name="piNode" type="Node"/>
                let mut r#pi_value; // type: DOMString // <var name="piValue" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#test_list = r#doc.child_nodes(); // <childNodes obj="doc" var="testList"/>
                r#pi_node = r#test_list
                    .item(0)
                    .unwrap()
                    .clone()
                    .as_processing_instruction()
                    .unwrap(); // <item interface="NodeList" obj="testList" index="0" var="piNode"/>
                r#pi_node.set_node_value("Something different").unwrap(); // <nodeValue obj="piNode" value="&quot;Something different&quot;"/>
                r#pi_value = r#pi_node.node_value().unwrap().to_string(); // <nodeValue obj="piNode" var="piValue"/>
                assert_eq!(r#pi_value, "Something different"); // <assertEquals actual="piValue" expected="&quot;Something different&quot;" id="nodeValue" ignoreCase="false"/>
                r#pi_value = r#pi_node.data().unwrap().to_string(); // <data interface="ProcessingInstruction" obj="piNode" var="piValue"/>
                assert_eq!(r#pi_value, "Something different"); // <assertEquals actual="piValue" expected="&quot;Something different&quot;" id="data" ignoreCase="false"/>
            }
            // hc_elementchangeattributevalue.xml
            #[test]
            fn test_hc_elementchangeattributevalue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(3).unwrap(); // <item interface="NodeList" obj="elementList" index="3" var="testEmployee"/>
                r#test_employee.set_attribute("class", "Neither").unwrap(); // <setAttribute obj="testEmployee" name="&quot;class&quot;" value="&quot;Neither&quot;"/>
                let r#attr_value = r#test_employee.get_attribute("class"); // <getAttribute obj="testEmployee" var="attrValue" name="&quot;class&quot;"/>
                assert_eq!(r#attr_value, "Neither"); // <assertEquals actual="attrValue" expected="&quot;Neither&quot;" id="elementChangeAttributeValueAssert" ignoreCase="false"/>
            }
            // hc_attrappendchild2.xml
            #[test]
            fn test_hc_attrappendchild2() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                let r#new_child = r#doc.create_element("terday".to_string()).unwrap(); // <createElement var="newChild" obj="doc" tagName="&quot;terday&quot;"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <appendChild var="retval" obj="titleAttr" newChild="newChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    title_attr
                        .append_child(new_child.into())
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // hc_characterdataindexsizeerrsubstringnegativeoffset.xml
            #[test]
            fn test_hc_characterdataindexsizeerrsubstringnegativeoffset() {
                // // unimplemented: // <implementationAttribute name="signed" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                // let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                // let mut r#bad_string; // type: DOMString // <var name="badString" type="DOMString"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                // r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                // r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // // unimplemented:
                // // <assertDOMException id="throws_INDEX_SIZE_ERR">
                // //  <INDEX_SIZE_ERR>
                // //      <substringData var="badString" obj="child" offset="-5" count="3"/>
                // //  </INDEX_SIZE_ERR>
                // // </assertDOMException>
            }
            // characterdatareplacedataexceedslengthofdata.xml
            #[test]
            fn test_characterdatareplacedataexceedslengthofdata() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.replace_data(0, 50, "2600").unwrap(); // <replaceData obj="child" offset="0" count="50" arg="&quot;2600&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "2600"); // <assertEquals actual="childData" expected="&quot;2600&quot;" id="characterdataReplaceDataExceedsLengthOfDataAssert" ignoreCase="false"/>
            }
            // nodenotationnodetype.xml
            #[test]
            fn test_nodenotationnodetype() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#notations = doc_type.notations(); // <notations obj="docType" var="notations"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                let r#notation_node = r#notations.get_named_item("notation1").unwrap(); // <getNamedItem obj="notations" var="notationNode" name="&quot;notation1&quot;"/>
                // unimplemented: // <assertNotNull actual="notationNode" id="notationNotNull"/>
                let r#node_type = r#notation_node.node_type(); // <nodeType obj="notationNode" var="nodeType"/>
                assert_eq!(r#node_type as i32, 12); // <assertEquals actual="nodeType" expected="12" id="nodeNotationNodeTypeAssert1" ignoreCase="false"/>
            }
            // characterdatainsertdataend.xml
            #[test]
            fn test_characterdatainsertdataend() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.insert_data(15, ", Esquire").unwrap(); // <insertData obj="child" offset="15" arg="&quot;, Esquire&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Margaret Martin, Esquire"); // <assertEquals actual="childData" expected="&quot;Margaret Martin, Esquire&quot;" id="characterdataInsertDataEndAssert" ignoreCase="false"/>
            }
            // elementnotfounderr.xml
            #[test]
            fn test_elementnotfounderr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#old_attribute; // type: Attr // <var name="oldAttribute" type="Attr"/>
                let r#address_element_list; // type: NodeList // <var name="addressElementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#address_element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="addressElementList"/>
                r#test_address = r#address_element_list.item(4).unwrap(); // <item interface="NodeList" obj="addressElementList" index="4" var="testAddress"/>
                r#old_attribute = r#doc.create_attribute("oldAttribute".to_string()).unwrap(); // <createAttribute obj="doc" var="oldAttribute" name="&quot;oldAttribute&quot;"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <removeAttributeNode obj="testAddress" oldAttr="oldAttribute" var="attrAddress"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    test_address
                        .remove_attribute_node(old_attribute)
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // noderemovechildgetnodename.xml
            #[test]
            fn test_noderemovechildgetnodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#length = r#child_list.length(); // <length var="length" obj="childList" interface="NodeList"/>
                let r#old_child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="oldChild"/>
                let r#removed_child = r#employee_node.remove_child(old_child).unwrap(); // <removeChild obj="employeeNode" oldChild="oldChild" var="removedChild"/>
                let r#child_name = r#removed_child.node_name().to_string(); // <nodeName obj="removedChild" var="childName"/>
                // <if><equals actual="length" expected="6" ignoreCase="false"/>
                //  <assertEquals actual="childName" expected="&quot;employeeId&quot;" id="nowhitespace" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="childName" expected="&quot;#text&quot;" id="whitespace" ignoreCase="false"/>
                // </else>
                // </if>
                if length == 6 {
                    assert_eq!(child_name, "employeeId");
                } else {
                    assert_eq!(child_name, "#text");
                }
            }
            // nodevalue05.xml
            #[test]
            fn test_nodevalue05() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_node = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="newNode"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="initiallyNull"/>
                r#new_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
            }
            // hc_attrinsertbefore6.xml
            #[test]
            fn test_hc_attrinsertbefore6() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let r#text_node; // type: Node // <var name="textNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#other_doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="otherDoc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#text_node = r#other_doc.create_text_node("terday"); // <createTextNode var="textNode" obj="otherDoc" data="&quot;terday&quot;"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <insertBefore var="retval" obj="titleAttr" newChild="textNode" refChild="refChild"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    title_attr
                        .insert_before(text_node.into(), None)
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // nodetextnodeattribute.xml
            #[test]
            fn test_nodetextnodeattribute() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#text_node = r#test_addr.first_child().unwrap(); // <firstChild interface="Node" obj="testAddr" var="textNode"/>
                let r#attr_list = r#text_node.attributes(); // <attributes obj="textNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="nodeTextNodeAttributesAssert1"/>
            }
            // textsplittexttwo.xml
            #[test]
            fn test_textsplittexttwo() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#split_node; // type: Text // <var name="splitNode" type="Text"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;name&quot;"/>
                r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                r#text_node = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="textNode"/>
                r#split_node = r#text_node.split_text(5).unwrap(); // <splitText obj="textNode" var="splitNode" offset="5"/>
                let r#value = r#text_node.node_value().unwrap().to_string(); // <nodeValue obj="textNode" var="value"/>
                assert_eq!(r#value, "Roger"); // <assertEquals actual="value" expected="&quot;Roger&quot;" id="textSplitTextTwoAssert" ignoreCase="false"/>
            }
            // nodereplacechild.xml
            #[test]
            fn test_nodereplacechild() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#replaced_node; // type: Node // <var name="replacedNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#old_child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="oldChild"/>
                r#new_child = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="newChild"/>
                r#replaced_node = r#employee_node
                    .replace_child(new_child.into(), old_child)
                    .unwrap(); // <replaceChild var="replacedNode" obj="employeeNode" newChild="newChild" oldChild="oldChild"/>
                r#child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="child"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                assert_eq!(r#child_name, "newChild"); // <assertEquals actual="childName" expected="&quot;newChild&quot;" id="nodeReplaceChildAssert1" ignoreCase="false"/>
            }
            // hc_elementgetelementsbytagname.xml
            #[test]
            fn test_hc_elementgetelementsbytagname() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                assert_eq!(element_list.length(), 5); // <assertSize collection="elementList" size="5" id="elementGetElementsByTagNameAssert"/>
            }
            // hc_namednodemapsetnameditem.xml
            #[test]
            fn test_hc_namednodemapsetnameditem() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let r#district_node; // type: Attr // <var name="districtNode" type="Attr"/>
                let mut r#set_node; // type: Node // <var name="setNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                r#test_address = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="1"/>
                r#new_attribute = r#doc.create_attribute("lang".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;lang&quot;"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                r#set_node = r#attributes.set_named_item(r#new_attribute).unwrap(); // <setNamedItem var="setNode" obj="attributes" arg="newAttribute"/>
                r#district_node = r#attributes.get_named_item("lang").unwrap(); // <getNamedItem obj="attributes" var="districtNode" name="&quot;lang&quot;"/>
                let r#attr_name = r#district_node.node_name().to_string(); // <nodeName obj="districtNode" var="attrName"/>
                assert_eq!(r#attr_name, "lang"); // <assertEquals actual="attrName" expected="&quot;lang&quot;" id="nodeName" ignoreCase="auto" context="attribute"/>
            }
            // hc_elementnormalize2.xml
            #[test]
            fn test_hc_elementnormalize2() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#root; // type: Element // <var name="root" type="Element"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                let r#empty_text; // type: Text // <var name="emptyText" type="Text"/>
                let mut r#attr_node; // type: Attr // <var name="attrNode" type="Attr"/>
                let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#root = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="root"/>
                r#empty_text = r#doc.create_text_node(""); // <createTextNode var="emptyText" obj="doc" data="&quot;&quot;"/>
                r#element_list = r#root.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Element" obj="root" tagname="&quot;acronym&quot;" var="elementList"/>
                r#element = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="element"/>
                r#attr_node = r#element.get_attribute_node("title").unwrap(); // <getAttributeNode var="attrNode" obj="element" name="&quot;title&quot;"/>
                r#retval = r#attr_node.append_child(empty_text.into()).unwrap(); // <appendChild var="retval" obj="attrNode" newChild="emptyText"/>
                r#element.normalize(); // <normalize obj="element"/>
                r#attr_node = r#element.get_attribute_node("title").unwrap(); // <getAttributeNode var="attrNode" obj="element" name="&quot;title&quot;"/>
                r#first_child = r#attr_node.first_child().unwrap(); // <firstChild interface="Node" obj="attrNode" var="firstChild"/>
                let r#child_value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="childValue"/>
                assert_eq!(r#child_value, "Yes"); // <assertEquals actual="childValue" expected="&quot;Yes&quot;" id="firstChild" ignoreCase="false"/>
                let r#second_child = r#first_child.next_sibling(); // <nextSibling var="secondChild" obj="firstChild" interface="Node"/>
                assert!(second_child.is_none()); // <assertNull actual="secondChild" id="secondChildNull"/>
            }
            // hc_nodeinsertbeforenodeancestor.xml
            #[test]
            fn test_hc_nodeinsertbeforenodeancestor() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#new_child = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="newChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#ref_child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="refChild"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <insertBefore var="insertedNode" obj="employeeNode" newChild="newChild" refChild="refChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    employee_node
                        .insert_before(new_child.into(), Some(ref_child))
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // hc_nodechildnodesempty.xml
            #[test]
            fn test_hc_nodechildnodesempty() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;em&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#text_node = r#employee_node.first_child().unwrap(); // <firstChild var="textNode" obj="employeeNode"/>
                r#child_list = r#text_node.child_nodes(); // <childNodes var="childList" obj="textNode"/>
                let r#length = r#child_list.length(); // <length var="length" obj="childList" interface="NodeList"/>
                assert_eq!(r#length, 0); // <assertEquals expected="0" actual="length" id="length_zero" ignoreCase="false"/>
            }
            // nodenotationnodeattributes.xml
            #[test]
            fn test_nodenotationnodeattributes() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#notations = doc_type.notations(); // <notations obj="docType" var="notations"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                let r#notation_node = r#notations.get_named_item("notation1").unwrap(); // <getNamedItem obj="notations" name="&quot;notation1&quot;" var="notationNode"/>
                // unimplemented: // <assertNotNull actual="notationNode" id="notationNotNull"/>
                let r#attr_list = r#notation_node.attributes(); // <attributes obj="notationNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="nodeNotationNodeAttributesAssert1"/>
            }
            // characterdataindexsizeerrreplacedataoffsetgreater.xml
            #[test]
            fn test_characterdataindexsizeerrreplacedataoffsetgreater() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                // <assertDOMException id="throw_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <replaceData obj="child" offset="40" count="3" arg="&quot;ABC&quot;"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
                assert!(
                    child
                        .replace_data(40, 3, "ABC")
                        .is_err_and(|err| err == DOMException::IndexSizeErr)
                );
            }
            // hc_nodegetnextsiblingnull.xml
            #[test]
            fn test_hc_nodegetnextsiblingnull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#lc_node = r#employee_node.last_child().unwrap(); // <lastChild interface="Node" obj="employeeNode" var="lcNode"/>
                let r#ns_node = r#lc_node.next_sibling(); // <nextSibling interface="Node" obj="lcNode" var="nsNode"/>
                assert!(ns_node.is_none()); // <assertNull actual="nsNode" id="nodeGetNextSiblingNullAssert1"/>
            }
            // hc_nodehaschildnodes.xml
            #[test]
            fn test_hc_nodehaschildnodes() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#state = r#employee_node.has_child_nodes(); // <hasChildNodes obj="employeeNode" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="nodeHasChildAssert1"/>
            }
            // hc_documentgetelementsbytagnamelength.xml
            #[test]
            fn test_hc_documentgetelementsbytagnamelength() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#name_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" var="nameList" tagname="&quot;strong&quot;"/>
                assert_eq!(name_list.length(), 5); // <assertSize collection="nameList" size="5" id="documentGetElementsByTagNameLengthAssert"/>
            }
            // elementreplaceattributewithself.xml
            #[test]
            fn test_elementreplaceattributewithself() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                let r#street_attr = r#test_employee.get_attribute_node("street").unwrap(); // <getAttributeNode var="streetAttr" obj="testEmployee" name="&quot;street&quot;"/>
                let r#replaced_attr = r#test_employee
                    .set_attribute_node(r#street_attr.clone())
                    .unwrap()
                    .unwrap(); // <setAttributeNode obj="testEmployee" var="replacedAttr" newAttr="streetAttr"/>
                assert!(replaced_attr.is_same_node(&street_attr.into())); // <assertSame actual="replacedAttr" expected="streetAttr" id="replacedAttr"/>
            }
            // nodecdatasectionnodename.xml
            #[test]
            fn test_nodecdatasectionnodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#cdata_name; // type: Element // <var name="cdataName" type="Element"/>
                let mut r#cdata_node; // type: Node // <var name="cdataNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;name&quot;"/>
                r#cdata_name = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="cdataName"/>
                r#cdata_node = r#cdata_name.last_child().unwrap(); // <lastChild interface="Node" obj="cdataName" var="cdataNode"/>
                let r#node_type = r#cdata_node.node_type(); // <nodeType var="nodeType" obj="cdataNode"/>
                // <if><notEquals actual="nodeType" expected="4" ignoreCase="false"/>
                //  <createCDATASection var="cdataNode" obj="doc" data="&quot;&quot;"/>
                // </if>
                if node_type as i32 != 4 {
                    cdata_node = doc.create_cdata_section("").unwrap().into();
                }
                let r#cdata_node_name = r#cdata_node.node_name().to_string(); // <nodeName obj="cdataNode" var="cdataNodeName"/>
                assert_eq!(r#cdata_node_name, "#cdata-section"); // <assertEquals actual="cdataNodeName" expected="&quot;#cdata-section&quot;" id="cdataNodeName" ignoreCase="false"/>
            }
            // hc_nodelisttraverselist.xml
            #[test]
            fn test_hc_nodelisttraverselist() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#employee_list; // type: NodeList // <var name="employeeList" type="NodeList"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let r#expected = vec!["em", "strong", "code", "sup", "var", "acronym"]; // type: List // <var name="expected" type="List"><member>"em"</member><member>"strong"</member><member>"code"</member><member>"sup"</member><member>"var"</member><member>"acronym"</member></var>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;p&quot;"/>
                r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                // <for-each collection="employeeList" member="child">
                //  <nodeType var="nodeType" obj="child"/>
                //  <nodeName obj="child" var="childName"/>
                //  <if><equals actual="nodeType" expected="1"/>
                //      <append collection="result" item="childName"/>
                //  <else>
                //      <assertEquals actual="nodeType" expected="3" id="textNodeType" ignoreCase="false"/>
                //      <assertEquals actual="childName" expected="&quot;#text&quot;" id="textNodeName" ignoreCase="false"/>
                //  </else>
                //  </if>
                // </for-each>
                for i in 0..employee_list.length() {
                    child = employee_list.item(i).unwrap();
                    node_type = child.node_type();
                    child_name = child.node_name().to_string();
                    if node_type as i32 == 1 {
                        result.push(child_name);
                    } else {
                        assert_eq!(node_type as i32, 3);
                        assert_eq!(child_name, "#text");
                    }
                }
                assert_eq!(r#result, expected); // <assertEquals actual="result" expected="expected" id="nodeNames" ignoreCase="auto"/>
            }
            // hc_nodevalue04.xml
            #[test]
            fn test_hc_nodevalue04() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // let mut r#new_value; // type: DOMString // <var name="newValue" type="DOMString"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#new_node = r#doc.doctype().unwrap(); // <doctype obj="doc" var="newNode"/>

                // // unimplemented:
                // // <assertTrue id="docTypeNotNullOrDocIsHTML">
                // //  <or>
                // //      <notNull obj="newNode"/>
                // //      <contentType type="text/html"/>
                // //  </or>
                // // </assertTrue>

                // // unimplemented: // <if><notNull obj="newNode"/><assertNotNull actual="newNode" id="docTypeNotNull"/><nodeValue obj="newNode" var="newValue"/><assertNull actual="newValue" id="initiallyNull"/><!--   attempt to change the value and make sure that it stays null  --><nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/><nodeValue obj="newNode" var="newValue"/><assertNull actual="newValue" id="nullAfterAttemptedChange"/></if>
            }
            // hc_nodeelementnodevalue.xml
            #[test]
            fn test_hc_nodeelementnodevalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="elementNode"/>
                let r#element_value = r#element_node.node_value(); // <nodeValue obj="elementNode" var="elementValue"/>
                assert!(element_value.is_none()); // <assertNull actual="elementValue" id="elementNodeValue"/>
            }
            // cdatasectiongetdata.xml
            #[test]
            fn test_cdatasectiongetdata() {
                // unimplemented: // <implementationAttribute name="coalescing" value="false"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#name_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="nameList" tagname="&quot;name&quot;"/>
                let r#child = r#name_list.item(1).unwrap(); // <item interface="NodeList" obj="nameList" var="child" index="1"/>
                let r#last_child = r#child.last_child().unwrap().as_cdata_section().unwrap(); // <lastChild interface="Node" obj="child" var="lastChild"/>
                let r#node_type = r#last_child.node_type(); // <nodeType var="nodeType" obj="lastChild"/>
                assert_eq!(r#node_type as i32, 4); // <assertEquals actual="nodeType" expected="4" id="isCDATA" ignoreCase="false"/>
                let r#data = r#last_child.data().to_string(); // <data interface="CharacterData" obj="lastChild" var="data"/>
                assert_eq!(
                    r#data,
                    "This is an adjacent CDATASection with a reference to a tab &tab;"
                ); // <assertEquals actual="data" expected="&quot;This is an adjacent CDATASection with a reference to a tab &amp;tab;&quot;" id="data" ignoreCase="false"/>
            }
            // characterdataindexsizeerrsubstringcountnegative.xml
            #[test]
            fn test_characterdataindexsizeerrsubstringcountnegative() {
                // // unimplemented: // <implementationAttribute name="signed" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                // let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                // let mut r#bad_substring; // type: DOMString // <var name="badSubstring" type="DOMString"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                // r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                // r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                // r#child = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>

                // // unimplemented:
                // // <assertDOMException id="throws_INDEX_SIZE_ERR">
                // //  <INDEX_SIZE_ERR>
                // //      <substringData var="badSubstring" obj="child" offset="10" count="-3"/>
                // //  </INDEX_SIZE_ERR>
                // // </assertDOMException>
            }
            // nodehaschildnodesfalse.xml
            #[test]
            fn test_nodehaschildnodesfalse() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#child = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="child"/>
                let r#employee_id_list = r#child.child_nodes(); // <childNodes obj="child" var="employeeIdList"/>
                let r#employee_node = r#employee_id_list.item(1).unwrap().clone(); // <item interface="NodeList" obj="employeeIdList" index="1" var="employeeNode"/>
                let r#text_node = r#employee_node.first_child().unwrap(); // <firstChild interface="Node" obj="employeeNode" var="textNode"/>
                let r#state = r#text_node.has_child_nodes(); // <hasChildNodes obj="textNode" var="state"/>
                assert!(!r#state); // <assertFalse actual="state" id="nodeHasChildFalseAssert1"/>
            }
            // nodelisttraverselist.xml
            #[test]
            fn test_nodelisttraverselist() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#employee_list; // type: NodeList // <var name="employeeList" type="NodeList"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let r#expected_whitespace = vec![
                    "#text",
                    "employeeId",
                    "#text",
                    "name",
                    "#text",
                    "position",
                    "#text",
                    "salary",
                    "#text",
                    "gender",
                    "#text",
                    "address",
                    "#text",
                ]; // type: List // <var name="expectedWhitespace" type="List"><member>"#text"</member><member>"employeeId"</member><member>"#text"</member><member>"name"</member><member>"#text"</member><member>"position"</member><member>"#text"</member><member>"salary"</member><member>"#text"</member><member>"gender"</member><member>"#text"</member><member>"address"</member><member>"#text"</member></var>
                let r#expected_no_whitespace = vec![
                    "employeeId",
                    "name",
                    "position",
                    "salary",
                    "gender",
                    "address",
                ]; // type: List // <var name="expectedNoWhitespace" type="List"><member>"employeeId"</member><member>"name"</member><member>"position"</member><member>"salary"</member><member>"gender"</member><member>"address"</member></var>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#length = r#employee_list.length(); // <length var="length" obj="employeeList" interface="NodeList"/>
                // <for-each collection="employeeList" member="child">
                //  <nodeName obj="child" var="childName"/>
                //  <append collection="result" item="childName"/>
                // </for-each>
                for i in 0..employee_list.length() {
                    child = employee_list.item(i).unwrap();
                    child_name = child.node_name().to_string();
                    result.push(child_name);
                }
                // <if><equals actual="length" expected="6" ignoreCase="false"/>
                //  <assertEquals actual="result" expected="expectedNoWhitespace" id="nowhitespace" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="result" expected="expectedWhitespace" id="whitespace" ignoreCase="false"/>
                // </else>
                // </if>
                if length == 6 {
                    assert_eq!(result, expected_no_whitespace);
                } else {
                    assert_eq!(result, expected_whitespace);
                }
            }
            // documentgetdoctype.xml
            #[test]
            fn test_documentgetdoctype() {
                let mut r#doc_type_name; // type: DOMString // <var name="docTypeName" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                r#doc_type_name = r#doc_type.name().to_string(); // <name interface="DocumentType" obj="docType" var="docTypeName"/>

                // unimplemented: // <if><contentType type="image/svg+xml"/>	<assertEquals actual="docTypeName" expected="&quot;svg&quot;" id="doctypeNameSVG" ignoreCase="false"/>	<else>		<assertEquals actual="docTypeName" expected="&quot;staff&quot;" id="doctypeName" ignoreCase="false"/>	</else></if>
                let r#node_value = r#doc_type.node_value(); // <nodeValue obj="docType" var="nodeValue"/>
                assert!(node_value.is_none()); // <assertNull actual="nodeValue" id="initiallyNull"/>
            }
            // hc_characterdatasubstringvalue.xml
            #[test]
            fn test_hc_characterdatasubstringvalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                let r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                let r#substring = child.substring_data(0, 8).unwrap(); // <substringData obj="child" var="substring" offset="0" count="8"/>
                assert_eq!(r#substring, "Margaret"); // <assertEquals actual="substring" expected="&quot;Margaret&quot;" id="characterdataSubStringValueAssert" ignoreCase="false"/>
            }
            // hc_nodelistindexgetlength.xml
            #[test]
            fn test_hc_nodelistindexgetlength() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;p&quot;"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#length = r#employee_list.length(); // <length var="length" obj="employeeList" interface="NodeList"/>
                // <if><equals actual="length" expected="6"/>
                //  <assertEquals actual="length" expected="6" ignoreCase="false" id="length_wo_space"/>
                // <else>
                //  <assertEquals actual="length" expected="13" ignoreCase="false" id="length_w_space"/>
                // </else>
                // </if>
                if length == 6 {
                    assert_eq!(length, 6);
                } else {
                    assert_eq!(length, 13);
                }
            }
            // nodegetownerdocument.xml
            #[test]
            fn test_nodegetownerdocument() {
                let mut r#element_name; // type: DOMString // <var name="elementName" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#doc_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="docNode"/>
                let r#owner_document: DocumentRef = r#doc_node.owner_document().unwrap(); // <ownerDocument obj="docNode" var="ownerDocument"/>
                let r#doc_element = r#owner_document.document_element().unwrap(); // <documentElement obj="ownerDocument" var="docElement"/>
                r#element_name = r#doc_element.node_name().to_string(); // <nodeName obj="docElement" var="elementName"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //  <assertEquals actual="elementName" expected="&quot;svg&quot;" id="svgTagName" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="elementName" expected="&quot;staff&quot;" id="nodeGetOwnerDocumentAssert1" ignoreCase="false"/>
                // </else>
                // </if>
            }
            // hc_attrinsertbefore7.xml
            #[test]
            fn test_hc_attrinsertbefore7() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                // let mut r#test_node; // type: Node // <var name="testNode" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                // let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                // let mut r#ter_node; // type: Text // <var name="terNode" type="Text"/>
                // let mut r#day_node; // type: Node // <var name="dayNode" type="Node"/>
                // let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                // let mut r#last_child; // type: Node // <var name="lastChild" type="Node"/>
                // let mut r#ref_child; // type: Node // <var name="refChild" type="Node" isNull="true"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                // r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                // r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                // r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                // r#ter_node = r#doc.create_text_node("ter"); // <createTextNode var="terNode" obj="doc" data="&quot;ter&quot;"/>

                // // unimplemented: // <if><contentType type="text/html"/>	<assertDOMException id="throw_NOT_SUPPORTED_ERR">		<NOT_SUPPORTED_ERR>			<createCDATASection var="dayNode" obj="doc" data="&quot;day&quot;"/>		</NOT_SUPPORTED_ERR>	</assertDOMException><else><createCDATASection var="dayNode" obj="doc" data="&quot;day&quot;"/><createDocumentFragment var="docFrag" obj="doc"/><appendChild var="retval" obj="docFrag" newChild="terNode"/><appendChild var="retval" obj="docFrag" newChild="dayNode"/><assertDOMException id="throw_HIERARCHY_REQUEST_ERR">	<HIERARCHY_REQUEST_ERR>		<insertBefore var="retval" obj="titleAttr" newChild="docFrag" refChild="refChild"/>	</HIERARCHY_REQUEST_ERR></assertDOMException></else></if>
            }
            // namednodemapgetnameditem.xml
            #[test]
            fn test_namednodemapgetnameditem() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="1"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("domestic").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;domestic&quot;"/>
                let r#attr_name = r#domestic_attr.node_name().to_string(); // <nodeName obj="domesticAttr" var="attrName"/>
                assert_eq!(r#attr_name, "domestic"); // <assertEquals actual="attrName" expected="&quot;domestic&quot;" id="namednodemapGetNamedItemAssert" ignoreCase="false"/>
            }
            // nodegetprevioussiblingnull.xml
            #[test]
            fn test_nodegetprevioussiblingnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="employeeNode"/>
                let r#fc_node = r#employee_node.first_child().unwrap(); // <firstChild interface="Node" obj="employeeNode" var="fcNode"/>
                let r#ps_node = r#fc_node.previous_sibling(); // <previousSibling interface="Node" obj="fcNode" var="psNode"/>
                assert!(ps_node.is_none()); // <assertNull actual="psNode" id="nodeGetPreviousSiblingNullAssert1"/>
            }
            // hc_notationssetnameditem1.xml
            #[test]
            fn test_hc_notationssetnameditem1() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <if><not><contentType type="text/html"/></not><assertNotNull actual="docType" id="docTypeNotNull"/><notations var="notations" obj="docType"/><assertNotNull actual="notations" id="notationsNotNull"/><createElement var="elem" obj="doc" tagName="&quot;br&quot;"/><try>	<setNamedItem var="retval" obj="notations" arg="elem"/>	<fail id="throw_HIER_OR_NO_MOD_ERR"/>	<catch>		<DOMException code="HIERARCHY_REQUEST_ERR"/>		<DOMException code="NO_MODIFICATION_ALLOWED_ERR"/>	</catch></try> </if>
            }
            // processinginstructionsetdatanomodificationallowederr.xml
            #[test]
            fn test_processinginstructionsetdatanomodificationallowederr() {
                // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender; // type: Node // <var name="gender" type="Node"/>
                let r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                let mut r#pi_node; // type: ProcessingInstruction // <var name="piNode" type="ProcessingInstruction"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#ent_ref = r#gender.first_child().unwrap(); // <firstChild interface="Node" var="entRef" obj="gender"/>
                // unimplemented: // <assertNotNull actual="entRef" id="entRefNotNull"/>
                r#pi_node = r#ent_ref
                    .last_child()
                    .unwrap()
                    .as_processing_instruction()
                    .unwrap(); // <lastChild interface="Node" var="piNode" obj="entRef"/>
                // unimplemented: // <assertNotNull actual="piNode" id="piNodeNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <data interface="ProcessingInstruction" obj="piNode" value="&quot;newData&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    pi_node
                        .set_data("newData")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // elementcreatenewattribute.xml
            #[test]
            fn test_elementcreatenewattribute() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#district_attr; // type: Attr // <var name="districtAttr" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_address = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddress"/>
                r#new_attribute = r#doc.create_attribute("district".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;district&quot;"/>
                let r#old_attr = r#test_address.set_attribute_node(r#new_attribute).unwrap(); // <setAttributeNode obj="testAddress" var="oldAttr" newAttr="newAttribute"/>
                assert!(old_attr.is_none()); // <assertNull actual="oldAttr" id="old_attr_doesnt_exist"/>
                r#district_attr = r#test_address.get_attribute_node("district").unwrap(); // <getAttributeNode obj="testAddress" var="districtAttr" name="&quot;district&quot;"/>
                // unimplemented: // <assertNotNull actual="districtAttr" id="new_district_accessible"/>
                let r#attr_val = r#test_address.get_attribute("district"); // <getAttribute var="attrVal" obj="testAddress" name="&quot;district&quot;"/>
                assert_eq!(r#attr_val, ""); // <assertEquals actual="attrVal" expected="&quot;&quot;" id="attr_value" ignoreCase="false"/>
            }
            // nodedocumenttypenodename.xml
            #[test]
            fn test_nodedocumenttypenodename() {
                let mut r#document_type_name; // type: DOMString // <var name="documentTypeName" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                r#document_type_name = r#doc_type.node_name().to_string(); // <nodeName obj="docType" var="documentTypeName"/>

                // unimplemented: // <if><contentType type="image/svg+xml"/><assertEquals actual="documentTypeName" expected="&quot;svg&quot;" id="doctypeNameSVG" ignoreCase="false"/><else><assertEquals actual="documentTypeName" expected="&quot;staff&quot;" id="documentName" ignoreCase="false"/></else></if>
            }
            // hc_elementaddnewattribute.xml
            #[test]
            fn test_hc_elementaddnewattribute() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(4).unwrap(); // <item interface="NodeList" obj="elementList" index="4" var="testEmployee"/>
                r#test_employee.set_attribute("lang", "EN-us").unwrap(); // <setAttribute obj="testEmployee" name="&quot;lang&quot;" value="&quot;EN-us&quot;"/>
                let r#attr_value = r#test_employee.get_attribute("lang"); // <getAttribute obj="testEmployee" var="attrValue" name="&quot;lang&quot;"/>
                assert_eq!(r#attr_value, "EN-us"); // <assertEquals actual="attrValue" expected="&quot;EN-us&quot;" id="attrValue" ignoreCase="false"/>
            }
            // hc_elementinvalidcharacterexception.xml
            #[test]
            fn test_hc_elementinvalidcharacterexception() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_address; // type: Element // <var name="testAddress" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_address = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddress"/>
                // <assertDOMException id="throw_INVALID_CHARACTER_ERR">
                //  <INVALID_CHARACTER_ERR>
                //      <setAttribute obj="testAddress" name="&quot;invalid^Name&quot;" value="&quot;value&quot;"/>
                //  </INVALID_CHARACTER_ERR>
                // </assertDOMException>
                assert!(
                    test_address
                        .set_attribute("invalid^Name", "value")
                        .is_err_and(|err| err == DOMException::InvalidCharacterErr)
                );
            }
            // notationgetpublicidnull.xml
            #[test]
            fn test_notationgetpublicidnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#notations = doc_type.notations(); // <notations obj="docType" var="notations"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                let r#notation_node = r#notations.get_named_item("notation2").unwrap(); // <getNamedItem obj="notations" var="notationNode" name="&quot;notation2&quot;"/>
                let r#public_id = r#notation_node.public_id(); // <publicId interface="Notation" obj="notationNode" var="publicId"/>
                assert!(public_id.is_none()); // <assertNull actual="publicId" id="publicId"/>
            }
            // notationgetsystemid.xml
            #[test]
            fn test_notationgetsystemid() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#notations = doc_type.notations(); // <notations obj="docType" var="notations"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                let r#notation_node = r#notations.get_named_item("notation2").unwrap(); // <getNamedItem obj="notations" var="notationNode" name="&quot;notation2&quot;"/>
                let r#system_id = r#notation_node.system_id().unwrap().to_string(); // <systemId interface="Notation" obj="notationNode" var="systemId"/>
                assert_eq!(system_id, "notation2File"); // <assertURIEquals actual="systemId" file="&quot;notation2File&quot;" id="uriEquals"/>
            }
            // nodegetfirstchildnull.xml
            #[test]
            fn test_nodegetfirstchildnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="employeeNode"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#second_child_node = r#employee_list.item(1).unwrap().clone(); // <item interface="NodeList" obj="employeeList" index="1" var="secondChildNode"/>
                let r#text_node = r#second_child_node.first_child().unwrap(); // <firstChild interface="Node" obj="secondChildNode" var="textNode"/>
                let r#no_child_node = r#text_node.first_child(); // <firstChild interface="Node" obj="textNode" var="noChildNode"/>
                assert!(no_child_node.is_none()); // <assertNull actual="noChildNode" id="nodeGetFirstChildNullAssert1"/>
            }
            // hc_elementretrieveallattributes.xml
            #[test]
            fn test_hc_elementretrieveallattributes() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#address_list; // type: NodeList // <var name="addressList" type="NodeList"/>
                // let mut r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                // let mut r#attribute_name; // type: DOMString // <var name="attributeName" type="DOMString"/>
                // let mut r#actual; // type: Collection // <var name="actual" type="Collection"/>
                // let mut r#html_expected; // type: Collection // <var name="htmlExpected" type="Collection">    <member>"title"</member></var>
                // let mut r#expected; // type: Collection // <var name="expected" type="Collection">    <member>"title"</member>    <member>"dir"</member></var>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#address_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="addressList"/>
                // r#test_address = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" index="0" var="testAddress"/>
                // r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>

                // // unimplemented: // <for-each collection="attributes" member="attribute">    <nodeName var="attributeName" obj="attribute"/>    <append collection="actual" item="attributeName"/></for-each>

                // // unimplemented: // <if><contentType type="text/html"/>    <assertEquals id="htmlAttributeNames" actual="actual" expected="htmlExpected" ignoreCase="true"/>    <else>        <assertEquals id="attributeNames" actual="actual" expected="expected" ignoreCase="true"/>    </else></if>
            }
            // characterdataappenddatanomodificationallowederr.xml
            #[test]
            fn test_characterdataappenddatanomodificationallowederr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let r#ent_element; // type: Node // <var name="entElement" type="Node"/>
                let mut r#ent_element_content; // type: Node // <var name="entElementContent" type="Node"/>
                let mut r#ent_reference; // type: Node // <var name="entReference" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" index="2" var="genderNode"/>
                r#ent_reference = r#gender_node.first_child().unwrap(); // <firstChild var="entReference" obj="genderNode" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entReference" id="entReferenceNotNull"/>
                let r#node_type = r#ent_reference.node_type(); // <nodeType var="nodeType" obj="entReference"/>
                // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>
                //  <createEntityReference var="entReference" obj="doc" name="&quot;ent4&quot;"/>
                //  <assertNotNull actual="entReference" id="createdEntRefNotNull"/>
                // </if>
                if node_type as i32 == 1 {
                    ent_reference = doc.create_entity_reference("ent4").unwrap().into();
                }
                r#ent_element = r#ent_reference.first_child().unwrap(); // <firstChild var="entElement" obj="entReference" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElementNotNull"/>
                r#ent_element_content =
                    r#ent_element.first_child().unwrap().as_text_node().unwrap(); // <firstChild var="entElementContent" obj="entElement" interface="Node"/>
                // unimplemented: // <assertNotNull actual="entElementContent" id="entElementContentNotNull"/>
                // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">
                //  <NO_MODIFICATION_ALLOWED_ERR>
                //      <appendData obj="entElementContent" arg="&quot;newString&quot;"/>
                //  </NO_MODIFICATION_ALLOWED_ERR>
                // </assertDOMException>
                assert!(
                    ent_element_content
                        .append_data("newString")
                        .is_err_and(|err| err == DOMException::NoModificationAllowedErr)
                );
            }
            // hc_characterdatagetlength.xml
            #[test]
            fn test_hc_characterdatagetlength() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                let r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                let r#child_value = r#child.data().to_string(); // <data var="childValue" obj="child" interface="CharacterData"/>
                let r#child_length = r#child_value.len(); // <length var="childLength" obj="childValue" interface="DOMString"/>
                assert_eq!(r#child_length, 15); // <assertEquals actual="childLength" expected="15" ignoreCase="false" id="characterdataGetLengthAssert"/>
            }
            // hc_attrnextsiblingnull.xml
            #[test]
            fn test_hc_attrnextsiblingnull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;acronym&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;title&quot;"/>
                let r#s = r#domestic_attr.next_sibling(); // <nextSibling interface="Node" obj="domesticAttr" var="s"/>
                assert!(s.is_none()); // <assertNull actual="s" id="attrNextSiblingNullAssert"/>
            }
            // hc_textindexsizeerrnegativeoffset.xml
            #[test]
            fn test_hc_textindexsizeerrnegativeoffset() {
                // // unimplemented: // <implementationAttribute name="signed" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                // let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                // let mut r#split_node; // type: Text // <var name="splitNode" type="Text"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;strong&quot;"/>
                // r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                // r#text_node = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="textNode"/>

                // // unimplemented:
                // // <assertDOMException id="throws_INDEX_SIZE_ERR">
                // //  <INDEX_SIZE_ERR>
                // //      <splitText obj="textNode" var="splitNode" offset="-69"/>
                // //  </INDEX_SIZE_ERR>
                // // </assertDOMException>
            }
            // hc_nodedocumentfragmentnodename.xml
            #[test]
            fn test_hc_nodedocumentfragmentnodename() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="docFragment"/>
                let r#document_fragment_name = r#doc_fragment.node_name().to_string(); // <nodeName obj="docFragment" var="documentFragmentName"/>
                assert_eq!(r#document_fragment_name, "#document-fragment"); // <assertEquals actual="documentFragmentName" expected="&quot;#document-fragment&quot;" id="nodeDocumentFragmentNodeNameAssert1" ignoreCase="false"/>
            }
            // hc_nodelistindexgetlengthofemptylist.xml
            #[test]
            fn test_hc_nodelistindexgetlengthofemptylist() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#em_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName interface="Document" obj="doc" var="emList" tagname="&quot;em&quot;"/>
                let r#em_node = r#em_list.item(2).unwrap(); // <item interface="NodeList" obj="emList" var="emNode" index="2"/>
                let r#text_node = r#em_node.first_child().unwrap(); // <firstChild var="textNode" obj="emNode"/>
                let r#text_list = r#text_node.child_nodes(); // <childNodes var="textList" obj="textNode"/>
                let r#length = r#text_list.length(); // <length var="length" obj="textList" interface="NodeList"/>
                assert_eq!(r#length, 0); // <assertEquals actual="length" expected="0" id="length" ignoreCase="false"/>
            }
            // nodegetlastchild.xml
            #[test]
            fn test_nodegetlastchild() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let mut r#lchild_node; // type: Node // <var name="lchildNode" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#lchild_node = r#employee_node.last_child().unwrap(); // <lastChild interface="Node" obj="employeeNode" var="lchildNode"/>
                r#child_name = r#lchild_node.node_name().to_string(); // <nodeName obj="lchildNode" var="childName"/>
                // <if><equals actual="childName" expected="&quot;#text&quot;" ignoreCase="false"/>
                //  <previousSibling interface="Node" obj="lchildNode" var="lchildNode"/>
                //  <nodeName obj="lchildNode" var="childName"/>
                // </if>
                if child_name == "#text" {
                    lchild_node = lchild_node.previous_sibling().unwrap();
                    child_name = lchild_node.node_name().to_string();
                }
                assert_eq!(r#child_name, "address"); // <assertEquals actual="childName" expected="&quot;address&quot;" id="nodeName" ignoreCase="false"/>
            }
            // hc_nodecloneattributescopied.xml
            #[test]
            fn test_hc_nodecloneattributescopied() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#address_node; // type: Node // <var name="addressNode" type="Node"/>
                // let mut r#cloned_node; // type: Node // <var name="clonedNode" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#attribute_node; // type: Node // <var name="attributeNode" type="Node"/>
                // let mut r#attribute_name; // type: DOMString // <var name="attributeName" type="DOMString"/>
                // let mut r#result; // type: Collection // <var name="result" type="Collection"/>
                // let mut r#html_expected; // type: Collection // <var name="htmlExpected" type="Collection"><member>"class"</member><member>"title"</member></var>
                // let mut r#expected; // type: Collection // <var name="expected" type="Collection"><member>"class"</member><member>"title"</member><member>"dir"</member></var>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                // r#address_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="addressNode"/>
                // r#cloned_node = r#address_node.clone_node(false); // <cloneNode obj="addressNode" deep="false" var="clonedNode"/>
                // r#attributes = r#cloned_node.attributes(); // <attributes obj="clonedNode" var="attributes"/>

                // // unimplemented: // <for-each collection="attributes" member="attributeNode"><nodeName obj="attributeNode" var="attributeName"/><append collection="result" item="attributeName"/></for-each>

                // // unimplemented: // <if><contentType type="text/html"/><assertEquals actual="result" expected="htmlExpected" id="nodeNames_html" ignoreCase="true"/><else><assertEquals actual="result" expected="expected" id="nodeNames" ignoreCase="false"/></else></if>
            }
            // nodegetprevioussibling.xml
            #[test]
            fn test_nodegetprevioussibling() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#ps_node; // type: Node // <var name="psNode" type="Node"/>
                let mut r#ps_name; // type: DOMString // <var name="psName" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                r#name_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="nameNode"/>
                r#ps_node = r#name_node.previous_sibling().unwrap(); // <previousSibling interface="Node" obj="nameNode" var="psNode"/>
                r#ps_name = r#ps_node.node_name().to_string(); // <nodeName obj="psNode" var="psName"/>
                // <if><equals actual="psName" expected="&quot;#text&quot;" ignoreCase="false"/>
                //  <previousSibling interface="Node" obj="psNode" var="psNode"/>
                //  <nodeName obj="psNode" var="psName"/>
                // </if>
                if ps_name == "#text" {
                    ps_node = ps_node.previous_sibling().unwrap();
                    ps_name = ps_node.node_name().to_string();
                }
                assert_eq!(r#ps_name, "employeeId"); // <assertEquals actual="psName" expected="&quot;employeeId&quot;" id="nodeName" ignoreCase="false"/>
            }
            // hc_characterdatagetdata.xml
            #[test]
            fn test_hc_characterdatagetdata() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                let r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "Margaret Martin"); // <assertEquals actual="childData" expected="&quot;Margaret Martin&quot;" id="characterdataGetDataAssert" ignoreCase="false"/>
            }
            // hc_attrsetvalue2.xml
            #[test]
            fn test_hc_attrsetvalue2() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                let mut r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#text_node = r#doc.create_text_node("terday"); // <createTextNode var="textNode" obj="doc" data="&quot;terday&quot;"/>
                r#retval = r#title_attr.append_child(text_node.into()).unwrap(); // <appendChild var="retval" obj="titleAttr" newChild="textNode"/>
                r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                // unimplemented: // <assertNotNull actual="firstChild" id="attrChildNotNull"/>
                r#title_attr.set_value("Tomorrow").unwrap(); // <value obj="titleAttr" value="&quot;Tomorrow&quot;" interface="Attr"/>
                r#first_child.set_node_value("impl reused node").unwrap(); // <nodeValue obj="firstChild" value="&quot;impl reused node&quot;"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Tomorrow"); // <assertEquals actual="value" expected="&quot;Tomorrow&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Tomorrow"); // <assertEquals actual="value" expected="&quot;Tomorrow&quot;" id="attrNodeValue" ignoreCase="false"/>
                r#first_child = r#title_attr.last_child().unwrap(); // <lastChild var="firstChild" obj="titleAttr" interface="Node"/>
                r#value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="value"/>
                assert_eq!(r#value, "Tomorrow"); // <assertEquals actual="value" expected="&quot;Tomorrow&quot;" id="firstChildValue" ignoreCase="false"/>
                let r#other_child = r#first_child.next_sibling(); // <nextSibling var="otherChild" obj="firstChild" interface="Node"/>
                assert!(other_child.is_none()); // <assertNull actual="otherChild" id="nextSiblingIsNull"/>
            }
            // hc_attrinsertbefore5.xml
            #[test]
            fn test_hc_attrinsertbefore5() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                // let mut r#test_node; // type: Node // <var name="testNode" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                // let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                // let mut r#text_node; // type: Node // <var name="textNode" type="Node"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#ref_child; // type: Node // <var name="refChild" type="Node" isNull="true"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                // r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                // r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                // r#title_attr = r#attributes.get_named_item("title").unwrap();
                // // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>

                // // unimplemented: // <if><contentType type="text/html"/>	<assertDOMException id="throw_NOT_SUPPORTED_ERR">		<NOT_SUPPORTED_ERR>			<createCDATASection var="textNode" obj="doc" data="&quot;terday&quot;"/>		</NOT_SUPPORTED_ERR>	</assertDOMException><else><createCDATASection var="textNode" obj="doc" data="&quot;terday&quot;"/><assertDOMException id="throw_HIERARCHY_REQUEST_ERR">	<HIERARCHY_REQUEST_ERR>		<insertBefore var="retval" obj="titleAttr" newChild="textNode" refChild="refChild"/>	</HIERARCHY_REQUEST_ERR></assertDOMException></else></if>
            }
            // elementretrievetagname.xml
            #[test]
            fn test_elementretrievetagname() {
                let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("position"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;position&quot;" var="elementList"/>
                let r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="testEmployee"/>
                r#name = r#test_employee.node_name().to_string(); // <nodeName obj="testEmployee" var="name"/>
                assert_eq!(r#name, "position"); // <assertEquals actual="name" expected="&quot;position&quot;" id="nodename" ignoreCase="false"/>
                r#name = r#test_employee.tag_name().to_string(); // <tagName obj="testEmployee" var="name"/>
                assert_eq!(r#name, "position"); // <assertEquals actual="name" expected="&quot;position&quot;" id="tagname" ignoreCase="false"/>
            }
            // nodereplacechildinvalidnodetype.xml
            #[test]
            fn test_nodereplacechildinvalidnodetype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Element // <var name="rootNode" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                let r#new_child = r#doc.create_attribute("newAttribute".to_string()).unwrap(); // <createAttribute obj="doc" name="&quot;newAttribute&quot;" var="newChild"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#old_child = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="oldChild"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <replaceChild var="replacedChild" obj="rootNode" newChild="newChild" oldChild="oldChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    root_node
                        .replace_child(new_child.into(), old_child.into())
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // nodedocumentnodeattribute.xml
            #[test]
            fn test_nodedocumentnodeattribute() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#attr_list = r#doc.attributes(); // <attributes obj="doc" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="documentAttributesNull"/>
            }
            // nodeclonefalsenocopytext.xml
            #[test]
            fn test_nodeclonefalsenocopytext() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#child_node = r#child_list.item(3).unwrap().clone(); // <item interface="NodeList" obj="childList" index="3" var="childNode"/>
                let r#cloned_node = r#child_node.clone_node(false); // <cloneNode obj="childNode" deep="false" var="clonedNode"/>
                let r#last_child_node = r#cloned_node.last_child(); // <lastChild interface="Node" obj="clonedNode" var="lastChildNode"/>
                assert!(last_child_node.is_none()); // <assertNull actual="lastChildNode" id="noTextNodes"/>
            }
            // hc_characterdatadeletedataexceedslength.xml
            #[test]
            fn test_hc_characterdatadeletedataexceedslength() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.delete_data(4, 50).unwrap(); // <deleteData obj="child" offset="4" count="50"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230"); // <assertEquals actual="childData" expected="&quot;1230&quot;" id="characterdataDeleteDataExceedsLengthAssert" ignoreCase="false"/>
            }
            // hc_documentcreatecomment.xml
            #[test]
            fn test_hc_documentcreatecomment() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#new_comment_node = r#doc.create_comment("This is a new Comment node"); // <createComment obj="doc" var="newCommentNode" data="&quot;This is a new Comment node&quot;"/>
                let r#new_comment_value = r#new_comment_node.node_value().unwrap().to_string(); // <nodeValue obj="newCommentNode" var="newCommentValue"/>
                assert_eq!(r#new_comment_value, "This is a new Comment node"); // <assertEquals actual="newCommentValue" expected="&quot;This is a new Comment node&quot;" ignoreCase="false" id="value"/>
                let r#new_comment_name = r#new_comment_node.node_name().to_string(); // <nodeName obj="newCommentNode" var="newCommentName"/>
                assert_eq!(r#new_comment_name, "#comment"); // <assertEquals actual="newCommentName" expected="&quot;#comment&quot;" ignoreCase="false" id="strong"/>
                let r#new_comment_type = r#new_comment_node.node_type(); // <nodeType obj="newCommentNode" var="newCommentType"/>
                assert_eq!(r#new_comment_type as i32, 8); // <assertEquals actual="newCommentType" expected="8" ignoreCase="false" id="type"/>
            }
            // characterdatadeletedataend.xml
            #[test]
            fn test_characterdatadeletedataend() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.delete_data(30, 5).unwrap(); // <deleteData obj="child" offset="30" count="5"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230 North Ave. Dallas, Texas "); // <assertEquals actual="childData" expected="&quot;1230 North Ave. Dallas, Texas &quot;" id="characterdataDeleteDataEndAssert" ignoreCase="false"/>
            }
            // hc_noderemovechildoldchildnonexistent.xml
            #[test]
            fn test_hc_noderemovechildoldchildnonexistent() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#old_child = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="oldChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <removeChild var="removedChild" obj="elementNode" oldChild="oldChild"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .remove_child(old_child.into())
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // documentcreateelementdefaultattr.xml
            #[test]
            fn test_documentcreateelementdefaultattr() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#new_element = r#doc.create_element("address".to_string()).unwrap(); // <createElement obj="doc" var="newElement" tagName="&quot;address&quot;"/>
                let r#default_attr = r#new_element.attributes(); // <attributes obj="newElement" var="defaultAttr"/>
                let r#child = r#default_attr.item(0).unwrap(); // <item obj="defaultAttr" var="child" index="0" interface="NamedNodeMap"/>
                // unimplemented: // <assertNotNull actual="child" id="defaultAttrNotNull"/>
                let r#name = r#child.node_name().to_string(); // <nodeName obj="child" var="name"/>
                assert_eq!(r#name, "street"); // <assertEquals actual="name" expected="&quot;street&quot;" id="attrName" ignoreCase="false"/>
                let r#value = r#child.node_value().unwrap().to_string(); // <nodeValue obj="child" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="attrValue" ignoreCase="false"/>
                assert_eq!(default_attr.length(), 1); // <assertSize collection="defaultAttr" size="1" id="attrCount"/>
            }
            // commentgetcomment.xml
            #[test]
            fn test_commentgetcomment() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#child_value; // type: DOMString // <var name="childValue" type="DOMString"/>
                let mut r#comment_count = 0; // type: int // <var name="commentCount" type="int" value="0"/>
                let mut r#child_type; // type: int // <var name="childType" type="int"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.child_nodes(); // <childNodes obj="doc" var="elementList"/>
                // <for-each collection="elementList" member="child">
                //  <nodeType obj="child" var="childType"/>
                //  <if><equals actual="childType" expected="8" ignoreCase="false"/>
                //      <nodeName obj="child" var="childName"/>
                //      <assertEquals actual="childName" expected="&quot;#comment&quot;" ignoreCase="false" id="nodeName"/>
                //      <nodeValue obj="child" var="childValue"/>
                //      <assertEquals actual="childValue" expected="&quot; This is comment number 1.&quot;" id="nodeValue" ignoreCase="false"/>
                //      <plus var="commentCount" op1="commentCount" op2="1"/>
                //  </if>
                // </for-each>
                for i in 0..element_list.length() {
                    child = element_list.item(i).unwrap();
                    child_type = child.node_type();
                    if child_type as i32 == 8 {
                        child_name = child.node_name().to_string();
                        assert_eq!(child_name, "#comment");
                        child_value = child.node_value().unwrap().to_string();
                        assert_eq!(child_value, " This is comment number 1.");
                        comment_count += 1;
                    }
                }
                assert_eq!(r#comment_count, 1); // <assertEquals actual="commentCount" expected="1" ignoreCase="false" id="commentCount"/>
            }
            // hc_documentgetrootnode.xml
            #[test]
            fn test_hc_documentgetrootnode() {
                let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#root = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="root"/>
                r#root_name = r#root.node_name().to_string(); // <nodeName obj="root" var="rootName"/>

                // unimplemented: // <if><contentType type="image/svg+xml"/><assertEquals actual="rootName" expected="&quot;svg&quot;" id="svgTagName" ignoreCase="false"/><else><assertEquals actual="rootName" expected="&quot;html&quot;" id="docElemName" ignoreCase="auto"/></else></if>
            }
            // hc_textindexsizeerroffsetoutofbounds.xml
            #[test]
            fn test_hc_textindexsizeerroffsetoutofbounds() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;strong&quot;"/>
                r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                r#text_node = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="textNode"/>
                // <assertDOMException id="throw_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <splitText obj="textNode" var="splitNode" offset="300"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
                assert!(
                    text_node
                        .split_text(300)
                        .is_err_and(|err| err == DOMException::IndexSizeErr)
                );
            }
            // attrnotspecifiedvalue.xml
            #[test]
            fn test_attrnotspecifiedvalue() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                let r#state = r#street_attr.specified(); // <specified obj="streetAttr" var="state"/>
                assert!(!r#state); // <assertFalse actual="state" id="streetNotSpecified"/>
            }
            // characterdatareplacedatabegining.xml
            #[test]
            fn test_characterdatareplacedatabegining() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.replace_data(0, 4, "2500").unwrap(); // <replaceData obj="child" offset="0" count="4" arg="&quot;2500&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "2500 North Ave. Dallas, Texas 98551"); // <assertEquals actual="childData" expected="&quot;2500 North Ave. Dallas, Texas 98551&quot;" id="characterdataReplaceDataBeginingAssert" ignoreCase="false"/>
            }
            // nodelistindexequalzero.xml
            #[test]
            fn test_nodelistindexequalzero() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#child = r#employee_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="employeeList" var="child" index="0"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                // <if><notEquals actual="childName" expected="&quot;#text&quot;" ignoreCase="false"/>
                //  <assertEquals actual="childName" expected="&quot;employeeId&quot;" id="childName" ignoreCase="false"/>
                // </if>
                if child_name != "#text" {
                    assert_eq!(child_name, "employeeId");
                }
            }
            // hc_namednodemapnotfounderr.xml
            #[test]
            fn test_hc_namednodemapnotfounderr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="2"/>
                r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <removeNamedItem var="removedNode" interface="NamedNodeMap" obj="attributes" name="&quot;lang&quot;"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .remove_named_item("lang")
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // hc_elementnormalize.xml
            #[test]
            fn test_hc_elementnormalize() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root; // type: Element // <var name="root" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_name; // type: Element // <var name="testName" type="Element"/>
                let r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#ret_node; // type: Node // <var name="retNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("sup"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;sup&quot;" var="elementList"/>
                r#test_name = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testName"/>
                r#text_node = r#doc.create_text_node(""); // <createTextNode var="textNode" obj="doc" data="&quot;&quot;"/>
                r#ret_node = r#test_name.append_child(text_node.into()).unwrap(); // <appendChild var="retNode" obj="testName" newChild="textNode"/>
                r#text_node = r#doc.create_text_node(",000"); // <createTextNode var="textNode" obj="doc" data="&quot;,000&quot;"/>
                r#ret_node = r#test_name.append_child(text_node.into()).unwrap(); // <appendChild var="retNode" obj="testName" newChild="textNode"/>
                r#root = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="root"/>
                r#root.normalize(); // <normalize obj="root"/>
                r#element_list = r#doc.get_elements_by_tag_name("sup"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;sup&quot;" var="elementList"/>
                r#test_name = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testName"/>
                r#first_child = r#test_name.first_child().unwrap(); // <firstChild interface="Node" obj="testName" var="firstChild"/>
                let r#child_value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="childValue"/>
                assert_eq!(r#child_value, "56,000,000"); // <assertEquals actual="childValue" expected="&quot;56,000,000&quot;" id="elementNormalizeAssert" ignoreCase="false"/>
            }
            // notationgetnotationname.xml
            #[test]
            fn test_notationgetnotationname() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#notations = doc_type.notations(); // <notations obj="docType" var="notations"/>
                // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                let r#notation_node = r#notations.get_named_item("notation1").unwrap(); // <getNamedItem obj="notations" var="notationNode" name="&quot;notation1&quot;"/>
                let r#notation_name = r#notation_node.node_name().to_string(); // <nodeName obj="notationNode" var="notationName"/>
                assert_eq!(r#notation_name, "notation1"); // <assertEquals actual="notationName" expected="&quot;notation1&quot;" id="notationGetNotationNameAssert" ignoreCase="false"/>
            }
            // nodechildnodesempty.xml
            #[test]
            fn test_nodechildnodesempty() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#second_c_node = r#child_list.item(1).unwrap().clone(); // <item interface="NodeList" obj="childList" index="1" var="secondCNode"/>
                let r#text_node = r#second_c_node.first_child().unwrap(); // <firstChild interface="Node" obj="secondCNode" var="textNode"/>
                let r#child_nodes_list = r#text_node.child_nodes(); // <childNodes obj="textNode" var="childNodesList"/>
                assert_eq!(child_nodes_list.length(), 0); // <assertSize collection="childNodesList" size="0" id="nodeChildNodesEmptyAssert1"/>
            }
            // hc_nodevalue05.xml
            #[test]
            fn test_hc_nodevalue05() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#new_node = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="newNode"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="initiallyNull"/>
                r#new_node
                    .set_node_value("This should have no effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have no effect&quot;"/>
                let r#new_value = r#new_node.node_value(); // <nodeValue obj="newNode" var="newValue"/>
                assert!(new_value.is_none()); // <assertNull actual="newValue" id="nullAfterAttemptedChange"/>
            }
            // hc_nodegetlastchild.xml
            #[test]
            fn test_hc_nodegetlastchild() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#lchild_node = r#employee_node.last_child().unwrap(); // <lastChild interface="Node" obj="employeeNode" var="lchildNode"/>
                let r#child_name = r#lchild_node.node_name().to_string(); // <nodeName obj="lchildNode" var="childName"/>
                assert_eq!(r#child_name, "#text"); // <assertEquals actual="childName" expected="&quot;#text&quot;" id="whitespace" ignoreCase="false"/>
            }
            // attrspecifiedvalueremove.xml
            #[test]
            fn test_attrspecifiedvalueremove() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#address_list; // type: NodeList // <var name="addressList" type="NodeList"/>
                let mut r#test_node; // type: Node // <var name="testNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                r#test_node = r#address_list.item(2).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="2"/>
                r#test_node.remove_attribute("street").unwrap(); // <removeAttribute obj="testNode" name="&quot;street&quot;"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                // unimplemented: // <assertNotNull actual="streetAttr" id="streetAttrNotNull"/>
                let r#state = r#street_attr.specified(); // <specified obj="streetAttr" var="state"/>
                assert!(!r#state); // <assertFalse actual="state" id="attrSpecifiedValueRemoveAssert"/>
            }
            // hc_nodereplacechildoldchildnonexistent.xml
            #[test]
            fn test_hc_nodereplacechildoldchildnonexistent() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#new_child = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="newChild"/>
                r#old_child = r#doc.create_element("b".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;b&quot;" var="oldChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <replaceChild var="replacedNode" obj="elementNode" newChild="newChild" oldChild="oldChild"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .replace_child(new_child.into(), old_child.into())
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // hc_attreffectivevalue.xml
            #[test]
            fn test_hc_attreffectivevalue() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;acronym&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;title&quot;"/>
                let r#value = r#domestic_attr.node_value().unwrap().to_string(); // <nodeValue obj="domesticAttr" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="attrEffectiveValueAssert" ignoreCase="false"/>
            }
            // hc_characterdatadeletedataend.xml
            #[test]
            fn test_hc_characterdatadeletedataend() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.delete_data(30, 5).unwrap(); // <deleteData obj="child" offset="30" count="5"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230 North Ave. Dallas, Texas "); // <assertEquals actual="childData" expected="&quot;1230 North Ave. Dallas, Texas &quot;" id="characterdataDeleteDataEndAssert" ignoreCase="false"/>
            }
            // nodecdatasectionnodeattribute.xml
            #[test]
            fn test_nodecdatasectionnodeattribute() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#cdata_name; // type: Element // <var name="cdataName" type="Element"/>
                let mut r#cdata_node; // type: Node // <var name="cdataNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;name&quot;"/>
                r#cdata_name = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="cdataName"/>
                r#cdata_node = r#cdata_name.last_child().unwrap(); // <lastChild interface="Node" obj="cdataName" var="cdataNode"/>
                let r#node_type = r#cdata_node.node_type(); // <nodeType var="nodeType" obj="cdataNode"/>
                // <if><notEquals actual="nodeType" expected="4" ignoreCase="false"/>
                //  <createCDATASection var="cdataNode" obj="doc" data="&quot;&quot;"/>
                // </if>
                if node_type as i32 == 4 {
                    cdata_node = doc.create_cdata_section("").unwrap().into();
                }
                let r#attr_list = r#cdata_node.attributes(); // <attributes obj="cdataNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="cdataSection"/>
            }
            // hc_namednodemapinuseattributeerr.xml
            #[test]
            fn test_hc_namednodemapinuseattributeerr() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#first_node; // type: Element // <var name="firstNode" type="Element"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#domestic_attr; // type: Attr // <var name="domesticAttr" type="Attr"/>
                let mut r#set_attr; // type: Attr // <var name="setAttr" type="Attr"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                r#first_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="firstNode" index="0"/>
                r#domestic_attr = r#doc.create_attribute("title".to_string()).unwrap(); // <createAttribute obj="doc" var="domesticAttr" name="&quot;title&quot;"/>
                r#domestic_attr.set_value("Y").unwrap(); // <value interface="Attr" obj="domesticAttr" value="&quot;Y&quot;"/>
                r#set_attr = r#first_node
                    .set_attribute_node(r#domestic_attr.clone())
                    .unwrap()
                    .unwrap(); // <setAttributeNode var="setAttr" obj="firstNode" newAttr="domesticAttr"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="2"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                // <assertDOMException id="throw_INUSE_ATTRIBUTE_ERR">
                //  <INUSE_ATTRIBUTE_ERR>
                //      <setNamedItem var="setNode" interface="NamedNodeMap" obj="attributes" arg="domesticAttr"/>
                //  </INUSE_ATTRIBUTE_ERR>
                // </assertDOMException>
                assert!(
                    attributes
                        .set_named_item(domestic_attr)
                        .is_err_and(|err| err == DOMException::InuseAttributeErr)
                );
            }
            // hc_namednodemapreturnnull.xml
            #[test]
            fn test_hc_namednodemapreturnnull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                let r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="1"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#district_node = r#attributes.get_named_item("lang"); // <getNamedItem obj="attributes" var="districtNode" name="&quot;lang&quot;"/>
                assert!(district_node.is_none()); // <assertNull actual="districtNode" id="langAttrNull"/>
            }
            // hc_documentcreateattribute.xml
            #[test]
            fn test_hc_documentcreateattribute() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#new_attr_node = r#doc.create_attribute("title".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttrNode" name="&quot;title&quot;"/>
                let r#attr_value = r#new_attr_node.node_value().unwrap().to_string(); // <nodeValue obj="newAttrNode" var="attrValue"/>
                assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" ignoreCase="false" id="value"/>
                let r#attr_name = r#new_attr_node.node_name().to_string(); // <nodeName obj="newAttrNode" var="attrName"/>
                assert_eq!(r#attr_name, "title"); // <assertEquals actual="attrName" expected="&quot;title&quot;" ignoreCase="auto" context="attribute" id="name"/>
                let r#attr_type = r#new_attr_node.node_type(); // <nodeType obj="newAttrNode" var="attrType"/>
                assert_eq!(r#attr_type as i32, 2); // <assertEquals actual="attrType" expected="2" ignoreCase="false" id="type"/>
            }
            // nodecommentnodeattributes.xml
            #[test]
            fn test_nodecommentnodeattributes() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#child_node; // type: Node // <var name="childNode" type="Node"/>
                let mut r#attr_list; // type: NamedNodeMap // <var name="attrList" type="NamedNodeMap"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#child_list = r#doc.child_nodes(); // <childNodes obj="doc" var="childList"/>
                // <for-each collection="childList" member="childNode">
                //  <nodeType var="nodeType" obj="childNode"/>
                //  <if><equals actual="nodeType" expected="8"/>
                //      <attributes obj="childNode" var="attrList"/>
                //      <assertNull actual="attrList" id="attributesNull"/>
                //  </if>
                // </for-each>
                for i in 0..child_list.length() {
                    child_node = child_list.item(i).unwrap();
                    node_type = child_node.node_type();
                    if node_type as i32 == 8 {
                        attr_list = child_node.attributes();
                        assert!(attr_list.is_none());
                    }
                }
                let r#child_node = r#doc.create_comment("This is a comment"); // <createComment var="childNode" obj="doc" data="&quot;This is a comment&quot;"/>
                r#attr_list = r#child_node.attributes(); // <attributes obj="childNode" var="attrList"/>
                assert!(attr_list.is_none()); // <assertNull actual="attrList" id="createdAttributesNull"/>
            }
            // elementremoveattributenode.xml
            #[test]
            fn test_elementremoveattributenode() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                let r#street_attr = r#test_employee.get_attribute_node("street").unwrap(); // <getAttributeNode obj="testEmployee" var="streetAttr" name="&quot;street&quot;"/>
                let r#removed_attr = r#test_employee
                    .remove_attribute_node(r#street_attr)
                    .unwrap(); // <removeAttributeNode obj="testEmployee" var="removedAttr" oldAttr="streetAttr"/>
                let r#removed_value = r#removed_attr.value().to_string(); // <value interface="Attr" obj="removedAttr" var="removedValue"/>
                assert_eq!(r#removed_value, "No"); // <assertEquals actual="removedValue" expected="&quot;No&quot;" id="elementRemoveAttributeNodeAssert" ignoreCase="false"/>
            }
            // attrparentnodenull.xml
            #[test]
            fn test_attrparentnodenull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                let r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#domestic_attr = r#attributes.get_named_item("domestic").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;domestic&quot;"/>
                let r#s = r#domestic_attr.parent_node(); // <parentNode interface="Node" obj="domesticAttr" var="s"/>
                assert!(s.is_none()); // <assertNull actual="s" id="attrParentNodeNullAssert"/>
            }
            // hc_namednodemapreturnattrnode.xml
            #[test]
            fn test_hc_namednodemapreturnattrnode() {
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                let r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="1"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#street_attr = r#attributes.get_named_item("class").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;class&quot;"/>
                // unimplemented: // <assertInstanceOf obj="streetAttr" type="Attr" id="typeAssert"/>
                r#attr_name = r#street_attr.node_name().to_string(); // <nodeName obj="streetAttr" var="attrName"/>
                assert_eq!(r#attr_name, "class"); // <assertEquals actual="attrName" expected="&quot;class&quot;" id="nodeName" ignoreCase="auto" context="attribute"/>
                r#attr_name = r#street_attr.name().to_string(); // <name obj="streetAttr" var="attrName" interface="Attr"/>
                assert_eq!(r#attr_name, "class"); // <assertEquals actual="attrName" expected="&quot;class&quot;" id="name" ignoreCase="auto" context="attribute"/>
            }
            // documentcreateprocessinginstruction.xml
            #[test]
            fn test_documentcreateprocessinginstruction() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#new_pi_node = r#doc
                    .create_processing_instruction("TESTPI", Some("This is a new PI node"))
                    .unwrap(); // <createProcessingInstruction obj="doc" var="newPINode" target="&quot;TESTPI&quot;" data="&quot;This is a new PI node&quot;"/>
                // unimplemented: // <assertNotNull actual="newPINode" id="createdPINotNull"/>
                let r#pi_name = r#new_pi_node.node_name().to_string(); // <nodeName obj="newPINode" var="piName"/>
                assert_eq!(r#pi_name, "TESTPI"); // <assertEquals actual="piName" expected="&quot;TESTPI&quot;" ignoreCase="false" id="name"/>
                let r#pi_value = r#new_pi_node.node_value().unwrap().to_string(); // <nodeValue obj="newPINode" var="piValue"/>
                assert_eq!(r#pi_value, "This is a new PI node"); // <assertEquals actual="piValue" expected="&quot;This is a new PI node&quot;" ignoreCase="false" id="value"/>
                let r#pi_type = r#new_pi_node.node_type(); // <nodeType obj="newPINode" var="piType"/>
                assert_eq!(r#pi_type as i32, 7); // <assertEquals actual="piType" expected="7" ignoreCase="false" id="type"/>
            }
            // entitygetpublicidnull.xml
            #[test]
            fn test_entitygetpublicidnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#entity_list = doc_type.entities(); // <entities obj="docType" var="entityList"/>
                // unimplemented: // <assertNotNull actual="entityList" id="entitiesNotNull"/>
                let r#entity_node = r#entity_list.get_named_item("ent1").unwrap(); // <getNamedItem obj="entityList" var="entityNode" name="&quot;ent1&quot;"/>
                let r#public_id = r#entity_node.public_id(); // <publicId interface="Entity" obj="entityNode" var="publicId"/>
                assert!(public_id.is_none()); // <assertNull actual="publicId" id="entityGetPublicIdNullAssert"/>
            }
            // nodechildnodes.xml
            #[test]
            fn test_nodechildnodes() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_nodes; // type: NodeList // <var name="childNodes" type="NodeList"/>
                let mut r#child_node; // type: Node // <var name="childNode" type="Node"/>
                let mut r#child_type; // type: int // <var name="childType" type="int"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#element_names = vec![]; // type: List // <var name="elementNames" type="List"/>
                let mut r#expected_element_names = vec![
                    "employeeId",
                    "name",
                    "position",
                    "salary",
                    "gender",
                    "address",
                ]; // type: List // <var name="expectedElementNames" type="List"><member>"employeeId"</member>  <member>"name"</member>  <member>"position"</member>  <member>"salary"</member>  <member>"gender"</member>  <member>"address"</member></var>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_nodes = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childNodes"/>
                // <for-each collection="childNodes" member="childNode">
                //  <nodeType var="childType" obj="childNode"/>
                //  <if><equals actual="childType" expected="1" ignoreCase="false"/>
                //      <nodeName var="childName" obj="childNode"/>
                //      <append collection="elementNames" item="childName"/>
                //  </if>
                // </for-each>
                for i in 0..child_nodes.length() {
                    child_node = child_nodes.item(i).unwrap();
                    child_type = child_node.node_type();
                    if child_type as i32 == 1 {
                        child_name = child_node.node_name().to_string();
                        element_names.push(child_name);
                    }
                }
                assert_eq!(r#element_names, expected_element_names); // <assertEquals actual="elementNames" expected="expectedElementNames" id="elementNames" ignoreCase="false"/>
            }
            // textwithnomarkup.xml
            #[test]
            fn test_textwithnomarkup() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;name&quot;"/>
                let r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                let r#node_v = r#name_node.first_child().unwrap(); // <firstChild interface="Node" obj="nameNode" var="nodeV"/>
                let r#value = r#node_v.node_value().unwrap().to_string(); // <nodeValue obj="nodeV" var="value"/>
                assert_eq!(r#value, "Roger\n Jones"); // <assertEquals actual="value" expected="&quot;Roger\n Jones&quot;" id="textNodeValue" ignoreCase="false"/>
            }
            // nodecdatasectionnodetype.xml
            #[test]
            fn test_nodecdatasectionnodetype() {
                // unimplemented: // <implementationAttribute name="coalescing" value="false"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#test_name; // type: Element // <var name="testName" type="Element"/>
                let mut r#cdata_node; // type: Node // <var name="cdataNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                r#test_name = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="testName"/>
                r#cdata_node = r#test_name.last_child().unwrap(); // <lastChild interface="Node" obj="testName" var="cdataNode"/>
                let r#node_type = r#cdata_node.node_type(); // <nodeType obj="cdataNode" var="nodeType"/>
                // <if><equals actual="nodeType" expected="3" ignoreCase="false"/>
                //  <createCDATASection var="cdataNode" obj="doc" data="&quot;&quot;"/>
                //  <nodeType obj="cdataNode" var="nodeType"/>
                // </if>
                if node_type as i32 == 3 {
                    cdata_node = doc.create_cdata_section("").unwrap().into();
                }
                assert_eq!(r#node_type as i32, 4); // <assertEquals actual="nodeType" expected="4" id="nodeTypeCDATA" ignoreCase="false"/>
            }
            // documentgetelementsbytagnamelength.xml
            #[test]
            fn test_documentgetelementsbytagnamelength() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#name_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" var="nameList" tagname="&quot;name&quot;"/>
                assert_eq!(name_list.length(), 5); // <assertSize collection="nameList" size="5" id="documentGetElementsByTagNameLengthAssert"/>
            }
            // hc_nodelistreturnfirstitem.xml
            #[test]
            fn test_hc_nodelistreturnfirstitem() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;p&quot;"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#child = r#employee_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="employeeList" var="child" index="0"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                // <if><equals actual="childName" expected="&quot;#text&quot;"/>
                //  <assertEquals actual="childName" expected="&quot;#text&quot;" ignoreCase="false" id="nodeName_w_space"/>
                // <else>
                //  <assertEquals actual="childName" expected="&quot;em&quot;" ignoreCase="auto" id="nodeName_wo_space"/>
                // </else>
                // </if>
                if child_name == "#text" {
                    assert_eq!(child_name, "#text");
                } else {
                    assert_eq!(child_name, "em");
                }
            }
            // nodedocumentnodevalue.xml
            #[test]
            fn test_nodedocumentnodevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#document_value = r#doc.node_value(); // <nodeValue obj="doc" var="documentValue"/>
                assert!(document_value.is_none()); // <assertNull actual="documentValue" id="documentNodeValueNull"/>
            }
            // characterdataindexsizeerrsubstringoffsetgreater.xml
            #[test]
            fn test_characterdataindexsizeerrsubstringoffsetgreater() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                let r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                // <assertDOMException id="throw_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <substringData var="badString" obj="child" offset="40" count="3"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
                assert!(
                    child
                        .substring_data(40, 3)
                        .is_err_and(|err| err == DOMException::IndexSizeErr)
                );
            }
            // hc_elementgetattributenode.xml
            #[test]
            fn test_hc_elementgetattributenode() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                let r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                let r#domestic_attr = r#test_employee.get_attribute_node("title").unwrap(); // <getAttributeNode obj="testEmployee" var="domesticAttr" name="&quot;title&quot;"/>
                let r#node_name = r#domestic_attr.node_name().to_string(); // <nodeName obj="domesticAttr" var="nodeName"/>
                assert_eq!(r#node_name, "title"); // <assertEquals actual="nodeName" expected="&quot;title&quot;" id="nodeName" ignoreCase="auto" context="attribute"/>
            }
            // hc_namednodemapreturnfirstitem.xml
            #[test]
            fn test_hc_namednodemapreturnfirstitem() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#html_expected; // type: Collection // <var name="htmlExpected" type="Collection">    <member>"title"</member>    <member>"class"</member></var>
                // let mut r#expected; // type: Collection // <var name="expected" type="Collection">    <member>"title"</member>    <member>"class"</member>    <member>"dir"</member></var>
                // let mut r#actual; // type: Collection // <var name="actual" type="Collection"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                // r#test_address = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="1"/>
                // r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>

                // // unimplemented: // <for-each collection="attributes" member="child"><nodeName obj="child" var="nodeName"/><append collection="actual" item="nodeName"/></for-each>

                // // unimplemented: // <if><contentType type="text/html"/><assertEquals id="attrName_html" actual="actual" expected="htmlExpected" ignoreCase="true"/><else><assertEquals id="attrName" actual="actual" expected="expected" ignoreCase="false"/></else></if>
            }
            // processinginstructiongetdata.xml
            #[test]
            fn test_processinginstructiongetdata() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#child_nodes = r#doc.child_nodes(); // <childNodes obj="doc" var="childNodes"/>
                let r#pi_node = r#child_nodes
                    .item(0)
                    .unwrap()
                    .clone()
                    .as_processing_instruction()
                    .unwrap(); // <item interface="NodeList" obj="childNodes" var="piNode" index="0"/>
                let r#data = r#pi_node.data().unwrap().to_string(); // <data interface="ProcessingInstruction" obj="piNode" var="data"/>
                assert_eq!(r#data, "PIDATA"); // <assertEquals actual="data" expected="&quot;PIDATA&quot;" id="processinginstructionGetTargetAssert" ignoreCase="false"/>
            }
            // characterdatareplacedatamiddle.xml
            #[test]
            fn test_characterdatareplacedatamiddle() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.replace_data(5, 5, "South").unwrap(); // <replaceData obj="child" offset="5" count="5" arg="&quot;South&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230 South Ave. Dallas, Texas 98551"); // <assertEquals actual="childData" expected="&quot;1230 South Ave. Dallas, Texas 98551&quot;" id="characterdataReplaceDataMiddleAssert" ignoreCase="false"/>
            }
            // nodegetlastchildnull.xml
            #[test]
            fn test_nodegetlastchildnull() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                let r#employee_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="employeeNode"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#second_child_node = r#employee_list.item(1).unwrap().clone(); // <item interface="NodeList" obj="employeeList" index="1" var="secondChildNode"/>
                let r#text_node = r#second_child_node.first_child().unwrap(); // <firstChild interface="Node" obj="secondChildNode" var="textNode"/>
                let r#no_child_node = r#text_node.last_child(); // <lastChild interface="Node" obj="textNode" var="noChildNode"/>
                assert!(no_child_node.is_none()); // <assertNull actual="noChildNode" id="nodeGetLastChildNullAssert1"/>
            }
            // hc_nodeparentnodenull.xml
            #[test]
            fn test_hc_nodeparentnodenull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#created_node = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="createdNode"/>
                let r#parent_node = r#created_node.parent_node(); // <parentNode interface="Node" obj="createdNode" var="parentNode"/>
                assert!(parent_node.is_none()); // <assertNull actual="parentNode" id="parentNode"/>
            }
            // nodechildnodesappendchild.xml
            #[test]
            fn test_nodechildnodesappendchild() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let mut r#expected_length; // type: int // <var name="expectedLength" type="int"/>
                let mut r#length; // type: int // <var name="length" type="int"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#expected_length = r#child_list.length(); // <length var="expectedLength" obj="childList" interface="NodeList"/>
                r#expected_length += 1; // <increment var="expectedLength" value="1"/>
                let r#created_node = r#doc.create_element("text3".to_string()).unwrap(); // <createElement obj="doc" var="createdNode" tagName="&quot;text3&quot;"/>
                r#employee_node = r#employee_node
                    .append_child(created_node.into())
                    .unwrap()
                    .as_element()
                    .unwrap(); // <appendChild obj="employeeNode" newChild="createdNode" var="employeeNode"/>
                r#length = r#child_list.length(); // <length var="length" obj="childList" interface="NodeList"/>
                assert_eq!(r#length, expected_length); // <assertEquals actual="length" expected="expectedLength" ignoreCase="false" id="childNodeLength"/>
            }
            // hc_nodeappendchildnodeancestor.xml
            #[test]
            fn test_hc_nodeappendchildnodeancestor() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#new_child = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="newChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <appendChild var="appendedChild" obj="employeeNode" newChild="newChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    employee_node
                        .append_child(new_child.into())
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // hc_nodegetlastchildnull.xml
            #[test]
            fn test_hc_nodegetlastchildnull() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#em_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;em&quot;" var="emList"/>
                let r#em_node = r#em_list.item(0).unwrap(); // <item interface="NodeList" obj="emList" index="0" var="emNode"/>
                let r#em_text = r#em_node.first_child().unwrap(); // <firstChild var="emText" obj="emNode" interface="Node"/>
                let r#null_child = r#em_text.last_child(); // <lastChild var="nullChild" obj="emText" interface="Node"/>
                assert!(null_child.is_none()); // <assertNull actual="nullChild" id="nullChild"/>
            }
            // hc_domimplementationfeaturenull.xml
            #[test]
            fn test_hc_domimplementationfeaturenull() {
                // // unimplemented: // <implementationAttribute name="hasNullString" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <if><contentType type="text/html"/><hasFeature obj="domImpl" var="state" feature="&quot;HTML&quot;"/><assertTrue actual="state" id="supports_HTML_null"/><else><hasFeature obj="domImpl" var="state" feature="&quot;XML&quot;"/><assertTrue actual="state" id="supports_XML_null"/></else></if>
            }
            // characterdatasubstringvalue.xml
            #[test]
            fn test_characterdatasubstringvalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                let r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                let r#substring = child.substring_data(0, 8).unwrap(); // <substringData obj="child" var="substring" offset="0" count="8"/>
                assert_eq!(r#substring, "Margaret"); // <assertEquals actual="substring" expected="&quot;Margaret&quot;" id="characterdataSubStringValueAssert" ignoreCase="false"/>
            }
            // documentinvalidcharacterexceptioncreateentref1.xml
            #[test]
            fn test_documentinvalidcharacterexceptioncreateentref1() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#bad_entity_ref; // type: EntityReference // <var name="badEntityRef" type="EntityReference"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // // unimplemented: // <if><contentType type="text/html"/><assertDOMException id="throw_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><createEntityReference var="badEntityRef" obj="doc" name="&quot;foo&quot;"/></NOT_SUPPORTED_ERR></assertDOMException><else><assertDOMException id="throw_INVALID_CHARACTER_ERR"><INVALID_CHARACTER_ERR><createEntityReference var="badEntityRef" obj="doc" name="&quot;&quot;"/></INVALID_CHARACTER_ERR></assertDOMException></else></if>
            }
            // hc_attrinsertbefore3.xml
            #[test]
            fn test_hc_attrinsertbefore3() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                let r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let r#ter_node; // type: Text // <var name="terNode" type="Text"/>
                let r#day_node; // type: Text // <var name="dayNode" type="Text"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                r#ter_node = r#doc.create_text_node("ter"); // <createTextNode var="terNode" obj="doc" data="&quot;ter&quot;"/>
                r#day_node = r#doc.create_text_node("day"); // <createTextNode var="dayNode" obj="doc" data="&quot;day&quot;"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#retval = r#doc_frag.append_child(ter_node.into()).unwrap(); // <appendChild var="retval" obj="docFrag" newChild="terNode"/>
                r#retval = r#doc_frag.append_child(day_node.into()).unwrap(); // <appendChild var="retval" obj="docFrag" newChild="dayNode"/>
                r#retval = r#title_attr.insert_before(doc_frag.into(), None).unwrap(); // <insertBefore var="retval" obj="titleAttr" newChild="docFrag" refChild="refChild"/>
                r#value = r#title_attr.value().to_string(); // <value interface="Attr" obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrValue" ignoreCase="false"/>
                r#value = r#title_attr.node_value().unwrap().to_string(); // <nodeValue obj="titleAttr" var="value"/>
                assert_eq!(r#value, "Yesterday"); // <assertEquals actual="value" expected="&quot;Yesterday&quot;" id="attrNodeValue" ignoreCase="false"/>
                let r#value = r#retval.node_value(); // <nodeValue obj="retval" var="value"/>
                assert!(value.is_none()); // <assertNull actual="value" id="retvalValue"/>
                let r#first_child = r#title_attr.first_child().unwrap(); // <firstChild var="firstChild" obj="titleAttr" interface="Node"/>
                let mut r#value = r#first_child.node_value().unwrap().to_string(); // <nodeValue obj="firstChild" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="firstChildValue" ignoreCase="false"/>
                let r#last_child = r#title_attr.last_child().unwrap(); // <lastChild var="lastChild" obj="titleAttr" interface="Node"/>
                r#value = r#last_child.node_value().unwrap().to_string(); // <nodeValue obj="lastChild" var="value"/>
                assert_eq!(r#value, "day"); // <assertEquals actual="value" expected="&quot;day&quot;" id="lastChildValue" ignoreCase="false"/>
            }
            // hc_nodeinsertbeforerefchildnonexistent.xml
            #[test]
            fn test_hc_nodeinsertbeforerefchildnonexistent() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#new_child = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="newChild"/>
                r#ref_child = r#doc.create_element("b".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;b&quot;" var="refChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                // <assertDOMException id="throw_NOT_FOUND_ERR">
                //  <NOT_FOUND_ERR>
                //      <insertBefore var="insertedNode" obj="elementNode" newChild="newChild" refChild="refChild"/>
                //  </NOT_FOUND_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .insert_before(new_child.into(), Some(ref_child.into()))
                        .is_err_and(|err| err == DOMException::NotFoundErr)
                );
            }
            // nodevalue09.xml
            #[test]
            fn test_nodevalue09() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                let mut r#new_value; // type: DOMString // <var name="newValue" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_node = r#doc
                    .create_processing_instruction("TARGET", Some("DATA"))
                    .unwrap(); // <createProcessingInstruction var="newNode" obj="doc" target="&quot;TARGET&quot;" data="&quot;DATA&quot;"/>
                r#new_value = r#new_node.node_value().unwrap().to_string(); // <nodeValue obj="newNode" var="newValue"/>
                assert_eq!(r#new_value, "DATA"); // <assertEquals actual="newValue" expected="&quot;DATA&quot;" ignoreCase="false" id="initial"/>
                r#new_node
                    .set_node_value("This should have an effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have an effect&quot;"/>
                r#new_value = r#new_node.node_value().unwrap().to_string(); // <nodeValue obj="newNode" var="newValue"/>
                assert_eq!(r#new_value, "This should have an effect"); // <assertEquals actual="newValue" expected="&quot;This should have an effect&quot;" ignoreCase="false" id="after"/>
            }
            // hc_nodevalue02.xml
            #[test]
            fn test_hc_nodevalue02() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                let mut r#new_value; // type: DOMString // <var name="newValue" type="DOMString"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#new_node = r#doc.create_comment("This is a new Comment node"); // <createComment obj="doc" var="newNode" data="&quot;This is a new Comment node&quot;"/>
                r#new_value = r#new_node.node_value().unwrap().to_string(); // <nodeValue obj="newNode" var="newValue"/>
                assert_eq!(r#new_value, "This is a new Comment node"); // <assertEquals actual="newValue" expected="&quot;This is a new Comment node&quot;" ignoreCase="false" id="initial"/>
                r#new_node
                    .set_node_value("This should have an effect")
                    .unwrap(); // <nodeValue obj="newNode" value="&quot;This should have an effect&quot;"/>
                r#new_value = r#new_node.node_value().unwrap().to_string(); // <nodeValue obj="newNode" var="newValue"/>
                assert_eq!(r#new_value, "This should have an effect"); // <assertEquals actual="newValue" expected="&quot;This should have an effect&quot;" id="afterChange" ignoreCase="false"/>
            }
            // namednodemapreturnattrnode.xml
            #[test]
            fn test_namednodemapreturnattrnode() {
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="1"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                let r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                // unimplemented: // <assertInstanceOf obj="streetAttr" type="Attr" id="typeAssert"/>
                r#attr_name = r#street_attr.node_name().to_string(); // <nodeName obj="streetAttr" var="attrName"/>
                assert_eq!(r#attr_name, "street"); // <assertEquals actual="attrName" expected="&quot;street&quot;" id="nodeName" ignoreCase="false"/>
                r#attr_name = r#street_attr.name().to_string(); // <name obj="streetAttr" var="attrName" interface="Attr"/>
                assert_eq!(r#attr_name, "street"); // <assertEquals actual="attrName" expected="&quot;street&quot;" id="attrName" ignoreCase="false"/>
            }
            // documenttypegetdoctype.xml
            #[test]
            fn test_documenttypegetdoctype() {
                let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                r#name = r#doc_type.name().to_string(); // <name interface="DocumentType" obj="docType" var="name"/>

                // unimplemented: // <if><contentType type="image/svg+xml"/><assertEquals actual="name" expected="&quot;svg&quot;" id="doctypeName" ignoreCase="false"/><else><assertEquals actual="name" expected="&quot;staff&quot;" id="documenttypeGetDocTypeAssert" ignoreCase="false"/></else></if>
            }
            // hc_attrfirstchild.xml
            #[test]
            fn test_hc_attrfirstchild() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="acronymList" tagname="&quot;acronym&quot;"/>
                let r#test_node = r#acronym_list.item(3).unwrap(); // <item interface="NodeList" obj="acronymList" var="testNode" index="3"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#title_attr = r#attributes.get_named_item("title").unwrap(); // <getNamedItem obj="attributes" var="titleAttr" name="&quot;title&quot;"/>
                let r#text_node = r#title_attr.first_child().unwrap(); // <firstChild var="textNode" obj="titleAttr" interface="Node"/>
                // unimplemented: // <assertNotNull actual="textNode" id="textNodeNotNull"/>
                let r#value = r#text_node.node_value().unwrap().to_string(); // <nodeValue var="value" obj="textNode"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="child1IsYes" ignoreCase="false"/>
                let r#other_child = r#text_node.next_sibling(); // <nextSibling var="otherChild" obj="textNode" interface="Node"/>
                assert!(other_child.is_none()); // <assertNull actual="otherChild" id="nextSiblingIsNull"/>
                let r#other_child = r#text_node.previous_sibling(); // <previousSibling var="otherChild" obj="textNode" interface="Node"/>
                assert!(other_child.is_none()); // <assertNull actual="otherChild" id="previousSiblingIsNull"/>
            }
            // namednodemapsetnameditemthatexists.xml
            #[test]
            fn test_namednodemapsetnameditemthatexists() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let r#district_node; // type: Attr // <var name="districtNode" type="Attr"/>
                let mut r#set_node; // type: Node // <var name="setNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="1"/>
                r#new_attribute = r#doc.create_attribute("street".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;street&quot;"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                r#set_node = r#attributes
                    .set_named_item(r#new_attribute)
                    .unwrap()
                    .unwrap(); // <setNamedItem var="setNode" obj="attributes" arg="newAttribute"/>
                r#district_node = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="districtNode" name="&quot;street&quot;"/>
                let r#attr_value = r#district_node.node_value().unwrap().to_string(); // <nodeValue obj="districtNode" var="attrValue"/>
                assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" id="streetValue" ignoreCase="false"/>
            }
            // hc_namednodemapnumberofnodes.xml
            #[test]
            fn test_hc_namednodemapnumberofnodes() {
                let mut r#length; // type: int // <var name="length" type="int"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;acronym&quot;"/>
                let r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="2"/>
                let r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                r#length = r#attributes.length(); // <length var="length" obj="attributes" interface="NamedNodeMap"/>

                // unimplemented: // <if><contentType type="text/html"/><assertEquals actual="length" expected="2" id="htmlLength" ignoreCase="false"/><else><assertEquals actual="length" expected="3" id="length" ignoreCase="false"/></else></if>
            }
            // attrentityreplacement.xml
            #[test]
            fn test_attrentityreplacement() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                let r#test_node = r#address_list.item(3).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="3"/>
                let r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                let r#street_attr = r#attributes.get_named_item("street").unwrap(); // <getNamedItem obj="attributes" var="streetAttr" name="&quot;street&quot;"/>
                let r#value = r#street_attr.value().to_string(); // <value interface="Attr" obj="streetAttr" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="streetYes" ignoreCase="false"/>
            }
            // hc_nodeclonenodetrue.xml
            #[test]
            fn test_hc_nodeclonenodetrue() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#cloned_node; // type: Node // <var name="clonedNode" type="Node"/>
                let r#cloned_list; // type: NodeList // <var name="clonedList" type="NodeList"/>
                let mut r#cloned_child; // type: Node // <var name="clonedChild" type="Node"/>
                let mut r#cloned_child_name; // type: DOMString // <var name="clonedChildName" type="DOMString"/>
                let r#orig_list; // type: NodeList // <var name="origList" type="NodeList"/>
                let mut r#orig_child; // type: Node // <var name="origChild" type="Node"/>
                let mut r#orig_child_name; // type: DOMString // <var name="origChildName" type="DOMString"/>
                let mut r#result = vec![]; // type: List // <var name="result" type="List"/>
                let mut r#expected = vec![]; // type: List // <var name="expected" type="List"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#orig_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="origList"/>
                // <for-each collection="origList" member="origChild">
                //  <nodeName obj="origChild" var="origChildName"/>
                //  <append collection="expected" item="origChildName"/>
                // </for-each>
                for i in 0..orig_list.length() {
                    orig_child = orig_list.item(i).unwrap();
                    orig_child_name = orig_child.node_name().to_string();
                    expected.push(orig_child_name);
                }
                r#cloned_node = r#employee_node.clone_node(true); // <cloneNode obj="employeeNode" deep="true" var="clonedNode"/>
                r#cloned_list = r#cloned_node.child_nodes(); // <childNodes obj="clonedNode" var="clonedList"/>
                // <for-each collection="clonedList" member="clonedChild">
                //  <nodeName obj="clonedChild" var="clonedChildName"/>
                //  <append collection="result" item="clonedChildName"/>
                // </for-each>
                for i in 0..cloned_list.length() {
                    cloned_child = cloned_list.item(i).unwrap();
                    cloned_child_name = cloned_child.node_name().to_string();
                    result.push(cloned_child_name);
                }
                assert_eq!(r#result, expected); // <assertEquals actual="result" expected="expected" id="clone" ignoreCase="false"/>
            }
            // hc_characterdataindexsizeerrdeletedataoffsetgreater.xml
            #[test]
            fn test_hc_characterdataindexsizeerrdeletedataoffsetgreater() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                // <assertDOMException id="throw_INDEX_SIZE_ERR">
                //  <INDEX_SIZE_ERR>
                //      <deleteData obj="child" offset="40" count="3"/>
                //  </INDEX_SIZE_ERR>
                // </assertDOMException>
                assert!(
                    child
                        .delete_data(40, 3)
                        .is_err_and(|err| err == DOMException::IndexSizeErr)
                );
            }
            // elementgetattributenode.xml
            #[test]
            fn test_elementgetattributenode() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                let r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                let r#domestic_attr = r#test_employee.get_attribute_node("domestic").unwrap(); // <getAttributeNode obj="testEmployee" var="domesticAttr" name="&quot;domestic&quot;"/>
                let r#name = r#domestic_attr.node_name().to_string(); // <nodeName obj="domesticAttr" var="name"/>
                assert_eq!(r#name, "domestic"); // <assertEquals actual="name" expected="&quot;domestic&quot;" id="elementGetAttributeNodeAssert" ignoreCase="false"/>
            }
            // nodeappendchildnodeancestor.xml
            #[test]
            fn test_nodeappendchildnodeancestor() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#new_child = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="newChild"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <appendChild var="appendedChild" obj="employeeNode" newChild="newChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    employee_node
                        .append_child(new_child.into())
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // hc_nodelistindexequalzero.xml
            #[test]
            fn test_hc_nodelistindexequalzero() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;p&quot;"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                let r#length = r#employee_list.length(); // <length var="length" obj="employeeList" interface="NodeList"/>
                let r#child = r#employee_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="employeeList" var="child" index="0"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                // <if><equals expected="13" actual="length" ignoreCase="false"/>
                //  <assertEquals actual="childName" expected="&quot;#text&quot;" ignoreCase="false" id="childName_w_whitespace"/>
                // <else>
                //  <assertEquals actual="childName" expected="&quot;em&quot;" ignoreCase="auto" id="childName_wo_whitespace"/>
                // </else>
                // </if>
                if length == 13 {
                    assert_eq!(child_name, "#text");
                } else {
                    assert_eq!(child_name, "em");
                }
            }
            // hc_nodecommentnodename.xml
            #[test]
            fn test_hc_nodecommentnodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#comment_node; // type: Node // <var name="commentNode" type="Node"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#comment_node_name; // type: DOMString // <var name="commentNodeName" type="DOMString"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#element_list = r#doc.child_nodes(); // <childNodes obj="doc" var="elementList"/>
                // <for-each collection="elementList" member="commentNode">
                //  <nodeType obj="commentNode" var="nodeType"/>
                //  <if><equals actual="nodeType" expected="8" ignoreCase="false"/>
                //      <nodeName obj="commentNode" var="commentNodeName"/>
                //      <assertEquals actual="commentNodeName" expected="&quot;#comment&quot;" id="existingNodeName" ignoreCase="false"/>
                //  </if>
                // </for-each>
                for i in 0..element_list.length() {
                    comment_node = element_list.item(i).unwrap();
                    node_type = comment_node.node_type();
                    if node_type as i32 == 8 {
                        comment_node_name = comment_node.node_name().to_string();
                        assert_eq!(comment_node_name, "#comment");
                    }
                }
                let r#comment_node = r#doc.create_comment("This is a comment"); // <createComment var="commentNode" obj="doc" data="&quot;This is a comment&quot;"/>
                r#comment_node_name = r#comment_node.node_name().to_string(); // <nodeName obj="commentNode" var="commentNodeName"/>
                assert_eq!(r#comment_node_name, "#comment"); // <assertEquals actual="commentNodeName" expected="&quot;#comment&quot;" id="createdNodeName" ignoreCase="false"/>
            }
            // hc_elementsetattributenodenull.xml
            #[test]
            fn test_hc_elementsetattributenodenull() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testEmployee"/>
                let r#new_attribute = r#doc.create_attribute("lang".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttribute" name="&quot;lang&quot;"/>
                let r#district_attr = r#test_employee.set_attribute_node(r#new_attribute).unwrap(); // <setAttributeNode obj="testEmployee" var="districtAttr" newAttr="newAttribute"/>
                assert!(district_attr.is_none()); // <assertNull actual="districtAttr" id="elementSetAttributeNodeNullAssert"/>
            }
            // nodeprocessinginstructionnodevalue.xml
            #[test]
            fn test_nodeprocessinginstructionnodevalue() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#test_list = r#doc.child_nodes(); // <childNodes obj="doc" var="testList"/>
                let r#pi_node = r#test_list
                    .item(0)
                    .unwrap()
                    .clone()
                    .as_processing_instruction()
                    .unwrap(); // <item interface="NodeList" obj="testList" index="0" var="piNode"/>
                let r#pi_value = r#pi_node.node_value().unwrap().to_string(); // <nodeValue obj="piNode" var="piValue"/>
                assert_eq!(r#pi_value, "PIDATA"); // <assertEquals actual="piValue" expected="&quot;PIDATA&quot;" id="value" ignoreCase="false"/>
            }
            // nodeinsertbeforedocfragment.xml
            #[test]
            fn test_nodeinsertbeforedocfragment() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                let mut r#newdoc_fragment; // type: DocumentFragment // <var name="newdocFragment" type="DocumentFragment"/>
                let r#new_child1; // type: Node // <var name="newChild1" type="Node"/>
                let r#new_child2; // type: Node // <var name="newChild2" type="Node"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#inserted_node; // type: Node // <var name="insertedNode" type="Node"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#ref_child = r#child_list.item(3).unwrap().clone(); // <item interface="NodeList" obj="childList" index="3" var="refChild"/>
                r#newdoc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="newdocFragment"/>
                r#new_child1 = r#doc.create_element("newChild1".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild1&quot;" var="newChild1"/>
                r#new_child2 = r#doc.create_element("newChild2".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild2&quot;" var="newChild2"/>
                r#appended_child = r#newdoc_fragment.append_child(new_child1.into()).unwrap(); // <appendChild var="appendedChild" obj="newdocFragment" newChild="newChild1"/>
                r#appended_child = r#newdoc_fragment.append_child(new_child2.into()).unwrap(); // <appendChild var="appendedChild" obj="newdocFragment" newChild="newChild2"/>
                r#inserted_node = r#employee_node
                    .insert_before(newdoc_fragment.into(), ref_child.into())
                    .unwrap(); // <insertBefore var="insertedNode" obj="employeeNode" newChild="newdocFragment" refChild="refChild"/>
                r#child = r#child_list.item(3).unwrap().clone(); // <item interface="NodeList" obj="childList" index="3" var="child"/>
                r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                assert_eq!(r#child_name, "newChild1"); // <assertEquals actual="childName" expected="&quot;newChild1&quot;" ignoreCase="false" id="childName3"/>
                r#child = r#child_list.item(4).unwrap().clone(); // <item interface="NodeList" obj="childList" index="4" var="child"/>
                r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                assert_eq!(r#child_name, "newChild2"); // <assertEquals actual="childName" expected="&quot;newChild2&quot;" ignoreCase="false" id="childName4"/>
            }
            // hc_nodelistreturnlastitem.xml
            #[test]
            fn test_hc_nodelistreturnlastitem() {
                let mut r#index; // type: int // <var name="index" type="int"/>
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;p&quot;"/>
                let r#employee_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="employeeNode" index="2"/>
                let r#employee_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="employeeList"/>
                r#index = r#employee_list.length(); // <length var="index" obj="employeeList" interface="NodeList"/>
                r#index -= 1; // <decrement var="index" value="1"/>
                let r#child = r#employee_list.item(index).unwrap().clone(); // <item interface="NodeList" obj="employeeList" var="child" index="index"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                // <if><equals actual="index" expected="12"/>
                //  <assertEquals actual="childName" expected="&quot;#text&quot;" id="lastNodeName_w_whitespace" ignoreCase="false"/>
                // <else>
                //  <assertEquals actual="childName" expected="&quot;acronym&quot;" id="lastNodeName" ignoreCase="auto"/>
                //  <assertEquals actual="index" expected="5" id="index" ignoreCase="false"/>
                // </else>
                // </if>
                if index == 12 {
                    assert_eq!(child_name, "#text");
                } else {
                    assert_eq!(child_name, "acronym");
                    assert_eq!(index, 5);
                }
            }
            // hc_nodereplacechild.xml
            #[test]
            fn test_hc_nodereplacechild() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#replaced_node; // type: Node // <var name="replacedNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                r#old_child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="oldChild"/>
                r#new_child = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="newChild"/>
                r#replaced_node = r#employee_node
                    .replace_child(new_child.into(), old_child)
                    .unwrap(); // <replaceChild var="replacedNode" obj="employeeNode" newChild="newChild" oldChild="oldChild"/>
                r#child = r#child_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="childList" index="0" var="child"/>
                let r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                assert_eq!(r#child_name, "br"); // <assertEquals actual="childName" expected="&quot;br&quot;" id="nodeName" ignoreCase="auto"/>
            }
            // characterdatadeletedatagetlengthanddata.xml
            #[test]
            fn test_characterdatadeletedatagetlengthanddata() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.delete_data(30, 5).unwrap(); // <deleteData obj="child" offset="30" count="5"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "1230 North Ave. Dallas, Texas "); // <assertEquals actual="childData" expected="&quot;1230 North Ave. Dallas, Texas &quot;" ignoreCase="false" id="data"/>
                let r#child_length = r#child.length(); // <length interface="CharacterData" obj="child" var="childLength"/>
                assert_eq!(r#child_length, 30); // <assertEquals actual="childLength" expected="30" ignoreCase="false" id="length"/>
            }
            // hc_nodeclonetruecopytext.xml
            #[test]
            fn test_hc_nodeclonetruecopytext() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                let r#element_list = r#doc.get_elements_by_tag_name("sup"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;sup&quot;" var="elementList"/>
                let r#child_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="childNode"/>
                let r#cloned_node = r#child_node.clone_node(true); // <cloneNode obj="childNode" deep="true" var="clonedNode"/>
                let r#last_child_node = r#cloned_node.last_child().unwrap(); // <lastChild interface="Node" obj="clonedNode" var="lastChildNode"/>
                let r#child_value = r#last_child_node.node_value().unwrap().to_string(); // <nodeValue obj="lastChildNode" var="childValue"/>
                assert_eq!(r#child_value, "35,000"); // <assertEquals actual="childValue" expected="&quot;35,000&quot;" id="cloneContainsText" ignoreCase="false"/>
            }
            // hc_nodegetprevioussibling.xml
            #[test]
            fn test_hc_nodegetprevioussibling() {
                let r#doc: DocumentRef = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;strong&quot;" var="elementList"/>
                let r#name_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="nameNode"/>
                let r#ps_node = r#name_node.previous_sibling().unwrap(); // <previousSibling interface="Node" obj="nameNode" var="psNode"/>
                let r#ps_name = r#ps_node.node_name().to_string(); // <nodeName obj="psNode" var="psName"/>
                assert_eq!(r#ps_name, "#text"); // <assertEquals actual="psName" expected="&quot;#text&quot;" id="whitespace" ignoreCase="false"/>
            }
            // hc_textsplittextone.xml
            #[test]
            fn test_hc_textsplittextone() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#split_node; // type: Text // <var name="splitNode" type="Text"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;strong&quot;"/>
                r#name_node = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="nameNode" index="2"/>
                r#text_node = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="textNode"/>
                r#split_node = r#text_node.split_text(7).unwrap(); // <splitText obj="textNode" var="splitNode" offset="7"/>
                let r#second_part = r#text_node.next_sibling().unwrap(); // <nextSibling interface="Node" obj="textNode" var="secondPart"/>
                let r#value = r#second_part.node_value().unwrap().to_string(); // <nodeValue obj="secondPart" var="value"/>
                assert_eq!(r#value, "Jones"); // <assertEquals actual="value" expected="&quot;Jones&quot;" id="textSplitTextOneAssert" ignoreCase="false"/>
            }
            // nodetextnodename.xml
            #[test]
            fn test_nodetextnodename() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                let r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                let r#text_node = r#test_addr.first_child().unwrap(); // <firstChild interface="Node" obj="testAddr" var="textNode"/>
                let r#text_name = r#text_node.node_name().to_string(); // <nodeName obj="textNode" var="textName"/>
                assert_eq!(r#text_name, "#text"); // <assertEquals actual="textName" expected="&quot;#text&quot;" id="nodeTextNodeNameAssert1" ignoreCase="false"/>
            }
            // hc_nodereplacechildnewchilddiffdocument.xml
            #[test]
            fn test_hc_nodereplacechildnewchilddiffdocument() {
                let r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                let r#new_child; // type: Node // <var name="newChild" type="Node"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_node; // type: Node // <var name="elementNode" type="Node"/>
                r#doc1 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc1" href="hc_staff" willBeModified="false"/>
                r#doc2 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc2" href="hc_staff" willBeModified="true"/>
                r#new_child = r#doc1.create_element("br".to_string()).unwrap(); // <createElement obj="doc1" tagName="&quot;br&quot;" var="newChild"/>
                r#element_list = r#doc2.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc2" tagname="&quot;p&quot;" var="elementList"/>
                r#element_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="elementNode"/>
                r#old_child = r#element_node.first_child().unwrap(); // <firstChild obj="elementNode" var="oldChild" interface="Node"/>
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <replaceChild var="replacedChild" obj="elementNode" newChild="newChild" oldChild="oldChild"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
                assert!(
                    element_node
                        .replace_child(new_child.into(), old_child)
                        .is_err_and(|err| err == DOMException::WrongDocumentErr)
                );
            }
            // hc_nodeelementnodeattributes.xml
            #[test]
            fn test_hc_nodeelementnodeattributes() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                // let mut r#addr_attr; // type: NamedNodeMap // <var name="addrAttr" type="NamedNodeMap"/>
                // let mut r#attr_node; // type: Node // <var name="attrNode" type="Node"/>
                // let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                // let mut r#attr_list; // type: Collection // <var name="attrList" type="Collection"/>
                // let mut r#html_expected; // type: Collection // <var name="htmlExpected" type="Collection"><member>"title"</member><member>"class"</member></var>
                // let mut r#expected; // type: Collection // <var name="expected" type="Collection"><member>"title"</member><member>"class"</member><member>"dir"</member></var>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                // r#test_addr = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="testAddr"/>
                // r#addr_attr = r#test_addr.attributes(); // <attributes obj="testAddr" var="addrAttr"/>

                // // unimplemented: // <for-each collection="addrAttr" member="attrNode"><nodeName obj="attrNode" var="attrName"/><append collection="attrList" item="attrName"/></for-each>

                // // unimplemented: // <if><contentType type="text/html"/><assertEquals actual="attrList" expected="htmlExpected" id="attrNames_html" ignoreCase="true"/><else><assertEquals actual="attrList" expected="expected" id="attrNames" ignoreCase="false"/></else></if>
            }
            // entitygetentityname.xml
            #[test]
            fn test_entitygetentityname() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // unimplemented: // <assertNotNull actual="docType" id="docTypeNotNull"/>
                let r#entity_list = doc_type.entities(); // <entities obj="docType" var="entityList"/>
                // unimplemented: // <assertNotNull actual="entityList" id="entitiesNotNull"/>
                let r#entity_node = r#entity_list.get_named_item("ent1").unwrap(); // <getNamedItem obj="entityList" var="entityNode" name="&quot;ent1&quot;"/>
                let r#entity_name = r#entity_node.node_name().to_string(); // <nodeName obj="entityNode" var="entityName"/>
                assert_eq!(r#entity_name, "ent1"); // <assertEquals actual="entityName" expected="&quot;ent1&quot;" id="entityGetEntityNameAssert" ignoreCase="false"/>
            }
            // nodeappendchildgetnodename.xml
            #[test]
            fn test_nodeappendchildgetnodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#new_child = r#doc.create_element("newChild".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;newChild&quot;" var="newChild"/>
                let r#append_node = r#employee_node.append_child(new_child.into()).unwrap(); // <appendChild obj="employeeNode" newChild="newChild" var="appendNode"/>
                let r#child_name = r#append_node.node_name().to_string(); // <nodeName obj="appendNode" var="childName"/>
                assert_eq!(r#child_name, "newChild"); // <assertEquals actual="childName" expected="&quot;newChild&quot;" id="nodeAppendChildGetNodeNameAssert1" ignoreCase="false"/>
            }
            // hc_nodeappendchildinvalidnodetype.xml
            #[test]
            fn test_hc_nodeappendchildinvalidnodetype() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root_node; // type: Element // <var name="rootNode" type="Element"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>
                let r#new_child = r#doc.create_attribute("newAttribute".to_string()).unwrap(); // <createAttribute obj="doc" name="&quot;newAttribute&quot;" var="newChild"/>
                // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">
                //  <HIERARCHY_REQUEST_ERR>
                //      <appendChild var="appendedChild" obj="rootNode" newChild="newChild"/>
                //  </HIERARCHY_REQUEST_ERR>
                // </assertDOMException>
                assert!(
                    root_node
                        .append_child(new_child.into())
                        .is_err_and(|err| err == DOMException::HierarchyRequestErr)
                );
            }
            // hc_nodeinsertbeforenodename.xml
            #[test]
            fn test_hc_nodeinsertbeforenodename() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;p&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>
                let r#child_list = r#employee_node.child_nodes(); // <childNodes obj="employeeNode" var="childList"/>
                let r#ref_child = r#child_list.item(3).unwrap().clone(); // <item interface="NodeList" obj="childList" index="3" var="refChild"/>
                let r#new_child = r#doc.create_element("br".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;br&quot;" var="newChild"/>
                let r#inserted_node = r#employee_node
                    .insert_before(new_child.into(), Some(ref_child))
                    .unwrap(); // <insertBefore obj="employeeNode" newChild="newChild" refChild="refChild" var="insertedNode"/>
                let r#child_name = r#inserted_node.node_name().to_string(); // <nodeName obj="insertedNode" var="childName"/>
                assert_eq!(r#child_name, "br"); // <assertEquals actual="childName" expected="&quot;br&quot;" id="nodeName" ignoreCase="auto"/>
            }
            // hc_characterdatareplacedataexceedslengthofarg.xml
            #[test]
            fn test_hc_characterdatareplacedataexceedslengthofarg() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.replace_data(0, 4, "260030").unwrap(); // <replaceData obj="child" offset="0" count="4" arg="&quot;260030&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "260030 North Ave. Dallas, Texas 98551"); // <assertEquals actual="childData" expected="&quot;260030 North Ave. Dallas, Texas 98551&quot;" id="characterdataReplaceDataExceedsLengthOfArgAssert" ignoreCase="false"/>
            }
            // domimplementationfeaturexml.xml
            #[test]
            fn test_domimplementationfeaturexml() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                let r#dom_impl = doc.implementation(); // <implementation obj="doc" var="domImpl"/>
                let r#state = dom_impl.has_feature("xml", Some("1.0")); // <hasFeature obj="domImpl" var="state" feature="&quot;xml&quot;" version="&quot;1.0&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="hasXML1"/>
            }
            // elementremoveattribute.xml
            #[test]
            fn test_elementremoveattribute() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Element // <var name="testEmployee" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(3).unwrap(); // <item interface="NodeList" obj="elementList" index="3" var="testEmployee"/>
                r#test_employee.remove_attribute("street").unwrap(); // <removeAttribute obj="testEmployee" name="&quot;street&quot;"/>
                let r#attr_value = r#test_employee.get_attribute("street"); // <getAttribute obj="testEmployee" var="attrValue" name="&quot;street&quot;"/>
                assert_eq!(r#attr_value, "Yes"); // <assertEquals actual="attrValue" expected="&quot;Yes&quot;" id="streetYes" ignoreCase="false"/>
            }
            // nodedocumentfragmentnodename.xml
            #[test]
            fn test_nodedocumentfragmentnodename() {
                let r#doc: DocumentRef = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                let r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="docFragment"/>
                let r#document_fragment_name = r#doc_fragment.node_name().to_string(); // <nodeName obj="docFragment" var="documentFragmentName"/>
                assert_eq!(r#document_fragment_name, "#document-fragment"); // <assertEquals actual="documentFragmentName" expected="&quot;#document-fragment&quot;" id="nodeDocumentFragmentNodeNameAssert1" ignoreCase="false"/>
            }
            // hc_characterdatareplacedatabegining.xml
            #[test]
            fn test_hc_characterdatareplacedatabegining() {
                let r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let r#name_node; // type: Node // <var name="nameNode" type="Node"/>
                let mut r#child; // type: CharacterData // <var name="child" type="CharacterData"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                r#name_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="nameNode"/>
                r#child = r#name_node.first_child().unwrap().as_text_node().unwrap(); // <firstChild interface="Node" obj="nameNode" var="child"/>
                r#child.replace_data(0, 4, "2500").unwrap(); // <replaceData obj="child" offset="0" count="4" arg="&quot;2500&quot;"/>
                let r#child_data = r#child.data().to_string(); // <data interface="CharacterData" obj="child" var="childData"/>
                assert_eq!(r#child_data, "2500 North Ave. Dallas, Texas 98551"); // <assertEquals actual="childData" expected="&quot;2500 North Ave. Dallas, Texas 98551&quot;" id="characterdataReplaceDataBeginingAssert" ignoreCase="false"/>
            }
        }
    }
    mod level2 {
        use super::*;
        mod core {
            use exml::dom::{
                named_node_map::NamedNodeMap, node_list::NodeList, notation::NotationIdentifier,
            };

            use super::*;

            const STAFF_XML: &str = "resources/DOM-Test-Suite/tests/level2/core/files/staff.xml";
            const STAFF_NS_XML: &str =
                "resources/DOM-Test-Suite/tests/level2/core/files/staffNS.xml";
            const HC_STAFF_XML: &str =
                "resources/DOM-Test-Suite/tests/level2/core/files/hc_staff.xml";

            #[rustfmt::skip]
            fn staff_xml(_doc: &str) -> Result<DocumentRef, DOMException> {
                let doctype = DocumentTypeRef::new("staff", None, Some("staff.dtd")).unwrap();
                let mut doc = DocumentRef::new(None, Some("staff"), Some(doctype)).unwrap();

                let mut doctype = doc.doctype().unwrap();
                // Internal Subset
                let mut ent = doctype.create_entity("ent1", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("es").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent2", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("1900 Dallas Road").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent3", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("Texas").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent4", EntityType::InternalGeneralEntity).unwrap();
                let mut ent_element = doc.create_element("entElement").unwrap();
                ent_element.set_attribute("domestic", "Yes").unwrap();
                ent_element.append_child(doc.create_text_node("Element data").into()).unwrap();
                ent.append_child(ent_element.into()).unwrap();
                ent.append_child(doc.create_processing_instruction("PItarget", Some("PIdata")).unwrap().into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent5", EntityType::ExternalGeneralUnparsedEntity).unwrap();
                ent.set_public_id(Some("entityURI"));
                ent.set_system_id(Some("entityFile"));
                ent.set_notation_name(Some("notation1"));
                doctype.add_entity::<false>(ent).unwrap();
                assert!(doctype.add_entity::<false>(doctype.create_entity("ent1", EntityType::InternalGeneralEntity).unwrap()).is_err());
                doctype.add_notation::<false>(doctype.create_notation("notation1",NotationIdentifier::PublicID { public_id: "notation1File".into() }).unwrap()).unwrap();
                doctype.add_notation::<false>(doctype.create_notation("notation2",NotationIdentifier::ExternalID { public_id: None, system_id: "notation2File".into() }).unwrap(),).unwrap();
                // External Subset
                doctype.add_element_decl::<true>(doctype.create_element_decl("employeeId",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("name",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("position",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("salary",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("address",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("entElement",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                let mut or = ElementContent::new_or(ElementContentOccur::Mult);
                or.set_first_child(Some(ElementContent::new_pcdata(ElementContentOccur::Once)));
                or.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"entElement")));
                doctype.add_element_decl::<true>(doctype.create_element_decl("gender", ContentSpec::Mixed(or)).unwrap()).unwrap();
                let mut seq1 = ElementContent::new_seq(ElementContentOccur::Once);
                seq1.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"employeeId")));
                let mut seq2 = ElementContent::new_seq(ElementContentOccur::Once);
                seq2.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"name")));
                let mut seq3 = ElementContent::new_seq(ElementContentOccur::Once);
                seq3.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"position")));
                let mut seq4 = ElementContent::new_seq(ElementContentOccur::Once);
                seq4.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"salary")));
                let mut seq5 = ElementContent::new_seq(ElementContentOccur::Once);
                seq5.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"gender")));
                seq5.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"address")));
                seq4.set_second_child(Some(seq5));
                seq3.set_second_child(Some(seq4));
                seq2.set_second_child(Some(seq3));
                seq1.set_second_child(Some(seq2));
                doctype.add_element_decl::<true>(doctype.create_element_decl("employee", ContentSpec::Children(seq1)).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("staff",ContentSpec::Children(ElementContent::new_element(ElementContentOccur::Plus,"employee"))).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("entElement","attr1",AttType::CDATA,DefaultDecl::None("Attr".into())).unwrap(),).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("address","domestic",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("address","street",AttType::CDATA,DefaultDecl::None("Yes".into())).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("entElement","domestic",AttType::CDATA,DefaultDecl::None("MALE".into())).unwrap()).unwrap();

                doc.insert_before(doc.create_processing_instruction("TEST-STYLE", Some("PIDATA")).unwrap().into(),Some(doctype.into())).unwrap();

                let mut root = doc.document_element().unwrap();
                assert!(root.parent_node().is_some());
                let comment = doc.create_comment(" This is comment number 1.").into();
                doc.insert_before(comment, Some(root.clone().into())).unwrap();

                let mut employee = root.append_child(doc.create_element("employee").unwrap().into()).unwrap();
                let mut employee_id = employee.append_child(doc.create_element("employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0001").into()).unwrap();
                let mut name = employee.append_child(doc.create_element("name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Margaret Martin").into()).unwrap();
                let mut position = employee.append_child(doc.create_element("position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Accountant").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element("salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("56,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element("gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("Female").into()).unwrap();
                let mut address = employee.append_child(doc.create_element("address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("1230 North Ave. Dallas, Texas 98551").into())?;
                address.set_attribute("domestic", "Yes").unwrap();

                let mut employee = root.append_child(doc.create_element("employee").unwrap().into()).unwrap();
                let mut employee_id = employee.append_child(doc.create_element("employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0002").into()).unwrap();
                let mut name = employee.append_child(doc.create_element("name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Martha Raynolds").into()).unwrap();
                name.append_child(doc.create_cdata_section("This is a CDATASection with EntityReference number 2 &ent2;").unwrap().into())?;
                name.append_child(doc.create_text_node("\n").into()).unwrap();
                name.append_child(doc.create_cdata_section("This is an adjacent CDATASection with a reference to a tab &tab;").unwrap().into())?;
                let mut position = employee.append_child(doc.create_element("position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Secretary").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element("salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("35,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element("gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("Female").into()).unwrap();
                let mut address = employee.append_child(doc.create_element("address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_entity_reference("ent2").unwrap().into()).unwrap();
                address.append_child(doc.create_text_node(" Dallas, ").into()).unwrap();
                address.append_child(doc.create_entity_reference("ent3").unwrap().into()).unwrap();
                address.append_child(doc.create_text_node("\n 98554").into()).unwrap();
                address.set_attribute("domestic", "Yes").unwrap();
                address.set_attribute("street", "Yes").unwrap();

                let mut employee = root.append_child(doc.create_element("employee").unwrap().into()).unwrap();
                let mut employee_id = employee.append_child(doc.create_element("employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0003").into()).unwrap();
                let mut name = employee.append_child(doc.create_element("name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Roger\n Jones").into()).unwrap();
                let mut position = employee.append_child(doc.create_element("position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Department Manager").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element("salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("100,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element("gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_entity_reference("ent4").unwrap().into()).unwrap();
                let mut address = employee.append_child(doc.create_element("address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("PO Box 27 Irving, texas 98553").into()).unwrap();
                address.set_attribute("domestic", "Yes").unwrap();
                address.set_attribute("street", "No").unwrap();

                let mut employee = root.append_child(doc.create_element("employee").unwrap().into()).unwrap();
                let mut employee_id = employee.append_child(doc.create_element("employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0004").into()).unwrap();
                let mut name = employee.append_child(doc.create_element("name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Jeny Oconnor").into()).unwrap();
                let mut position = employee.append_child(doc.create_element("position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Personnel Director").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element("salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("95,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element("gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("Female").into()).unwrap();
                let mut address = employee.append_child(doc.create_element("address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("PO Box 27 Irving, texas 98553").into()).unwrap();
                address.set_attribute("domestic", "Yes")?;
                address.set_attribute("street", "Y")?;
                let mut street = address.get_attribute_node("street").unwrap();
                street.append_child(doc.create_entity_reference("ent1").unwrap().into()).unwrap();

                let mut employee = root.append_child(doc.create_element("employee").unwrap().into()).unwrap();
                let mut employee_id = employee.append_child(doc.create_element("employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0005").into()).unwrap();
                let mut name = employee.append_child(doc.create_element("name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Robert Myers").into()).unwrap();
                let mut position = employee.append_child(doc.create_element("position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Computer Specialist").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element("salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("90,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element("gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("male").into()).unwrap();
                let mut address = employee.append_child(doc.create_element("address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("1821 Nordic. Road, Irving Texas 98558").into())?;
                address.set_attribute("street", "Yes").unwrap();

                doc.enable_read_only_check();
                Ok(doc)
                // Ok(load_xml::<false>(doc))
            }
            #[rustfmt::skip]
            fn staff_ns_xml(_doc: &str) -> Result<DocumentRef, DOMException> {
                let doctype = DocumentTypeRef::new("staff", Some("STAFF"), Some("staffNS.dtd")).unwrap();
                let mut doc = DocumentRef::new(None, Some("staff"), Some(doctype)).unwrap();

                let mut doctype = doc.doctype().unwrap();
                // Internal Subset
                let mut ent = doctype.create_entity("ent1", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("es").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent2", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("1900 Dallas Road").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent3", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("Texas").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent4", EntityType::InternalGeneralEntity).unwrap();
                let mut ent_element = doc.create_element("entElement1").unwrap();
                ent_element.set_attribute_ns(Some(XML_NS_NAMESPACE), "xmlns:local1", "www.xyz.com").unwrap();
                ent_element.append_child(doc.create_text_node("Element data").into()).unwrap();
                ent.append_child(ent_element.into()).unwrap();
                ent.append_child(doc.create_processing_instruction("PItarget", Some("PIdata")).unwrap().into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("ent5", EntityType::ExternalGeneralUnparsedEntity).unwrap();
                ent.set_public_id(Some("entityURI"));
                ent.set_system_id(Some("entityFile"));
                ent.set_notation_name(Some("notation1"));
                doctype.add_entity::<false>(ent).unwrap();
                assert!(doctype.add_entity::<false>(doctype.create_entity("ent1", EntityType::InternalGeneralEntity).unwrap()).is_err());
                doctype.add_notation::<false>(doctype.create_notation("notation1",NotationIdentifier::PublicID { public_id: "notation1File".into() }).unwrap()).unwrap();
                doctype.add_notation::<false>(doctype.create_notation("notation2",NotationIdentifier::ExternalID { public_id: None, system_id: "notation2File".into() }).unwrap(),).unwrap();
                // External Subset
                // <!ELEMENT staff (employee+,emp:employee,employee) >
                let mut seq1 = ElementContent::new_seq(ElementContentOccur::Once);
                seq1.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Plus, "employee")));
                let mut seq2 = ElementContent::new_seq(ElementContentOccur::Once);
                seq2.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once, "emp:employee")));
                seq2.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once, "employee")));
                seq1.set_second_child(Some(seq2));
                doctype.add_element_decl::<true>(doctype.create_element_decl("staff",ContentSpec::Children(seq1)).unwrap()).unwrap();
                // <!ELEMENT employee (employeeId,name,position,salary,gender,address) >
                let mut seq1 = ElementContent::new_seq(ElementContentOccur::Once);
                seq1.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"employeeId")));
                let mut seq2 = ElementContent::new_seq(ElementContentOccur::Once);
                seq2.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"name")));
                let mut seq3 = ElementContent::new_seq(ElementContentOccur::Once);
                seq3.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"position")));
                let mut seq4 = ElementContent::new_seq(ElementContentOccur::Once);
                seq4.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"salary")));
                let mut seq5 = ElementContent::new_seq(ElementContentOccur::Once);
                seq5.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"gender")));
                seq5.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"address")));
                seq4.set_second_child(Some(seq5));
                seq3.set_second_child(Some(seq4));
                seq2.set_second_child(Some(seq3));
                seq1.set_second_child(Some(seq2));
                doctype.add_element_decl::<true>(doctype.create_element_decl("employee", ContentSpec::Children(seq1)).unwrap()).unwrap();
                // <!ATTLIST employee xmlns CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("employee", "xmlns", AttType::CDATA, DefaultDecl::Implied).unwrap()).unwrap();
                // <!ATTLIST employee xmlns:dmstc CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("employee", "xmlns:dmstc", AttType::CDATA, DefaultDecl::Implied).unwrap()).unwrap();
                // <!ATTLIST employee xmlns:emp2 CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("employee", "xmlns:emp2", AttType::CDATA, DefaultDecl::Implied).unwrap()).unwrap();
                // <!ELEMENT employeeId (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("employeeId",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ELEMENT name (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("name",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ELEMENT position (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("position",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ELEMENT salary (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("salary",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ELEMENT entElement1 (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("entElement1",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ELEMENT gender (#PCDATA | entElement1)* >
                let mut or = ElementContent::new_or(ElementContentOccur::Mult);
                or.set_first_child(Some(ElementContent::new_pcdata(ElementContentOccur::Once)));
                or.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"entElement")));
                doctype.add_element_decl::<true>(doctype.create_element_decl("gender", ContentSpec::Mixed(or)).unwrap()).unwrap();
                // <!ELEMENT address (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("address",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ATTLIST address dmstc:domestic CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("address","dmstc:domestic",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                // <!ATTLIST address street CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("address","street",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                // <!ATTLIST address domestic CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("address","domestic",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                // <!ATTLIST address xmlns CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("address","xmlns",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                // <!ELEMENT emp:employee (emp:employeeId,nm:name,emp:position,emp:salary,emp:gender,emp:address) >
                let mut seq1 = ElementContent::new_seq(ElementContentOccur::Once);
                seq1.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once, "emp:employeeId")));
                let mut seq2 = ElementContent::new_seq(ElementContentOccur::Once);
                seq2.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once, "emp:position")));
                let mut seq3 = ElementContent::new_seq(ElementContentOccur::Once);
                seq3.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once, "emp:salary")));
                let mut seq4 = ElementContent::new_seq(ElementContentOccur::Once);
                seq4.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once, "emp:gender")));
                seq4.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once, "emp:address")));
                seq3.set_second_child(Some(seq4));
                seq2.set_second_child(Some(seq3));
                seq1.set_second_child(Some(seq2));
                doctype.add_element_decl::<true>(doctype.create_element_decl("emp:employee",ContentSpec::Children(seq1)).unwrap()).unwrap();
                // <!ATTLIST emp:employee xmlns:emp CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("emp:employee","xmlns:emp",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                // <!ATTLIST emp:employee xmlns:nm CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("emp:employee","xmlns:ns",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                // <!ATTLIST emp:employee defaultAttr CDATA 'defaultVal'>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("emp:employee","defaultAttr",AttType::CDATA,DefaultDecl::None("defaultVal".into())).unwrap()).unwrap();
                // <!ELEMENT emp:employeeId (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("emp:employeeId",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ELEMENT nm:name (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("nm:name",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ELEMENT emp:position (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("emp:position",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ELEMENT emp:salary (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("emp:salary",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ELEMENT emp:gender (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("emp:gender",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ELEMENT emp:address (#PCDATA) >
                doctype.add_element_decl::<true>(doctype.create_element_decl("emp:address",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                // <!ATTLIST emp:address emp:domestic CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("emp:address","emp:domestic",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                // <!ATTLIST emp:address street CDATA #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("emp:address","street",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                // <!ATTLIST emp:address emp:zone ID #IMPLIED>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("emp:address","emp:zone",AttType::ID,DefaultDecl::Implied).unwrap()).unwrap();
                // <!ATTLIST emp:address emp:district CDATA 'DISTRICT'>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("emp:address","emp:distric",AttType::CDATA,DefaultDecl::None("DISTRICT".into())).unwrap()).unwrap();
                // <!ATTLIST emp:address emp:local1 CDATA 'FALSE'>
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("emp:address","emp:local1",AttType::CDATA,DefaultDecl::None("FALSE".into())).unwrap()).unwrap();

                doc.insert_before(doc.create_processing_instruction("TEST-STYLE", Some("PIDATA")).unwrap().into(),Some(doctype.into())).unwrap();

                let mut root = doc.document_element().unwrap();
                assert!(root.parent_node().is_some());
                let comment = doc.create_comment(" This is comment number 1.").into();
                doc.insert_before(comment, Some(root.clone().into())).unwrap();

                let mut employee = root.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "employee").unwrap().into()).unwrap().as_element().unwrap();
                employee.set_attribute_ns(Some(XML_NS_NAMESPACE), "xmlns", "http://www.nist.gov").unwrap();
                employee.set_attribute_ns(Some(XML_NS_NAMESPACE), "xmlns:dmstc", "http://www.usa.com").unwrap();
                let mut employee_id = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0001").into()).unwrap();
                let mut name = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Margaret Martin").into()).unwrap();
                let mut position = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Accountant").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("56,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("Female").into()).unwrap();
                let mut address = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("1230 North Ave. Dallas, Texas 98551").into())?;
                address.set_attribute_ns(Some("http://www.usa.com"), "dmstc:domestic", "Yes").unwrap();

                let mut employee = root.append_child(doc.create_element_ns(None, "employee").unwrap().into()).unwrap().as_element().unwrap();
                employee.set_attribute_ns(Some(XML_NS_NAMESPACE), "xmlns:dmstc", "http://www.usa.com").unwrap();
                let mut employee_id = employee.append_child(doc.create_element_ns(None, "employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0002").into()).unwrap();
                let mut name = employee.append_child(doc.create_element_ns(None, "name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Martha Raynolds").into()).unwrap();
                name.append_child(doc.create_cdata_section("This is a CDATASection with EntityReference number 2 &ent2;").unwrap().into())?;
                name.append_child(doc.create_text_node("\n").into()).unwrap();
                name.append_child(doc.create_cdata_section("This is an adjacent CDATASection with a reference to a tab &tab;").unwrap().into())?;
                let mut position = employee.append_child(doc.create_element_ns(None, "position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Secretary").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element_ns(None, "salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("35,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element_ns(None, "gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("Female").into()).unwrap();
                let mut address = employee.append_child(doc.create_element_ns(None, "address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_entity_reference("ent2").unwrap().into()).unwrap();
                address.append_child(doc.create_text_node(" Dallas, ").into()).unwrap();
                address.append_child(doc.create_entity_reference("ent3").unwrap().into()).unwrap();
                address.append_child(doc.create_text_node("\n 98554").into()).unwrap();
                address.set_attribute_ns(Some("http://www.usa.com"), "dmstc:domestic", "Yes").unwrap();
                address.set_attribute_ns(None, "street", "Yes").unwrap();

                let mut employee = root.append_child(doc.create_element_ns(None, "employee").unwrap().into()).unwrap().as_element().unwrap();
                employee.set_attribute_ns(Some(XML_NS_NAMESPACE), "xmlns:dmstc", "http://www.netzero.com");
                let mut employee_id = employee.append_child(doc.create_element_ns(None, "employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0003").into()).unwrap();
                let mut name = employee.append_child(doc.create_element_ns(None, "name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Roger\n Jones").into()).unwrap();
                let mut position = employee.append_child(doc.create_element_ns(None, "position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Department Manager").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element_ns(None, "salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("100,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element_ns(None, "gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_entity_reference("ent4").unwrap().into()).unwrap();
                let mut address = employee.append_child(doc.create_element_ns(None, "address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("PO Box 27 Irving, texas 98553").into()).unwrap();
                address.set_attribute_ns(Some("http://www.netzero.com"), "dmstc:domestic", "Yes").unwrap();
                address.set_attribute("street", "No").unwrap();

                let mut employee = root.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "emp:employee").unwrap().into()).unwrap().as_element().unwrap();
                employee.set_attribute_ns(Some(XML_NS_NAMESPACE), "xmlns:emp", "http://www.nist.gov").unwrap();
                employee.set_attribute_ns(Some(XML_NS_NAMESPACE), "xmlns:nm", "http://www.altavista.com").unwrap();
                let mut employee_id = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "emp:employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0004").into()).unwrap();
                let mut name = employee.append_child(doc.create_element_ns(Some("http://www.altavista.com"), "nm:name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Jeny Oconnor").into()).unwrap();
                let mut position = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "emp:position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Personnel Director").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "emp:salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("95,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "emp:gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("Female").into()).unwrap();
                let mut address = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "emp:address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("27 South Road. Dallas, texas 98556").into()).unwrap();
                address.set_attribute_ns(Some("http://www.nist.gov"), "emp:domestic", "Yes").unwrap();
                address.set_attribute("street", "Y").unwrap();
                let mut street = address.get_attribute_node("street").unwrap();
                street.append_child(doc.create_entity_reference("ent1").unwrap().into()).unwrap();
                address.set_attribute_ns(Some("http://www.nist.gov"), "emp:zone", "CANADA").unwrap();
                address.set_attribute_ns(Some("http://www.nist.gov"), "emp:local1", "TRUE").unwrap();

                let mut employee = root.append_child(doc.create_element_ns(None, "employee").unwrap().into()).unwrap().as_element().unwrap();
                employee.set_attribute_ns(Some(XML_NS_NAMESPACE), "xmlns:emp2", "http://www.nist.gov").unwrap();
                let mut employee_id = employee.append_child(doc.create_element_ns(None, "employeeId").unwrap().into()).unwrap();
                employee_id.append_child(doc.create_text_node("EMP0005").into()).unwrap();
                let mut name = employee.append_child(doc.create_element_ns(None, "name").unwrap().into()).unwrap();
                name.append_child(doc.create_text_node("Robert Myers").into()).unwrap();
                let mut position = employee.append_child(doc.create_element_ns(None, "position").unwrap().into()).unwrap();
                position.append_child(doc.create_text_node("Computer Specialist").into()).unwrap();
                let mut salary = employee.append_child(doc.create_element_ns(None, "salary").unwrap().into()).unwrap();
                salary.append_child(doc.create_text_node("90,000").into()).unwrap();
                let mut gender = employee.append_child(doc.create_element_ns(None, "gender").unwrap().into()).unwrap();
                gender.append_child(doc.create_text_node("male").into()).unwrap();
                let mut address = employee.append_child(doc.create_element_ns(Some("http://www.nist.gov"), "address").unwrap().into()).unwrap().as_element().unwrap();
                address.append_child(doc.create_text_node("1821 Nordic. Road, Irving Texas 98558").into())?;
                address.set_attribute("street", "Yes").unwrap();
                address.set_attribute_ns(Some(XML_NS_NAMESPACE), "xmlns", "http://www.nist.gov").unwrap();

                doc.enable_read_only_check();
                Ok(doc)
                // Ok(load_xml::<false>(doc))
            }
            #[rustfmt::skip]
            fn hc_staff_xml(_doc: &str) -> Result<DocumentRef, DOMException> {
                let doctype = DocumentTypeRef::new("html",Some("-//W3C//DTD HTML 4.01//EN"),Some("http://www.w3.org/TR/html4/strict.dtd")).unwrap();
                let mut doc = DocumentRef::new(None, Some("html"), Some(doctype)).unwrap();
                let mut doctype = doc.doctype().unwrap();

                let mut ent = doctype.create_entity("alpha", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B1}").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("beta", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B2}").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("gamma", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B3}").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("delta", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B4}").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("epsilon", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B5}").into()).unwrap();
                doctype.add_entity::<false>(ent).unwrap();
                let mut ent = doctype.create_entity("alpha", EntityType::InternalGeneralEntity).unwrap();
                ent.append_child(doc.create_text_node("\u{3B6}").into()).unwrap();
                assert!(doctype.add_entity::<false>(ent).is_err());
                doctype.add_notation::<false>(doctype.create_notation("notation1",NotationIdentifier::PublicID { public_id: "notation1File".into() }).unwrap()).unwrap();
                doctype.add_notation::<false>(doctype.create_notation("notation2",NotationIdentifier::ExternalID { public_id: None, system_id: "notation2File".into() }).unwrap()).unwrap();

                // TODO: add external subset
                let mut seq = ElementContent::new_seq(ElementContentOccur::Once);
                seq.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"head")));
                seq.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"body")));
                doctype.add_element_decl::<true>(doctype.create_element_decl("html", ContentSpec::Children(seq)).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("html","xmlns",AttType::CDATA,DefaultDecl::Implied,).unwrap()).unwrap();
                let mut seq = ElementContent::new_seq(ElementContentOccur::Once);
                seq.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"meta")));
                let seq2 = ElementContent::new_seq(ElementContentOccur::Once);
                seq.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"title")));
                seq.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Mult,"script")));
                seq.set_second_child(Some(seq2));
                doctype.add_element_decl::<true>(doctype.create_element_decl("head", ContentSpec::Children(seq)).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("meta", ContentSpec::Empty).unwrap()).unwrap();
                doctype.create_attlist_decl("meta", "http-equiv", AttType::CDATA, DefaultDecl::Implied).unwrap();
                doctype.create_attlist_decl("meta", "content", AttType::CDATA, DefaultDecl::Implied).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("title",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("body",ContentSpec::Children(ElementContent::new_element(ElementContentOccur::Mult,"p"))).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("body","onload",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                let mut or = ElementContent::new_or(ElementContentOccur::Mult);
                or.set_first_child(Some(ElementContent::new_pcdata(ElementContentOccur::Once)));
                let mut or2 = ElementContent::new_or(ElementContentOccur::Once);
                or2.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"em")));
                let mut or3 = ElementContent::new_or(ElementContentOccur::Once);
                or3.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"strong")));
                let mut or4 = ElementContent::new_or(ElementContentOccur::Once);
                or4.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"code")));
                let mut or5 = ElementContent::new_or(ElementContentOccur::Once);
                or5.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"sup")));
                let mut or6 = ElementContent::new_or(ElementContentOccur::Once);
                or6.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"var")));
                let mut or7 = ElementContent::new_or(ElementContentOccur::Once);
                or7.set_first_child(Some(ElementContent::new_element(ElementContentOccur::Once,"acronym")));
                or7.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"abbr")));
                or6.set_second_child(Some(or7));
                or5.set_second_child(Some(or6));
                or4.set_second_child(Some(or5));
                or3.set_second_child(Some(or4));
                or2.set_second_child(Some(or3));
                or.set_second_child(Some(or2));
                doctype.add_element_decl::<true>(doctype.create_element_decl("p", ContentSpec::Mixed(or)).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("p","xmlns:dmstc",AttType::CDATA,DefaultDecl::Implied,).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("p","xmlns:nm",AttType::CDATA,DefaultDecl::Implied,).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("p","xmlns:emp2",AttType::CDATA,DefaultDecl::Implied,).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("p", "id", AttType::ID, DefaultDecl::Implied).unwrap()).unwrap();

                doctype.add_element_decl::<true>(doctype.create_element_decl("em",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("span",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("strong",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("code",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("sup",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                let mut or = ElementContent::new_or(ElementContentOccur::Mult);
                or.set_first_child(Some(ElementContent::new_pcdata(ElementContentOccur::Once)));
                or.set_second_child(Some(ElementContent::new_element(ElementContentOccur::Once,"span")));
                doctype.add_element_decl::<true>(doctype.create_element_decl("var", ContentSpec::Mixed(or)).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("acronym",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("acronym","title",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("acronym","class",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("acronym", "id", AttType::ID, DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("abbr",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("abbr","title",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("abbr","class",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("abbr", "id", AttType::ID, DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_element_decl::<true>(doctype.create_element_decl("script",ContentSpec::Mixed(ElementContent::new_pcdata(ElementContentOccur::Once))).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("script","type",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("script","src",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();
                doctype.add_attlist_decl::<true>(doctype.create_attlist_decl("script","charset",AttType::CDATA,DefaultDecl::Implied).unwrap()).unwrap();

                doc.insert_before(doc.create_processing_instruction("TEST-STYLE", Some("PIDATA")).unwrap().into(),Some(doctype.into())).unwrap();

                let mut root = doc.document_element().unwrap();
                assert!(root.parent_node().is_some());
                let comment = doc.create_comment(" This is comment number 1.").into();
                doc.insert_before(comment, Some(root.clone().into())).unwrap();

                let mut head = root.append_child(doc.create_element("head").unwrap().into()).unwrap();
                let mut meta = head.append_child(doc.create_element("meta").unwrap().into()).unwrap().as_element().unwrap();
                meta.set_attribute("http-equiv", "Content-Type").unwrap();
                meta.set_attribute("content", "text/html; charset=UTF-8").unwrap();
                let mut title = head.append_child(doc.create_element("title").unwrap().into()).unwrap();
                title.append_child(doc.create_text_node("hc_staff").into()).unwrap();
                let mut script = head.append_child(doc.create_element("script").unwrap().into()).unwrap().as_element().unwrap();
                script.set_attribute("type", "text/javascript").unwrap();
                script.set_attribute("src", "svgunit.js").unwrap();
                let mut script = head.append_child(doc.create_element("script").unwrap().into()).unwrap().as_element().unwrap();
                script.set_attribute("charset", "UTF-8").unwrap();
                script.set_attribute("type", "text/javascript").unwrap();
                script.set_attribute("src", "svgtest.js").unwrap();
                let mut script = head.append_child(doc.create_element("script").unwrap().into()).unwrap().as_element().unwrap();
                script.set_attribute("type", "text/javascript").unwrap();
                script.append_child(doc.create_text_node("function loadComplete() { startTest(); }").into(),).unwrap();

                let mut body = root.append_child(doc.create_element("body").unwrap().into()).unwrap().as_element().unwrap();
                body.set_attribute("onload", "parent.loadComplete()").unwrap();

                let mut p = body.append_child(doc.create_element("p").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut em = p.append_child(doc.create_element("em").unwrap().into()).unwrap();
                em.append_child(doc.create_text_node("EMP0001").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p.append_child(doc.create_element("strong").unwrap().into()).unwrap();
                strong.append_child(doc.create_text_node("Margaret Martin").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p.append_child(doc.create_element("code").unwrap().into()).unwrap();
                code.append_child(doc.create_text_node("Accountant").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p.append_child(doc.create_element("sup").unwrap().into()).unwrap();
                sup.append_child(doc.create_text_node("56,000").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p.append_child(doc.create_element("var").unwrap().into()).unwrap();
                var.append_child(doc.create_text_node("Female").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p.append_child(doc.create_element("acronym").unwrap().into()).unwrap().as_element().unwrap();
                acronym.append_child(doc.create_text_node("1230 North Ave. Dallas, Texas 98551").into())?;
                acronym.set_attribute("title", "Yes").unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();

                let mut p = body.append_child(doc.create_element("p").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut em = p.append_child(doc.create_element("em").unwrap().into()).unwrap();
                em.append_child(doc.create_text_node("EMP0002").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p.append_child(doc.create_element("strong").unwrap().into()).unwrap();
                strong.append_child(doc.create_text_node("Martha RaynoldsThis is a CDATASection with EntityReference number 2 &ent2;\nThis is an adjacent CDATASection with a reference to a tab &tab;").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p.append_child(doc.create_element("code").unwrap().into()).unwrap();
                code.append_child(doc.create_text_node("Secretary").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p.append_child(doc.create_element("sup").unwrap().into()).unwrap();
                sup.append_child(doc.create_text_node("35,000").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p.append_child(doc.create_element("var").unwrap().into()).unwrap();
                var.append_child(doc.create_text_node("Female").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p.append_child(doc.create_element("acronym").unwrap().into()).unwrap().as_element().unwrap();
                acronym.append_child(doc.create_entity_reference("beta").unwrap().into()).unwrap();
                acronym.append_child(doc.create_text_node(" Dallas, ").into()).unwrap();
                acronym.append_child(doc.create_entity_reference("gamma").unwrap().into()).unwrap();
                acronym.append_child(doc.create_text_node("\n 98554").into()).unwrap();
                acronym.set_attribute("title", "Yes").unwrap();
                acronym.set_attribute("class", "Yes").unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();

                let mut p = body.append_child(doc.create_element("p").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut em = p.append_child(doc.create_element("em").unwrap().into()).unwrap();
                em.append_child(doc.create_text_node("EMP0003").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p.append_child(doc.create_element("strong").unwrap().into()).unwrap();
                strong.append_child(doc.create_text_node("Roger\n Jones").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p.append_child(doc.create_element("code").unwrap().into()).unwrap();
                code.append_child(doc.create_text_node("Department Manager").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p.append_child(doc.create_element("sup").unwrap().into()).unwrap();
                sup.append_child(doc.create_text_node("100,000").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p.append_child(doc.create_element("var").unwrap().into()).unwrap();
                var.append_child(doc.create_entity_reference("delta").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p.append_child(doc.create_element("acronym").unwrap().into()).unwrap().as_element().unwrap();
                acronym.append_child(doc.create_text_node("PO Box 27 Irving, texas 98553").into()).unwrap();
                acronym.set_attribute("title", "Yes").unwrap();
                acronym.set_attribute("class", "No").unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();

                let mut p = body.append_child(doc.create_element("p").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut em = p.append_child(doc.create_element("em").unwrap().into()).unwrap();
                em.append_child(doc.create_text_node("EMP0004").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p.append_child(doc.create_element("strong").unwrap().into()).unwrap();
                strong.append_child(doc.create_text_node("Jeny Oconnor").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p.append_child(doc.create_element("code").unwrap().into()).unwrap();
                code.append_child(doc.create_text_node("Personnel Director").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p.append_child(doc.create_element("sup").unwrap().into()).unwrap();
                sup.append_child(doc.create_text_node("95,000").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p.append_child(doc.create_element("var").unwrap().into()).unwrap();
                var.append_child(doc.create_text_node("Female").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p.append_child(doc.create_element("acronym").unwrap().into()).unwrap().as_element().unwrap();
                acronym.append_child(doc.create_text_node("PO Box 27 Irving, texas 98553").into()).unwrap();
                acronym.set_attribute("title", "Yes")?;
                acronym.set_attribute("class", "Y")?;
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut class = acronym.get_attribute_node("class").unwrap();
                class.append_child(doc.create_entity_reference("alpha").unwrap().into()).unwrap();

                let mut p = body.append_child(doc.create_element("p").unwrap().into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut em = p.append_child(doc.create_element("em").unwrap().into()).unwrap();
                em.append_child(doc.create_text_node("EMP0005").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut strong = p.append_child(doc.create_element("strong").unwrap().into()).unwrap();
                strong.append_child(doc.create_text_node("Robert Myers").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut code = p.append_child(doc.create_element("code").unwrap().into()).unwrap();
                code.append_child(doc.create_text_node("Computer Specialist").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut sup = p.append_child(doc.create_element("sup").unwrap().into()).unwrap();
                sup.append_child(doc.create_text_node("90,000").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut var = p.append_child(doc.create_element("var").unwrap().into()).unwrap();
                var.append_child(doc.create_text_node("male").into()).unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();
                let mut acronym = p.append_child(doc.create_element("acronym").unwrap().into()).unwrap().as_element().unwrap();
                acronym.append_child(doc.create_text_node("1821 Nordic. Road, Irving Texas 98558").into(),)?;
                acronym.set_attribute("title", "Yes").unwrap();
                p.append_child(doc.create_text_node("\n").into()).unwrap();

                doc.enable_read_only_check();
                Ok(doc)
            }

            // namednodemapsetnameditemns08.xml
            #[test]
            fn test_namednodemapsetnameditemns08() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                // r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                // r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                // r#attr = r#attributes
                //     .get_named_item_ns(Some("http://www.usa.com".into()), "domestic".into())
                //     .unwrap()
                //     .unwrap(); // <getNamedItemNS var="attr" obj="attributes" namespaceURI="&quot;http://www.usa.com&quot;" localName="&quot;domestic&quot;"/>
                // r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                // r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>

                // // unimplemented: // <assertDOMException id="namednodemapsetnameditemns08"><INUSE_ATTRIBUTE_ERR><setNamedItemNS var="newNode" obj="attributes" arg="attr"/></INUSE_ATTRIBUTE_ERR></assertDOMException>
            }
            // prefix08.xml
            #[test]
            fn test_prefix08() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender_node; // type: Node // <var name="genderNode" type="Node"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                let mut r#ent_element; // type: Node // <var name="entElement" type="Node"/>
                let mut r#created_node; // type: Node // <var name="createdNode" type="Node"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;gender&quot;" var="genderList"/>
                r#gender_node = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" index="2" var="genderNode"/>
                r#ent_ref = r#gender_node.first_child().unwrap(); // <firstChild interface="Node" obj="genderNode" var="entRef"/>
                r#node_type = r#ent_ref.node_type(); // <nodeType var="nodeType" obj="entRef"/>

                // unimplemented: // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>	<createEntityReference var="entRef" name="&quot;ent4&quot;" obj="doc"/>	<assertNotNull actual="entRef" id="createdEntRefNotNull"/></if>
                r#ent_element = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" obj="entRef" var="entElement"/>
                // unimplemented: // <assertNotNull actual="entElement" id="entElement"/>
                r#created_node = r#doc.create_element("text3".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;text3&quot;" var="createdNode"/>

                // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR"><NO_MODIFICATION_ALLOWED_ERR><prefix obj="entElement" value="&quot;newPrefix&quot;"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // namednodemapremovenameditemns05.xml
            #[test]
            fn test_namednodemapremovenameditemns05() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                // let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entities" obj="docType"/>

                // // unimplemented: // <assertNotNull actual="entities" id="entitiesNotNull"/>

                // // unimplemented: // <notations var="notations" obj="docType"/>

                // // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>

                // // unimplemented: // <try>   <removeNamedItemNS var="removedNode" obj="entities" namespaceURI="nullNS" localName="&quot;ent1&quot;"/>   <fail id="entity_throw_DOMException"/>   <catch>   		<DOMException code="NOT_FOUND_ERR"/>   		<DOMException code="NO_MODIFICATION_ALLOWED_ERR"/>   </catch></try>

                // // unimplemented: // <try>	<removeNamedItemNS var="removedNode" obj="notations" namespaceURI="nullNS" localName="&quot;notation1&quot;"/>    <fail id="notation_throw_DOMException"/>    <catch>    	<DOMException code="NOT_FOUND_ERR"/>    	<DOMException code="NO_MODIFICATION_ALLOWED_ERR"/>    </catch></try>
            }
            // prefix07.xml
            #[test]
            fn test_prefix07() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="employeeNode"/>

                // unimplemented: // <assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><prefix obj="employeeNode" value="&quot;emp::&quot;"/></NAMESPACE_ERR></assertDOMException>
            }
            // createDocument01.xml
            #[test]
            fn test_create_document01() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.ecommerce.org/&quot;"/>
                // let mut r#malformed_name; // type: DOMString // <var name="malformedName" type="DOMString" value="&quot;prefix::local&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType" isNull="true"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><createDocument obj="domImpl" var="aNewDoc" namespaceURI="namespaceURI" qualifiedName="malformedName" doctype="docType"/></NAMESPACE_ERR></assertDOMException>
            }
            // isSupported07.xml
            #[test]
            fn test_is_supported07() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                // r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>

                // // unimplemented: // <isSupported obj="rootNode" feature="&quot;XML&quot;" version="&quot;&quot;" var="state"/>
                // assert!(r#state); // <assertTrue actual="state" id="throw_True"/>
            }
            // localName02.xml
            #[test]
            fn test_local_name02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#created_node; // type: Node // <var name="createdNode" type="Node"/>
                let mut r#local_name; // type: DOMString // <var name="localName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#created_node = r#doc.create_element("test:employee".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;test:employee&quot;" var="createdNode"/>
                r#local_name = r#created_node.local_name(); // <localName obj="createdNode" var="localName"/>
                assert!(local_name.is_none()); // <assertNull actual="localName" id="localNameNull"/>
            }
            // setNamedItemNS02.xml
            #[test]
            fn test_set_named_item_n_s02() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.usa.com&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;dmstc:domestic&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#another_doc: DocumentRef; // <var name="anotherDoc" type="Document"/>
                // let mut r#arg; // type: Node // <var name="arg" type="Node"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#set_node; // type: Node // <var name="setNode" type="Node"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#another_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="anotherDoc" href="staffNS" willBeModified="true"/>
                // r#arg = r#another_doc
                //     .create_attribute_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                //     .unwrap(); // <createAttributeNS obj="anotherDoc" var="arg" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                // r#arg.set_node_value("Maybe").unwrap(); // <nodeValue obj="arg" value="&quot;Maybe&quot;"/>
                // r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                // r#test_address = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="0"/>
                // r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>

                // // unimplemented: // <assertDOMException id="throw_WRONG_DOCUMENT_ERR"><WRONG_DOCUMENT_ERR><setNamedItemNS var="setNode" interface="NamedNodeMap" obj="attributes" arg="arg"/></WRONG_DOCUMENT_ERR></assertDOMException>
            }
            // namednodemapgetnameditemns05.xml
            #[test]
            fn test_namednodemapgetnameditemns05() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Node // <var name="element" type="Node"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attribute = r#attributes.get_named_item_ns(Some("*"), "street").unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;*&quot;" localName="&quot;street&quot;"/>
                assert!(attribute.is_none()); // <assertNull actual="attribute" id="namednodemapgetnameditemns05"/>
            }
            // hasAttribute03.xml
            #[test]
            fn test_has_attribute03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_node; // type: Element // <var name="testNode" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="0"/>
                r#state = r#test_node.has_attribute("nomatch"); // <hasAttribute obj="testNode" var="state" name="&quot;nomatch&quot;"/>
                assert!(!r#state); // <assertFalse actual="state" id="throw_False"/>
            }
            // createDocument06.xml
            #[test]
            fn test_create_document06() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://ecommerce.org/schema&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;xml:local&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType" isNull="true"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><createDocument obj="domImpl" var="aNewDoc" namespaceURI="namespaceURI" qualifiedName="qualifiedName" doctype="docType"/></NAMESPACE_ERR></assertDOMException>
            }
            // setAttributeNS10.xml
            #[test]
            fn test_set_attribute_n_s10() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.example.gov&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;em&quot;"/>
                // r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>

                // // unimplemented: // <assertDOMException id="throw_INVALID_CHARACTER_ERR"><INVALID_CHARACTER_ERR><setAttributeNS obj="testAddr" namespaceURI="namespaceURI" qualifiedName="&quot;&quot;" value="&quot;newValue&quot;"/></INVALID_CHARACTER_ERR></assertDOMException>
            }
            // removeAttributeNS02.xml
            #[test]
            fn test_remove_attribute_n_s02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                let mut r#addr_attr; // type: Attr // <var name="addrAttr" type="Attr"/>
                let mut r#attr; // type: DOMString // <var name="attr" type="DOMString"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                let mut r#local_name; // type: DOMString // <var name="localName" type="DOMString"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:address&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>
                r#test_addr
                    .remove_attribute_ns(Some("http://www.nist.gov"), "local1")
                    .unwrap(); // <removeAttributeNS obj="testAddr" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;local1&quot;"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:address&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>
                r#addr_attr = r#test_addr
                    .get_attribute_node_ns(Some("http://www.nist.gov"), "local1")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS obj="testAddr" var="addrAttr" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;local1&quot;"/>
                r#attr = r#test_addr
                    .get_attribute_ns(Some("http://www.nist.gov"), "local1")
                    .unwrap(); // <getAttributeNS obj="testAddr" var="attr" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;local1&quot;"/>
                r#namespace_uri = r#addr_attr.namespace_uri().unwrap().to_string(); // <namespaceURI obj="addrAttr" var="namespaceURI"/>
                r#local_name = r#addr_attr.local_name().unwrap().to_string(); // <localName obj="addrAttr" var="localName"/>
                r#prefix = r#test_addr.prefix().unwrap().to_string(); // <prefix obj="testAddr" var="prefix"/>
                assert_eq!(r#attr, "FALSE"); // <assertEquals actual="attr" expected="&quot;FALSE&quot;" ignoreCase="false" id="attr"/>
                assert_eq!(r#namespace_uri, "http://www.nist.gov"); // <assertEquals actual="namespaceURI" expected="&quot;http://www.nist.gov&quot;" ignoreCase="false" id="uri"/>
                assert_eq!(r#local_name, "local1"); // <assertEquals actual="localName" expected="&quot;local1&quot;" ignoreCase="false" id="lname"/>
                assert_eq!(r#prefix, "emp"); // <assertEquals actual="prefix" expected="&quot;emp&quot;" ignoreCase="false" id="prefix"/>
            }
            // nodehasattributes01.xml
            #[test]
            fn test_nodehasattributes01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#has_attributes; // type: boolean // <var name="hasAttributes" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employeeId"); // <getElementsByTagName var="elementList" obj="doc" tagname="&quot;employeeId&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                r#has_attributes = r#element.has_attributes(); // <hasAttributes var="hasAttributes" obj="element"/>
                assert!(!r#has_attributes); // <assertFalse actual="hasAttributes" id="employeeIdHasAttributesFalse"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName var="elementList" obj="doc" tagname="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                r#has_attributes = r#element.has_attributes(); // <hasAttributes var="hasAttributes" obj="element"/>
                assert!(r#has_attributes); // <assertTrue actual="hasAttributes" id="addressHasAttributesTrue"/>
            }
            // documentcreateattributeNS07.xml
            #[test]
            fn test_documentcreateattribute_n_s07() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.W3.org/2000/xmlns&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;xmlns&quot;"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <assertDOMException id="documentcreateattributeNS07"><NAMESPACE_ERR><createAttributeNS obj="doc" var="attribute" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/></NAMESPACE_ERR></assertDOMException>
            }
            // nodesetprefix07.xml
            #[test]
            fn test_nodesetprefix07() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#attribute = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Test/L2"), "abc:elem".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/L2&quot;" qualifiedName="&quot;abc:elem&quot;"/>

                // unimplemented: // <assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><prefix obj="attribute" value="&quot;xmlns&quot;"/></NAMESPACE_ERR></assertDOMException>
            }
            // hasAttributes01.xml
            #[test]
            fn test_has_attributes01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#addr_list; // type: NodeList // <var name="addrList" type="NodeList"/>
                let mut r#addr_node; // type: Node // <var name="addrNode" type="Node"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#addr_list = r#doc.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;name&quot;" var="addrList"/>
                r#addr_node = r#addr_list.item(0).unwrap(); // <item interface="NodeList" obj="addrList" index="0" var="addrNode"/>
                r#state = r#addr_node.has_attributes(); // <hasAttributes obj="addrNode" var="state"/>
                assert!(!r#state); // <assertFalse actual="state" id="throw_False"/>
            }
            // elementsetattributenodens04.xml
            #[test]
            fn test_elementsetattributenodens04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element1; // type: Element // <var name="element1" type="Element"/>
                let mut r#element2; // type: Element // <var name="element2" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element1 = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test"), "elem1".as_ref())
                    .unwrap(); // <createElementNS var="element1" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;elem1&quot;"/>
                r#element2 = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test"), "elem2".as_ref())
                    .unwrap(); // <createElementNS var="element2" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;elem2&quot;"/>
                r#attribute = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Test"), "attr".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;attr&quot;"/>
                r#new_attribute = r#element1.set_attribute_node_ns(r#attribute).unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element1" newAttr="attribute"/>

                // unimplemented: // <assertDOMException id="elementsetattributenodens04">    <INUSE_ATTRIBUTE_ERR>      <setAttributeNodeNS var="newAttribute" obj="element2" newAttr="attribute"/>    </INUSE_ATTRIBUTE_ERR>  </assertDOMException>
            }
            // documentcreateattributeNS05.xml
            #[test]
            fn test_documentcreateattribute_n_s05() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType" isNull="true"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" isNull="true"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;abc:def&quot;"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;dom:doc&quot;" doctype="docType"/>

                // // unimplemented: // <assertDOMException id="documentcreateattributeNS05"><NAMESPACE_ERR><createAttributeNS obj="newDoc" var="attribute" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/></NAMESPACE_ERR></assertDOMException>
            }
            // nodehasattributes04.xml
            #[test]
            fn test_nodehasattributes04() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType" isNull="true"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#element_test; // type: Element // <var name="elementTest" type="Element"/>
                // let mut r#element_doc; // type: Element // <var name="elementDoc" type="Element"/>
                // let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                // let mut r#set_node; // type: Node // <var name="setNode" type="Node"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#has_attributes; // type: boolean // <var name="hasAttributes" type="boolean"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;test&quot;" doctype="docType"/>
                // r#element = r#new_doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/DOM/Test"),
                //         "dom:elem".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="element" obj="newDoc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;dom:elem&quot;"/>
                // r#attribute = r#new_doc.create_attribute("attr".to_string()).unwrap(); // <createAttribute var="attribute" obj="newDoc" name="&quot;attr&quot;"/>
                // r#set_node = r#element
                //     .set_attribute_node(r#attribute)
                //     .unwrap()
                //     .unwrap(); // <setAttributeNode var="setNode" obj="element" newAttr="attribute"/>
                // r#element_doc = r#new_doc.document_element().unwrap(); // <documentElement var="elementDoc" obj="newDoc"/>
                // r#appended_child = r#element_doc.append_child(element.into()).unwrap(); // <appendChild var="appendedChild" obj="elementDoc" newChild="element"/>
                // r#element_list = r#new_doc
                //     .get_elements_by_tag_name_ns(Some("http://www.w3.org/DOM/Test"), "elem"); // <getElementsByTagNameNS var="elementList" obj="newDoc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" localName="&quot;elem&quot;" interface="Document"/>
                // r#element_test = r#element_list.item(0).unwrap(); // <item var="elementTest" obj="elementList" index="0" interface="NodeList"/>
                // r#has_attributes = r#element_test.has_attributes(); // <hasAttributes var="hasAttributes" obj="elementTest"/>
                // assert!(r#has_attributes); // <assertTrue actual="hasAttributes" id="nodehasattributes04"/>
            }
            // namednodemapgetnameditemns01.xml
            #[test]
            fn test_namednodemapgetnameditemns01() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                // let mut r#entity_name; // type: DOMString // <var name="entityName" type="DOMString"/>
                // let mut r#notation_name; // type: DOMString // <var name="notationName" type="DOMString"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entities" obj="docType"/>

                // // unimplemented: // <assertNotNull actual="entities" id="entitiesNotNull"/>

                // // unimplemented: // <notations var="notations" obj="docType"/>

                // // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                // r#entity = r#entities
                //     .get_named_item_ns(Some(r#null_ns), "ent1")
                //     .unwrap()
                //     .unwrap(); // <getNamedItemNS var="entity" obj="entities" namespaceURI="nullNS" localName="&quot;ent1&quot;"/>

                // // unimplemented: // <assertNull actual="entity" id="entityNull"/>
                // r#notation = r#notations
                //     .get_named_item_ns(Some(r#null_ns), "notation1")
                //     .unwrap()
                //     .unwrap(); // <getNamedItemNS var="notation" obj="notations" namespaceURI="nullNS" localName="&quot;notation1&quot;"/>

                // // unimplemented: // <assertNull actual="notation" id="notationNull"/>
            }
            // nodegetlocalname03.xml
            #[test]
            fn test_nodegetlocalname03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#qelement; // type: Element // <var name="qelement" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#qattr; // type: Attr // <var name="qattr" type="Attr"/>
                let mut r#local_elem_name; // type: DOMString // <var name="localElemName" type="DOMString"/>
                let mut r#local_q_elem_name; // type: DOMString // <var name="localQElemName" type="DOMString"/>
                let mut r#local_attr_name; // type: DOMString // <var name="localAttrName" type="DOMString"/>
                let mut r#local_q_attr_name; // type: DOMString // <var name="localQAttrName" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test/elem"), "elem".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/elem&quot;" qualifiedName="&quot;elem&quot;"/>
                r#qelement = r#doc
                    .create_element_ns(
                        Some("http://www.w3.org/DOM/Test/elem"),
                        "qual:qelem".as_ref(),
                    )
                    .unwrap(); // <createElementNS var="qelement" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/elem&quot;" qualifiedName="&quot;qual:qelem&quot;"/>
                r#attr = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Test/attr"), "attr".as_ref())
                    .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/attr&quot;" qualifiedName="&quot;attr&quot;"/>
                r#qattr = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/DOM/Test/attr"),
                        "qual:qattr".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="qattr" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/attr&quot;" qualifiedName="&quot;qual:qattr&quot;"/>
                r#local_elem_name = r#element.local_name().unwrap().to_string(); // <localName var="localElemName" obj="element"/>
                r#local_q_elem_name = r#qelement.local_name().unwrap().to_string(); // <localName var="localQElemName" obj="qelement"/>
                r#local_attr_name = r#attr.local_name().unwrap().to_string(); // <localName var="localAttrName" obj="attr"/>
                r#local_q_attr_name = r#qattr.local_name().unwrap().to_string(); // <localName var="localQAttrName" obj="qattr"/>
                assert_eq!(r#local_elem_name, "elem"); // <assertEquals actual="localElemName" expected="&quot;elem&quot;" id="nodegetlocalname03_localElemName" ignoreCase="false"/>
                assert_eq!(r#local_q_elem_name, "qelem"); // <assertEquals actual="localQElemName" expected="&quot;qelem&quot;" id="nodegetlocalname03_localQElemName" ignoreCase="false"/>
                assert_eq!(r#local_attr_name, "attr"); // <assertEquals actual="localAttrName" expected="&quot;attr&quot;" id="nodegetlocalname03_localAttrName" ignoreCase="false"/>
                assert_eq!(r#local_q_attr_name, "qattr"); // <assertEquals actual="localQAttrName" expected="&quot;qattr&quot;" id="nodegetlocalname03_localQAttrName" ignoreCase="false"/>
            }
            // getNamedItemNS02.xml
            #[test]
            fn test_get_named_item_n_s02() {
                let mut r#namespace_uri = "http://www.usa.com"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.usa.com&quot;"/>
                let mut r#local_name = "domest"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;domest&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="1"/>
                r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                r#new_attr = r#attributes
                    .get_named_item_ns(Some(r#namespace_uri), r#local_name)
                    .unwrap(); // <getNamedItemNS obj="attributes" var="newAttr" namespaceURI="namespaceURI" localName="localName"/>
                assert!(new_attr.is_none()); // <assertNull actual="newAttr" id="throw_Null"/>
            }
            // namednodemapsetnameditemns06.xml
            #[test]
            fn test_namednodemapsetnameditemns06() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                // r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                // r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                // r#attr = r#attributes
                //     .get_named_item_ns(Some("http://www.usa.com".into()), "domestic".into())
                //     .unwrap()
                //     .unwrap(); // <getNamedItemNS var="attr" obj="attributes" namespaceURI="&quot;http://www.usa.com&quot;" localName="&quot;domestic&quot;"/>
                // r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                // r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>

                // // unimplemented: // <assertDOMException id="namednodemapsetnameditemns06"><INUSE_ATTRIBUTE_ERR><setNamedItemNS var="newNode" obj="attributes" arg="attr"/></INUSE_ATTRIBUTE_ERR></assertDOMException>
            }
            // elementsetattributenodens03.xml
            #[test]
            fn test_elementsetattributenodens03() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element1; // type: Element // <var name="element1" type="Element"/>
                // let mut r#element2; // type: Element // <var name="element2" type="Element"/>
                // let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                // let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element_list = r#doc
                //     .get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;" interface="Document"/>
                // r#element1 = r#element_list.item(1).unwrap(); // <item var="element1" obj="elementList" index="1" interface="NodeList"/>
                // r#attribute = r#element1
                //     .get_attribute_node_ns(Some(r#null_ns), "street".into())
                //     .unwrap()
                //     .unwrap(); // <getAttributeNodeNS var="attribute" obj="element1" namespaceURI="nullNS" localName="&quot;street&quot;"/>
                // r#element2 = r#element_list.item(2).unwrap(); // <item var="element2" obj="elementList" index="2" interface="NodeList"/>

                // // unimplemented: // <assertDOMException id="elementsetattributenodens03">    <INUSE_ATTRIBUTE_ERR>      <setAttributeNodeNS var="newAttribute" obj="element2" newAttr="attribute"/>    </INUSE_ATTRIBUTE_ERR>  </assertDOMException>
            }
            // createElementNS02.xml
            #[test]
            fn test_create_element_n_s02() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" isNull="true"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;prefix:local&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_element; // type: Element // <var name="newElement" type="Element"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><createElementNS obj="doc" var="newElement" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/></NAMESPACE_ERR></assertDOMException>
            }
            // nodegetownerdocument02.xml
            #[test]
            fn test_nodegetownerdocument02() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#new_elem; // type: Element // <var name="newElem" type="Element"/>
                // let mut r#owner_doc_doc: DocumentRef; // <var name="ownerDocDoc" type="Document"/>
                // let mut r#owner_doc_elem: DocumentRef; // <var name="ownerDocElem" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocumentType var="docType" obj="domImpl" qualifiedName="&quot;mydoc&quot;" publicId="nullNS" systemId="nullNS"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;mydoc&quot;" doctype="docType"/>
                // r#owner_doc_doc = r#new_doc.owner_document().unwrap(); // <ownerDocument var="ownerDocDoc" obj="newDoc"/>

                // // unimplemented: // <assertNull actual="ownerDocDoc" id="nodegetownerdocument02_1"/>
                // r#new_elem = r#new_doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/DOM/Test"),
                //         "myelem".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="newElem" obj="newDoc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;myelem&quot;"/>
                // r#owner_doc_elem = r#new_elem.owner_document().unwrap(); // <ownerDocument var="ownerDocElem" obj="newElem"/>

                // // unimplemented: // <assertNotNull actual="ownerDocElem" id="nodegetownerdocument02_2"/>
            }
            // importNode12.xml
            #[test]
            fn test_import_node12() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                // let mut r#doc1_type; // type: DocumentType // <var name="doc1Type" type="DocumentType"/>
                // let mut r#entity_list; // type: NamedNodeMap // <var name="entityList" type="NamedNodeMap"/>
                // let mut r#entity2; // type: Entity // <var name="entity2" type="Entity"/>
                // let mut r#entity1; // type: Entity // <var name="entity1" type="Entity"/>
                // let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                // let mut r#entity_name; // type: DOMString // <var name="entityName" type="DOMString"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                // r#doc1_type = r#a_new_doc.doctype().unwrap(); // <doctype obj="aNewDoc" var="doc1Type"/>

                // // unimplemented: // <entities obj="doc1Type" var="entityList"/>

                // // unimplemented: // <assertNotNull actual="entityList" id="entitiesNotNull"/>
                // r#entity2 = r#entity_list.get_named_item("ent4".into()).unwrap(); // <getNamedItem obj="entityList" var="entity2" name="&quot;ent4&quot;"/>
                // r#entity1 = r#doc.import_node(r#entity2.into(), true).unwrap(); // <importNode obj="doc" var="entity1" importedNode="entity2" deep="true"/>
                // r#owner_document = r#entity1.owner_document().unwrap(); // <ownerDocument obj="entity1" var="ownerDocument"/>
                // r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                // r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>

                // // unimplemented: // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="systemId"/>
                // r#entity_name = r#entity1.node_name().to_string(); // <nodeName obj="entity1" var="entityName"/>
                // assert_eq!(r#entity_name, "ent4"); // <assertEquals actual="entityName" expected="&quot;ent4&quot;" id="entityName" ignoreCase="false"/>
                // r#child = r#entity1.first_child().unwrap(); // <firstChild interface="Node" obj="entity1" var="child"/>

                // // unimplemented: // <assertNotNull actual="child" id="notnull"/>
                // r#child_name = r#child.node_name().to_string(); // <nodeName obj="child" var="childName"/>
                // assert_eq!(r#child_name, "entElement1"); // <assertEquals actual="childName" expected="&quot;entElement1&quot;" id="childName" ignoreCase="false"/>
            }
            // setAttributeNS04.xml
            #[test]
            fn test_set_attribute_n_s04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                let mut r#addr_attr; // type: Attr // <var name="addrAttr" type="Attr"/>
                let mut r#result_attr; // type: DOMString // <var name="resultAttr" type="DOMString"/>
                let mut r#result_namespace_uri; // type: DOMString // <var name="resultNamespaceURI" type="DOMString"/>
                let mut r#result_local_name; // type: DOMString // <var name="resultLocalName" type="DOMString"/>
                let mut r#result_prefix; // type: DOMString // <var name="resultPrefix" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:address&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                r#test_addr
                    .set_attribute_ns(Some("http://www.nist.gov"), "newprefix:zone", "newValue")
                    .unwrap(); // <setAttributeNS obj="testAddr" namespaceURI="&quot;http://www.nist.gov&quot;" qualifiedName="&quot;newprefix:zone&quot;" value="&quot;newValue&quot;"/>
                r#addr_attr = r#test_addr
                    .get_attribute_node_ns(Some("http://www.nist.gov"), "zone")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS obj="testAddr" var="addrAttr" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;zone&quot;"/>
                r#result_attr = r#test_addr
                    .get_attribute_ns(Some("http://www.nist.gov"), "zone")
                    .unwrap(); // <getAttributeNS obj="testAddr" var="resultAttr" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;zone&quot;"/>
                assert_eq!(r#result_attr, "newValue"); // <assertEquals actual="resultAttr" expected="&quot;newValue&quot;" id="attrValue" ignoreCase="false"/>
                r#result_namespace_uri = r#addr_attr.namespace_uri().unwrap().to_string(); // <namespaceURI obj="addrAttr" var="resultNamespaceURI"/>
                assert_eq!(r#result_namespace_uri, "http://www.nist.gov"); // <assertEquals actual="resultNamespaceURI" expected="&quot;http://www.nist.gov&quot;" id="nsuri" ignoreCase="false"/>
                r#result_local_name = r#addr_attr.local_name().unwrap().to_string(); // <localName obj="addrAttr" var="resultLocalName"/>
                assert_eq!(r#result_local_name, "zone"); // <assertEquals actual="resultLocalName" expected="&quot;zone&quot;" id="lname" ignoreCase="false"/>
                r#result_prefix = r#addr_attr.prefix().unwrap().to_string(); // <prefix obj="addrAttr" var="resultPrefix"/>
                assert_eq!(r#result_prefix, "newprefix"); // <assertEquals actual="resultPrefix" expected="&quot;newprefix&quot;" id="prefix" ignoreCase="false"/>
            }
            // documentimportnode08.xml
            #[test]
            fn test_documentimportnode08() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#imported; // type: Node // <var name="imported" type="Node"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocumentType var="docType" obj="domImpl" qualifiedName="&quot;test:root&quot;" publicId="nullNS" systemId="nullNS"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><importNode var="imported" obj="doc" importedNode="docType" deep="true"/></NOT_SUPPORTED_ERR></assertDOMException>
            }
            // createElementNS05.xml
            #[test]
            fn test_create_element_n_s05() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;gov:faculty&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_element; // type: Element // <var name="newElement" type="Element"/>
                // let mut r#element_name; // type: DOMString // <var name="elementName" type="DOMString"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#new_element = r#doc
                //     .create_element_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                //     .unwrap(); // <createElementNS obj="doc" var="newElement" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                // r#element_name = r#new_element.tag_name().to_string(); // <tagName obj="newElement" var="elementName"/>
                // assert_eq!(r#element_name, qualified_name); // <assertEquals actual="elementName" expected="qualifiedName" id="throw_Equals" ignoreCase="false"/>
            }
            // documentgetelementsbytagnameNS02.xml
            #[test]
            fn test_documentgetelementsbytagname_n_s02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#element = r#doc
                    .create_element_ns(Some("test"), "employeeId".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;test&quot;" qualifiedName="&quot;employeeId&quot;"/>
                r#appended_child = r#doc_elem.append_child(element.into()).unwrap(); // <appendChild var="appendedChild" obj="docElem" newChild="element"/>
                r#child_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "employeeId"); // <getElementsByTagNameNS var="childList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;employeeId&quot;" interface="Document"/>

                // unimplemented: // <assertSize size="6" collection="childList" id="documentgetelementsbytagnameNS02"/>
            }
            // documentimportnode22.xml
            #[test]
            fn test_documentimportnode22() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type_null; // type: DocumentType // <var name="docTypeNull" type="DocumentType" isNull="true"/>
                // let mut r#doc_imp: DocumentRef; // <var name="docImp" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#node_map; // type: NamedNodeMap // <var name="nodeMap" type="NamedNodeMap"/>
                // let mut r#notation1; // type: Notation // <var name="notation1" type="Notation"/>
                // let mut r#notation2; // type: Notation // <var name="notation2" type="Notation"/>
                // let mut r#notation_imp1; // type: Notation // <var name="notationImp1" type="Notation"/>
                // let mut r#notation_imp2; // type: Notation // <var name="notationImp2" type="Notation"/>
                // let mut r#notation_imp_new1; // type: Notation // <var name="notationImpNew1" type="Notation"/>
                // let mut r#notation_imp_new2; // type: Notation // <var name="notationImpNew2" type="Notation"/>
                // let mut r#public_id1; // type: DOMString // <var name="publicId1" type="DOMString"/>
                // let mut r#public_id1_imp; // type: DOMString // <var name="publicId1Imp" type="DOMString"/>
                // let mut r#public_id1_new_imp; // type: DOMString // <var name="publicId1NewImp" type="DOMString"/>
                // let mut r#public_id2_imp; // type: DOMString // <var name="publicId2Imp" type="DOMString"/>
                // let mut r#public_id2_new_imp; // type: DOMString // <var name="publicId2NewImp" type="DOMString"/>
                // let mut r#system_id1_imp; // type: DOMString // <var name="systemId1Imp" type="DOMString"/>
                // let mut r#system_id1_new_imp; // type: DOMString // <var name="systemId1NewImp" type="DOMString"/>
                // let mut r#system_id2; // type: DOMString // <var name="systemId2" type="DOMString"/>
                // let mut r#system_id2_imp; // type: DOMString // <var name="systemId2Imp" type="DOMString"/>
                // let mut r#system_id2_new_imp; // type: DOMString // <var name="systemId2NewImp" type="DOMString"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <createDocument var="docImp" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;a:b&quot;" doctype="docTypeNull"/>

                // // unimplemented: // <notations var="nodeMap" obj="docType"/>

                // // unimplemented: // <assertNotNull actual="nodeMap" id="notationsNotNull"/>
                // r#notation1 = r#node_map.get_named_item("notation1".into()).unwrap(); // <getNamedItem var="notation1" obj="nodeMap" name="&quot;notation1&quot;"/>
                // r#notation2 = r#node_map.get_named_item("notation2".into()).unwrap(); // <getNamedItem var="notation2" obj="nodeMap" name="&quot;notation2&quot;"/>
                // r#notation_imp1 = r#doc.import_node(r#notation1.into(), true); // <importNode var="notationImp1" obj="doc" importedNode="notation1" deep="true"/>
                // r#notation_imp2 = r#doc.import_node(r#notation2.into(), false); // <importNode var="notationImp2" obj="doc" importedNode="notation2" deep="false"/>
                // r#notation_imp_new1 = r#doc_imp.import_node(r#notation1.into(), false); // <importNode var="notationImpNew1" obj="docImp" importedNode="notation1" deep="false"/>
                // r#notation_imp_new2 = r#doc_imp.import_node(r#notation2.into(), true); // <importNode var="notationImpNew2" obj="docImp" importedNode="notation2" deep="true"/>
                // r#public_id1 = r#notation1.public_id().unwrap().to_string(); // <publicId var="publicId1" obj="notation1" interface="Notation"/>
                // r#public_id1_imp = r#notation1.public_id().unwrap().to_string(); // <publicId var="publicId1Imp" obj="notation1" interface="Notation"/>
                // r#public_id1_new_imp = r#notation1.public_id().unwrap().to_string(); // <publicId var="publicId1NewImp" obj="notation1" interface="Notation"/>
                // r#system_id1_imp = r#notation1.system_id().unwrap().to_string(); // <systemId var="systemId1Imp" obj="notation1" interface="Notation"/>
                // r#system_id1_new_imp = r#notation1.system_id().unwrap().to_string(); // <systemId var="systemId1NewImp" obj="notation1" interface="Notation"/>
                // r#public_id2_imp = r#notation2.public_id().unwrap().to_string(); // <publicId var="publicId2Imp" obj="notation2" interface="Notation"/>
                // r#public_id2_new_imp = r#notation2.public_id().unwrap().to_string(); // <publicId var="publicId2NewImp" obj="notation2" interface="Notation"/>
                // r#system_id2 = r#notation2.system_id().unwrap().to_string(); // <systemId var="systemId2" obj="notation2" interface="Notation"/>
                // r#system_id2_imp = r#notation2.system_id().unwrap().to_string(); // <systemId var="systemId2Imp" obj="notation2" interface="Notation"/>
                // r#system_id2_new_imp = r#notation2.system_id().unwrap().to_string(); // <systemId var="systemId2NewImp" obj="notation2" interface="Notation"/>
                // assert_eq!(r#public_id1_imp, public_id1); // <assertEquals expected="publicId1" actual="publicId1Imp" id="documentimportnode22_N1PID" ignoreCase="false"/>
                // assert_eq!(r#public_id1_new_imp, public_id1); // <assertEquals expected="publicId1" actual="publicId1NewImp" id="documentimportnode22_N1NPID" ignoreCase="false"/>

                // // unimplemented: // <assertNull actual="systemId1Imp" id="documentimportnode22_N1SID"/>

                // // unimplemented: // <assertNull actual="systemId1NewImp" id="documentimportnode22_N1NSID"/>
                // assert_eq!(r#system_id2_imp, system_id2); // <assertEquals expected="systemId2" actual="systemId2Imp" id="documentimportnode22_N2SID" ignoreCase="false"/>
                // assert_eq!(r#system_id2_new_imp, system_id2); // <assertEquals expected="systemId2" actual="systemId2NewImp" id="documentimportnode22_N2NSID" ignoreCase="false"/>

                // // unimplemented: // <assertNull actual="publicId2Imp" id="documentimportnode22_N2PID"/>

                // // unimplemented: // <assertNull actual="publicId2Imp" id="documentimportnode22_N2NPID"/>
            }
            // systemId01.xml
            #[test]
            fn test_system_id01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#system_id; // type: DOMString // <var name="systemId" type="DOMString"/>
                // let mut r#index; // type: int // <var name="index" type="int"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                // r#system_id = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="systemId"/>

                // // unimplemented: // <assertURIEquals actual="systemId" file="&quot;staffNS.dtd&quot;" id="systemId"/>
            }
            // setAttributeNS09.xml
            #[test]
            fn test_set_attribute_n_s09() {
                let mut r#local_name = "newAttr"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;newAttr&quot;"/>
                let mut r#namespace_uri = "http://www.newattr.com"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.newattr.com&quot;"/>
                let mut r#qualified_name = "emp:newAttr"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:newAttr&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                let mut r#addr_attr; // type: Attr // <var name="addrAttr" type="Attr"/>
                let mut r#result_attr; // type: DOMString // <var name="resultAttr" type="DOMString"/>
                let mut r#result_namespace_uri; // type: DOMString // <var name="resultNamespaceURI" type="DOMString"/>
                let mut r#result_local_name; // type: DOMString // <var name="resultLocalName" type="DOMString"/>
                let mut r#result_prefix; // type: DOMString // <var name="resultPrefix" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:address&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                r#test_addr
                    .set_attribute_ns(Some(r#namespace_uri), r#qualified_name, "newValue")
                    .unwrap(); // <setAttributeNS obj="testAddr" namespaceURI="namespaceURI" qualifiedName="qualifiedName" value="&quot;newValue&quot;"/>
                r#addr_attr = r#test_addr
                    .get_attribute_node_ns(Some(r#namespace_uri), r#local_name)
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS obj="testAddr" var="addrAttr" namespaceURI="namespaceURI" localName="localName"/>
                r#result_attr = r#test_addr
                    .get_attribute_ns(Some(r#namespace_uri), r#local_name)
                    .unwrap(); // <getAttributeNS obj="testAddr" var="resultAttr" namespaceURI="namespaceURI" localName="localName"/>
                assert_eq!(r#result_attr, "newValue"); // <assertEquals actual="resultAttr" expected="&quot;newValue&quot;" id="attrValue" ignoreCase="false"/>
                r#result_namespace_uri = r#addr_attr.namespace_uri().unwrap().to_string(); // <namespaceURI obj="addrAttr" var="resultNamespaceURI"/>
                assert_eq!(r#result_namespace_uri, "http://www.newattr.com"); // <assertEquals actual="resultNamespaceURI" expected="&quot;http://www.newattr.com&quot;" id="nsuri" ignoreCase="false"/>
                r#result_local_name = r#addr_attr.local_name().unwrap().to_string(); // <localName obj="addrAttr" var="resultLocalName"/>
                assert_eq!(r#result_local_name, "newAttr"); // <assertEquals actual="resultLocalName" expected="&quot;newAttr&quot;" id="lname" ignoreCase="false"/>
                r#result_prefix = r#addr_attr.prefix().unwrap().to_string(); // <prefix obj="addrAttr" var="resultPrefix"/>
                assert_eq!(r#result_prefix, "emp"); // <assertEquals actual="resultPrefix" expected="&quot;emp&quot;" id="prefix" ignoreCase="false"/>
            }
            // documentimportnode18.xml
            #[test]
            fn test_documentimportnode18() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_imp: DocumentRef; // <var name="docImp" type="Document"/>
                let mut r#pi_import; // type: ProcessingInstruction // <var name="piImport" type="ProcessingInstruction"/>
                let mut r#pi_to_import; // type: ProcessingInstruction // <var name="piToImport" type="ProcessingInstruction"/>
                let mut r#pi_data; // type: DOMString // <var name="piData" type="DOMString"/>
                let mut r#pi_target; // type: DOMString // <var name="piTarget" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_imp = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="docImp" href="staffNS" willBeModified="true"/>
                r#pi_to_import = r#doc
                    .create_processing_instruction("Target", Some("Data"))
                    .unwrap(); // <createProcessingInstruction var="piToImport" obj="doc" target="&quot;Target&quot;" data="&quot;Data&quot;"/>
                r#pi_import = r#doc
                    .import_node(r#pi_to_import.into(), false)
                    .unwrap()
                    .as_processing_instruction()
                    .unwrap(); // <importNode var="piImport" obj="doc" importedNode="piToImport" deep="false"/>
                r#pi_target = r#pi_import.target().to_string(); // <target var="piTarget" obj="piImport" interface="ProcessingInstruction"/>
                r#pi_data = r#pi_import.data().unwrap().to_string(); // <data var="piData" obj="piImport" interface="ProcessingInstruction"/>
                assert_eq!(r#pi_target, "Target"); // <assertEquals expected="&quot;Target&quot;" actual="piTarget" id="documentimportnode18_Target" ignoreCase="false"/>
                assert_eq!(r#pi_data, "Data"); // <assertEquals expected="&quot;Data&quot;" actual="piData" id="documentimportnode18_Data" ignoreCase="false"/>
            }
            // domimplementationcreatedocumenttype02.xml
            #[test]
            fn test_domimplementationcreatedocumenttype02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc_type; // type: DocumentType // <var name="newDocType" type="DocumentType"/>
                // let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                // let mut r#public_id; // type: DOMString // <var name="publicId" type="DOMString" value="&quot;http://www.w3.org/DOM/Test/dom2.dtd&quot;"/>
                // let mut r#system_id; // type: DOMString // <var name="systemId" type="DOMString" value="&quot;dom2.dtd&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString"/>
                // let mut r#qualified_names; // type: List // <var name="qualifiedNames" type="List"><member>"_:_"</member><member>"_:h0"</member><member>"_:test"</member><member>"_:_."</member><member>"_:a-"</member><member>"l_:_"</member><member>"ns:_0"</member><member>"ns:a0"</member><member>"ns0:test"</member><member>"ns:EEE."</member><member>"ns:_-"</member><member>"a.b:c"</member><member>"a-b:c.j"</member><member>"a-b:c"</member></var>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <for-each collection="qualifiedNames" member="qualifiedName"><createDocumentType obj="domImpl" var="newDocType" qualifiedName="qualifiedName" publicId="publicId" systemId="systemId"/><assertNotNull actual="newDocType" id="domimplementationcreatedocumenttype02_newDocType"/><ownerDocument obj="newDocType" var="ownerDocument"/><assertNull actual="ownerDocument" id="domimplementationcreatedocumenttype02_ownerDocument"/></for-each>
            }
            // localName03.xml
            #[test]
            fn test_local_name03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let mut r#text_node; // type: Node // <var name="textNode" type="Node"/>
                let mut r#local_name; // type: DOMString // <var name="localName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employeeId"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employeeId&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                r#text_node = r#test_employee.first_child().unwrap(); // <firstChild interface="Node" obj="testEmployee" var="textNode"/>
                r#local_name = r#text_node.local_name(); // <localName obj="textNode" var="localName"/>
                assert!(local_name.is_none()); // <assertNull actual="localName" id="textNodeLocalName"/>
            }
            // setAttributeNodeNS04.xml
            #[test]
            fn test_set_attribute_node_n_s04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                let mut r#new_addr_attr; // type: Attr // <var name="newAddrAttr" type="Attr"/>
                let mut r#new_name; // type: DOMString // <var name="newName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:address&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                r#new_attr = r#doc
                    .create_attribute_ns(Some("http://www.nist.gov"), "xxx:domestic".as_ref())
                    .unwrap(); // <createAttributeNS obj="doc" var="newAttr" namespaceURI="&quot;http://www.nist.gov&quot;" qualifiedName="&quot;xxx:domestic&quot;"/>
                r#new_addr_attr = r#test_addr
                    .set_attribute_node_ns(r#new_attr)
                    .unwrap()
                    .unwrap(); // <setAttributeNodeNS obj="testAddr" newAttr="newAttr" var="newAddrAttr"/>
                r#new_name = r#new_addr_attr.node_name().to_string(); // <nodeName obj="newAddrAttr" var="newName"/>
                assert_eq!(r#new_name, "emp:domestic"); // <assertEquals actual="newName" expected="&quot;emp:domestic&quot;" id="nodeName" ignoreCase="false"/>
            }
            // documentimportnode03.xml
            #[test]
            fn test_documentimportnode03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#imported_attr; // type: Node // <var name="importedAttr" type="Node"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#child_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "employee"); // <getElementsByTagNameNS var="childList" obj="doc" localName="&quot;employee&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" interface="Document"/>
                r#element = r#child_list.item(1).unwrap(); // <item var="element" obj="childList" index="1" interface="NodeList"/>
                r#attr = r#element.get_attribute_node("defaultAttr").unwrap(); // <getAttributeNode var="attr" obj="element" name="&quot;defaultAttr&quot;"/>
                r#imported_attr = r#doc.import_node(r#attr.into(), false).unwrap(); // <importNode var="importedAttr" obj="doc" importedNode="attr" deep="false"/>
                r#node_name = r#imported_attr.node_name().to_string(); // <nodeName var="nodeName" obj="importedAttr"/>
                r#node_value = r#imported_attr.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="importedAttr"/>
                r#node_type = r#imported_attr.node_type(); // <nodeType var="nodeType" obj="importedAttr"/>
                assert_eq!(r#node_name, "defaultAttr"); // <assertEquals expected="&quot;defaultAttr&quot;" actual="nodeName" id="documentimportnode03_nodeName" ignoreCase="false"/>
                assert_eq!(r#node_type as i32, 2); // <assertEquals expected="2" actual="nodeType" id="documentimportnode03_nodeType" ignoreCase="false"/>
                assert_eq!(r#node_value, "defaultVal"); // <assertEquals expected="&quot;defaultVal&quot;" actual="nodeValue" id="documentimportnode03_nodeValue" ignoreCase="false"/>
            }
            // createElementNS06.xml
            #[test]
            fn test_create_element_n_s06() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.example.com/&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#done; // type: boolean // <var name="done" type="boolean"/>
                // let mut r#new_element; // type: Element // <var name="newElement" type="Element"/>
                // let mut r#charact; // type: DOMString // <var name="charact" type="DOMString"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // // unimplemented: // <assertDOMException id="throw_INVALID_CHARACTER_ERR"><INVALID_CHARACTER_ERR><createElementNS obj="doc" var="newElement" namespaceURI="namespaceURI" qualifiedName="&quot;&quot;"/></INVALID_CHARACTER_ERR></assertDOMException>
            }
            // prefix04.xml
            #[test]
            fn test_prefix04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                r#prefix = r#test_employee.prefix(); // <prefix obj="testEmployee" var="prefix"/>
                assert!(prefix.is_none()); // <assertNull actual="prefix" id="throw_Null"/>
            }
            // documentimportnode17.xml
            #[test]
            fn test_documentimportnode17() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_imp: DocumentRef; // <var name="docImp" type="Document"/>
                let mut r#comment_import; // type: Node // <var name="commentImport" type="Node"/>
                let mut r#comment_to_import; // type: Node // <var name="commentToImport" type="Node"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_imp = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="docImp" href="staffNS" willBeModified="true"/>
                r#comment_to_import =
                    r#doc.create_comment("Document.importNode test for a COMMENT_NODE"); // <createComment var="commentToImport" obj="doc" data="&quot;Document.importNode test for a COMMENT_NODE&quot;"/>
                r#comment_import = r#doc.import_node(r#comment_to_import.into(), true).unwrap(); // <importNode var="commentImport" obj="doc" importedNode="commentToImport" deep="true"/>
                r#node_value = r#comment_import.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="commentImport"/>
                assert_eq!(r#node_value, "Document.importNode test for a COMMENT_NODE"); // <assertEquals expected="&quot;Document.importNode test for a COMMENT_NODE&quot;" actual="nodeValue" id="documentimportnode17" ignoreCase="false"/>
            }
            // createDocument07.xml
            #[test]
            fn test_create_document07() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.ecommerce.org/schema&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;y:x&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType" isNull="true"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <createDocument obj="domImpl" var="aNewDoc" namespaceURI="namespaceURI" qualifiedName="qualifiedName" doctype="docType"/>
                // r#node_name = r#a_new_doc.node_name().to_string(); // <nodeName var="nodeName" obj="aNewDoc"/>
                // r#node_value = r#a_new_doc.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="aNewDoc"/>
                // assert_eq!(r#node_name, "#document"); // <assertEquals actual="nodeName" expected="&quot;#document&quot;" id="nodeName" ignoreCase="false"/>

                // // unimplemented: // <assertNull actual="nodeValue" id="nodeValue"/>
            }
            // elementsetattributens04.xml
            #[test]
            fn test_elementsetattributens04() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString"/>
                // let mut r#qualified_names; // type: List // <var name="qualifiedNames" type="List">    <member>"/"</member>    <member>"//"</member>    <member>"\\"</member>    <member>";"</member>    <member>"&amp;"</member>    <member>"*"</member>    <member>"]]"</member>    <member>"&gt;"</member>    <member>"&lt;"</member>  </var>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/DOM/Test/L2"),
                //         "dom:elem".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/L2&quot;" qualifiedName="&quot;dom:elem&quot;"/>

                // // unimplemented: // <for-each collection="qualifiedNames" member="qualifiedName">    <assertDOMException id="elementsetattributens04">      <INVALID_CHARACTER_ERR>	<setAttributeNS obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/L2&quot;" qualifiedName="qualifiedName" value="&quot;test&quot;"/>      </INVALID_CHARACTER_ERR>    </assertDOMException>  </for-each>
            }
            // createDocument04.xml
            #[test]
            fn test_create_document04() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.ecommerce.org/schema&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;namespaceURI:x&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>

                // // unimplemented: // <implementation obj="aNewDoc" var="domImpl"/>

                // // unimplemented: // <assertDOMException id="throw_WRONG_DOCUMENT_ERR"><WRONG_DOCUMENT_ERR><createDocument obj="domImpl" var="aNewDoc" namespaceURI="namespaceURI" qualifiedName="qualifiedName" doctype="docType"/></WRONG_DOCUMENT_ERR></assertDOMException>
            }
            // publicId01.xml
            #[test]
            fn test_public_id01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#public_id; // type: DOMString // <var name="publicId" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>
                r#public_id = r#doc_type.public_id().unwrap().to_string(); // <publicId interface="DocumentType" obj="docType" var="publicId"/>
                assert_eq!(r#public_id, "STAFF"); // <assertEquals actual="publicId" expected="&quot;STAFF&quot;" id="throw_Equals" ignoreCase="false"/>
            }
            // elementhasattribute04.xml
            #[test]
            fn test_elementhasattribute04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element = r#doc.create_element("address".to_string()).unwrap(); // <createElement var="element" obj="doc" tagName="&quot;address&quot;"/>
                r#attribute = r#doc.create_attribute("domestic".to_string()).unwrap(); // <createAttribute var="attribute" obj="doc" name="&quot;domestic&quot;"/>
                r#new_attribute = r#element.set_attribute_node(r#attribute).unwrap(); // <setAttributeNode var="newAttribute" obj="element" newAttr="attribute"/>
                r#state = r#element.has_attribute("domestic"); // <hasAttribute var="state" obj="element" name="&quot;domestic&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="elementhasattribute04"/>
            }
            // getNamedItemNS01.xml
            #[test]
            fn test_get_named_item_n_s01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#domestic_attr; // type: Attr // <var name="domesticAttr" type="Attr"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testEmployee" index="1"/>
                r#attributes = r#test_employee.attributes(); // <attributes obj="testEmployee" var="attributes"/>
                r#domestic_attr = r#attributes
                    .get_named_item_ns(Some("http://www.usa.com"), "domestic")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS obj="attributes" var="domesticAttr" namespaceURI="&quot;http://www.usa.com&quot;" localName="&quot;domestic&quot;"/>
                r#attr_name = r#domestic_attr.node_name().to_string(); // <nodeName obj="domesticAttr" var="attrName"/>
                assert_eq!(r#attr_name, "dmstc:domestic"); // <assertEquals actual="attrName" expected="&quot;dmstc:domestic&quot;" id="attrName" ignoreCase="false"/>
            }
            // elementgetelementsbytagnamens02.xml
            #[test]
            fn test_elementgetelementsbytagnamens02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element = r#doc.document_element().unwrap(); // <documentElement var="element" obj="doc"/>
                r#element_list = r#element.get_elements_by_tag_name_ns(Some("**"), "*"); // <getElementsByTagNameNS var="elementList" obj="element" namespaceURI="&quot;**&quot;" localName="&quot;*&quot;" interface="Element"/>

                // unimplemented: // <assertSize size="0" collection="elementList" id="elementgetelementsbytagnamens02"/>
            }
            // hasAttribute02.xml
            #[test]
            fn test_has_attribute02() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_node; // type: Element // <var name="testNode" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="0"/>
                r#state = r#test_node.has_attribute("street"); // <hasAttribute obj="testNode" var="state" name="&quot;street&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="throw_True"/>
            }
            // getAttributeNS05.xml
            #[test]
            fn test_get_attribute_n_s05() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                r#attr_value = r#test_addr
                    .get_attribute_ns(Some("http://www.nist.gov"), "domestic")
                    .unwrap(); // <getAttributeNS obj="testAddr" var="attrValue" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;domestic&quot;"/>
                assert_eq!(r#attr_value, "Yes"); // <assertEquals actual="attrValue" expected="&quot;Yes&quot;" id="attrValue" ignoreCase="false"/>
            }
            // documentimportnode09.xml
            #[test]
            fn test_documentimportnode09() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_fragment; // type: DocumentFragment // <var name="docFragment" type="DocumentFragment"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                let mut r#address_node; // type: Node // <var name="addressNode" type="Node"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#imported_doc_frag; // type: Node // <var name="importedDocFrag" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment var="docFragment" obj="doc"/>
                r#child_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="childList" obj="doc" localName="&quot;address&quot;" namespaceURI="&quot;*&quot;" interface="Document"/>
                r#address_node = r#child_list.item(0).unwrap(); // <item var="addressNode" obj="childList" index="0" interface="NodeList"/>
                r#appended_child = r#doc_fragment.append_child(address_node.into()).unwrap(); // <appendChild var="appendedChild" obj="docFragment" newChild="addressNode"/>
                r#imported_doc_frag = r#doc.import_node(r#doc_fragment.into(), false).unwrap(); // <importNode var="importedDocFrag" obj="doc" importedNode="docFragment" deep="false"/>
                r#success = r#imported_doc_frag.has_child_nodes(); // <hasChildNodes var="success" obj="importedDocFrag"/>
                assert!(!r#success); // <assertFalse actual="success" id="documentimportnode09"/>
            }
            // elementgetattributenodens02.xml
            #[test]
            fn test_elementgetattributenodens02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attribute1; // type: Attr // <var name="newAttribute1" type="Attr"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element = r#doc
                    .create_element_ns(Some("namespaceURI"), "root".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;namespaceURI&quot;" qualifiedName="&quot;root&quot;"/>
                r#attribute = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Level2"), "l2:att".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Level2&quot;" qualifiedName="&quot;l2:att&quot;"/>
                r#new_attribute1 = r#element.set_attribute_node_ns(r#attribute).unwrap(); // <setAttributeNodeNS var="newAttribute1" obj="element" newAttr="attribute"/>
                r#attribute = r#element
                    .get_attribute_node_ns(Some("http://www.w3.org/DOM/Level2"), "att")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attribute" obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Level2&quot;" localName="&quot;att&quot;"/>
                r#attr_value = r#attribute.node_value().unwrap().to_string(); // <nodeValue var="attrValue" obj="attribute"/>
                assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" id="elementgetattributenodens02" ignoreCase="false"/>
            }
            // elementsetattributens08.xml
            #[test]
            fn test_elementsetattributens08() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element = r#doc
                    .create_element_ns(
                        Some("http://www.w3.org/DOMTest/level2"),
                        "dom:elem".as_ref(),
                    )
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOMTest/level2&quot;" qualifiedName="&quot;dom:elem&quot;"/>

                // unimplemented: // <assertDOMException id="elementsetattributens08_Err1">    <NAMESPACE_ERR>      <setAttributeNS obj="element" namespaceURI="&quot;http://www.w3.org/DOMTest/level2&quot;" qualifiedName="&quot;xmlns&quot;" value="&quot;test&quot;"/>    </NAMESPACE_ERR>  </assertDOMException>

                // unimplemented: // <assertDOMException id="elementsetattributens08_Err2">    <NAMESPACE_ERR>      <setAttributeNS obj="element" namespaceURI="&quot;http://www.w3.org/DOMTest/level2&quot;" qualifiedName="&quot;xmlns:root&quot;" value="&quot;test&quot;"/>    </NAMESPACE_ERR>  </assertDOMException>
            }
            // createDocument02.xml
            #[test]
            fn test_create_document02() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" isNull="true"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;k:local&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType" isNull="true"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><createDocument obj="domImpl" var="aNewDoc" namespaceURI="namespaceURI" qualifiedName="qualifiedName" doctype="docType"/></NAMESPACE_ERR></assertDOMException>
            }
            // importNode16.xml
            #[test]
            fn test_import_node16() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#another_doc: DocumentRef; // <var name="anotherDoc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#another_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="anotherDoc" href="staffNS" willBeModified="true"/>
                // r#doc_type = r#another_doc.doctype().unwrap(); // <doctype obj="anotherDoc" var="docType"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><importNode obj="doc" var="node" importedNode="docType" deep="false"/></NOT_SUPPORTED_ERR></assertDOMException>
            }
            // elementsetattributenodens01.xml
            #[test]
            fn test_elementsetattributenodens01() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#attribute1; // type: Attr // <var name="attribute1" type="Attr"/>
                // let mut r#attribute2; // type: Attr // <var name="attribute2" type="Attr"/>
                // let mut r#attr_node; // type: Attr // <var name="attrNode" type="Attr"/>
                // let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                // let mut r#attr_ns; // type: DOMString // <var name="attrNS" type="DOMString"/>
                // let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                // r#element = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/DOM/Test/Level2".as_ref()),
                //         "new:element".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/Level2&quot;" qualifiedName="&quot;new:element&quot;"/>
                // r#attribute1 = r#doc
                //     .create_attribute_ns(
                //         Some("http://www.w3.org/DOM/Test/att1".as_ref()),
                //         "p1:att".as_ref(),
                //     )
                //     .unwrap(); // <createAttributeNS var="attribute1" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/att1&quot;" qualifiedName="&quot;p1:att&quot;"/>
                // r#attribute2 = r#doc
                //     .create_attribute_ns(
                //         Some("http://www.w3.org/DOM/Test/att1".as_ref()),
                //         "p2:att".as_ref(),
                //     )
                //     .unwrap(); // <createAttributeNS var="attribute2" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/att1&quot;" qualifiedName="&quot;p2:att&quot;"/>
                // r#attribute2.set_value("value2").unwrap(); // <value obj="attribute2" value="&quot;value2&quot;" interface="Attr"/>
                // r#new_attribute = r#element
                //     .set_attribute_node_ns(r#attribute1)
                //     .unwrap()
                //     .unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="attribute1"/>
                // r#new_attribute = r#element
                //     .set_attribute_node_ns(r#attribute2)
                //     .unwrap()
                //     .unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="attribute2"/>
                // r#attr_node = r#element
                //     .get_attribute_node_ns(
                //         Some("http://www.w3.org/DOM/Test/att1".into()),
                //         "att".into(),
                //     )
                //     .unwrap()
                //     .unwrap(); // <getAttributeNodeNS var="attrNode" obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/att1&quot;" localName="&quot;att&quot;"/>
                // r#attr_name = r#attr_node.node_name().to_string(); // <nodeName var="attrName" obj="attrNode"/>
                // r#attr_ns = r#attr_node.namespace_uri().unwrap().to_string(); // <namespaceURI var="attrNS" obj="attrNode"/>
                // assert_eq!(r#attr_name, "p2:att"); // <assertEquals actual="attrName" expected="&quot;p2:att&quot;" id="elementsetattributenodens01_attrName" ignoreCase="false"/>
                // assert_eq!(r#attr_ns, "http://www.w3.org/DOM/Test/att1"); // <assertEquals actual="attrNS" expected="&quot;http://www.w3.org/DOM/Test/att1&quot;" id="elementsetattributenodens01_attrNS" ignoreCase="false"/>
                // r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                // r#length = r#attributes.len(); // <length var="length" obj="attributes" interface="NamedNodeMap"/>
                // assert_eq!(r#length, 1); // <assertEquals actual="length" expected="1" id="length" ignoreCase="false"/>
            }
            // getAttributeNS02.xml
            #[test]
            fn test_get_attribute_n_s02() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                // let mut r#local_name; // type: DOMString // <var name="localName" type="DOMString" value="&quot;district&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:district&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                // let mut r#district_attr; // type: Attr // <var name="districtAttr" type="Attr"/>
                // let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#new_attribute = r#doc
                //     .create_attribute_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                //     .unwrap(); // <createAttributeNS obj="doc" var="newAttribute" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                // r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                // r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>

                // // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                // r#district_attr = r#test_addr
                //     .set_attribute_node_ns(r#new_attribute.into())
                //     .unwrap()
                //     .unwrap(); // <setAttributeNodeNS obj="testAddr" var="districtAttr" newAttr="newAttribute"/>
                // r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                // r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                // r#attr_value = r#test_addr
                //     .get_attribute_ns(Some(r#namespace_uri), r#local_name)
                //     .unwrap()
                //     .unwrap(); // <getAttributeNS obj="testAddr" var="attrValue" namespaceURI="namespaceURI" localName="localName"/>
                // assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" id="throw_Equals" ignoreCase="false"/>
            }
            // removeAttributeNS01.xml
            #[test]
            fn test_remove_attribute_n_s01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender; // type: Node // <var name="gender" type="Node"/>
                let mut r#gen; // type: Node // <var name="gen" type="Node"/>
                let mut r#g_list; // type: NodeList // <var name="gList" type="NodeList"/>
                let mut r#gen_element; // type: Element // <var name="genElement" type="Element"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#gen = r#gender.first_child().unwrap(); // <firstChild var="gen" obj="gender" interface="Node"/>
                r#node_type = r#gen.node_type(); // <nodeType var="nodeType" obj="gen"/>

                // unimplemented: // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>	<createEntityReference name="&quot;ent4&quot;" obj="doc" var="gen"/>	<assertNotNull actual="gen" id="createdEntRefNotNull"/></if>
                r#g_list = r#gen.child_nodes(); // <childNodes obj="gen" var="gList"/>
                r#gen_element = r#g_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="gList" var="genElement" index="0"/>
                // unimplemented: // <assertNotNull actual="genElement" id="notnull"/>

                // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR"><NO_MODIFICATION_ALLOWED_ERR><removeAttributeNS obj="genElement" namespaceURI="&quot;www.xyz.com&quot;" localName="&quot;local1&quot;"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // elementhasattributens03.xml
            #[test]
            fn test_elementhasattributens03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM"), "address".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM&quot;" qualifiedName="&quot;address&quot;"/>
                // unimplemented: // <assertNotNull actual="element" id="createElementNotNull"/>
                r#attribute = r#doc
                    .create_attribute_ns(None, "domestic".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute" obj="doc" namespaceURI="nullNS" qualifiedName="&quot;domestic&quot;"/>
                r#new_attribute = r#element.set_attribute_node(r#attribute).unwrap(); // <setAttributeNode var="newAttribute" obj="element" newAttr="attribute"/>
                r#state = r#element.has_attribute_ns(None, "domestic").unwrap(); // <hasAttributeNS var="state" obj="element" namespaceURI="nullNS" localName="&quot;domestic&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="elementhasattributens03"/>
            }
            // namednodemapremovenameditemns04.xml
            #[test]
            fn test_namednodemapremovenameditemns04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Node // <var name="element" type="Node"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#attribute_removed; // type: Attr // <var name="attributeRemoved" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "employee"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;employee&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attribute_removed = r#attributes
                    .remove_named_item_ns(Some("http://www.w3.org/2000/xmlns/"), "xmlns")
                    .unwrap(); // <removeNamedItemNS var="attributeRemoved" obj="attributes" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" localName="&quot;xmlns&quot;"/>
                r#attribute = r#attributes
                    .get_named_item_ns(Some("http://www.w3.org/2000/xmlns/"), "xmlns")
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" localName="&quot;xmlns&quot;"/>
                assert!(attribute.is_none()); // <assertNull actual="attribute" id="namednodemapremovenameditemns04_1"/>
                r#attribute_removed = r#attributes
                    .remove_named_item_ns(Some("http://www.w3.org/2000/xmlns/"), "dmstc")
                    .unwrap(); // <removeNamedItemNS var="attributeRemoved" obj="attributes" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" localName="&quot;dmstc&quot;"/>
                r#attribute = r#attributes
                    .get_named_item_ns(Some("http://www.w3.org/2000/xmlns/"), "dmstc")
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" localName="&quot;dmstc&quot;"/>
                assert!(attribute.is_none()); // <assertNull actual="attribute" id="namednodemapremovenameditemns04_2"/>
            }
            // namespaceURI03.xml
            #[test]
            fn test_namespace_ur_i03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let mut r#employee_namespace; // type: DOMString // <var name="employeeNamespace" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                // unimplemented: // <assertNotNull actual="testEmployee" id="employeeNotNull"/>
                r#employee_namespace = r#test_employee.namespace_uri().unwrap().to_string(); // <namespaceURI obj="testEmployee" var="employeeNamespace"/>
                assert_eq!(r#employee_namespace, "http://www.nist.gov"); // <assertEquals actual="employeeNamespace" expected="&quot;http://www.nist.gov&quot;" id="namespaceURI" ignoreCase="false"/>
            }
            // importNode02.xml
            #[test]
            fn test_import_node02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#c_data_sec; // type: CDATASection // <var name="cDataSec" type="CDATASection"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                r#c_data_sec = r#a_new_doc
                    .create_cdata_section("this is CDATASection data")
                    .unwrap(); // <createCDATASection obj="aNewDoc" var="cDataSec" data="&quot;this is CDATASection data&quot;"/>
                r#a_node = r#doc.import_node(r#c_data_sec.into(), false).unwrap(); // <importNode obj="doc" var="aNode" importedNode="cDataSec" deep="false"/>
                r#owner_document = r#a_node.owner_document().unwrap(); // <ownerDocument obj="aNode" var="ownerDocument"/>
                // unimplemented: // <assertNotNull actual="ownerDocument" id="ownerDocumentNotNull"/>
                r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>

                // unimplemented: // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="dtdSystemId"/>
                r#value = r#a_node.node_value().unwrap().to_string(); // <nodeValue obj="aNode" var="value"/>
                assert_eq!(r#value, "this is CDATASection data"); // <assertEquals actual="value" expected="&quot;this is CDATASection data&quot;" id="nodeValue" ignoreCase="false"/>
            }
            // documentgetelementbyid01.xml
            #[test]
            fn test_documentgetelementbyid01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#element_id; // type: DOMString // <var name="elementId" type="DOMString" value="&quot;---&quot;"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#element = r#doc.get_element_by_id(r#element_id.as_ref()); // <getElementById var="element" obj="doc" elementId="elementId"/>

                // // unimplemented: // <assertNull actual="element" id="documentgetelementbyid01"/>
            }
            // hasAttributeNS01.xml
            #[test]
            fn test_has_attribute_n_s01() {
                // let mut r#local_name; // type: DOMString // <var name="localName" type="DOMString" value="&quot;nomatch&quot;"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.usa.com&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_node; // type: Element // <var name="testNode" type="Element"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                // r#test_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="0"/>
                // r#state = r#test_node
                //     .has_attribute_ns(Some(r#namespace_uri), r#local_name.as_ref())
                //     .unwrap(); // <hasAttributeNS obj="testNode" var="state" namespaceURI="namespaceURI" localName="localName"/>
                // assert!(!r#state); // <assertFalse actual="state" id="throw_False"/>
            }
            // documentcreateattributeNS04.xml
            #[test]
            fn test_documentcreateattribute_n_s04() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/DOM/Test/Level2&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString"/>
                // let mut r#qualified_names; // type: List // <var name="qualifiedNames" type="List"><member>"_:"</member><member>":0a"</member><member>":"</member><member>"a:b:c"</member><member>"_::a"</member></var>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <for-each collection="qualifiedNames" member="qualifiedName"><assertDOMException id="documentcreateattributeNS04"><NAMESPACE_ERR><createAttributeNS obj="doc" var="attribute" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/></NAMESPACE_ERR></assertDOMException></for-each>
            }
            // getAttributeNS01.xml
            #[test]
            fn test_get_attribute_n_s01() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // // unimplemented: // <implementationAttribute name="validating" value="true"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                // let mut r#local_name; // type: DOMString // <var name="localName" type="DOMString" value="&quot;district&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:district&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                // let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                // r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                // r#attr_value = r#test_addr
                //     .get_attribute_ns(Some(r#namespace_uri), r#local_name)
                //     .unwrap()
                //     .unwrap(); // <getAttributeNS obj="testAddr" var="attrValue" namespaceURI="namespaceURI" localName="localName"/>
                // assert_eq!(r#attr_value, "DISTRICT"); // <assertEquals actual="attrValue" expected="&quot;DISTRICT&quot;" id="attrValue" ignoreCase="false"/>
            }
            // elementgetelementsbytagnamens05.xml
            #[test]
            fn test_elementgetelementsbytagnamens05() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element = r#doc.document_element().unwrap(); // <documentElement var="element" obj="doc"/>
                r#element_list =
                    r#element.get_elements_by_tag_name_ns(Some("http://www.altavista.com"), "*"); // <getElementsByTagNameNS var="elementList" obj="element" namespaceURI="&quot;http://www.altavista.com&quot;" localName="&quot;*&quot;" interface="Element"/>

                // unimplemented: // <assertSize size="1" collection="elementList" id="elementgetelementsbytagnamens05"/>
            }
            // getElementsByTagNameNS04.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s04() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                // let mut r#result; // type: List // <var name="result" type="List"/>
                // let mut r#expected_result; // type: List // <var name="expectedResult" type="List"><member>"address"</member><member>"address"</member><member>"address"</member><member>"emp:address"</member><member>"address"</member></var>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS interface="Document" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" var="elementList"/>

                // // unimplemented: // <for-each collection="elementList" member="child"><nodeName obj="child" var="childName"/><append collection="result" item="childName"/></for-each>
                // assert_eq!(r#result, expected_result); // <assertEquals actual="result" expected="expectedResult" id="nodeNames" ignoreCase="false"/>
            }
            // hasAttributeNS04.xml
            #[test]
            fn test_has_attribute_n_s04() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // // unimplemented: // <implementationAttribute name="validating" value="true"/>
                // let mut r#local_name; // type: DOMString // <var name="localName" type="DOMString" value="&quot;district&quot;"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_node; // type: Element // <var name="testNode" type="Element"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:address&quot;"/>
                // r#test_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="0"/>

                // // unimplemented: // <assertNotNull actual="testNode" id="empAddressNotNull"/>
                // r#state = r#test_node
                //     .has_attribute_ns(Some(r#namespace_uri), r#local_name.as_ref())
                //     .unwrap(); // <hasAttributeNS obj="testNode" var="state" namespaceURI="namespaceURI" localName="localName"/>
                // assert!(r#state); // <assertTrue actual="state" id="hasAttribute"/>
            }
            // namednodemapgetnameditemns03.xml
            #[test]
            fn test_namednodemapgetnameditemns03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Node // <var name="element" type="Node"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attr1; // type: Attr // <var name="newAttr1" type="Attr"/>
                let mut r#new_attr2; // type: Attr // <var name="newAttr2" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test"), "root".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;root&quot;"/>
                r#new_attr1 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/L1"), "L1:att".as_ref())
                    .unwrap(); // <createAttributeNS var="newAttr1" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" qualifiedName="&quot;L1:att&quot;"/>
                r#new_attribute = r#element.set_attribute_node_ns(r#new_attr1).unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="newAttr1"/>
                r#new_attr2 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/L2"), "L2:att".as_ref())
                    .unwrap(); // <createAttributeNS var="newAttr2" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/L2&quot;" qualifiedName="&quot;L2:att&quot;"/>
                r#new_attribute = r#element.set_attribute_node_ns(r#new_attr2).unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="newAttr2"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attribute = r#attributes
                    .get_named_item_ns(Some("http://www.w3.org/DOM/L2"), "att")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.w3.org/DOM/L2&quot;" localName="&quot;att&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                assert_eq!(r#attr_name, "L2:att"); // <assertEquals actual="attrName" expected="&quot;L2:att&quot;" id="namednodemapgetnameditemns03" ignoreCase="false"/>
            }
            // prefix09.xml
            #[test]
            fn test_prefix09() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#addr_node; // type: Element // <var name="addrNode" type="Element"/>
                let mut r#addr_attr; // type: Attr // <var name="addrAttr" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="elementList"/>
                r#addr_node = r#element_list.item(3).unwrap(); // <item interface="NodeList" obj="elementList" index="3" var="addrNode"/>
                r#addr_attr = r#addr_node.get_attribute_node("xmlns").unwrap(); // <getAttributeNode obj="addrNode" name="&quot;xmlns&quot;" var="addrAttr"/>

                // unimplemented:
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <prefix obj="addrAttr" value="&quot;xxx&quot;"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
            }
            // namednodemapremovenameditemns07.xml
            #[test]
            fn test_namednodemapremovenameditemns07() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#element; // type: Node // <var name="element" type="Node"/>
                // let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element_list = r#doc
                //     .get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "employee"); // <getElementsByTagNameNS var="elementList" obj="doc" localName="&quot;employee&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" interface="Document"/>
                // r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                // r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR"><NOT_FOUND_ERR><removeNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;domestic&quot;"/></NOT_FOUND_ERR></assertDOMException>
            }
            // namednodemapremovenameditemns08.xml
            #[test]
            fn test_namednodemapremovenameditemns08() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element_list = r#doc
                //     .get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" localName="&quot;address&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" interface="Document"/>
                // r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                // r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                // r#element
                //     .remove_attribute_ns(Some("http://www.nist.gov".into()), "domestic".into())
                //     .unwrap(); // <removeAttributeNS obj="element" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;domestic&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR"><NOT_FOUND_ERR><removeNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;domestic&quot;"/></NOT_FOUND_ERR></assertDOMException>
            }
            // setAttributeNS07.xml
            #[test]
            fn test_set_attribute_n_s07() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;xmlns&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                // r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>

                // // unimplemented: // <assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><setAttributeNS obj="testAddr" namespaceURI="namespaceURI" qualifiedName="qualifiedName" value="&quot;newValue&quot;"/></NAMESPACE_ERR></assertDOMException>
            }
            // namednodemapsetnameditemns09.xml
            #[test]
            fn test_namednodemapsetnameditemns09() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entities" obj="docType"/>

                // // unimplemented: // <notations var="notations" obj="docType"/>
                // r#attr = r#doc
                //     .create_attribute_ns(
                //         Some("http://www.w3.org/DOM/Test"),
                //         "test".as_ref(),
                //     )
                //     .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;test&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR_entities"><NO_MODIFICATION_ALLOWED_ERR><setNamedItemNS var="newNode" obj="entities" arg="attr"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR_notations"><NO_MODIFICATION_ALLOWED_ERR><setNamedItemNS var="newNode" obj="notations" arg="attr"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // elementsetattributenodens06.xml
            #[test]
            fn test_elementsetattributenodens06() {
                // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#attribute2; // type: Attr // <var name="attribute2" type="Attr"/>
                let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#new_attribute; // type: Node // <var name="newAttribute" type="Node"/>
                let mut r#new_child; // type: Node // <var name="newChild" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test"), "elem1".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;elem1&quot;"/>
                r#attribute = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Test"), "attr".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;attr&quot;"/>
                r#ent_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent4&quot;"/>
                r#new_child = r#attribute.append_child(ent_ref.clone().into()).unwrap(); // <appendChild var="newChild" obj="attribute" newChild="entRef"/>
                r#new_attribute = r#element.set_attribute_node_ns(r#attribute).unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="attribute"/>
                r#element_list = r#ent_ref.child_nodes(); // <childNodes var="elementList" obj="entRef"/>
                r#element = r#element_list
                    .item(0)
                    .unwrap()
                    .clone()
                    .as_element()
                    .unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                r#attribute2 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Test"), "attr2".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute2" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;attr2&quot;"/>

                // unimplemented: // <assertDOMException id="elementsetattributenodens06"><NO_MODIFICATION_ALLOWED_ERR><setAttributeNodeNS var="newAttribute" obj="element" newAttr="attribute2"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // nodesetprefix08.xml
            #[test]
            fn test_nodesetprefix08() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName var="elementList" obj="doc" tagname="&quot;employee&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                r#attribute = r#element.get_attribute_node("xmlns").unwrap(); // <getAttributeNode var="attribute" obj="element" name="&quot;xmlns&quot;"/>

                // unimplemented:
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <prefix obj="attribute" value="&quot;xml&quot;"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
            }
            // importNode10.xml
            #[test]
            fn test_import_node10() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                r#ent_ref = r#a_new_doc
                    .create_entity_reference("entRef1".to_string())
                    .unwrap(); // <createEntityReference obj="aNewDoc" var="entRef" name="&quot;entRef1&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                r#ent_ref.set_node_value("entRef1Value").unwrap(); // <nodeValue obj="entRef" value="&quot;entRef1Value&quot;"/>
                r#a_node = r#doc.import_node(r#ent_ref.into(), false).unwrap(); // <importNode obj="doc" var="aNode" importedNode="entRef" deep="false"/>
                r#owner_document = r#a_node.owner_document().unwrap(); // <ownerDocument obj="aNode" var="ownerDocument"/>
                r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>

                // unimplemented: // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="systemId"/>
                r#name = r#a_node.node_name().to_string(); // <nodeName obj="aNode" var="name"/>
                assert_eq!(r#name, "entRef1"); // <assertEquals actual="name" expected="&quot;entRef1&quot;" id="nodeName" ignoreCase="false"/>
            }
            // documentimportnode04.xml
            #[test]
            fn test_documentimportnode04() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // // unimplemented: // <implementationAttribute name="validating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType" isNull="true"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#imported_attr; // type: Node // <var name="importedAttr" type="Node"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;l2:root&quot;" doctype="docType"/>
                // r#child_list = r#doc
                //     .get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "employee"); // <getElementsByTagNameNS var="childList" obj="doc" localName="&quot;employee&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" interface="Document"/>
                // r#element = r#child_list.item(1).unwrap().clone(); // <item var="element" obj="childList" index="1" interface="NodeList"/>
                // r#attr = r#element.get_attribute_node("defaultAttr").unwrap(); // <getAttributeNode var="attr" obj="element" name="&quot;defaultAttr&quot;"/>
                // r#imported_attr = r#new_doc.import_node(r#attr.into(), true).unwrap(); // <importNode var="importedAttr" obj="newDoc" importedNode="attr" deep="true"/>
                // r#node_name = r#imported_attr.node_name().to_string(); // <nodeName var="nodeName" obj="importedAttr"/>
                // r#node_value = r#imported_attr.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="importedAttr"/>
                // r#node_type = r#imported_attr.node_type(); // <nodeType var="nodeType" obj="importedAttr"/>
                // assert_eq!(r#node_name, "defaultAttr"); // <assertEquals expected="&quot;defaultAttr&quot;" actual="nodeName" id="documentimportnode04_nodeName" ignoreCase="false"/>
                // assert_eq!(r#node_type as i32, 2); // <assertEquals expected="2" actual="nodeType" id="documentimportnode04_nodeType" ignoreCase="false"/>
                // assert_eq!(r#node_value, "defaultVal"); // <assertEquals expected="&quot;defaultVal&quot;" actual="nodeValue" id="documentimportnode04_nodeValue" ignoreCase="false"/>
            }
            // getAttributeNS03.xml
            #[test]
            fn test_get_attribute_n_s03() {
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#local_name = "domestic"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;domestic&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                r#test_addr
                    .remove_attribute_ns(Some(r#namespace_uri), r#local_name)
                    .unwrap(); // <removeAttributeNS obj="testAddr" namespaceURI="namespaceURI" localName="localName"/>
                r#attr_value = r#test_addr
                    .get_attribute_ns(Some(r#namespace_uri), r#local_name)
                    .unwrap(); // <getAttributeNS obj="testAddr" var="attrValue" namespaceURI="namespaceURI" localName="localName"/>
                assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" id="throw_Equals" ignoreCase="false"/>
            }
            // elementremoveattributens01.xml
            #[test]
            fn test_elementremoveattributens01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM"), "elem".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM&quot;" qualifiedName="&quot;elem&quot;"/>
                r#attribute = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/DOM/Test/createAttributeNS"),
                        "attr".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="attribute" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/createAttributeNS&quot;" qualifiedName="&quot;attr&quot;"/>
                r#new_attribute = r#element.set_attribute_node_ns(r#attribute).unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="attribute"/>
                r#element
                    .remove_attribute_ns(
                        Some("http://www.w3.org/DOM/Test/createAttributeNS"),
                        "attr",
                    )
                    .unwrap(); // <removeAttributeNS obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/createAttributeNS&quot;" localName="&quot;attr&quot;"/>
                r#state = r#element
                    .has_attribute_ns(Some("http://www.w3.org/DOM/Test/createAttributeNS"), "attr")
                    .unwrap(); // <hasAttributeNS var="state" obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/createAttributeNS&quot;" localName="&quot;attr&quot;"/>
                assert!(!r#state); // <assertFalse actual="state" id="elementremoveattributens01"/>
            }
            // documentgetelementsbytagnameNS04.xml
            #[test]
            fn test_documentgetelementsbytagname_n_s04() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#child_list = r#doc.get_elements_by_tag_name_ns(Some(r#null_ns.as_ref()), "0");
                // // <getElementsByTagNameNS var="childList" obj="doc" namespaceURI="nullNS" localName="&quot;0&quot;" interface="Document"/>

                // // unimplemented: // <assertSize size="0" collection="childList" id="documentgetelementsbytagnameNS04"/>
            }
            // elementgetattributenodens01.xml
            #[test]
            fn test_elementgetattributenodens01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute1; // type: Attr // <var name="attribute1" type="Attr"/>
                let mut r#attribute2; // type: Attr // <var name="attribute2" type="Attr"/>
                let mut r#new_attribute1; // type: Attr // <var name="newAttribute1" type="Attr"/>
                let mut r#new_attribute2; // type: Attr // <var name="newAttribute2" type="Attr"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                let mut r#att_node_name; // type: DOMString // <var name="attNodeName" type="DOMString"/>
                let mut r#attr_local_name; // type: DOMString // <var name="attrLocalName" type="DOMString"/>
                let mut r#attr_ns; // type: DOMString // <var name="attrNS" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element = r#doc
                    .create_element_ns(Some("namespaceURI"), "root".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;namespaceURI&quot;" qualifiedName="&quot;root&quot;"/>
                r#attribute1 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Level2"), "l2:att".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute1" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Level2&quot;" qualifiedName="&quot;l2:att&quot;"/>
                r#new_attribute1 = r#element.set_attribute_node_ns(r#attribute1).unwrap(); // <setAttributeNodeNS var="newAttribute1" obj="element" newAttr="attribute1"/>
                r#attribute2 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Level1"), "att".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute2" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Level1&quot;" qualifiedName="&quot;att&quot;"/>
                r#new_attribute2 = r#element.set_attribute_node_ns(r#attribute2).unwrap(); // <setAttributeNodeNS var="newAttribute2" obj="element" newAttr="attribute2"/>
                r#attribute = r#element
                    .get_attribute_node_ns(Some("http://www.w3.org/DOM/Level2"), "att")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attribute" obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Level2&quot;" localName="&quot;att&quot;"/>
                r#attr_value = r#attribute.node_value().unwrap().to_string(); // <nodeValue var="attrValue" obj="attribute"/>
                r#attr_name = r#attribute.name().to_string(); // <name var="attrName" obj="attribute" interface="Attr"/>
                r#att_node_name = r#attribute.node_name().to_string(); // <nodeName var="attNodeName" obj="attribute"/>
                r#attr_local_name = r#attribute.local_name().unwrap().to_string(); // <localName var="attrLocalName" obj="attribute"/>
                r#attr_ns = r#attribute.namespace_uri().unwrap().to_string(); // <namespaceURI var="attrNS" obj="attribute"/>
                assert_eq!(r#attr_value, ""); // <assertEquals actual="attrValue" expected="&quot;&quot;" id="elementgetattributenodens01_attrValue" ignoreCase="false"/>
                assert_eq!(r#attr_name, "l2:att"); // <assertEquals actual="attrName" expected="&quot;l2:att&quot;" id="elementgetattributenodens01_attrName" ignoreCase="false"/>
                assert_eq!(r#att_node_name, "l2:att"); // <assertEquals actual="attNodeName" expected="&quot;l2:att&quot;" id="elementgetattributenodens01_attrNodeName" ignoreCase="false"/>
                assert_eq!(r#attr_local_name, "att"); // <assertEquals actual="attrLocalName" expected="&quot;att&quot;" id="elementgetattributenodens01_attrLocalName" ignoreCase="false"/>
                assert_eq!(r#attr_ns, "http://www.w3.org/DOM/Level2"); // <assertEquals actual="attrNS" expected="&quot;http://www.w3.org/DOM/Level2&quot;" id="elementgetattributenodens01_attrNs" ignoreCase="false"/>
            }
            // createDocument05.xml
            #[test]
            fn test_create_document05() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.ecommerce.org/schema&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType" isNull="true"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                // let mut r#charact; // type: DOMString // <var name="charact" type="DOMString"/>
                // let mut r#illegal_q_names; // type: List // <var name="illegalQNames" type="List"><member>"namespaceURI:{"</member><member>"namespaceURI:}"</member><member>"namespaceURI:~"</member><member>"namespaceURI:'"</member><member>"namespaceURI:!"</member><member>"namespaceURI:@"</member><member>"namespaceURI:#"</member><member>"namespaceURI:$"</member><member>"namespaceURI:%"</member><member>"namespaceURI:^"</member><member>"namespaceURI:&amp;"</member><member>"namespaceURI:*"</member><member>"namespaceURI:("</member><member>"namespaceURI:)"</member><member>"namespaceURI:+"</member><member>"namespaceURI:="</member><member>"namespaceURI:["</member><member>"namespaceURI:]"</member><member>"namespaceURI:\\"</member><member>"namespaceURI:/"</member><member>"namespaceURI:;"</member><member>"namespaceURI:`"</member><member>"namespaceURI:&lt;"</member><member>"namespaceURI:&gt;"</member><member>"namespaceURI:,"</member><member>"namespaceURI:a "</member><member>"namespaceURI:\""</member></var>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <for-each collection="illegalQNames" member="qualifiedName"><implementation obj="doc" var="domImpl"/><assertDOMException id="throw_INVALID_CHARACTER_ERR"><INVALID_CHARACTER_ERR><createDocument obj="domImpl" var="aNewDoc" namespaceURI="namespaceURI" qualifiedName="qualifiedName" doctype="docType"/></INVALID_CHARACTER_ERR></assertDOMException></for-each>
            }
            // nodehasattributes02.xml
            #[test]
            fn test_nodehasattributes02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#has_attributes; // type: boolean // <var name="hasAttributes" type="boolean"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                r#has_attributes = r#doc_type.has_attributes(); // <hasAttributes var="hasAttributes" obj="docType"/>
                assert!(!r#has_attributes); // <assertFalse actual="hasAttributes" id="nodehasattributes02"/>
            }
            // namednodemapsetnameditemns07.xml
            #[test]
            fn test_namednodemapsetnameditemns07() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                // r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                // r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                // r#attr = r#attributes
                //     .get_named_item_ns(Some("http://www.usa.com".into()), "domestic".into())
                //     .unwrap()
                //     .unwrap(); // <getNamedItemNS var="attr" obj="attributes" namespaceURI="&quot;http://www.usa.com&quot;" localName="&quot;domestic&quot;"/>
                // r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                // r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>

                // // unimplemented: // <assertDOMException id="namednodemapsetnameditemns07"><INUSE_ATTRIBUTE_ERR><setNamedItemNS var="newNode" obj="attributes" arg="attr"/></INUSE_ATTRIBUTE_ERR></assertDOMException>
            }
            // hc_nodedocumentfragmentnormalize1.xml
            #[test]
            fn test_hc_nodedocumentfragmentnormalize1() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_fragment; // type: DocumentFragment // <var name="docFragment" type="DocumentFragment"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                let mut r#txt_node; // type: Text // <var name="txtNode" type="Text"/>
                let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="docFragment"/>
                r#txt_node = r#doc.create_text_node("foo"); // <createTextNode var="txtNode" obj="doc" data="&quot;foo&quot;"/>
                r#retval = r#doc_fragment.append_child(txt_node.into()).unwrap(); // <appendChild var="retval" obj="docFragment" newChild="txtNode"/>
                r#txt_node = r#doc.create_text_node("bar"); // <createTextNode var="txtNode" obj="doc" data="&quot;bar&quot;"/>
                r#retval = r#doc_fragment.append_child(txt_node.into()).unwrap(); // <appendChild var="retval" obj="docFragment" newChild="txtNode"/>
                r#doc_fragment.normalize(); // <normalize obj="docFragment"/>
                r#txt_node = r#doc_fragment
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild var="txtNode" obj="docFragment" interface="Node"/>
                r#node_value = r#txt_node.node_value().unwrap().to_string(); // <nodeValue obj="txtNode" var="nodeValue"/>
                assert_eq!(r#node_value, "foobar"); // <assertEquals actual="nodeValue" expected="&quot;foobar&quot;" id="normalizedNodeValue" ignoreCase="false"/>
                let r#retval = r#txt_node.next_sibling(); // <nextSibling var="retval" obj="txtNode" interface="Node"/>
                assert!(retval.is_none()); // <assertNull actual="retval" id="singleChild"/>
            }
            // createAttributeNS01.xml
            #[test]
            fn test_create_attribute_n_s01() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.ecommerce.org/&quot;"/>
                // let mut r#malformed_name; // type: DOMString // <var name="malformedName" type="DOMString" value="&quot;prefix::local&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><createAttributeNS obj="doc" var="newAttr" namespaceURI="namespaceURI" qualifiedName="malformedName"/></NAMESPACE_ERR></assertDOMException>
            }
            // createAttributeNS06.xml
            #[test]
            fn test_create_attribute_n_s06() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.example.com/&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // // unimplemented: // <assertDOMException id="throw_INVALID_CHARACTER_ERR"><INVALID_CHARACTER_ERR><createAttributeNS obj="doc" var="newAttr" namespaceURI="namespaceURI" qualifiedName="&quot;&quot;"/></INVALID_CHARACTER_ERR></assertDOMException>
            }
            // documenttypesystemid01.xml
            #[test]
            fn test_documenttypesystemid01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#public_id; // type: DOMString // <var name="publicId" type="DOMString"/>
                // let mut r#system_id; // type: DOMString // <var name="systemId" type="DOMString"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocumentType var="docType" obj="domImpl" qualifiedName="&quot;l2:root&quot;" publicId="&quot;PUB&quot;" systemId="&quot;SYS&quot;"/>
                // r#public_id = r#doc_type.public_id().unwrap().to_string(); // <publicId var="publicId" obj="docType" interface="DocumentType"/>
                // r#system_id = r#doc_type.system_id().unwrap().to_string(); // <systemId var="systemId" obj="docType" interface="DocumentType"/>
                // assert_eq!(r#public_id, "PUB"); // <assertEquals actual="publicId" expected="&quot;PUB&quot;" id="documenttypepublicid01" ignoreCase="false"/>
                // assert_eq!(r#system_id, "SYS"); // <assertEquals actual="systemId" expected="&quot;SYS&quot;" id="documenttypesystemid01" ignoreCase="false"/>
            }
            // namednodemapsetnameditemns01.xml
            #[test]
            fn test_namednodemapsetnameditemns01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Node // <var name="element" type="Node"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#new_attr1; // type: Attr // <var name="newAttr1" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#new_attr1 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/L1"), "streets".as_ref())
                    .unwrap(); // <createAttributeNS var="newAttr1" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" qualifiedName="&quot;streets&quot;"/>
                r#new_attribute = r#element.set_attribute_node_ns(r#new_attr1).unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="newAttr1"/>
                r#attribute = r#attributes
                    .get_named_item_ns(Some("http://www.w3.org/DOM/L1"), "streets")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" localName="&quot;streets&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                assert_eq!(r#attr_name, "streets"); // <assertEquals actual="attrName" expected="&quot;streets&quot;" id="namednodemapsetnameditemns01" ignoreCase="false"/>
            }
            // getElementById01.xml
            #[test]
            fn test_get_element_by_id01() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#tagname; // type: DOMString // <var name="tagname" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element = r#doc.get_element_by_id("CANADA".as_ref()).unwrap(); // <getElementById interface="Document" obj="doc" var="element" elementId="&quot;CANADA&quot;"/>
                r#tagname = r#element.tag_name().to_string(); // <tagName obj="element" var="tagname"/>
                assert_eq!(r#tagname, "emp:address"); // <assertEquals actual="tagname" expected="&quot;emp:address&quot;" id="throw_Equals" ignoreCase="false"/>
            }
            // isSupported14.xml
            #[test]
            fn test_is_supported14() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // let mut r#null_string; // type: DOMString // <var name="nullString" type="DOMString" isNull="true"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                // r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>

                // // unimplemented: // <isSupported obj="rootNode" feature="&quot;Core&quot;" version="nullString" var="state"/>
                // assert!(r#state); // <assertTrue actual="state" id="Core"/>
            }
            // namednodemapsetnameditemns05.xml
            #[test]
            fn test_namednodemapsetnameditemns05() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entities" obj="docType"/>

                // // unimplemented: // <assertNotNull actual="entities" id="entitiesNotNull"/>

                // // unimplemented: // <notations var="notations" obj="docType"/>

                // // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                // r#entity = r#entities.get_named_item("ent1".into()).unwrap(); // <getNamedItem var="entity" obj="entities" name="&quot;ent1&quot;"/>
                // r#notation = r#notations.get_named_item("notation1".into()).unwrap();
                // // <getNamedItem var="notation" obj="notations" name="&quot;notation1&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR_entities"><NO_MODIFICATION_ALLOWED_ERR><setNamedItemNS var="newNode" obj="entities" arg="entity"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR_notations"><NO_MODIFICATION_ALLOWED_ERR><setNamedItemNS var="newNode" obj="notations" arg="notation"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // hasAttribute01.xml
            #[test]
            fn test_has_attribute01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_node; // type: Element // <var name="testNode" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_node = r#element_list.item(4).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="4"/>
                r#state = r#test_node.has_attribute("domestic"); // <hasAttribute obj="testNode" var="state" name="&quot;domestic&quot;"/>
                assert!(!r#state); // <assertFalse actual="state" id="throw_False"/>
            }
            // attrgetownerelement01.xml
            #[test]
            fn test_attrgetownerelement01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#owner_element; // type: Element // <var name="ownerElement" type="Element"/>
                let mut r#owner_element_name; // type: DOMString // <var name="ownerElementName" type="DOMString"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "employee"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;employee&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attr = r#attributes
                    .get_named_item_ns(None, "defaultAttr")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attr" obj="attributes" namespaceURI="nullNS" localName="&quot;defaultAttr&quot;"/>
                r#owner_element = r#attr.owner_element().unwrap(); // <ownerElement var="ownerElement" obj="attr"/>
                r#owner_element_name = r#owner_element.node_name().to_string(); // <nodeName var="ownerElementName" obj="ownerElement"/>
                assert_eq!(r#owner_element_name, "emp:employee"); // <assertEquals actual="ownerElementName" expected="&quot;emp:employee&quot;" id="attrgetownerelement01" ignoreCase="false"/>
            }
            // documentimportnode10.xml
            #[test]
            fn test_documentimportnode10() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_fragment; // type: DocumentFragment // <var name="docFragment" type="DocumentFragment"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                let mut r#address_node; // type: Node // <var name="addressNode" type="Node"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#imported_doc_frag; // type: Node // <var name="importedDocFrag" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment var="docFragment" obj="doc"/>
                r#child_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="childList" obj="doc" localName="&quot;address&quot;" namespaceURI="&quot;*&quot;" interface="Document"/>
                r#address_node = r#child_list.item(0).unwrap(); // <item var="addressNode" obj="childList" index="0" interface="NodeList"/>
                r#appended_child = r#doc_fragment.append_child(address_node.into()).unwrap(); // <appendChild var="appendedChild" obj="docFragment" newChild="addressNode"/>
                r#imported_doc_frag = r#doc.import_node(r#doc_fragment.into(), true).unwrap(); // <importNode var="importedDocFrag" obj="doc" importedNode="docFragment" deep="true"/>
                r#success = r#imported_doc_frag.has_child_nodes(); // <hasChildNodes var="success" obj="importedDocFrag"/>
                assert!(r#success); // <assertTrue actual="success" id="documentimportnode10"/>
            }
            // setNamedItemNS05.xml
            #[test]
            fn test_set_named_item_n_s05() {
                let mut r#namespace_uri = "http://www.usa.com"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.usa.com&quot;"/>
                let mut r#qualified_name = "dmstc:domestic"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;dmstc:domestic&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#arg; // type: Node // <var name="arg" type="Node"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#retnode; // type: Node // <var name="retnode" type="Node"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#arg = r#doc
                    .create_attribute_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                    .unwrap(); // <createAttributeNS obj="doc" var="arg" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                r#arg.set_node_value("newValue").unwrap(); // <nodeValue obj="arg" value="&quot;newValue&quot;"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="0"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                r#retnode = r#attributes.set_named_item_ns(r#arg).unwrap().unwrap(); // <setNamedItemNS interface="NamedNodeMap" obj="attributes" var="retnode" arg="arg"/>
                r#value = r#retnode.node_value().unwrap().to_string(); // <nodeValue obj="retnode" var="value"/>
                assert_eq!(r#value, "Yes"); // <assertEquals actual="value" expected="&quot;Yes&quot;" id="throw_Equals" ignoreCase="false"/>
            }
            // documentcreateelementNS01.xml
            #[test]
            fn test_documentcreateelement_n_s01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#namespace_uri = "http://www.w3.org/DOM/Test/level2"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/DOM/Test/level2&quot;"/>
                let mut r#qualified_name = "XML:XML"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;XML:XML&quot;"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#ns_uri; // type: DOMString // <var name="nsURI" type="DOMString"/>
                let mut r#local_name; // type: DOMString // <var name="localName" type="DOMString"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                let mut r#tag_name; // type: DOMString // <var name="tagName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element = r#doc
                    .create_element_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                    .unwrap(); // <createElementNS obj="doc" var="element" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                r#node_name = r#element.node_name().to_string(); // <nodeName var="nodeName" obj="element"/>
                r#ns_uri = r#element.namespace_uri().unwrap().to_string(); // <namespaceURI var="nsURI" obj="element"/>
                r#local_name = r#element.local_name().unwrap().to_string(); // <localName var="localName" obj="element"/>
                r#prefix = r#element.prefix().unwrap().to_string(); // <prefix var="prefix" obj="element"/>
                r#tag_name = r#element.tag_name().to_string(); // <tagName var="tagName" obj="element"/>
                assert_eq!(r#node_name, "XML:XML"); // <assertEquals actual="nodeName" expected="&quot;XML:XML&quot;" id="documentcreateelementNS01_nodeName" ignoreCase="false"/>
                assert_eq!(r#ns_uri, "http://www.w3.org/DOM/Test/level2"); // <assertEquals actual="nsURI" expected="&quot;http://www.w3.org/DOM/Test/level2&quot;" id="documentcreateelementNS01_namespaceURI" ignoreCase="false"/>
                assert_eq!(r#local_name, "XML"); // <assertEquals actual="localName" expected="&quot;XML&quot;" id="documentcreateelementNS01_localName" ignoreCase="false"/>
                assert_eq!(r#prefix, "XML"); // <assertEquals actual="prefix" expected="&quot;XML&quot;" id="documentcreateelementNS01_prefix" ignoreCase="false"/>
                assert_eq!(r#tag_name, "XML:XML"); // <assertEquals actual="tagName" expected="&quot;XML:XML&quot;" id="documentcreateelementNS01_tagName" ignoreCase="false"/>
            }
            // namednodemapremovenameditemns03.xml
            #[test]
            fn test_namednodemapremovenameditemns03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Node // <var name="element" type="Node"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#attribute1; // type: Attr // <var name="attribute1" type="Attr"/>
                let mut r#attribute2; // type: Attr // <var name="attribute2" type="Attr"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test"), "root".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;root&quot;"/>
                r#attribute1 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/L1"), "L1:att".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute1" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" qualifiedName="&quot;L1:att&quot;"/>
                r#new_attribute = r#element.set_attribute_node_ns(r#attribute1).unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="attribute1"/>
                r#attribute2 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/L2"), "L2:att".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute2" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/L2&quot;" qualifiedName="&quot;L2:att&quot;"/>
                r#new_attribute = r#element.set_attribute_node_ns(r#attribute2).unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="attribute2"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attribute = r#attributes
                    .remove_named_item_ns(Some("http://www.w3.org/DOM/L1"), "att")
                    .unwrap(); // <removeNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" localName="&quot;att&quot;"/>
                r#attribute = r#attributes
                    .get_named_item_ns(Some("http://www.w3.org/DOM/L2"), "att")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.w3.org/DOM/L2&quot;" localName="&quot;att&quot;"/>
                r#node_name = r#attribute.node_name().to_string(); // <nodeName var="nodeName" obj="attribute"/>
                assert_eq!(r#node_name, "L2:att"); // <assertEquals actual="nodeName" expected="&quot;L2:att&quot;" id="namednodemapremovenameditemns02" ignoreCase="false"/>
            }
            // nodeissupported05.xml
            #[test]
            fn test_nodeissupported05() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                // let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#pi = r#doc
                //     .create_processing_instruction("PITarget", Some("PIData"))
                //     .unwrap(); // <createProcessingInstruction var="pi" obj="doc" target="&quot;PITarget&quot;" data="&quot;PIData&quot;"/>

                // // unimplemented: // <isSupported obj="pi" var="success" feature="&quot;-&quot;" version="&quot;+&quot;"/>
                // assert!(!r#success); // <assertFalse actual="success" id="nodeissupported05"/>
            }
            // domimplementationcreatedocument04.xml
            #[test]
            fn test_domimplementationcreatedocument04() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" isNull="true"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;dom:root&quot;"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <assertDOMException id="domimplementationcreatedocument04"><NAMESPACE_ERR><createDocument obj="domImpl" var="newDoc" namespaceURI="namespaceURI" qualifiedName="qualifiedName" doctype="docType"/></NAMESPACE_ERR></assertDOMException>
            }
            // createDocumentType03.xml
            #[test]
            fn test_create_document_type03() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://ecommerce.org/schema&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;prefix:myDoc&quot;"/>
                // let mut r#public_id; // type: DOMString // <var name="publicId" type="DOMString" value="&quot;http://www.localhost.com&quot;"/>
                // let mut r#system_id; // type: DOMString // <var name="systemId" type="DOMString" value="&quot;myDoc.dtd&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_type; // type: DocumentType // <var name="newType" type="DocumentType" isNull="true"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <createDocumentType obj="domImpl" var="newType" qualifiedName="qualifiedName" publicId="publicId" systemId="systemId"/>
                // r#node_name = r#new_type.node_name().to_string(); // <nodeName var="nodeName" obj="newType"/>
                // assert_eq!(r#node_name, "prefix:myDoc"); // <assertEquals actual="nodeName" expected="&quot;prefix:myDoc&quot;" ignoreCase="false" id="nodeName"/>
                // r#node_value = r#new_type.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="newType"/>

                // // unimplemented: // <assertNull actual="nodeValue" id="nodeValue"/>
            }
            // nodeissupported03.xml
            #[test]
            fn test_nodeissupported03() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <isSupported obj="docType" var="success" feature="&quot;&quot;" version="&quot;&quot;"/>
                // assert!(!r#success); // <assertFalse actual="success" id="nodeissupported03"/>
            }
            // importNode05.xml
            #[test]
            fn test_import_node05() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#has_child; // type: boolean // <var name="hasChild" type="boolean"/>
                let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                let mut r#addresses; // type: NodeList // <var name="addresses" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                r#addresses = r#a_new_doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName var="addresses" obj="aNewDoc" interface="Document" tagname="&quot;emp:address&quot;"/>
                r#element = r#addresses.item(0).unwrap(); // <item var="element" obj="addresses" interface="NodeList" index="0"/>
                // unimplemented: // <assertNotNull actual="element" id="empAddressNotNull"/>
                r#a_node = r#doc.import_node(r#element.into(), false).unwrap(); // <importNode obj="doc" var="aNode" importedNode="element" deep="false"/>
                r#has_child = r#a_node.has_child_nodes(); // <hasChildNodes obj="aNode" var="hasChild"/>
                assert!(!r#has_child); // <assertFalse actual="hasChild" id="hasChild"/>
                r#owner_document = r#a_node.owner_document().unwrap(); // <ownerDocument obj="aNode" var="ownerDocument"/>
                r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>

                // unimplemented: // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="dtdSystemId"/>
                r#name = r#a_node.node_name().to_string(); // <nodeName obj="aNode" var="name"/>
                assert_eq!(r#name, "emp:address"); // <assertEquals actual="name" expected="&quot;emp:address&quot;" id="nodeName" ignoreCase="false"/>
            }
            // setAttributeNodeNS05.xml
            #[test]
            fn test_set_attribute_node_n_s05() {
                // let mut r#namespace_uri = "http://www.newattr.com"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.newattr.com&quot;"/>
                // let mut r#qualified_name = "emp:newAttr"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:newAttr&quot;"/>
                // let mut r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                // let mut r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                // let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                // let mut r#set_attr1; // type: Attr // <var name="setAttr1" type="Attr"/>
                // r#doc1 = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc1" href="staffNS" willBeModified="true"/>
                // r#doc2 = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc2" href="staffNS" willBeModified="true"/>
                // r#new_attr = r#doc2
                //     .create_attribute_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                //     .unwrap(); // <createAttributeNS obj="doc2" var="newAttr" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                // r#element_list = r#doc1.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc1" var="elementList" tagname="&quot;emp:address&quot;"/>
                // r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>

                // // unimplemented: // <assertDOMException id="throw_WRONG_DOCUMENT_ERR"><WRONG_DOCUMENT_ERR><setAttributeNodeNS var="setAttr1" obj="testAddr" newAttr="newAttr"/></WRONG_DOCUMENT_ERR></assertDOMException>
            }
            // elementsetattributensurinull.xml
            #[test]
            fn test_elementsetattributensurinull() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" isNull="true"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:qualifiedName&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                // r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>

                // // unimplemented: // <assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><setAttributeNS obj="testAddr" namespaceURI="namespaceURI" qualifiedName="qualifiedName" value="&quot;newValue&quot;"/></NAMESPACE_ERR></assertDOMException>
            }
            // namednodemapremovenameditemns01.xml
            #[test]
            fn test_namednodemapremovenameditemns01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Node // <var name="element" type="Node"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attribute = r#attributes
                    .remove_named_item_ns(Some("http://www.nist.gov"), "domestic")
                    .unwrap(); // <removeNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;domestic&quot;"/>
                let r#attribute = r#attributes
                    .get_named_item_ns(Some("http://www.nist.gov"), "domestic")
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;domestic&quot;"/>
                assert!(attribute.is_none()); // <assertNull actual="attribute" id="namednodemapremovenameditemns01"/>
            }
            // domimplementationfeaturecore.xml
            #[test]
            fn test_domimplementationfeaturecore() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <hasFeature obj="domImpl" var="state" feature="&quot;core&quot;" version="&quot;2.0&quot;"/>
                // assert!(r#state); // <assertTrue actual="state" id="domimplementationFeaturecoreAssert"/>
            }
            // hc_nodedocumentfragmentnormalize2.xml
            #[test]
            fn test_hc_nodedocumentfragmentnormalize2() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_fragment; // type: DocumentFragment // <var name="docFragment" type="DocumentFragment"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // let mut r#txt_node; // type: Text // <var name="txtNode" type="Text"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment obj="doc" var="docFragment"/>
                // r#txt_node = r#doc.create_text_node(""); // <createTextNode var="txtNode" obj="doc" data="&quot;&quot;"/>
                // r#retval = r#doc_fragment.append_child(txt_node.into()).unwrap(); // <appendChild var="retval" obj="docFragment" newChild="txtNode"/>
                // r#doc_fragment.normalize(); // <normalize obj="docFragment"/>
                // r#txt_node = r#doc_fragment
                //     .first_child()
                //     .unwrap()
                //     .as_text_node()
                //     .unwrap(); // <firstChild var="txtNode" obj="docFragment" interface="Node"/>

                // // unimplemented: // <assertNull actual="txtNode" id="noChild"/>
            }
            // nodeissupported02.xml
            #[test]
            fn test_nodeissupported02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                // let mut r#version; // type: DOMString // <var name="version" type="DOMString" value="&quot;&quot;"/>
                // let mut r#version1; // type: DOMString // <var name="version1" type="DOMString" value="&quot;1.0&quot;"/>
                // let mut r#version2; // type: DOMString // <var name="version2" type="DOMString" value="&quot;2.0&quot;"/>
                // let mut r#feature_core; // type: DOMString // <var name="featureCore" type="DOMString"/>
                // let mut r#feature_xml; // type: DOMString // <var name="featureXML" type="DOMString"/>
                // let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                // let mut r#features_xml; // type: List // <var name="featuresXML" type="List"><member>"XML"</member><member>"xmL"</member></var>
                // let mut r#features_core; // type: List // <var name="featuresCore" type="List"><member>"Core"</member><member>"CORE"</member></var>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#attribute = r#doc.create_attribute("TestAttr".to_string()).unwrap();
                // // <createAttribute obj="doc" var="attribute" name="&quot;TestAttr&quot;"/>

                // // unimplemented: // <for-each collection="featuresXML" member="featureXML"><isSupported obj="attribute" var="success" feature="featureXML" version="version"/><assertTrue actual="success" id="nodeissupported02_XML1"/><isSupported obj="attribute" var="success" feature="featureXML" version="version1"/><assertTrue actual="success" id="nodeissupported02_XML2"/></for-each>

                // // unimplemented: // <for-each collection="featuresCore" member="featureCore"><isSupported obj="attribute" var="success" feature="featureCore" version="version"/><assertTrue actual="success" id="nodeissupported02_Core1"/><!--   isSupported("Core", "1.0") is unspecified since "Core" was not defined in L1  --><isSupported obj="attribute" var="success" feature="featureCore" version="version1"/><isSupported obj="attribute" var="success" feature="featureCore" version="version2"/><assertTrue actual="success" id="nodeissupported02_Core3"/></for-each>
            }
            // localName01.xml
            #[test]
            fn test_local_name01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                let mut r#addr_attr; // type: Attr // <var name="addrAttr" type="Attr"/>
                let mut r#local_name; // type: DOMString // <var name="localName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                r#addr_attr = r#test_addr.get_attribute_node("emp:domestic").unwrap(); // <getAttributeNode obj="testAddr" name="&quot;emp:domestic&quot;" var="addrAttr"/>
                r#local_name = r#addr_attr.local_name().unwrap().to_string(); // <localName obj="addrAttr" var="localName"/>
                assert_eq!(r#local_name, "domestic"); // <assertEquals actual="localName" expected="&quot;domestic&quot;" id="localName" ignoreCase="false"/>
            }
            // isSupported04.xml
            #[test]
            fn test_is_supported04() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                // r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>

                // // unimplemented: // <isSupported obj="rootNode" feature="&quot;xml&quot;" version="&quot;1.0&quot;" var="state"/>
                // assert!(r#state); // <assertTrue actual="state" id="throw_True"/>
            }
            // prefix02.xml
            #[test]
            fn test_prefix02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let mut r#text_node; // type: Node // <var name="textNode" type="Node"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:employeeId"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:employeeId&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                // unimplemented: // <assertNotNull actual="testEmployee" id="empEmployeeNotNull"/>
                r#text_node = r#test_employee.first_child().unwrap(); // <firstChild interface="Node" obj="testEmployee" var="textNode"/>
                r#prefix = r#text_node.prefix(); // <prefix obj="textNode" var="prefix"/>
                assert!(prefix.is_none()); // <assertNull actual="prefix" id="textNodePrefix"/>
            }
            // attrgetownerelement04.xml
            #[test]
            fn test_attrgetownerelement04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_imp: DocumentRef; // <var name="docImp" type="Document"/>
                let mut r#owner_element; // type: Node // <var name="ownerElement" type="Node"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#attr_imp; // type: Attr // <var name="attrImp" type="Attr"/>
                let mut r#addresses; // type: NodeList // <var name="addresses" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_imp = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="docImp" href="staff" willBeModified="false"/>
                r#addresses =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="addresses" obj="doc" interface="Document" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;"/>
                r#element = r#addresses.item(1).unwrap(); // <item var="element" obj="addresses" interface="NodeList" index="1"/>
                // unimplemented: // <assertNotNull actual="element" id="empAddressNotNull"/>
                r#attr = r#element
                    .get_attribute_node_ns(Some("http://www.nist.gov"), "zone")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attr" obj="element" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;zone&quot;"/>
                r#attr_imp = r#doc_imp
                    .import_node(r#attr.into(), true)
                    .unwrap()
                    .as_attribute()
                    .unwrap(); // <importNode var="attrImp" obj="docImp" importedNode="attr" deep="true"/>
                r#owner_element = r#attr_imp.owner_element(); // <ownerElement var="ownerElement" obj="attrImp"/>
                assert!(owner_element.is_none()); // <assertNull actual="ownerElement" id="attrgetownerelement04"/>
            }
            // namednodemapgetnameditemns04.xml
            #[test]
            fn test_namednodemapgetnameditemns04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attr1; // type: Attr // <var name="newAttr1" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#new_attr1 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/L1"), "street".as_ref())
                    .unwrap(); // <createAttributeNS var="newAttr1" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" qualifiedName="&quot;street&quot;"/>
                r#new_attribute = r#element.set_attribute_node_ns(r#new_attr1).unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="newAttr1"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attribute = r#attributes
                    .get_named_item_ns(Some("http://www.w3.org/DOM/L1"), "street")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" localName="&quot;street&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                assert_eq!(r#attr_name, "street"); // <assertEquals actual="attrName" expected="&quot;street&quot;" id="namednodemapgetnameditemns04" ignoreCase="false"/>
            }
            // nodegetownerdocument01.xml
            #[test]
            fn test_nodegetownerdocument01() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#owner_doc: DocumentRef; // <var name="ownerDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#null_id; // type: DOMString // <var name="nullID" type="DOMString" isNull="true"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocumentType var="docType" obj="domImpl" qualifiedName="&quot;mydoc&quot;" publicId="nullID" systemId="nullID"/>
                // r#owner_doc = r#doc_type.owner_document().unwrap(); // <ownerDocument var="ownerDoc" obj="docType"/>

                // // unimplemented: // <assertNull actual="ownerDoc" id="nodegetownerdocument01"/>
            }
            // elementsetattributens02.xml
            #[test]
            fn test_elementsetattributens02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                r#element
                    .set_attribute_ns(
                        Some("http://www.w3.org/DOM/Test/setAttributeNS"),
                        "this:street",
                        "Silver Street",
                    )
                    .unwrap(); // <setAttributeNS obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/setAttributeNS&quot;" qualifiedName="&quot;this:street&quot;" value="&quot;Silver Street&quot;"/>
                r#attribute = r#element
                    .get_attribute_node_ns(
                        Some("http://www.w3.org/DOM/Test/setAttributeNS"),
                        "street",
                    )
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attribute" obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/setAttributeNS&quot;" localName="&quot;street&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                r#attr_value = r#attribute.node_value().unwrap().to_string(); // <nodeValue var="attrValue" obj="attribute"/>
                assert_eq!(r#attr_name, "this:street"); // <assertEquals actual="attrName" expected="&quot;this:street&quot;" id="elementsetattributens02_attrName" ignoreCase="false"/>
                assert_eq!(r#attr_value, "Silver Street"); // <assertEquals actual="attrValue" expected="&quot;Silver Street&quot;" id="elementsetattributens02_attrValue" ignoreCase="false"/>
            }
            // hasAttributeNS02.xml
            #[test]
            fn test_has_attribute_n_s02() {
                let mut r#local_name = "domestic"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;domestic&quot;"/>
                let mut r#namespace_uri = "http://www.nomatch.com"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nomatch.com&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_node; // type: Element // <var name="testNode" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="0"/>
                r#state = r#test_node
                    .has_attribute_ns(Some(r#namespace_uri), r#local_name)
                    .unwrap(); // <hasAttributeNS obj="testNode" var="state" namespaceURI="namespaceURI" localName="localName"/>
                assert!(!r#state); // <assertFalse actual="state" id="throw_False"/>
            }
            // documentimportnode07.xml
            #[test]
            fn test_documentimportnode07() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#imported; // type: Node // <var name="imported" type="Node"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // unimplemented:
                // <assertDOMException id="throw_NOT_SUPPORTED_ERR">
                //  <NOT_SUPPORTED_ERR>
                //      <importNode var="imported" obj="doc" importedNode="docType" deep="true"/>
                //  </NOT_SUPPORTED_ERR>
                // </assertDOMException>
            }
            // setAttributeNS06.xml
            #[test]
            fn test_set_attribute_n_s06() {
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#qualified_name = "xml:qualifiedName"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;xml:qualifiedName&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>

                // unimplemented:
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <setAttributeNS obj="testAddr" namespaceURI="namespaceURI" qualifiedName="qualifiedName" value="&quot;newValue&quot;"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
            }
            // createElementNS04.xml
            #[test]
            fn test_create_element_n_s04() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/XML/1998/namespaces&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;xml:element1&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_element; // type: Element // <var name="newElement" type="Element"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // unimplemented:
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <createElementNS obj="doc" var="newElement" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
            }
            // documentcreateattributeNS01.xml
            #[test]
            fn test_documentcreateattribute_n_s01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#qualified_name = "test"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;test&quot;"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#attribute = r#doc
                    .create_attribute_ns(None, r#qualified_name.as_ref())
                    .unwrap(); // <createAttributeNS obj="doc" var="attribute" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                r#node_name = r#attribute.node_name().to_string(); // <nodeName var="nodeName" obj="attribute"/>
                r#node_value = r#attribute.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="attribute"/>
                assert_eq!(r#node_name, "test"); // <assertEquals actual="nodeName" expected="&quot;test&quot;" id="documentcreateattributeNS01" ignoreCase="false"/>
            }
            // namednodemapsetnameditemns03.xml
            #[test]
            fn test_namednodemapsetnameditemns03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_alt: DocumentRef; // <var name="docAlt" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#attributes_alt; // type: NamedNodeMap // <var name="attributesAlt" type="NamedNodeMap"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#element_list_alt; // type: NodeList // <var name="elementListAlt" type="NodeList"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#element_alt; // type: Element // <var name="elementAlt" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#doc_alt = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="docAlt" href="staffNS" willBeModified="true"/>
                r#element_list_alt = r#doc_alt.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementListAlt" obj="docAlt" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element_alt = r#element_list_alt.item(1).unwrap(); // <item var="elementAlt" obj="elementListAlt" index="1" interface="NodeList"/>
                r#attributes_alt = r#element_alt.attributes(); // <attributes var="attributesAlt" obj="elementAlt"/>
                r#attr = r#attributes_alt
                    .get_named_item_ns(None, "street")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attr" obj="attributesAlt" namespaceURI="nullNS" localName="&quot;street&quot;"/>
                r#new_node = r#attributes_alt
                    .remove_named_item_ns(None, "street")
                    .unwrap(); // <removeNamedItemNS var="newNode" obj="attributesAlt" namespaceURI="nullNS" localName="&quot;street&quot;"/>

                // unimplemented:
                // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">
                //  <WRONG_DOCUMENT_ERR>
                //      <setNamedItemNS var="newNode" obj="attributes" arg="attr"/>
                //  </WRONG_DOCUMENT_ERR>
                // </assertDOMException>
            }
            // attrgetownerelement05.xml
            #[test]
            fn test_attrgetownerelement05() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Node // <var name="element" type="Node"/>
                let mut r#owner_element; // type: Element // <var name="ownerElement" type="Element"/>
                let mut r#parent_element; // type: Element // <var name="parentElement" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#owner_element_name; // type: DOMString // <var name="ownerElementName" type="DOMString"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#removed_child; // type: Node // <var name="removedChild" type="Node"/>
                let mut r#node_map; // type: NamedNodeMap // <var name="nodeMap" type="NamedNodeMap"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#parent_element = r#element.parent_node().unwrap(); // <parentNode interface="Node" var="parentElement" obj="element"/>
                r#node_map = r#element.attributes(); // <attributes var="nodeMap" obj="element"/>
                r#removed_child = r#parent_element.remove_child(element.into()).unwrap(); // <removeChild var="removedChild" obj="parentElement" oldChild="element"/>
                r#attr = r#node_map
                    .get_named_item_ns(None, "street")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attr" obj="nodeMap" namespaceURI="nullNS" localName="&quot;street&quot;"/>
                r#owner_element = r#attr.owner_element().unwrap(); // <ownerElement var="ownerElement" obj="attr"/>
                r#owner_element_name = r#owner_element.node_name().to_string(); // <nodeName var="ownerElementName" obj="ownerElement"/>
                assert_eq!(r#owner_element_name, "address"); // <assertEquals actual="ownerElementName" expected="&quot;address&quot;" id="attrgetownerelement05" ignoreCase="false"/>
            }
            // setAttributeNS03.xml
            #[test]
            fn test_set_attribute_n_s03() {
                let mut r#namespace_uri = "www.xyz.com"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;www.xyz.com&quot;"/>
                let mut r#qualified_name = "emp:local1"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:local1&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                let mut r#gender; // type: Node // <var name="gender" type="Node"/>
                let mut r#gen_list; // type: NodeList // <var name="genList" type="NodeList"/>
                let mut r#gen; // type: Node // <var name="gen" type="Node"/>
                let mut r#g_list; // type: NodeList // <var name="gList" type="NodeList"/>
                let mut r#gen_element; // type: Element // <var name="genElement" type="Element"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#gender_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/>
                r#gender = r#gender_list.item(2).unwrap().clone(); // <item interface="NodeList" obj="genderList" var="gender" index="2"/>
                r#gen_list = r#gender.child_nodes(); // <childNodes obj="gender" var="genList"/>
                r#gen = r#gen_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="genList" var="gen" index="0"/>
                r#node_type = r#gen.node_type(); // <nodeType var="nodeType" obj="gen"/>

                // unimplemented: // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>	<createEntityReference var="gen" name="&quot;ent4&quot;" obj="doc"/>	<assertNotNull actual="gen" id="createdEntRefNotNull"/></if>
                r#g_list = r#gen.child_nodes(); // <childNodes obj="gen" var="gList"/>
                r#gen_element = r#g_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="gList" var="genElement" index="0"/>
                // unimplemented: // <assertNotNull actual="genElement" id="notnull"/>

                // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR"><NO_MODIFICATION_ALLOWED_ERR><setAttributeNS obj="genElement" namespaceURI="namespaceURI" qualifiedName="qualifiedName" value="&quot;newValue&quot;"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // nodesetprefix02.xml
            #[test]
            fn test_nodesetprefix02() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                // let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                // let mut r#set_node; // type: Node // <var name="setNode" type="Node"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                // let mut r#new_attr_name; // type: DOMString // <var name="newAttrName" type="DOMString"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName var="elementList" obj="doc" tagname="&quot;address&quot;" interface="Document"/>
                // r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                // r#new_attribute = r#doc
                //     .create_attribute_ns(
                //         Some("http://www.w3.org/DOM/Test"),
                //         "test:address".as_ref(),
                //     )
                //     .unwrap(); // <createAttributeNS var="newAttribute" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;test:address&quot;"/>
                // r#set_node = r#element
                //     .set_attribute_node_ns(r#new_attribute.into())
                //     .unwrap()
                //     .unwrap(); // <setAttributeNodeNS var="setNode" obj="element" newAttr="newAttribute"/>
                // r#new_attribute.set_prefix("dom").unwrap(); // <prefix obj="newAttribute" value="&quot;dom&quot;"/>
                // r#attribute = r#element
                //     .get_attribute_node_ns(Some("http://www.usa.com".into()), "domestic".into())
                //     .unwrap()
                //     .unwrap(); // <getAttributeNodeNS var="attribute" obj="element" namespaceURI="&quot;http://www.usa.com&quot;" localName="&quot;domestic&quot;"/>
                // r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                // r#new_attr_name = r#new_attribute.node_name().to_string(); // <nodeName var="newAttrName" obj="newAttribute"/>
                // assert_eq!(r#attr_name, "dmstc:domestic"); // <assertEquals actual="attrName" expected="&quot;dmstc:domestic&quot;" id="nodesetprefix02_attrName" ignoreCase="false"/>
                // assert_eq!(r#new_attr_name, "dom:address"); // <assertEquals actual="newAttrName" expected="&quot;dom:address&quot;" id="nodesetprefix02_newAttrName" ignoreCase="false"/>
            }
            // ownerDocument01.xml
            #[test]
            fn test_owner_document01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#owner_document; // type: DocumentType // <var name="ownerDocument" type="DocumentType"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#owner_document = r#doc.owner_document(); // <ownerDocument obj="doc" var="ownerDocument"/>
                assert!(owner_document.is_none()); // <assertNull actual="ownerDocument" id="throw_Null"/>
            }
            // removeNamedItemNS02.xml
            #[test]
            fn test_remove_named_item_n_s02() {
                // let mut r#namespace_uri = "http://www.usa.com"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.usa.com&quot;"/>
                // let mut r#local_name = "domest"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;domest&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                // r#test_address = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="1"/>
                // r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR"><NOT_FOUND_ERR><removeNamedItemNS var="removedNode" interface="NamedNodeMap" obj="attributes" namespaceURI="namespaceURI" localName="localName"/></NOT_FOUND_ERR></assertDOMException>
            }
            // setAttributeNS01.xml
            #[test]
            fn test_set_attribute_n_s01() {
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#qualified_name = "emp:qual?name"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:qual?name&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;employee&quot;"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>

                // unimplemented: // <assertDOMException id="throw_INVALID_CHARACTER_ERR"><INVALID_CHARACTER_ERR><setAttributeNS obj="testAddr" namespaceURI="namespaceURI" qualifiedName="qualifiedName" value="&quot;newValue&quot;"/></INVALID_CHARACTER_ERR></assertDOMException>
            }
            // namednodemapremovenameditemns06.xml
            #[test]
            fn test_namednodemapremovenameditemns06() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#element; // type: Node // <var name="element" type="Node"/>
                // let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element_list = r#doc
                //     .get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "employee"); // <getElementsByTagNameNS var="elementList" obj="doc" localName="&quot;employee&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" interface="Document"/>
                // r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                // r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR"><NOT_FOUND_ERR><removeNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.Nist.gov&quot;" localName="&quot;domestic&quot;"/></NOT_FOUND_ERR></assertDOMException>
            }
            // importNode03.xml
            #[test]
            fn test_import_node03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                r#comment = r#a_new_doc.create_comment("this is a comment"); // <createComment obj="aNewDoc" var="comment" data="&quot;this is a comment&quot;"/>
                r#a_node = r#doc.import_node(r#comment.into(), false).unwrap(); // <importNode obj="doc" var="aNode" importedNode="comment" deep="false"/>
                r#owner_document = r#a_node.owner_document().unwrap(); // <ownerDocument obj="aNode" var="ownerDocument"/>
                // unimplemented: // <assertNotNull actual="ownerDocument" id="ownerDocumentNotNull"/>
                r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>
                assert_eq!(system, "staffNS.dtd"); // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="systemId"/>
                r#value = r#a_node.node_value().unwrap().to_string(); // <nodeValue obj="aNode" var="value"/>
                assert_eq!(r#value, "this is a comment"); // <assertEquals actual="value" expected="&quot;this is a comment&quot;" id="nodeValue" ignoreCase="false"/>
            }
            // createDocumentType01.xml
            #[test]
            fn test_create_document_type01() {
                // let mut r#public_id; // type: DOMString // <var name="publicId" type="DOMString" value="&quot;STAFF&quot;"/>
                // let mut r#system_id; // type: DOMString // <var name="systemId" type="DOMString" value="&quot;staff.xml&quot;"/>
                // let mut r#malformed_name; // type: DOMString // <var name="malformedName" type="DOMString" value="&quot;prefix::local&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_type; // type: DocumentType // <var name="newType" type="DocumentType"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><createDocumentType obj="domImpl" var="newType" publicId="publicId" qualifiedName="malformedName" systemId="systemId"/></NAMESPACE_ERR></assertDOMException>
            }
            // elementsetattributenodens02.xml
            #[test]
            fn test_elementsetattributenodens02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#element2; // type: Element // <var name="element2" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#attribute_cloned; // type: Attr // <var name="attributeCloned" type="Attr"/>
                let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attribute = r#element
                    .get_attribute_node_ns(None, "street")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attribute" obj="element" namespaceURI="nullNS" localName="&quot;street&quot;"/>
                r#attribute_cloned = r#attribute.clone_node(true); // <cloneNode var="attributeCloned" obj="attribute" deep="true"/>
                r#element2 = r#element_list.item(2).unwrap(); // <item var="element2" obj="elementList" index="2" interface="NodeList"/>
                r#new_attr = r#element2
                    .set_attribute_node_ns(r#attribute_cloned.as_attribute().unwrap())
                    .unwrap()
                    .unwrap(); // <setAttributeNodeNS var="newAttr" obj="element2" newAttr="attributeCloned"/>
                r#attr_name = r#new_attr.node_name().to_string(); // <nodeName var="attrName" obj="newAttr"/>
                r#attr_value = r#new_attr.node_value().unwrap().to_string(); // <nodeValue var="attrValue" obj="newAttr"/>
                assert_eq!(r#attr_name, "street"); // <assertEquals actual="attrName" expected="&quot;street&quot;" id="elementsetattributenodens02_attrName" ignoreCase="false"/>
                assert_eq!(r#attr_value, "Yes"); // <assertEquals actual="attrValue" expected="&quot;Yes&quot;" id="elementsetattributenodens02_attrValue" ignoreCase="false"/>
            }
            // documentimportnode11.xml
            #[test]
            fn test_documentimportnode11() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_element; // type: Element // <var name="docElement" type="Element"/>
                let mut r#imported; // type: Node // <var name="imported" type="Node"/>
                let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                let mut r#node_name_orig; // type: DOMString // <var name="nodeNameOrig" type="DOMString"/>
                let mut r#node_name_imported; // type: DOMString // <var name="nodeNameImported" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_element = r#doc.document_element().unwrap(); // <documentElement var="docElement" obj="doc"/>
                r#imported = r#doc
                    .import_node(r#doc_element.clone().into(), false)
                    .unwrap(); // <importNode var="imported" obj="doc" importedNode="docElement" deep="false"/>
                r#success = r#imported.has_child_nodes(); // <hasChildNodes var="success" obj="imported"/>
                assert!(!r#success); // <assertFalse actual="success" id="documentimportnode11"/>
                r#node_name_imported = r#imported.node_name().to_string(); // <nodeName var="nodeNameImported" obj="imported"/>
                r#node_name_orig = r#doc_element.node_name().to_string(); // <nodeName var="nodeNameOrig" obj="docElement"/>
                assert_eq!(r#node_name_orig, node_name_imported); // <assertEquals actual="nodeNameOrig" expected="nodeNameImported" id="documentimportnode11_NodeName" ignoreCase="false"/>
            }
            // nodesetprefix01.xml
            #[test]
            fn test_nodesetprefix01() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_fragment; // type: DocumentFragment // <var name="docFragment" type="DocumentFragment"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#element_tag_name; // type: DOMString // <var name="elementTagName" type="DOMString"/>
                // let mut r#element_node_name; // type: DOMString // <var name="elementNodeName" type="DOMString"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                // r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment var="docFragment" obj="doc"/>
                // r#element = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/DOM/Test"),
                //         "emp:address".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;emp:address&quot;"/>
                // r#appended_child = r#doc_fragment.append_child(element.into()).unwrap(); // <appendChild var="appendedChild" obj="docFragment" newChild="element"/>
                // r#element.set_prefix("dmstc").unwrap(); // <prefix obj="element" value="&quot;dmstc&quot;"/>
                // r#element_tag_name = r#element.tag_name().to_string(); // <tagName var="elementTagName" obj="element"/>
                // r#element_node_name = r#element.node_name().to_string(); // <nodeName var="elementNodeName" obj="element"/>
                // assert_eq!(r#element_tag_name, "dmstc:address"); // <assertEquals actual="elementTagName" expected="&quot;dmstc:address&quot;" id="nodesetprefix01_tagname" ignoreCase="false"/>
                // assert_eq!(r#element_node_name, "dmstc:address"); // <assertEquals actual="elementNodeName" expected="&quot;dmstc:address&quot;" id="nodesetprefix01_nodeName" ignoreCase="false"/>
            }
            // getElementsByTagNameNS12.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s12() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#element_list =
                    r#doc_elem.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "nomatch"); // <getElementsByTagNameNS interface="Element" obj="docElem" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;nomatch&quot;" var="elementList"/>

                // unimplemented: // <assertSize collection="elementList" size="0" id="size"/>
            }
            // hc_entitiessetnameditemns1.xml
            #[test]
            fn test_hc_entitiessetnameditemns1() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <if><not><contentType type="text/html"/></not><assertNotNull actual="docType" id="docTypeNotNull"/><entities var="entities" obj="docType"/><assertNotNull actual="entities" id="entitiesNotNull"/><createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;br&quot;"/><try>	<setNamedItemNS var="retval" obj="entities" arg="elem"/>	<fail id="throw_HIER_OR_NO_MOD_ERR"/>	<catch>		<DOMException code="HIERARCHY_REQUEST_ERR"/>		<DOMException code="NO_MODIFICATION_ALLOWED_ERR"/>	</catch></try> </if>
            }
            // getElementsByTagNameNS02.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_list; // type: NodeList // <var name="newList" type="NodeList"/>
                let mut r#new_element; // type: Element // <var name="newElement" type="Element"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                let mut r#lname; // type: DOMString // <var name="lname" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#new_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "employee"); // <getElementsByTagNameNS interface="Document" obj="doc" var="newList" namespaceURI="&quot;*&quot;" localName="&quot;employee&quot;"/>

                // unimplemented: // <assertSize collection="newList" size="5" id="employeeCount"/>
                r#new_element = r#new_list.item(3).unwrap(); // <item interface="NodeList" obj="newList" var="newElement" index="3"/>
                r#prefix = r#new_element.prefix().unwrap().to_string(); // <prefix obj="newElement" var="prefix"/>
                assert_eq!(r#prefix, "emp"); // <assertEquals actual="prefix" expected="&quot;emp&quot;" id="prefix" ignoreCase="false"/>
                r#lname = r#new_element.local_name().unwrap().to_string(); // <localName obj="newElement" var="lname"/>
                assert_eq!(r#lname, "employee"); // <assertEquals actual="lname" expected="&quot;employee&quot;" id="lname" ignoreCase="false"/>
            }
            // createDocument03.xml
            #[test]
            fn test_create_document03() {
                // let mut r#namespace_uri = "http://www.ecommerce.org/schema"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.ecommerce.org/schema&quot;"/>
                // let mut r#qualified_name = "namespaceURI:x"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;namespaceURI:x&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <assertDOMException id="throw_WRONG_DOCUMENT_ERR"><WRONG_DOCUMENT_ERR><createDocument obj="domImpl" var="aNewDoc" namespaceURI="namespaceURI" qualifiedName="qualifiedName" doctype="docType"/></WRONG_DOCUMENT_ERR></assertDOMException>
            }
            // setNamedItemNS03.xml
            #[test]
            fn test_set_named_item_n_s03() {
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#qualified_name = "prefix:newAttr"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;prefix:newAttr&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#arg; // type: Node // <var name="arg" type="Node"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#retnode; // type: Node // <var name="retnode" type="Node"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let mut r#set_node; // type: Node // <var name="setNode" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#arg = r#doc
                    .create_attribute_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                    .unwrap(); // <createAttributeNS obj="doc" var="arg" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                r#arg.set_node_value("newValue").unwrap(); // <nodeValue obj="arg" value="&quot;newValue&quot;"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="0"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                r#set_node = r#attributes.set_named_item_ns(r#arg).unwrap(); // <setNamedItemNS var="setNode" interface="NamedNodeMap" obj="attributes" arg="arg"/>
                r#retnode = r#attributes
                    .get_named_item_ns(Some(r#namespace_uri), "newAttr")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS obj="attributes" var="retnode" namespaceURI="namespaceURI" localName="&quot;newAttr&quot;"/>
                r#value = r#retnode.node_value().unwrap().to_string(); // <nodeValue obj="retnode" var="value"/>
                assert_eq!(r#value, "newValue"); // <assertEquals actual="value" expected="&quot;newValue&quot;" id="throw_Equals" ignoreCase="false"/>
            }
            // prefix11.xml
            #[test]
            fn test_prefix11() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                // r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>

                // // unimplemented: // <if><contentType type="image/svg+xml"/><createElementNS var="employeeNode" obj="doc" namespaceURI="nullNS" qualifiedName="&quot;employee&quot;"/></if>
                // r#namespace_uri = r#employee_node.namespace_uri().unwrap().to_string();
                // // <namespaceURI obj="employeeNode" var="namespaceURI"/>

                // // unimplemented: // <assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><prefix obj="employeeNode" value="&quot;employee1&quot;"/></NAMESPACE_ERR></assertDOMException>

                // // unimplemented: // <assertNull actual="namespaceURI" id="employeeNS"/>
            }
            // isSupported13.xml
            #[test]
            fn test_is_supported13() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                // r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>

                // // unimplemented: // <isSupported obj="rootNode" feature="&quot;Core&quot;" version="&quot;&quot;" var="state"/>
                // assert!(r#state); // <assertTrue actual="state" id="Core"/>
            }
            // getAttributeNodeNS01.xml
            #[test]
            fn test_get_attribute_node_n_s01() {
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#local_name = "invalidlocalname"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;invalidlocalname&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                r#attribute = r#test_addr
                    .get_attribute_node_ns(Some(r#namespace_uri), r#local_name)
                    .unwrap(); // <getAttributeNodeNS obj="testAddr" var="attribute" namespaceURI="namespaceURI" localName="localName"/>
                assert!(attribute.is_none()); // <assertNull actual="attribute" id="throw_Null"/>
            }
            // nodehasattributes03.xml
            #[test]
            fn test_nodehasattributes03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#has_attributes; // type: boolean // <var name="hasAttributes" type="boolean"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:employee"); // <getElementsByTagName var="elementList" obj="doc" tagname="&quot;emp:employee&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                // unimplemented: // <assertNotNull actual="element" id="empEmployeeNotNull"/>
                r#has_attributes = r#element.has_attributes(); // <hasAttributes var="hasAttributes" obj="element"/>
                assert!(r#has_attributes); // <assertTrue actual="hasAttributes" id="hasAttributes"/>
            }
            // setNamedItemNS04.xml
            #[test]
            fn test_set_named_item_n_s04() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/2000/xmlns/&quot;"/>
                // let mut r#local_name; // type: DOMString // <var name="localName" type="DOMString" value="&quot;local1&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                // let mut r#n_list; // type: NodeList // <var name="nList" type="NodeList"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#n2_list; // type: NodeList // <var name="n2List" type="NodeList"/>
                // let mut r#child2; // type: Node // <var name="child2" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#arg; // type: Node // <var name="arg" type="Node"/>
                // let mut r#set_node; // type: Node // <var name="setNode" type="Node"/>
                // let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;gender&quot;"/>
                // r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                // r#n_list = r#test_address.child_nodes(); // <childNodes obj="testAddress" var="nList"/>
                // r#child = r#n_list[0].clone(); // <item interface="NodeList" obj="nList" var="child" index="0"/>
                // r#node_type = r#child.node_type(); // <nodeType var="nodeType" obj="child"/>

                // // unimplemented: // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>	<createEntityReference var="child" name="&quot;ent4&quot;" obj="doc"/>	<assertNotNull actual="child" id="createdEntRefNotNull"/></if>
                // r#n2_list = r#child.child_nodes(); // <childNodes obj="child" var="n2List"/>
                // r#child2 = r#n2_list[0].clone(); // <item interface="NodeList" obj="n2List" var="child2" index="0"/>

                // // unimplemented: // <assertNotNull actual="child2" id="notnull"/>
                // r#attributes = r#child2.attributes().unwrap(); // <attributes obj="child2" var="attributes"/>
                // r#arg = r#attributes
                //     .get_named_item_ns(Some(r#namespace_uri), r#local_name)
                //     .unwrap()
                //     .unwrap(); // <getNamedItemNS obj="attributes" var="arg" namespaceURI="namespaceURI" localName="localName"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR"><NO_MODIFICATION_ALLOWED_ERR><setNamedItemNS var="setNode" interface="NamedNodeMap" obj="attributes" arg="arg"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // attrgetownerelement02.xml
            #[test]
            fn test_attrgetownerelement02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#owner_element; // type: Element // <var name="ownerElement" type="Element"/>
                let mut r#owner_element_name; // type: DOMString // <var name="ownerElementName" type="DOMString"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element = r#doc.create_element("root".to_string()).unwrap(); // <createElement var="element" obj="doc" tagName="&quot;root&quot;"/>
                r#attr = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/L1"), "L1:att".as_ref())
                    .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" qualifiedName="&quot;L1:att&quot;"/>
                r#new_attr = r#element.set_attribute_node_ns(r#attr.clone()).unwrap(); // <setAttributeNodeNS var="newAttr" obj="element" newAttr="attr"/>
                r#owner_element = r#attr.owner_element().unwrap(); // <ownerElement var="ownerElement" obj="attr"/>
                r#owner_element_name = r#owner_element.node_name().to_string(); // <nodeName var="ownerElementName" obj="ownerElement"/>
                assert_eq!(r#owner_element_name, "root"); // <assertEquals actual="ownerElementName" expected="&quot;root&quot;" id="attrgetownerelement02" ignoreCase="true"/>
            }
            // domimplementationcreatedocumenttype01.xml
            #[test]
            fn test_domimplementationcreatedocumenttype01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc_type; // type: DocumentType // <var name="newDocType" type="DocumentType"/>
                // let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;test:root&quot;"/>
                // let mut r#public_id; // type: DOMString // <var name="publicId" type="DOMString"/>
                // let mut r#system_id; // type: DOMString // <var name="systemId" type="DOMString"/>
                // let mut r#public_ids; // type: List // <var name="publicIds" type="List"><member>"1234"</member><member>"test"</member></var>
                // let mut r#system_ids; // type: List // <var name="systemIds" type="List"><member>""</member><member>"test"</member></var>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <for-each collection="publicIds" member="publicId"><for-each collection="systemIds" member="systemId"><createDocumentType obj="domImpl" var="newDocType" qualifiedName="qualifiedName" publicId="publicId" systemId="systemId"/><assertNotNull actual="newDocType" id="domimplementationcreatedocumenttype01_newDocType"/><ownerDocument obj="newDocType" var="ownerDocument"/><assertNull actual="ownerDocument" id="domimplementationcreatedocumenttype01_ownerDocument"/></for-each></for-each>
            }
            // setNamedItemNS01.xml
            #[test]
            fn test_set_named_item_n_s01() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#another_element; // type: Node // <var name="anotherElement" type="Node"/>
                // let mut r#another_map; // type: NamedNodeMap // <var name="anotherMap" type="NamedNodeMap"/>
                // let mut r#arg; // type: Node // <var name="arg" type="Node"/>
                // let mut r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                // let mut r#map; // type: NamedNodeMap // <var name="map" type="NamedNodeMap"/>
                // let mut r#set_node; // type: Node // <var name="setNode" type="Node"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                // r#another_element = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="anotherElement" index="2"/>
                // r#another_map = r#another_element.attributes(); // <attributes obj="anotherElement" var="anotherMap"/>
                // r#arg = r#another_map
                //     .get_named_item_ns(Some("http://www.netzero.com".into()), "domestic".into())
                //     .unwrap()
                //     .unwrap(); // <getNamedItemNS obj="anotherMap" var="arg" namespaceURI="&quot;http://www.netzero.com&quot;" localName="&quot;domestic&quot;"/>
                // r#test_address = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="0"/>
                // r#map = r#test_address.attributes(); // <attributes obj="testAddress" var="map"/>

                // // unimplemented: // <assertDOMException id="throw_INUSE_ATTRIBUTE_ERR"><INUSE_ATTRIBUTE_ERR><setNamedItemNS var="setNode" interface="NamedNodeMap" obj="map" arg="arg"/></INUSE_ATTRIBUTE_ERR></assertDOMException>
            }
            // importNode11.xml
            #[test]
            fn test_import_node11() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_value; // type: DOMString // <var name="childValue" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#a_new_doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="aNewDoc" href="staff" willBeModified="true"/>
                r#ent_ref = r#a_new_doc
                    .create_entity_reference("ent3".to_string())
                    .unwrap(); // <createEntityReference obj="aNewDoc" var="entRef" name="&quot;ent3&quot;"/>
                // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                r#a_node = r#doc.import_node(r#ent_ref.into(), true).unwrap(); // <importNode obj="doc" var="aNode" importedNode="entRef" deep="true"/>
                r#name = r#a_node.node_name().to_string(); // <nodeName obj="aNode" var="name"/>
                assert_eq!(r#name, "ent3"); // <assertEquals actual="name" id="entityName" expected="&quot;ent3&quot;" ignoreCase="false"/>
                r#child = r#a_node.first_child().unwrap(); // <firstChild interface="Node" obj="aNode" var="child"/>
                // unimplemented: // <assertNotNull id="child" actual="child"/>
                r#child_value = r#child.node_value().unwrap().to_string(); // <nodeValue obj="child" var="childValue"/>
                assert_eq!(r#child_value, "Texas"); // <assertEquals actual="childValue" id="childValue" expected="&quot;Texas&quot;" ignoreCase="false"/>
            }
            // documentimportnode02.xml
            #[test]
            fn test_documentimportnode02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_imported: DocumentRef; // <var name="docImported" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#imported_attr; // type: Node // <var name="importedAttr" type="Node"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                let mut r#addresses; // type: NodeList // <var name="addresses" type="NodeList"/>
                let mut r#attrs_parent; // type: Node // <var name="attrsParent" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_imported = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="docImported" href="staff" willBeModified="true"/>
                r#addresses =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="addresses" obj="doc" interface="Document" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;"/>
                r#element = r#addresses.item(1).unwrap(); // <item var="element" obj="addresses" interface="NodeList" index="1"/>
                r#attr = r#element
                    .get_attribute_node_ns(Some("http://www.nist.gov"), "zone")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attr" obj="element" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;zone&quot;"/>
                r#imported_attr = r#doc_imported.import_node(r#attr.into(), false).unwrap(); // <importNode var="importedAttr" obj="docImported" importedNode="attr" deep="false"/>
                r#node_name = r#imported_attr.node_name().to_string(); // <nodeName var="nodeName" obj="importedAttr"/>
                r#node_type = r#imported_attr.node_type(); // <nodeType var="nodeType" obj="importedAttr"/>
                r#node_value = r#imported_attr.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="importedAttr"/>
                r#attrs_parent = r#imported_attr.parent_node(); // <parentNode var="attrsParent" obj="importedAttr" interface="Node"/>
                assert!(attrs_parent.is_none()); // <assertNull actual="attrsParent" id="documentimportnode02_parentNull"/>
                assert_eq!(r#node_name, "emp:zone"); // <assertEquals expected="&quot;emp:zone&quot;" actual="nodeName" id="documentimportnode02_nodeName" ignoreCase="false"/>
                assert_eq!(r#node_type as i32, 2); // <assertEquals expected="2" actual="nodeType" id="documentimportnode02_nodeType" ignoreCase="false"/>
                assert_eq!(r#node_value, "CANADA"); // <assertEquals expected="&quot;CANADA&quot;" actual="nodeValue" id="documentimportnode02_nodeValue" ignoreCase="false"/>
            }
            // hc_namednodemapinvalidtype1.xml
            #[test]
            fn test_hc_namednodemapinvalidtype1() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#new_elem; // type: Element // <var name="newElem" type="Element"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#attributes = r#doc_elem.attributes(); // <attributes var="attributes" obj="docElem"/>
                // r#new_elem = r#doc.create_element("html".to_string()).unwrap(); // <createElement var="newElem" obj="doc" tagName="&quot;html&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR">	<HIERARCHY_REQUEST_ERR>		<setNamedItem var="retval" obj="attributes" arg="newElem"/>	</HIERARCHY_REQUEST_ERR></assertDOMException>
            }
            // importNode15.xml
            #[test]
            fn test_import_node15() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#text; // type: Text // <var name="text" type="Text"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                r#text = r#a_new_doc.create_text_node("this is text data"); // <createTextNode obj="aNewDoc" var="text" data="&quot;this is text data&quot;"/>
                r#a_node = r#doc.import_node(r#text.into(), false).unwrap(); // <importNode obj="doc" var="aNode" importedNode="text" deep="false"/>
                r#owner_document = r#a_node.owner_document().unwrap(); // <ownerDocument obj="aNode" var="ownerDocument"/>
                // unimplemented: // <assertNotNull actual="ownerDocument" id="ownerDocumentNotNull"/>
                r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>
                assert_eq!(system, "staffNS.dtd"); // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="systemId"/>
                r#value = r#a_node.node_value().unwrap().to_string(); // <nodeValue obj="aNode" var="value"/>
                assert_eq!(r#value, "this is text data"); // <assertEquals actual="value" expected="&quot;this is text data&quot;" id="nodeValue" ignoreCase="false"/>
            }
            // prefix06.xml
            #[test]
            fn test_prefix06() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="employeeNode"/>

                // unimplemented: // <assertDOMException id="throw_INVALID_CHARACTER_ERR"><INVALID_CHARACTER_ERR><prefix obj="employeeNode" value="&quot;pre^fix xmlns='http//www.nist.gov'&quot;"/></INVALID_CHARACTER_ERR></assertDOMException>
            }
            // elementsetattributens05.xml
            #[test]
            fn test_elementsetattributens05() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/DOM/Test/L2"),
                //         "dom:elem".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/L2&quot;" qualifiedName="&quot;dom:elem&quot;"/>

                // // unimplemented: // <assertDOMException id="elementsetattributens05">    <NAMESPACE_ERR>      <setAttributeNS obj="element" namespaceURI="nullNS" qualifiedName="&quot;dom:root&quot;" value="&quot;test&quot;"/>    </NAMESPACE_ERR>  </assertDOMException>
            }
            // createAttributeNS04.xml
            #[test]
            fn test_create_attribute_n_s04() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/XML/1998/namespaces&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;xml:attr1&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><createAttributeNS obj="doc" var="newAttr" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/></NAMESPACE_ERR></assertDOMException>
            }
            // createAttributeNS02.xml
            #[test]
            fn test_create_attribute_n_s02() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" isNull="true"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;prefix:local&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><createAttributeNS obj="doc" var="newAttr" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/></NAMESPACE_ERR></assertDOMException>
            }
            // getNamedItemNS04.xml
            #[test]
            fn test_get_named_item_n_s04() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                // let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <notations var="notations" obj="docType"/>

                // // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                // r#notation = r#notations
                //     .get_named_item_ns(Some(r#null_ns), "notation1")
                //     .unwrap()
                //     .unwrap(); // <getNamedItemNS var="notation" obj="notations" namespaceURI="nullNS" localName="&quot;notation1&quot;"/>

                // // unimplemented: // <assertNull actual="notation" id="notationNull"/>
            }
            // nodeissupported04.xml
            #[test]
            fn test_nodeissupported04() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#ent_ref = r#doc.create_entity_reference("ent1".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent1&quot;"/>

                // // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>

                // // unimplemented: // <isSupported obj="entRef" var="success" feature="&quot;XML CORE&quot;" version="&quot;&quot;"/>
                // assert!(!r#success); // <assertFalse actual="success" id="nodeissupported04"/>
            }
            // documentcreateelementNS02.xml
            #[test]
            fn test_documentcreateelement_n_s02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" isNull="true"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;^^&quot;"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <assertDOMException id="documentcreateelementNS02"><INVALID_CHARACTER_ERR><createElementNS obj="doc" var="element" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/></INVALID_CHARACTER_ERR></assertDOMException>
            }
            // domimplementationcreatedocumenttype04.xml
            #[test]
            fn test_domimplementationcreatedocumenttype04() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc_type; // type: DocumentType // <var name="newDocType" type="DocumentType"/>
                // let mut r#public_id; // type: DOMString // <var name="publicId" type="DOMString" value="&quot;http://www.w3.org/DOM/Test/dom2.dtd&quot;"/>
                // let mut r#system_id; // type: DOMString // <var name="systemId" type="DOMString" value="&quot;dom2.dtd&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString"/>
                // let mut r#qualified_names; // type: List // <var name="qualifiedNames" type="List"><member>"{"</member><member>"}"</member><member>"'"</member><member>"~"</member><member>"`"</member><member>"@"</member><member>"#"</member><member>"$"</member><member>"%"</member><member>"^"</member><member>"&amp;"</member><member>"*"</member><member>"("</member><member>")"</member>	</var>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <for-each collection="qualifiedNames" member="qualifiedName"><assertDOMException id="domimplementationcreatedocumenttype04"><INVALID_CHARACTER_ERR><createDocumentType obj="domImpl" var="newDocType" qualifiedName="qualifiedName" publicId="publicId" systemId="systemId"/></INVALID_CHARACTER_ERR></assertDOMException></for-each>
            }
            // namespaceURI04.xml
            #[test]
            fn test_namespace_ur_i04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let mut r#employee_namespace; // type: DOMString // <var name="employeeNamespace" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="testEmployee"/>
                r#employee_namespace = r#test_employee.namespace_uri(); // <namespaceURI obj="testEmployee" var="employeeNamespace"/>

                // unimplemented:
                // <if><contentType type="image/svg+xml"/>
                //  <!--  the element is staffNS.svg has a non-null namespace but since namespace awareness is not asserted, the namespaceURI may be null -->
                //  <assertTrue id="employeeNS_svg">
                //      <or>
                //          <isNull obj="employeeNamespace"/>
                //          <equals actual="employeeNamespace" expected="&quot;http://www.w3.org/2001/DOM-Test-Suite/Level-2/Files&quot;" ignoreCase="false"/>
                //      </or>
                //  </assertTrue>
                // <else>
                //  <assertNull actual="employeeNamespace" id="employeeNS_null"/>
                assert!(employee_namespace.is_none());
                // </else>
                // </if>
            }
            // ownerElement01.xml
            #[test]
            fn test_owner_element01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#address_list; // type: NodeList // <var name="addressList" type="NodeList"/>
                let mut r#test_node; // type: Node // <var name="testNode" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#domestic_attr; // type: Attr // <var name="domesticAttr" type="Attr"/>
                let mut r#element_node; // type: Element // <var name="elementNode" type="Element"/>
                let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="addressList" tagname="&quot;address&quot;"/>
                r#test_node = r#address_list.item(0).unwrap(); // <item interface="NodeList" obj="addressList" var="testNode" index="0"/>
                r#attributes = r#test_node.attributes(); // <attributes obj="testNode" var="attributes"/>
                r#domestic_attr = r#attributes.get_named_item("domestic").unwrap(); // <getNamedItem obj="attributes" var="domesticAttr" name="&quot;domestic&quot;"/>
                r#element_node = r#domestic_attr.owner_element().unwrap(); // <ownerElement obj="domesticAttr" var="elementNode"/>
                r#name = r#element_node.node_name().to_string(); // <nodeName obj="elementNode" var="name"/>
                assert_eq!(r#name, "address"); // <assertEquals actual="name" expected="&quot;address&quot;" id="throw_Equals" ignoreCase="false"/>
            }
            // nodesetprefix06.xml
            #[test]
            fn test_nodesetprefix06() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test/L2"), "dom:elem".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/L2&quot;" qualifiedName="&quot;dom:elem&quot;"/>

                // unimplemented:
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <prefix obj="element" value="&quot;xml&quot;"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
            }
            // importNode07.xml
            #[test]
            fn test_import_node07() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                let mut r#attr; // type: Node // <var name="attr" type="Node"/>
                let mut r#lname; // type: DOMString // <var name="lname" type="DOMString"/>
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#qualified_name = "emp:employee"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:employee&quot;"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#a_new_doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="aNewDoc" href="staff" willBeModified="true"/>
                r#element = r#a_new_doc
                    .create_element_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                    .unwrap(); // <createElementNS obj="aNewDoc" var="element" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                r#a_node = r#doc.import_node(r#element.into(), false).unwrap(); // <importNode obj="doc" var="aNode" importedNode="element" deep="false"/>
                r#attributes = r#a_node.attributes().unwrap(); // <attributes obj="aNode" var="attributes"/>
                assert_eq!(attributes.length(), 1); // <assertSize collection="attributes" size="1" id="throw_Size"/>
                r#name = r#a_node.node_name().to_string(); // <nodeName obj="aNode" var="name"/>
                assert_eq!(r#name, "emp:employee"); // <assertEquals actual="name" expected="&quot;emp:employee&quot;" ignoreCase="false" id="nodeName"/>
                r#attr = r#attributes.item(0).unwrap(); // <item interface="NamedNodeMap" obj="attributes" var="attr" index="0"/>
                r#lname = r#attr.local_name().unwrap().to_string(); // <localName obj="attr" var="lname"/>
                assert_eq!(r#lname, "defaultAttr"); // <assertEquals actual="lname" expected="&quot;defaultAttr&quot;" ignoreCase="false" id="lname"/>
            }
            // domimplementationcreatedocument05.xml
            #[test]
            fn test_domimplementationcreatedocument05() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/xml/1998/namespace&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;xml:root&quot;"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <assertDOMException id="domimplementationcreatedocument05"><NAMESPACE_ERR><createDocument obj="domImpl" var="newDoc" namespaceURI="namespaceURI" qualifiedName="qualifiedName" doctype="docType"/></NAMESPACE_ERR></assertDOMException>
            }
            // getAttributeNodeNS02.xml
            #[test]
            fn test_get_attribute_node_n_s02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                r#attribute = r#test_addr
                    .get_attribute_node_ns(Some("http://www.nist.gov"), "domestic")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS obj="testAddr" var="attribute" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;domestic&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName obj="attribute" var="attrName"/>
                assert_eq!(r#attr_name, "emp:domestic"); // <assertEquals actual="attrName" expected="&quot;emp:domestic&quot;" id="attrName" ignoreCase="false"/>
            }
            // domimplementationcreatedocument03.xml
            #[test]
            fn test_domimplementationcreatedocument03() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType" isNull="true"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/DOMTest/L2&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString"/>
                // let mut r#qualified_names; // type: List // <var name="qualifiedNames" type="List"><member>"_:_"</member><member>"_:h0"</member><member>"_:test"</member><member>"l_:_"</member><member>"ns:_0"</member><member>"ns:a0"</member><member>"ns0:test"</member><member>"a.b:c"</member><member>"a-b:c"</member><member>"a-b:c"</member></var>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <for-each collection="qualifiedNames" member="qualifiedName"><createDocument obj="domImpl" var="newDoc" namespaceURI="namespaceURI" qualifiedName="qualifiedName" doctype="docType"/><assertNotNull actual="newDoc" id="domimplementationcreatedocument03"/></for-each>
            }
            // documenttypepublicid01.xml
            #[test]
            fn test_documenttypepublicid01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#public_id; // type: DOMString // <var name="publicId" type="DOMString"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocumentType var="docType" obj="domImpl" qualifiedName="&quot;l2:root&quot;" publicId="&quot;PUB&quot;" systemId="nullNS"/>
                // r#public_id = r#doc_type.public_id().unwrap().to_string(); // <publicId var="publicId" obj="docType" interface="DocumentType"/>
                // assert_eq!(r#public_id, "PUB"); // <assertEquals actual="publicId" expected="&quot;PUB&quot;" id="documenttypepublicid01" ignoreCase="false"/>
            }
            // createElementNS01.xml
            #[test]
            fn test_create_element_n_s01() {
                // let mut r#namespace_uri = "http://www.ecommerce.org/"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.ecommerce.org/&quot;"/>
                // let mut r#malformed_name = "prefix::local"; // type: DOMString // <var name="malformedName" type="DOMString" value="&quot;prefix::local&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_element; // type: Element // <var name="newElement" type="Element"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><createElementNS obj="doc" var="newElement" namespaceURI="namespaceURI" qualifiedName="malformedName"/></NAMESPACE_ERR></assertDOMException>
            }
            // nodesetprefix05.xml
            #[test]
            fn test_nodesetprefix05() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#prefix_value; // type: DOMString // <var name="prefixValue" type="DOMString"/>
                // let mut r#prefix_values; // type: List // <var name="prefixValues" type="List"><member>"_:"</member><member>":0"</member><member>":"</member><member>"_::"</member><member>"a:0:c"</member></var>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/DOM/Test/L2"),
                //         "dom:elem".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/L2&quot;" qualifiedName="&quot;dom:elem&quot;"/>

                // // unimplemented: // <for-each collection="prefixValues" member="prefixValue"><assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><prefix obj="element" value="prefixValue"/></NAMESPACE_ERR></assertDOMException></for-each>
            }
            // documentimportnode20.xml
            #[test]
            fn test_documentimportnode20() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_imp: DocumentRef; // <var name="docImp" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#doc_type_null; // type: DocumentType // <var name="docTypeNull" type="DocumentType" isNull="true"/>
                // let mut r#node_map; // type: NamedNodeMap // <var name="nodeMap" type="NamedNodeMap"/>
                // let mut r#entity4; // type: Entity // <var name="entity4" type="Entity"/>
                // let mut r#entity_imp4; // type: Entity // <var name="entityImp4" type="Entity"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#cdata; // type: CharacterData // <var name="cdata" type="CharacterData"/>
                // let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#elemchild_list; // type: NodeList // <var name="elemchildList" type="NodeList"/>
                // let mut r#ent4_name; // type: DOMString // <var name="ent4Name" type="DOMString"/>
                // let mut r#ent4_imp_name; // type: DOMString // <var name="ent4ImpName" type="DOMString"/>
                // let mut r#cdata_val; // type: DOMString // <var name="cdataVal" type="DOMString"/>
                // let mut r#pi_target_val; // type: DOMString // <var name="piTargetVal" type="DOMString"/>
                // let mut r#pi_data_val; // type: DOMString // <var name="piDataVal" type="DOMString"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <createDocument var="docImp" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;a:b&quot;" doctype="docTypeNull"/>

                // // unimplemented: // <entities var="nodeMap" obj="docType"/>
                // r#entity4 = r#node_map.get_named_item("ent4".into()).unwrap(); // <getNamedItem var="entity4" obj="nodeMap" name="&quot;ent4&quot;"/>
                // r#entity_imp4 = r#doc_imp.import_node(r#entity4.into(), true).unwrap(); // <importNode var="entityImp4" obj="docImp" importedNode="entity4" deep="true"/>
                // r#child_list = r#entity_imp4.child_nodes(); // <childNodes var="childList" obj="entityImp4"/>
                // r#element = r#child_list.item(0).unwrap().clone(); // <item var="element" obj="childList" index="0" interface="NodeList"/>
                // r#elemchild_list = r#element.child_nodes(); // <childNodes var="elemchildList" obj="element"/>
                // r#cdata = r#elemchild_list[0].clone().as_cdata_section().unwrap(); // <item var="cdata" obj="elemchildList" index="0" interface="NodeList"/>
                // r#pi = r#child_list.item(1).unwrap().clone().as_processing_instruction().unwrap(); // <item var="pi" obj="childList" index="1" interface="NodeList"/>
                // r#ent4_name = r#entity4.node_name().to_string(); // <nodeName var="ent4Name" obj="entity4"/>
                // r#ent4_imp_name = r#entity_imp4.node_name().to_string(); // <nodeName var="ent4ImpName" obj="entityImp4"/>
                // r#cdata_val = r#cdata.data().to_string(); // <data var="cdataVal" obj="cdata" interface="CharacterData"/>
                // r#pi_target_val = r#pi.target().to_string(); // <target var="piTargetVal" obj="pi" interface="ProcessingInstruction"/>
                // r#pi_data_val = r#pi.data().unwrap().to_string(); // <data var="piDataVal" obj="pi" interface="ProcessingInstruction"/>
                // assert_eq!(r#ent4_imp_name, ent4_name); // <assertEquals expected="ent4Name" actual="ent4ImpName" id="documentimportnode20_Ent4NodeName" ignoreCase="false"/>
                // assert_eq!(r#cdata_val, "Element data"); // <assertEquals expected="&quot;Element data&quot;" actual="cdataVal" id="documentimportnode20_Cdata" ignoreCase="false"/>
                // assert_eq!(r#pi_target_val, "PItarget"); // <assertEquals expected="&quot;PItarget&quot;" actual="piTargetVal" id="documentimportnode20_PITarget" ignoreCase="false"/>
                // assert_eq!(r#pi_data_val, "PIdata"); // <assertEquals expected="&quot;PIdata&quot;" actual="piDataVal" id="documentimportnode20_PIData" ignoreCase="false"/>
            }
            // internalSubset01.xml
            #[test]
            fn test_internal_subset01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#internal; // type: DOMString // <var name="internal" type="DOMString"/>
                // r#doc = todo!(); // staff2.xml // <load var="doc" href="staff2" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType"/>

                // // unimplemented: // <internalSubset obj="docType" var="internal"/>

                // // unimplemented: // <assertNull actual="internal" id="internalSubsetNull"/>
            }
            // documentcreateattributeNS06.xml
            #[test]
            fn test_documentcreateattribute_n_s06() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType" isNull="true"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/XML/1998 /namespace&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;xml:root&quot;"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;dom:doc&quot;" doctype="docType"/>

                // // unimplemented: // <assertDOMException id="documentcreateattributeNS06"><NAMESPACE_ERR><createAttributeNS obj="newDoc" var="attribute" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/></NAMESPACE_ERR></assertDOMException>
            }
            // namednodemapgetnameditemns02.xml
            #[test]
            fn test_namednodemapgetnameditemns02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Node // <var name="element" type="Node"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attribute = r#attributes
                    .get_named_item_ns(Some("http://www.nist.gov"), "domestic")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;domestic&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                assert_eq!(r#attr_name, "emp:domestic"); // <assertEquals actual="attrName" expected="&quot;emp:domestic&quot;" id="namednodemapgetnameditemns02" ignoreCase="false"/>
            }
            // domimplementationhasfeature02.xml
            #[test]
            fn test_domimplementationhasfeature02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <hasFeature obj="domImpl" var="success" feature="&quot;Blah Blah&quot;" version="&quot;&quot;"/>
                // assert!(!r#success); // <assertFalse actual="success" id="domimplementationhasfeature02"/>
            }
            // nodegetprefix03.xml
            #[test]
            fn test_nodegetprefix03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#qelement; // type: Element // <var name="qelement" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#qattr; // type: Attr // <var name="qattr" type="Attr"/>
                let mut r#elem_no_prefix; // type: DOMString // <var name="elemNoPrefix" type="DOMString"/>
                let mut r#elem_prefix; // type: DOMString // <var name="elemPrefix" type="DOMString"/>
                let mut r#attr_no_prefix; // type: DOMString // <var name="attrNoPrefix" type="DOMString"/>
                let mut r#attr_prefix; // type: DOMString // <var name="attrPrefix" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test/elem"), "elem".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/elem&quot;" qualifiedName="&quot;elem&quot;"/>
                r#qelement = r#doc
                    .create_element_ns(
                        Some("http://www.w3.org/DOM/Test/elem"),
                        "qual:qelem".as_ref(),
                    )
                    .unwrap(); // <createElementNS var="qelement" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/elem&quot;" qualifiedName="&quot;qual:qelem&quot;"/>
                r#attr = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Test/attr"), "attr".as_ref())
                    .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/attr&quot;" qualifiedName="&quot;attr&quot;"/>
                r#qattr = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/DOM/Test/attr"),
                        "qual:qattr".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="qattr" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/attr&quot;" qualifiedName="&quot;qual:qattr&quot;"/>
                r#elem_no_prefix = r#element.prefix(); // <prefix var="elemNoPrefix" obj="element"/>
                r#elem_prefix = r#qelement.prefix().unwrap().to_string(); // <prefix var="elemPrefix" obj="qelement"/>
                r#attr_no_prefix = r#attr.prefix(); // <prefix var="attrNoPrefix" obj="attr"/>
                r#attr_prefix = r#qattr.prefix().unwrap().to_string(); // <prefix var="attrPrefix" obj="qattr"/>
                assert!(elem_no_prefix.is_none()); // <assertNull actual="elemNoPrefix" id="nodegetprefix03_1"/>
                assert_eq!(r#elem_prefix, "qual"); // <assertEquals actual="elemPrefix" expected="&quot;qual&quot;" id="nodegetprefix03_2" ignoreCase="false"/>
                assert!(attr_no_prefix.is_none()); // <assertNull actual="attrNoPrefix" id="nodegetprefix03_3"/>
                assert_eq!(r#attr_prefix, "qual"); // <assertEquals actual="attrPrefix" expected="&quot;qual&quot;" id="nodegetprefix03_4" ignoreCase="false"/>
            }
            // isSupported05.xml
            #[test]
            fn test_is_supported05() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                // r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>

                // // unimplemented: // <isSupported obj="rootNode" feature="&quot;core&quot;" version="&quot;2.0&quot;" var="state"/>
                // assert!(r#state); // <assertTrue actual="state" id="throw_True"/>
            }
            // importNode06.xml
            #[test]
            fn test_import_node06() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#has_child; // type: boolean // <var name="hasChild" type="boolean"/>
                let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#value; // type: DOMString // <var name="value" type="DOMString"/>
                let mut r#addresses; // type: NodeList // <var name="addresses" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                r#addresses = r#a_new_doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName var="addresses" obj="aNewDoc" interface="Document" tagname="&quot;emp:address&quot;"/>
                r#element = r#addresses.item(0).unwrap(); // <item var="element" obj="addresses" interface="NodeList" index="0"/>
                // unimplemented: // <assertNotNull actual="element" id="empAddressNotNull"/>
                r#a_node = r#doc.import_node(r#element.into(), true).unwrap(); // <importNode obj="doc" var="aNode" importedNode="element" deep="true"/>
                r#has_child = r#a_node.has_child_nodes(); // <hasChildNodes obj="aNode" var="hasChild"/>
                assert!(r#has_child); // <assertTrue actual="hasChild" id="throw_True"/>
                r#name = r#a_node.node_name().to_string(); // <nodeName obj="aNode" var="name"/>
                assert_eq!(r#name, "emp:address"); // <assertEquals actual="name" expected="&quot;emp:address&quot;" id="nodeName" ignoreCase="false"/>
                r#child = r#a_node.first_child().unwrap(); // <firstChild interface="Node" obj="aNode" var="child"/>
                r#value = r#child.node_value().unwrap().to_string(); // <nodeValue obj="child" var="value"/>
                assert_eq!(r#value, "27 South Road. Dallas, texas 98556"); // <assertEquals actual="value" expected="&quot;27 South Road. Dallas, texas 98556&quot;" id="nodeValue" ignoreCase="false"/>
            }
            // documentimportnode06.xml
            #[test]
            fn test_documentimportnode06() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_imported: DocumentRef; // <var name="docImported" type="Document"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>

                // unimplemented: // <assertDOMException id="throw_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><importNode var="docImported" obj="doc" importedNode="doc" deep="false"/></NOT_SUPPORTED_ERR></assertDOMException>
            }
            // ownerElement02.xml
            #[test]
            fn test_owner_element02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                let mut r#element_node; // type: Element // <var name="elementNode" type="Element"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#new_attr = r#doc.create_attribute("newAttribute".to_string()).unwrap(); // <createAttribute obj="doc" var="newAttr" name="&quot;newAttribute&quot;"/>
                r#element_node = r#new_attr.owner_element(); // <ownerElement obj="newAttr" var="elementNode"/>
                assert!(element_node.is_none()); // <assertNull actual="elementNode" id="throw_Null"/>
            }
            // hc_entitiesremovenameditemns1.xml
            #[test]
            fn test_hc_entitiesremovenameditemns1() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <if><not><contentType type="text/html"/></not>	<assertNotNull actual="docType" id="docTypeNotNull"/>	<entities var="entities" obj="docType"/>	<assertNotNull actual="entities" id="entitiesNotNull"/>	<try>		<removeNamedItemNS var="retval" obj="entities" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" localName="&quot;alpha&quot;"/>		<fail id="throw_NO_MOD_OR_NOT_FOUND_ERR"/>		<catch>			<DOMException code="NO_MODIFICATION_ALLOWED_ERR"/>			<DOMException code="NOT_FOUND_ERR"/>		</catch>	</try></if>
            }
            // hasAttributeNS05.xml
            #[test]
            fn test_has_attribute_n_s05() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#local_name; // type: DOMString // <var name="localName" type="DOMString" value="&quot;domestic&quot;"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.usa.com&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_node; // type: Element // <var name="testNode" type="Element"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                // r#test_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="0"/>
                // r#state = r#test_node
                //     .has_attribute_ns(Some(r#namespace_uri), r#local_name.as_ref())
                //     .unwrap(); // <hasAttributeNS obj="testNode" var="state" namespaceURI="namespaceURI" localName="localName"/>
                // assert!(r#state); // <assertTrue actual="state" id="hasAttribute"/>
            }
            // namednodemapsetnameditemns04.xml
            #[test]
            fn test_namednodemapsetnameditemns04() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc_alt: DocumentRef; // <var name="docAlt" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType" isNull="true"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#attr_alt; // type: Attr // <var name="attrAlt" type="Attr"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                // r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                // r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="docAlt" obj="domImpl" namespaceURI="nullNS" qualifiedName="&quot;newDoc&quot;" doctype="docType"/>
                // r#attr_alt = r#doc_alt
                //     .create_attribute_ns(None, "street".as_ref())
                //     .unwrap(); // <createAttributeNS var="attrAlt" obj="docAlt" namespaceURI="nullNS" qualifiedName="&quot;street&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_WRONG_DOCUMENT_ERR"><WRONG_DOCUMENT_ERR><setNamedItemNS var="newNode" obj="attributes" arg="attrAlt"/></WRONG_DOCUMENT_ERR></assertDOMException>
            }
            // isSupported10.xml
            #[test]
            fn test_is_supported10() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                // r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>

                // // unimplemented: // <isSupported obj="rootNode" feature="&quot;CORE&quot;" version="&quot;2.0&quot;" var="state"/>
                // assert!(r#state); // <assertTrue actual="state" id="throw_True"/>
            }
            // namespaceURI02.xml
            #[test]
            fn test_namespace_ur_i02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                let mut r#addr_attr; // type: Attr // <var name="addrAttr" type="Attr"/>
                let mut r#attr_namespace_uri; // type: DOMString // <var name="attrNamespaceURI" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                // unimplemented: // <assertNotNull actual="testAddr" id="empAddressNotNull"/>
                r#addr_attr = r#test_addr
                    .get_attribute_node_ns(Some("http://www.nist.gov"), "domestic")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS obj="testAddr" localName="&quot;domestic&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" var="addrAttr"/>
                r#attr_namespace_uri = r#addr_attr.namespace_uri().unwrap().to_string(); // <namespaceURI obj="addrAttr" var="attrNamespaceURI"/>
                assert_eq!(r#attr_namespace_uri, "http://www.nist.gov"); // <assertEquals actual="attrNamespaceURI" expected="&quot;http://www.nist.gov&quot;" id="namespaceURI" ignoreCase="false"/>
            }
            // elementhasattribute01.xml
            #[test]
            fn test_elementhasattribute01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="false"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element = r#doc.document_element().unwrap(); // <documentElement var="element" obj="doc"/>
                r#state = r#element.has_attribute(""); // <hasAttribute var="state" obj="element" name="&quot;&quot;"/>
                assert!(!r#state); // <assertFalse actual="state" id="elementhasattribute01"/>
            }
            // getElementsByTagNameNS10.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s10() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                // let mut r#result; // type: List // <var name="result" type="List"/>
                // let mut r#expected_result; // type: List // <var name="expectedResult" type="List"><member>"employee"</member><member>"employeeId"</member><member>"name"</member><member>"position"</member><member>"salary"</member><member>"gender"</member><member>"address"</member><member>"emp:employee"</member><member>"emp:employeeId"</member><member>"emp:position"</member><member>"emp:salary"</member><member>"emp:gender"</member><member>"emp:address"</member><member>"address"</member></var>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#element_list = r#doc_elem
                //     .get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "*".into()); // <getElementsByTagNameNS interface="Element" obj="docElem" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;*&quot;" var="elementList"/>

                // // unimplemented: // <for-each collection="elementList" member="child"><nodeName obj="child" var="childName"/><append collection="result" item="childName"/></for-each>
                // assert_eq!(r#result, expected_result); // <assertEquals actual="result" expected="expectedResult" id="nodeNames" ignoreCase="false"/>
            }
            // getElementsByTagNameNS08.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s08() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#new_list; // type: NodeList // <var name="newList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#new_list = r#doc_elem.get_elements_by_tag_name_ns(Some("*"), "*");
                // <getElementsByTagNameNS interface="Element" obj="docElem" var="newList" namespaceURI="&quot;*&quot;" localName="&quot;*&quot;"/>

                // unimplemented: // <if><contentType type="image/svg+xml"/><assertSize collection="newList" size="38" id="listSize_svg"/><else><assertSize collection="newList" size="36" id="listSize"/></else></if>
            }
            // documentimportnode21.xml
            #[test]
            fn test_documentimportnode21() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type_null; // type: DocumentType // <var name="docTypeNull" type="DocumentType" isNull="true"/>
                // let mut r#doc_imp: DocumentRef; // <var name="docImp" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#address_list; // type: NodeList // <var name="addressList" type="NodeList"/>
                // let mut r#address_child_list; // type: NodeList // <var name="addressChildList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#ent_ref2; // type: EntityReference // <var name="entRef2" type="EntityReference"/>
                // let mut r#ent_ref_imp2; // type: EntityReference // <var name="entRefImp2" type="EntityReference"/>
                // let mut r#ent_ref3; // type: EntityReference // <var name="entRef3" type="EntityReference"/>
                // let mut r#ent_ref_imp3; // type: EntityReference // <var name="entRefImp3" type="EntityReference"/>
                // let mut r#node_name2; // type: DOMString // <var name="nodeName2" type="DOMString"/>
                // let mut r#node_name3; // type: DOMString // <var name="nodeName3" type="DOMString"/>
                // let mut r#node_name_imp2; // type: DOMString // <var name="nodeNameImp2" type="DOMString"/>
                // let mut r#node_name_imp3; // type: DOMString // <var name="nodeNameImp3" type="DOMString"/>
                // let mut r#nodes; // type: NodeList // <var name="nodes" type="NodeList"/>
                // let mut r#node_imp3; // type: Node // <var name="nodeImp3" type="Node"/>
                // let mut r#node_imp2; // type: Node // <var name="nodeImp2" type="Node"/>
                // let mut r#node_value_imp2; // type: DOMString // <var name="nodeValueImp2" type="DOMString"/>
                // let mut r#node_value_imp3; // type: DOMString // <var name="nodeValueImp3" type="DOMString"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="docImp" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;a:b&quot;" doctype="docTypeNull"/>
                // r#address_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName var="addressList" obj="doc" tagname="&quot;address&quot;" interface="Document"/>
                // r#element = r#address_list.item(1).unwrap(); // <item var="element" obj="addressList" index="1" interface="NodeList"/>
                // r#address_child_list = r#element.child_nodes(); // <childNodes var="addressChildList" obj="element"/>
                // r#ent_ref2 = r#address_child_list[0].clone(); // <item var="entRef2" obj="addressChildList" index="0" interface="NodeList"/>
                // r#ent_ref3 = r#address_child_list[2].clone(); // <item var="entRef3" obj="addressChildList" index="2" interface="NodeList"/>
                // r#ent_ref_imp2 = r#doc_imp.import_node(r#ent_ref2.into(), true).unwrap(); // <importNode var="entRefImp2" obj="docImp" importedNode="entRef2" deep="true"/>
                // r#ent_ref_imp3 = r#doc_imp.import_node(r#ent_ref3.into(), false).unwrap(); // <importNode var="entRefImp3" obj="docImp" importedNode="entRef3" deep="false"/>
                // r#node_name2 = r#ent_ref2.node_name().to_string(); // <nodeName var="nodeName2" obj="entRef2"/>
                // r#node_name3 = r#ent_ref3.node_name().to_string(); // <nodeName var="nodeName3" obj="entRef3"/>
                // r#node_name_imp2 = r#ent_ref_imp2.node_name().to_string(); // <nodeName var="nodeNameImp2" obj="entRefImp2"/>
                // r#node_name_imp3 = r#ent_ref_imp3.node_name().to_string(); // <nodeName var="nodeNameImp3" obj="entRefImp3"/>
                // assert_eq!(r#node_name_imp2, node_name2); // <assertEquals expected="nodeName2" actual="nodeNameImp2" id="documentimportnode21_Ent2NodeName" ignoreCase="false"/>
                // assert_eq!(r#node_name_imp3, node_name3); // <assertEquals expected="nodeName3" actual="nodeNameImp3" id="documentimportnode21_Ent3NodeName" ignoreCase="false"/>
                // r#ent_ref_imp2 = r#doc.import_node(r#ent_ref2.into(), true).unwrap(); // <importNode var="entRefImp2" obj="doc" importedNode="entRef2" deep="true"/>
                // r#ent_ref_imp3 = r#doc.import_node(r#ent_ref3.into(), false).unwrap(); // <importNode var="entRefImp3" obj="doc" importedNode="entRef3" deep="false"/>
                // r#nodes = r#ent_ref_imp2.child_nodes(); // <childNodes var="nodes" obj="entRefImp2" interface="Node"/>
                // r#node_imp2 = r#nodes[0].clone(); // <item var="nodeImp2" obj="nodes" index="0" interface="NodeList"/>
                // r#node_value_imp2 = r#node_imp2.node_value().unwrap().to_string(); // <nodeValue var="nodeValueImp2" obj="nodeImp2"/>
                // r#nodes = r#ent_ref_imp3.child_nodes(); // <childNodes var="nodes" obj="entRefImp3" interface="Node"/>
                // r#node_imp3 = r#nodes[0].clone(); // <item var="nodeImp3" obj="nodes" index="0" interface="NodeList"/>
                // r#node_value_imp3 = r#node_imp3.node_value().unwrap().to_string(); // <nodeValue var="nodeValueImp3" obj="nodeImp3"/>
                // assert_eq!(r#node_value_imp2, "1900 Dallas Road"); // <assertEquals actual="nodeValueImp2" expected="&quot;1900 Dallas Road&quot;" id="documentimportnode21_Ent2NodeValue" ignoreCase="false"/>
                // assert_eq!(r#node_value_imp3, "Texas"); // <assertEquals actual="nodeValueImp3" expected="&quot;Texas&quot;" id="documentimportnode21_Ent3Nodevalue" ignoreCase="false"/>
            }
            // domimplementationfeaturexmlversion2.xml
            #[test]
            fn test_domimplementationfeaturexmlversion2() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <hasFeature obj="domImpl" var="state" feature="&quot;xml&quot;" version="&quot;2.0&quot;"/>
                // assert!(r#state); // <assertTrue actual="state" id="domimplementationFeaturexmlVersion2Assert"/>
            }
            // namednodemapsetnameditemns02.xml
            #[test]
            fn test_namednodemapsetnameditemns02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#attribute1; // type: Attr // <var name="attribute1" type="Attr"/>
                let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test"), "root".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;root&quot;"/>
                r#attribute1 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/L1"), "L1:att".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute1" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" qualifiedName="&quot;L1:att&quot;"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#new_node = r#attributes.set_named_item_ns(r#attribute1).unwrap(); // <setNamedItemNS var="newNode" obj="attributes" arg="attribute1"/>
                r#attribute = r#attributes
                    .get_named_item_ns(Some("http://www.w3.org/DOM/L1"), "att")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" localName="&quot;att&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                assert_eq!(r#attr_name, "L1:att"); // <assertEquals actual="attrName" expected="&quot;L1:att&quot;" id="namednodemapsetnameditemns02" ignoreCase="false"/>
            }
            // createDocument08.xml
            #[test]
            fn test_create_document08() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.example.org/schema&quot;"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType" isNull="true"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                // let mut r#charact; // type: DOMString // <var name="charact" type="DOMString"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <assertDOMException id="throw_INVALID_CHARACTER_ERR"><INVALID_CHARACTER_ERR><createDocument obj="domImpl" var="aNewDoc" namespaceURI="namespaceURI" qualifiedName="&quot;&quot;" doctype="docType"/></INVALID_CHARACTER_ERR></assertDOMException>
            }
            // elementhasattribute03.xml
            #[test]
            fn test_elementhasattribute03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element = r#doc.create_element("address".to_string()).unwrap(); // <createElement var="element" obj="doc" tagName="&quot;address&quot;"/>
                r#attribute = r#doc.create_attribute("domestic".to_string()).unwrap(); // <createAttribute var="attribute" obj="doc" name="&quot;domestic&quot;"/>
                r#state = r#element.has_attribute("domestic"); // <hasAttribute var="state" obj="element" name="&quot;domestic&quot;"/>
                assert!(!r#state); // <assertFalse actual="state" id="elementhasattribute03_False"/>
                r#new_attribute = r#element.set_attribute_node(r#attribute).unwrap(); // <setAttributeNode var="newAttribute" obj="element" newAttr="attribute"/>
                r#state = r#element.has_attribute("domestic"); // <hasAttribute var="state" obj="element" name="&quot;domestic&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="elementhasattribute03_True"/>
            }
            // prefix03.xml
            #[test]
            fn test_prefix03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:employee&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                // unimplemented: // <assertNotNull actual="testEmployee" id="empEmployeeNotNull"/>
                r#prefix = r#test_employee.prefix().unwrap().to_string(); // <prefix obj="testEmployee" var="prefix"/>
                assert_eq!(r#prefix, "emp"); // <assertEquals actual="prefix" expected="&quot;emp&quot;" id="prefix" ignoreCase="false"/>
            }
            // importNode14.xml
            #[test]
            fn test_import_node14() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                // let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                // let mut r#a_node; // type: ProcessingInstruction // <var name="aNode" type="ProcessingInstruction"/>
                // let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                // let mut r#target; // type: DOMString // <var name="target" type="DOMString"/>
                // let mut r#data; // type: DOMString // <var name="data" type="DOMString"/>
                // let mut r#result; // type: List // <var name="result" type="List"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                // r#pi = r#a_new_doc
                //     .create_processing_instruction("target1", Some("data1"))
                //     .unwrap(); // <createProcessingInstruction obj="aNewDoc" var="pi" target="&quot;target1&quot;" data="&quot;data1&quot;"/>
                // r#a_node = r#doc
                //     .import_node(r#pi.into(), false)
                //     .unwrap()
                //     .as_processing_instruction()
                //     .unwrap(); // <importNode obj="doc" var="aNode" importedNode="pi" deep="false"/>
                // r#owner_document = r#a_node.owner_document().unwrap(); // <ownerDocument obj="aNode" var="ownerDocument"/>

                // // unimplemented: // <assertNotNull actual="ownerDocument" id="ownerDocumentNotNull"/>
                // r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                // r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>

                // // unimplemented: // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="systemId"/>
                // r#target = r#a_node.target().to_string(); // <target interface="ProcessingInstruction" obj="aNode" var="target"/>
                // assert_eq!(r#target, "target1"); // <assertEquals actual="target" expected="&quot;target1&quot;" id="piTarget" ignoreCase="false"/>
                // r#data = r#a_node.data().unwrap().to_string(); // <data interface="ProcessingInstruction" obj="aNode" var="data"/>
                // assert_eq!(r#data, "data1"); // <assertEquals actual="data" expected="&quot;data1&quot;" id="piData" ignoreCase="false"/>
            }
            // setAttributeNS02.xml
            #[test]
            fn test_set_attribute_n_s02() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("emp:employee"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:employee&quot;"/>
                // r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>

                // // unimplemented: // <assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><setAttributeNS obj="testAddr" namespaceURI="namespaceURI" qualifiedName="qualifiedName" value="&quot;newValue&quot;"/></NAMESPACE_ERR></assertDOMException>
            }
            // elementhasattributens01.xml
            #[test]
            fn test_elementhasattributens01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "employee"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;employee&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                r#state = r#element
                    .has_attribute_ns(Some("http://www.w3.org/2000/xmlns/"), "xmlns")
                    .unwrap(); // <hasAttributeNS var="state" obj="element" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" localName="&quot;xmlns&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="elementhasattributens01"/>
            }
            // setAttributeNodeNS03.xml
            #[test]
            fn test_set_attribute_node_n_s03() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.newattr.com&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:newAttr&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                // let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                // let mut r#new_addr_attr; // type: Attr // <var name="newAddrAttr" type="Attr"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:address&quot;"/>
                // r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>

                // // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                // r#new_attr = r#doc
                //     .create_attribute_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                //     .unwrap(); // <createAttributeNS obj="doc" var="newAttr" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                // r#new_addr_attr = r#test_addr
                //     .set_attribute_node_ns(r#new_attr)
                //     .unwrap()
                //     .unwrap(); // <setAttributeNodeNS obj="testAddr" newAttr="newAttr" var="newAddrAttr"/>

                // // unimplemented: // <assertNull actual="newAddrAttr" id="throw_Null"/>
            }
            // importNode17.xml
            #[test]
            fn test_import_node17() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#another_doc: DocumentRef; // <var name="anotherDoc" type="Document"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#another_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="anotherDoc" href="staffNS" willBeModified="true"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><importNode obj="doc" var="node" importedNode="anotherDoc" deep="false"/></NOT_SUPPORTED_ERR></assertDOMException>
            }
            // isSupported01.xml
            #[test]
            fn test_is_supported01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                // r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>

                // // unimplemented: // <isSupported obj="rootNode" feature="&quot;XXX&quot;" version="&quot;1.0&quot;" var="state"/>
                // assert!(!r#state); // <assertFalse actual="state" id="throw_False"/>
            }
            // documentcreateattributeNS03.xml
            #[test]
            fn test_documentcreateattribute_n_s03() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/DOM/Test/Level2&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString"/>
                // let mut r#qualified_names; // type: List // <var name="qualifiedNames" type="List"><member>"/"</member><member>"//"</member><member>"\\"</member><member>";"</member><member>"&amp;"</member><member>"*"</member><member>"]]"</member><member>"&gt;"</member><member>"&lt;"</member></var>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <for-each collection="qualifiedNames" member="qualifiedName"><assertDOMException id="documentcreateattributeNS03"><INVALID_CHARACTER_ERR><createAttributeNS obj="doc" var="attribute" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/></INVALID_CHARACTER_ERR></assertDOMException></for-each>
            }
            // getElementsByTagNameNS13.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s13() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#element_list = r#doc_elem
                    .get_elements_by_tag_name_ns(Some("http://www.nomatch.com"), "address"); // <getElementsByTagNameNS interface="Element" obj="docElem" namespaceURI="&quot;http://www.nomatch.com&quot;" localName="&quot;address&quot;" var="elementList"/>

                // unimplemented: // <assertSize collection="elementList" size="0" id="matchSize"/>
            }
            // documentgetelementsbytagnameNS03.xml
            #[test]
            fn test_documentgetelementsbytagname_n_s03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#child_list = r#doc.get_elements_by_tag_name_ns(Some("**"), "*"); // <getElementsByTagNameNS var="childList" obj="doc" namespaceURI="&quot;**&quot;" localName="&quot;*&quot;" interface="Document"/>

                // unimplemented: // <assertSize size="0" collection="childList" id="documentgetelementsbytagnameNS03"/>
            }
            // isSupported09.xml
            #[test]
            fn test_is_supported09() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                // r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>

                // // unimplemented: // <isSupported obj="rootNode" feature="&quot;XML&quot;" version="&quot;1.0&quot;" var="state"/>
                // assert!(r#state); // <assertTrue actual="state" id="throw_True"/>
            }
            // documentcreateelementNS05.xml
            #[test]
            fn test_documentcreateelement_n_s05() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" isNull="true"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;null:xml&quot;"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <assertDOMException id="documentcreateelementNS05"><NAMESPACE_ERR><createElementNS obj="doc" var="element" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/></NAMESPACE_ERR></assertDOMException>
            }
            // domimplementationhasfeature01.xml
            #[test]
            fn test_domimplementationhasfeature01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#version; // type: DOMString // <var name="version" type="DOMString" value="&quot;&quot;"/>
                // let mut r#version1; // type: DOMString // <var name="version1" type="DOMString" value="&quot;1.0&quot;"/>
                // let mut r#version2; // type: DOMString // <var name="version2" type="DOMString" value="&quot;2.0&quot;"/>
                // let mut r#feature_core; // type: DOMString // <var name="featureCore" type="DOMString"/>
                // let mut r#feature_xml; // type: DOMString // <var name="featureXML" type="DOMString"/>
                // let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                // let mut r#features_xml; // type: List // <var name="featuresXML" type="List"><member>"XML"</member><member>"xmL"</member></var>
                // let mut r#features_core; // type: List // <var name="featuresCore" type="List"><member>"Core"</member><member>"CORE"</member></var>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <for-each collection="featuresXML" member="featureXML"><hasFeature obj="domImpl" var="success" feature="featureXML" version="version"/><assertTrue actual="success" id="domimplementationhasfeature01_XML_1"/><hasFeature obj="domImpl" var="success" feature="featureXML" version="version1"/><assertTrue actual="success" id="domimplementationhasfeature01_XML_2"/></for-each>

                // // unimplemented: // <for-each collection="featuresCore" member="featureCore"><hasFeature obj="domImpl" var="success" feature="featureCore" version="version"/><assertTrue actual="success" id="domimplementationhasfeature01_Core_1"/><!--  result is indeterminant since Core was not defined in DOM L1   --><hasFeature obj="domImpl" var="success" feature="featureCore" version="version1"/><hasFeature obj="domImpl" var="success" feature="featureCore" version="version2"/><assertTrue actual="success" id="domimplementationhasfeature01_Core_3"/></for-each>
            }
            // hasAttributes02.xml
            #[test]
            fn test_has_attributes02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#addr_list; // type: NodeList // <var name="addrList" type="NodeList"/>
                let mut r#addr_node; // type: Node // <var name="addrNode" type="Node"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#addr_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;address&quot;" var="addrList"/>
                r#addr_node = r#addr_list.item(0).unwrap(); // <item interface="NodeList" obj="addrList" index="0" var="addrNode"/>
                r#state = r#addr_node.has_attributes(); // <hasAttributes obj="addrNode" var="state"/>
                assert!(r#state); // <assertTrue actual="state" id="throw_True"/>
            }
            // getElementsByTagNameNS01.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s01() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;*&quot;"/>
                // let mut r#local_name; // type: DOMString // <var name="localName" type="DOMString" value="&quot;*&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_list; // type: NodeList // <var name="newList" type="NodeList"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#new_list = r#doc.get_elements_by_tag_name_ns(
                //     Some(r#namespace_uri),
                //     r#local_name.as_ref(),
                // ); // <getElementsByTagNameNS interface="Document" obj="doc" var="newList" namespaceURI="namespaceURI" localName="localName"/>

                // // unimplemented: // <if><contentType type="image/svg+xml"/><assertSize collection="newList" size="39" id="listLength_svg"/><else><assertSize collection="newList" size="37" id="listLength"/></else></if>
            }
            // hasAttributeNS03.xml
            #[test]
            fn test_has_attribute_n_s03() {
                // let mut r#local_name; // type: DOMString // <var name="localName" type="DOMString" value="&quot;blank&quot;"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_node; // type: Element // <var name="testNode" type="Element"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:address&quot;"/>
                // r#test_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="0"/>

                // // unimplemented: // <assertNotNull actual="testNode" id="empAddrNotNull"/>
                // r#state = r#test_node
                //     .has_attribute_ns(Some(r#namespace_uri), r#local_name.as_ref())
                //     .unwrap(); // <hasAttributeNS obj="testNode" var="state" namespaceURI="namespaceURI" localName="localName"/>
                // assert!(!r#state); // <assertFalse actual="state" id="throw_False"/>
            }
            // importNode08.xml
            #[test]
            fn test_import_node08() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#has_child; // type: boolean // <var name="hasChild" type="boolean"/>
                let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                r#doc_frag = r#a_new_doc.create_document_fragment(); // <createDocumentFragment obj="aNewDoc" var="docFrag"/>
                r#a_node = r#doc.import_node(r#doc_frag.into(), false).unwrap(); // <importNode obj="doc" var="aNode" importedNode="docFrag" deep="false"/>
                r#has_child = r#a_node.has_child_nodes(); // <hasChildNodes obj="aNode" var="hasChild"/>
                assert!(!r#has_child); // <assertFalse actual="hasChild" id="hasChild"/>
                r#owner_document = r#a_node.owner_document().unwrap(); // <ownerDocument obj="aNode" var="ownerDocument"/>
                r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>

                // unimplemented: // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="system"/>
            }
            // setAttributeNodeNS02.xml
            #[test]
            fn test_set_attribute_node_n_s02() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#gender_list; // type: NodeList // <var name="genderList" type="NodeList"/>
                // let mut r#gender; // type: Node // <var name="gender" type="Node"/>
                // let mut r#gen_list; // type: NodeList // <var name="genList" type="NodeList"/>
                // let mut r#gen; // type: Node // <var name="gen" type="Node"/>
                // let mut r#g_list; // type: NodeList // <var name="gList" type="NodeList"/>
                // let mut r#gen_element; // type: Element // <var name="genElement" type="Element"/>
                // let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                // let mut r#set_attr1; // type: Attr // <var name="setAttr1" type="Attr"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>

                // // unimplemented: // <if><implementationAttribute name="expandEntityReferences" value="false"/><getElementsByTagName interface="Document" obj="doc" var="genderList" tagname="&quot;gender&quot;"/><item interface="NodeList" obj="genderList" var="gender" index="2"/><childNodes obj="gender" var="genList"/><item interface="NodeList" obj="genList" var="gen" index="0"/><else><createEntityReference var="gen" name="&quot;ent4&quot;" obj="doc"/></else></if>
                // r#g_list = r#gen.child_nodes(); // <childNodes obj="gen" var="gList"/>
                // r#gen_element = r#g_list.item(0).unwrap().clone(); // <item interface="NodeList" obj="gList" var="genElement" index="0"/>

                // // unimplemented: // <assertNotNull actual="genElement" id="notnull"/>
                // r#new_attr = r#doc
                //     .create_attribute_ns(Some("www.xyz.com".as_ref()), "emp:local1".as_ref())
                //     .unwrap(); // <createAttributeNS obj="doc" var="newAttr" namespaceURI="&quot;www.xyz.com&quot;" qualifiedName="&quot;emp:local1&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR"><NO_MODIFICATION_ALLOWED_ERR><setAttributeNodeNS var="setAttr1" obj="genElement" newAttr="newAttr"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // hasAttribute04.xml
            #[test]
            fn test_has_attribute04() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_node; // type: Element // <var name="testNode" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testNode" index="0"/>
                r#state = r#test_node.has_attribute("dmstc:domestic"); // <hasAttribute obj="testNode" var="state" name="&quot;dmstc:domestic&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="hasDomesticAttr"/>
            }
            // removeNamedItemNS01.xml
            #[test]
            fn test_remove_named_item_n_s01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;address&quot;"/>
                r#test_address = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="1"/>
                r#attributes = r#test_address.attributes(); // <attributes obj="testAddress" var="attributes"/>
                r#removed_node = r#attributes
                    .remove_named_item_ns(Some("http://www.usa.com"), "domestic")
                    .unwrap(); // <removeNamedItemNS var="removedNode" interface="NamedNodeMap" obj="attributes" namespaceURI="&quot;http://www.usa.com&quot;" localName="&quot;domestic&quot;"/>
                // unimplemented: // <assertNotNull actual="removedNode" id="retval"/>
                r#new_attr = r#attributes.get_named_item("dmstc:domestic"); // <getNamedItem obj="attributes" var="newAttr" name="&quot;dmstc:domestic&quot;"/>
                assert!(new_attr.is_none()); // <assertNull actual="newAttr" id="nodeRemoved"/>
            }
            // nodegetnamespaceuri03.xml
            #[test]
            fn test_nodegetnamespaceuri03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#element_ns; // type: Element // <var name="elementNS" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#attr_ns; // type: Attr // <var name="attrNS" type="Attr"/>
                let mut r#elem_nsuri; // type: DOMString // <var name="elemNSURI" type="DOMString"/>
                let mut r#elem_nsuri_null; // type: DOMString // <var name="elemNSURINull" type="DOMString"/>
                let mut r#attr_nsuri; // type: DOMString // <var name="attrNSURI" type="DOMString"/>
                let mut r#attr_nsuri_null; // type: DOMString // <var name="attrNSURINull" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element = r#doc.create_element_ns(None, "elem".as_ref()).unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="nullNS" qualifiedName="&quot;elem&quot;"/>
                r#element_ns = r#doc
                    .create_element_ns(
                        Some("http://www.w3.org/DOM/Test/elem"),
                        "qual:qelem".as_ref(),
                    )
                    .unwrap(); // <createElementNS var="elementNS" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/elem&quot;" qualifiedName="&quot;qual:qelem&quot;"/>
                r#attr = r#doc.create_attribute_ns(None, "attr".as_ref()).unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="nullNS" qualifiedName="&quot;attr&quot;"/>
                r#attr_ns = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/DOM/Test/attr"),
                        "qual:qattr".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="attrNS" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/attr&quot;" qualifiedName="&quot;qual:qattr&quot;"/>
                r#elem_nsuri = r#element_ns.namespace_uri().unwrap().to_string(); // <namespaceURI var="elemNSURI" obj="elementNS"/>
                r#elem_nsuri_null = r#element.namespace_uri(); // <namespaceURI var="elemNSURINull" obj="element"/>
                r#attr_nsuri = r#attr_ns.namespace_uri().unwrap().to_string(); // <namespaceURI var="attrNSURI" obj="attrNS"/>
                r#attr_nsuri_null = r#attr.namespace_uri(); // <namespaceURI var="attrNSURINull" obj="attr"/>
                assert_eq!(r#elem_nsuri, "http://www.w3.org/DOM/Test/elem"); // <assertEquals actual="elemNSURI" expected="&quot;http://www.w3.org/DOM/Test/elem&quot;" id="nodegetnamespaceuri03_elemNSURI" ignoreCase="false"/>
                assert!(elem_nsuri_null.is_none()); // <assertNull actual="elemNSURINull" id="nodegetnamespaceuri03_1"/>
                assert_eq!(r#attr_nsuri, "http://www.w3.org/DOM/Test/attr"); // <assertEquals actual="attrNSURI" expected="&quot;http://www.w3.org/DOM/Test/attr&quot;" id="nodegetnamespaceuri03_attrNSURI" ignoreCase="false"/>
                assert!(attr_nsuri_null.is_none()); // <assertNull actual="attrNSURINull" id="nodegetnamespaceuri03_2"/>
            }
            // elementhasattributens02.xml
            #[test]
            fn test_elementhasattributens02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM"), "address".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM&quot;" qualifiedName="&quot;address&quot;"/>
                r#attribute = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM"), "domestic".as_ref())
                    .unwrap(); // <createAttributeNS var="attribute" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM&quot;" qualifiedName="&quot;domestic&quot;"/>
                r#new_attribute = r#element.set_attribute_node(r#attribute).unwrap(); // <setAttributeNode var="newAttribute" obj="element" newAttr="attribute"/>
                r#state = r#element
                    .has_attribute_ns(Some("http://www.w3.org/DOM"), "domestic")
                    .unwrap(); // <hasAttributeNS var="state" obj="element" namespaceURI="&quot;http://www.w3.org/DOM&quot;" localName="&quot;domestic&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="hasDomesticAttr"/>
            }
            // elementhasattribute02.xml
            #[test]
            fn test_elementhasattribute02() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:employee&quot;" var="elementList"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                // unimplemented: // <assertNotNull actual="element" id="empEmployeeNotNull"/>
                r#state = r#element.has_attribute("defaultAttr"); // <hasAttribute var="state" obj="element" name="&quot;defaultAttr&quot;"/>
                assert!(r#state); // <assertTrue actual="state" id="elementhasattribute02"/>
            }
            // namednodemapremovenameditemns09.xml
            #[test]
            fn test_namednodemapremovenameditemns09() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#new_attributes; // type: NamedNodeMap // <var name="newAttributes" type="NamedNodeMap"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" localName="&quot;address&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attribute = r#attributes
                    .remove_named_item_ns(Some("http://www.nist.gov"), "domestic")
                    .unwrap(); // <removeNamedItemNS var="attribute" obj="attributes" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;domestic&quot;"/>
                r#new_attributes = r#element.attributes(); // <attributes var="newAttributes" obj="element"/>
                let r#attribute = r#new_attributes
                    .get_named_item_ns(Some("http://www.nist.gov"), "domestic")
                    .unwrap(); // <getNamedItemNS var="attribute" obj="newAttributes" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;domestic&quot;"/>
                assert!(attribute.is_none()); // <assertNull actual="attribute" id="namednodemapremovenameditemns09"/>
            }
            // getElementsByTagNameNS07.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s07() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS interface="Document" obj="doc" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;" var="elementList"/>

                // unimplemented: // <assertSize collection="elementList" size="3" id="addresses"/>
            }
            // createDocumentType02.xml
            #[test]
            fn test_create_document_type02() {
                // let mut r#public_id; // type: DOMString // <var name="publicId" type="DOMString" value="&quot;http://www.localhost.com/&quot;"/>
                // let mut r#system_id; // type: DOMString // <var name="systemId" type="DOMString" value="&quot;myDoc.dtd&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType" isNull="true"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#illegal_q_names; // type: List // <var name="illegalQNames" type="List"><member>"edi:{"</member><member>"edi:}"</member><member>"edi:~"</member><member>"edi:'"</member><member>"edi:!"</member><member>"edi:@"</member><member>"edi:#"</member><member>"edi:$"</member><member>"edi:%"</member><member>"edi:^"</member><member>"edi:&amp;"</member><member>"edi:*"</member><member>"edi:("</member><member>"edi:)"</member><member>"edi:+"</member><member>"edi:="</member><member>"edi:["</member><member>"edi:]"</member><member>"edi:\\"</member><member>"edi:/"</member><member>"edi:;"</member><member>"edi:`"</member><member>"edi:&lt;"</member><member>"edi:&gt;"</member><member>"edi:,"</member><member>"edi:a "</member><member>"edi:\""</member></var>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <for-each collection="illegalQNames" member="qualifiedName"><implementation obj="doc" var="domImpl"/><assertDOMException id="throw_INVALID_CHARACTER_ERR"><INVALID_CHARACTER_ERR><createDocumentType obj="domImpl" var="docType" qualifiedName="qualifiedName" publicId="publicId" systemId="systemId"/></INVALID_CHARACTER_ERR></assertDOMException></for-each>
            }
            // elementsetattributens01.xml
            #[test]
            fn test_elementsetattributens01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#element = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM"), "dom:elem".as_ref())
                    .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM&quot;" qualifiedName="&quot;dom:elem&quot;"/>
                r#element
                    .set_attribute_ns(
                        Some("http://www.w3.org/DOM/Test/setAttributeNS"),
                        "attr",
                        "value",
                    )
                    .unwrap(); // <setAttributeNS obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/setAttributeNS&quot;" qualifiedName="&quot;attr&quot;" value="&quot;value&quot;"/>
                r#attribute = r#element
                    .get_attribute_node_ns(
                        Some("http://www.w3.org/DOM/Test/setAttributeNS"),
                        "attr",
                    )
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attribute" obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/setAttributeNS&quot;" localName="&quot;attr&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                r#attr_value = r#attribute.node_value().unwrap().to_string(); // <nodeValue var="attrValue" obj="attribute"/>
                assert_eq!(r#attr_name, "attr"); // <assertEquals actual="attrName" expected="&quot;attr&quot;" id="elementsetattributens01_attrName" ignoreCase="false"/>
                assert_eq!(r#attr_value, "value"); // <assertEquals actual="attrValue" expected="&quot;value&quot;" id="elementsetattributens01_attrValue" ignoreCase="false"/>
            }
            // hc_notationsremovenameditemns1.xml
            #[test]
            fn test_hc_notationsremovenameditemns1() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <if><not><contentType type="text/html"/></not><assertNotNull actual="docType" id="docTypeNotNull"/><notations var="notations" obj="docType"/><assertNotNull actual="notations" id="notationsNotNull"/><try>	<removeNamedItemNS var="retval" obj="notations" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" localName="&quot;alpha&quot;"/>	<fail id="throw_NO_MOD_OR_NOT_FOUND_ERR"/>	<catch>		<DOMException code="NO_MODIFICATION_ALLOWED_ERR"/>		<DOMException code="NOT_FOUND_ERR"/>	</catch></try></if>
            }
            // isSupported06.xml
            #[test]
            fn test_is_supported06() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                // r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>

                // // unimplemented: // <isSupported obj="rootNode" feature="&quot;xml&quot;" version="&quot;2.0&quot;" var="state"/>
                // assert!(r#state); // <assertTrue actual="state" id="throw_True"/>
            }
            // isSupported12.xml
            #[test]
            fn test_is_supported12() {
                // let mut r#features; // type: List // <var name="features" type="List"><member>"Core"</member><member>"XML"</member><member>"HTML"</member><member>"Views"</member><member>"StyleSheets"</member><member>"CSS"</member><member>"CSS2"</member><member>"Events"</member><member>"UIEvents"</member><member>"MouseEvents"</member><member>"MutationEvents"</member><member>"HTMLEvents"</member><member>"Range"</member><member>"Traversal"</member><member>"bogus.bogus.bogus"</member></var>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                // let mut r#feature_element; // type: DOMString // <var name="featureElement" type="DOMString"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                // r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>

                // // unimplemented: // <isSupported obj="rootNode" feature="&quot;Core&quot;" version="&quot;2.0&quot;" var="state"/>
                // assert!(r#state); // <assertTrue actual="state" id="Core2"/>

                // // unimplemented: // <for-each collection="features" member="featureElement"><isSupported obj="rootNode" feature="featureElement" version="&quot;1.0&quot;" var="state"/></for-each>

                // // unimplemented: // <for-each collection="features" member="featureElement"><isSupported obj="rootNode" feature="featureElement" version="&quot;2.0&quot;" var="state"/></for-each>
            }
            // documenttypeinternalSubset01.xml
            #[test]
            fn test_documenttypeinternal_subset01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#internal; // type: DOMString // <var name="internal" type="DOMString"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocumentType var="docType" obj="domImpl" qualifiedName="&quot;l2:root&quot;" publicId="nullNS" systemId="nullNS"/>

                // // unimplemented: // <internalSubset var="internal" obj="docType"/>

                // // unimplemented: // <assertNull actual="internal" id="internalSubsetNull"/>
            }
            // setAttributeNS05.xml
            #[test]
            fn test_set_attribute_n_s05() {
                // let mut r#local_name; // type: DOMString // <var name="localName" type="DOMString" value="&quot;newAttr&quot;"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.newattr.com&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:newAttr&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                // let mut r#addr_attr; // type: Attr // <var name="addrAttr" type="Attr"/>
                // let mut r#result_attr; // type: DOMString // <var name="resultAttr" type="DOMString"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:address&quot;"/>
                // r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>

                // // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                // r#test_addr
                //     .set_attribute_ns(Some(r#namespace_uri), r#qualified_name, "<newValue>")
                //     .unwrap(); // <setAttributeNS obj="testAddr" namespaceURI="namespaceURI" qualifiedName="qualifiedName" value="&quot;&lt;newValue&gt;&quot;"/>
                // r#result_attr = r#test_addr
                //     .get_attribute_ns(Some(r#namespace_uri), r#local_name)
                //     .unwrap()
                //     .unwrap(); // <getAttributeNS obj="testAddr" var="resultAttr" namespaceURI="namespaceURI" localName="localName"/>
                // assert_eq!(r#result_attr, "<newValue>"); // <assertEquals actual="resultAttr" expected="&quot;&lt;newValue&gt;&quot;" id="throw_Equals" ignoreCase="false"/>
            }
            // elementgetattributenodens03.xml
            #[test]
            fn test_elementgetattributenodens03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#child_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "employee"); // <getElementsByTagNameNS var="childList" obj="doc" localName="&quot;employee&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" interface="Document"/>
                r#element = r#child_list.item(1).unwrap(); // <item var="element" obj="childList" index="1" interface="NodeList"/>
                r#attribute = r#element
                    .get_attribute_node_ns(None, "defaultAttr")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attribute" obj="element" localName="&quot;defaultAttr&quot;" namespaceURI="nullNS"/>
                r#attr_value = r#attribute.node_value().unwrap().to_string(); // <nodeValue var="attrValue" obj="attribute"/>
                assert_eq!(r#attr_value, "defaultVal"); // <assertEquals actual="attrValue" expected="&quot;defaultVal&quot;" id="elementgetattributenodens03" ignoreCase="false"/>
            }
            // namednodemapgetnameditemns06.xml
            #[test]
            fn test_namednodemapgetnameditemns06() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes_map1; // type: NamedNodeMap // <var name="attributesMap1" type="NamedNodeMap"/>
                let mut r#attributes_map2; // type: NamedNodeMap // <var name="attributesMap2" type="NamedNodeMap"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#new_attr1; // type: Attr // <var name="newAttr1" type="Attr"/>
                let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes_map1 = r#element.attributes(); // <attributes var="attributesMap1" obj="element"/>
                r#attributes_map2 = r#element.attributes(); // <attributes var="attributesMap2" obj="element"/>
                r#new_attr1 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/L1"), "street".as_ref())
                    .unwrap(); // <createAttributeNS var="newAttr1" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" qualifiedName="&quot;street&quot;"/>
                r#new_attribute = r#element
                    .set_attribute_node_ns(r#new_attr1)
                    .unwrap()
                    .unwrap(); // <setAttributeNodeNS var="newAttribute" obj="element" newAttr="newAttr1"/>
                r#attribute = r#attributes_map1
                    .get_named_item_ns(Some("http://www.w3.org/DOM/L1"), "street")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributesMap1" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" localName="&quot;street&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                assert_eq!(r#attr_name, "street"); // <assertEquals actual="attrName" expected="&quot;street&quot;" id="namednodemapgetnameditemnsMap106" ignoreCase="false"/>
                r#attribute = r#attributes_map2
                    .get_named_item_ns(Some("http://www.w3.org/DOM/L1"), "street")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributesMap2" namespaceURI="&quot;http://www.w3.org/DOM/L1&quot;" localName="&quot;street&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                assert_eq!(r#attr_name, "street"); // <assertEquals actual="attrName" expected="&quot;street&quot;" id="namednodemapgetnameditemnsMap206" ignoreCase="false"/>
            }
            // elementgetelementsbytagnamens04.xml
            #[test]
            fn test_elementgetelementsbytagnamens04() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#child1; // type: Element // <var name="child1" type="Element"/>
                // let mut r#child2; // type: Element // <var name="child2" type="Element"/>
                // let mut r#child3; // type: Element // <var name="child3" type="Element"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#element = r#doc
                //     .create_element_ns(Some("http://www.w3.org/DOM"), "root".as_ref())
                //     .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM&quot;" qualifiedName="&quot;root&quot;"/>
                // r#child1 = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/DOM/Level1"),
                //         "dom:child".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="child1" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Level1&quot;" qualifiedName="&quot;dom:child&quot;"/>
                // r#child2 = r#doc
                //     .create_element_ns(Some(r#null_ns.as_ref()), "child".as_ref())
                //     .unwrap(); // <createElementNS var="child2" obj="doc" namespaceURI="nullNS" qualifiedName="&quot;child&quot;"/>
                // r#child3 = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/DOM/Level2"),
                //         "dom:child".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="child3" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Level2&quot;" qualifiedName="&quot;dom:child&quot;"/>
                // r#appended_child = r#element.append_child(child1.into()).unwrap(); // <appendChild var="appendedChild" obj="element" newChild="child1"/>
                // r#appended_child = r#element.append_child(child2.into()).unwrap(); // <appendChild var="appendedChild" obj="element" newChild="child2"/>
                // r#appended_child = r#element.append_child(child3.into()).unwrap(); // <appendChild var="appendedChild" obj="element" newChild="child3"/>
                // r#element_list =
                //     r#element.get_elements_by_tag_name_ns(Some(r#null_ns.as_ref()), "child".into()); // <getElementsByTagNameNS var="elementList" obj="element" namespaceURI="nullNS" localName="&quot;child&quot;" interface="Element"/>

                // // unimplemented: // <assertSize size="1" collection="elementList" id="elementgetelementsbytagnamens04_1"/>
                // r#element_list =
                //     r#element.get_elements_by_tag_name_ns(Some("*"), "child".into());
                // // <getElementsByTagNameNS var="elementList" obj="element" namespaceURI="&quot;*&quot;" localName="&quot;child&quot;" interface="Element"/>

                // // unimplemented: // <assertSize size="3" collection="elementList" id="elementgetelementsbytagnamens04_2"/>
            }
            // elementsetattributenodens05.xml
            #[test]
            fn test_elementsetattributenodens05() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_alt: DocumentRef; // <var name="docAlt" type="Document"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                // let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#doc_alt = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="docAlt" href="staffNS" willBeModified="true"/>
                // r#element = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/DOM/Test"),
                //         "elem1".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;elem1&quot;"/>
                // r#attribute = r#doc_alt
                //     .create_attribute_ns(
                //         Some("http://www.w3.org/DOM/Test"),
                //         "attr".as_ref(),
                //     )
                //     .unwrap(); // <createAttributeNS var="attribute" obj="docAlt" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;attr&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_WRONG_DOCUMENT_ERR">    <WRONG_DOCUMENT_ERR>      <setAttributeNodeNS var="newAttribute" obj="element" newAttr="attribute"/>    </WRONG_DOCUMENT_ERR>  </assertDOMException>
            }
            // createElementNS03.xml
            #[test]
            fn test_create_element_n_s03() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.wedding.com/&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#done; // type: boolean // <var name="done" type="boolean"/>
                // let mut r#new_element; // type: Element // <var name="newElement" type="Element"/>
                // let mut r#charact; // type: DOMString // <var name="charact" type="DOMString"/>
                // let mut r#illegal_q_names; // type: List // <var name="illegalQNames" type="List"><member>"person:{"</member><member>"person:}"</member><member>"person:~"</member><member>"person:'"</member><member>"person:!"</member><member>"person:@"</member><member>"person:#"</member><member>"person:$"</member><member>"person:%"</member><member>"person:^"</member><member>"person:&amp;"</member><member>"person:*"</member><member>"person:("</member><member>"person:)"</member><member>"person:+"</member><member>"person:="</member><member>"person:["</member><member>"person:]"</member><member>"person:\\"</member><member>"person:/"</member><member>"person:;"</member><member>"person:`"</member><member>"person:&lt;"</member><member>"person:&gt;"</member><member>"person:,"</member><member>"person:a "</member><member>"person:\""</member></var>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <for-each collection="illegalQNames" member="qualifiedName"><assertDOMException id="throw_INVALID_CHARACTER_ERR"><INVALID_CHARACTER_ERR><createElementNS obj="doc" var="newElement" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/></INVALID_CHARACTER_ERR></assertDOMException></for-each>
            }
            // hc_notationssetnameditemns1.xml
            #[test]
            fn test_hc_notationssetnameditemns1() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <if><not><contentType type="text/html"/></not><assertNotNull actual="docType" id="docTypeNotNull"/><notations var="notations" obj="docType"/><assertNotNull actual="notations" id="notationsNotNull"/><createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;br&quot;"/><try>	<setNamedItemNS var="retval" obj="notations" arg="elem"/>	<fail id="throw_HIER_OR_NO_MOD_ERR"/>	<catch>		<DOMException code="HIERARCHY_REQUEST_ERR"/>		<DOMException code="NO_MODIFICATION_ALLOWED_ERR"/>	</catch></try></if>
            }
            // getAttributeNS04.xml
            #[test]
            fn test_get_attribute_n_s04() {
                // let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                // let mut r#local_name = "blank"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;blank&quot;"/>
                // let mut r#qualified_name = "emp:blank"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:blank&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_attribute; // type: Attr // <var name="newAttribute" type="Attr"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                // let mut r#district_attr; // type: Attr // <var name="districtAttr" type="Attr"/>
                // let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#new_attribute = r#doc
                //     .create_attribute_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                //     .unwrap(); // <createAttributeNS obj="doc" var="newAttribute" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                // r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                // r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>

                // // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                // r#test_addr
                //     .set_attribute_ns(
                //         Some(r#namespace_uri.into()),
                //         r#qualified_name.into(),
                //         "NewValue",
                //     )
                //     .unwrap(); // <setAttributeNS obj="testAddr" namespaceURI="namespaceURI" qualifiedName="qualifiedName" value="&quot;NewValue&quot;"/>
                // r#attr_value = r#test_addr
                //     .get_attribute_ns(Some(r#namespace_uri.into()), r#local_name.into())
                //     .unwrap()
                //     .unwrap(); // <getAttributeNS obj="testAddr" var="attrValue" namespaceURI="namespaceURI" localName="localName"/>
                // assert_eq!(r#attr_value, "NewValue"); // <assertEquals actual="attrValue" expected="&quot;NewValue&quot;" id="throw_Equals" ignoreCase="false"/>
            }
            // nodenormalize01.xml
            #[test]
            fn test_nodenormalize01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#doc_type_null; // type: DocumentType // <var name="docTypeNull" type="DocumentType" isNull="true"/>
                // let mut r#document_element; // type: Element // <var name="documentElement" type="Element"/>
                // let mut r#element1; // type: Element // <var name="element1" type="Element"/>
                // let mut r#element2; // type: Element // <var name="element2" type="Element"/>
                // let mut r#element3; // type: Element // <var name="element3" type="Element"/>
                // let mut r#element4; // type: Element // <var name="element4" type="Element"/>
                // let mut r#element5; // type: Element // <var name="element5" type="Element"/>
                // let mut r#element6; // type: Element // <var name="element6" type="Element"/>
                // let mut r#element7; // type: Element // <var name="element7" type="Element"/>
                // let mut r#text1; // type: Text // <var name="text1" type="Text"/>
                // let mut r#text2; // type: Text // <var name="text2" type="Text"/>
                // let mut r#text3; // type: Text // <var name="text3" type="Text"/>
                // let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                // let mut r#c_data; // type: CDATASection // <var name="cData" type="CDATASection"/>
                // let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;dom:root&quot;" doctype="docTypeNull"/>
                // r#element1 = r#new_doc.create_element("element1".to_string()).unwrap(); // <createElement var="element1" obj="newDoc" tagName="&quot;element1&quot;"/>
                // r#element2 = r#new_doc.create_element("element2".to_string()).unwrap(); // <createElement var="element2" obj="newDoc" tagName="&quot;element2&quot;"/>
                // r#element3 = r#new_doc.create_element("element3".to_string()).unwrap(); // <createElement var="element3" obj="newDoc" tagName="&quot;element3&quot;"/>
                // r#element4 = r#new_doc.create_element("element4".to_string()).unwrap(); // <createElement var="element4" obj="newDoc" tagName="&quot;element4&quot;"/>
                // r#element5 = r#new_doc.create_element("element5".to_string()).unwrap(); // <createElement var="element5" obj="newDoc" tagName="&quot;element5&quot;"/>
                // r#element6 = r#new_doc.create_element("element6".to_string()).unwrap(); // <createElement var="element6" obj="newDoc" tagName="&quot;element6&quot;"/>
                // r#element7 = r#new_doc.create_element("element7".to_string()).unwrap(); // <createElement var="element7" obj="newDoc" tagName="&quot;element7&quot;"/>
                // r#text1 = r#new_doc.create_text_node("text1"); // <createTextNode var="text1" obj="newDoc" data="&quot;text1&quot;"/>
                // r#text2 = r#new_doc.create_text_node("text2"); // <createTextNode var="text2" obj="newDoc" data="&quot;text2&quot;"/>
                // r#text3 = r#new_doc.create_text_node("text3"); // <createTextNode var="text3" obj="newDoc" data="&quot;text3&quot;"/>
                // r#c_data = r#new_doc.create_cdata_section("Cdata").unwrap(); // <createCDATASection var="cData" obj="newDoc" data="&quot;Cdata&quot;"/>
                // r#comment = r#new_doc.create_comment("comment"); // <createComment var="comment" obj="newDoc" data="&quot;comment&quot;"/>
                // r#pi = r#new_doc
                //     .create_processing_instruction("PITarget", Some("PIData"))
                //     .unwrap(); // <createProcessingInstruction var="pi" obj="newDoc" target="&quot;PITarget&quot;" data="&quot;PIData&quot;"/>
                // r#ent_ref = r#new_doc
                //     .create_entity_reference("EntRef".to_string())
                //     .unwrap(); // <createEntityReference var="entRef" obj="newDoc" name="&quot;EntRef&quot;"/>

                // // unimplemented: // <assertNotNull actual="entRef" id="createdEntRefNotNull"/>
                // r#document_element = r#new_doc.document_element().unwrap(); // <documentElement var="documentElement" obj="newDoc"/>
                // r#appended_child = r#document_element.append_child(element1.into()).unwrap(); // <appendChild var="appendedChild" obj="documentElement" newChild="element1"/>
                // r#appended_child = r#element2.append_child(text1.into()).unwrap(); // <appendChild var="appendedChild" obj="element2" newChild="text1"/>
                // r#appended_child = r#element2.append_child(text2.into()).unwrap(); // <appendChild var="appendedChild" obj="element2" newChild="text2"/>
                // r#appended_child = r#element2.append_child(text3.into()).unwrap(); // <appendChild var="appendedChild" obj="element2" newChild="text3"/>
                // r#appended_child = r#element1.append_child(element2.into()).unwrap(); // <appendChild var="appendedChild" obj="element1" newChild="element2"/>
                // r#text1 = r#text1.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text1" obj="text1" deep="false"/>
                // r#text2 = r#text2.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text2" obj="text2" deep="false"/>
                // r#appended_child = r#element3.append_child(ent_ref.into()).unwrap(); // <appendChild var="appendedChild" obj="element3" newChild="entRef"/>
                // r#appended_child = r#element3.append_child(text1.into()).unwrap(); // <appendChild var="appendedChild" obj="element3" newChild="text1"/>
                // r#appended_child = r#element3.append_child(text2.into()).unwrap(); // <appendChild var="appendedChild" obj="element3" newChild="text2"/>
                // r#appended_child = r#element1.append_child(element3.into()).unwrap(); // <appendChild var="appendedChild" obj="element1" newChild="element3"/>
                // r#text1 = r#text1.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text1" obj="text1" deep="false"/>
                // r#text2 = r#text2.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text2" obj="text2" deep="false"/>
                // r#appended_child = r#element4.append_child(c_data.into()).unwrap(); // <appendChild var="appendedChild" obj="element4" newChild="cData"/>
                // r#appended_child = r#element4.append_child(text1.into()).unwrap(); // <appendChild var="appendedChild" obj="element4" newChild="text1"/>
                // r#appended_child = r#element4.append_child(text2.into()).unwrap(); // <appendChild var="appendedChild" obj="element4" newChild="text2"/>
                // r#appended_child = r#element1.append_child(element4.into()).unwrap(); // <appendChild var="appendedChild" obj="element1" newChild="element4"/>
                // r#text2 = r#text2.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text2" obj="text2" deep="false"/>
                // r#text3 = r#text3.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text3" obj="text3" deep="false"/>
                // r#appended_child = r#element5.append_child(comment.into()).unwrap(); // <appendChild var="appendedChild" obj="element5" newChild="comment"/>
                // r#appended_child = r#element5.append_child(text2.into()).unwrap(); // <appendChild var="appendedChild" obj="element5" newChild="text2"/>
                // r#appended_child = r#element5.append_child(text3.into()).unwrap(); // <appendChild var="appendedChild" obj="element5" newChild="text3"/>
                // r#appended_child = r#element1.append_child(element5.into()).unwrap(); // <appendChild var="appendedChild" obj="element1" newChild="element5"/>
                // r#text2 = r#text2.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text2" obj="text2" deep="false"/>
                // r#text3 = r#text3.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text3" obj="text3" deep="false"/>
                // r#appended_child = r#element6.append_child(pi.into()).unwrap(); // <appendChild var="appendedChild" obj="element6" newChild="pi"/>
                // r#appended_child = r#element6.append_child(text2.into()).unwrap(); // <appendChild var="appendedChild" obj="element6" newChild="text2"/>
                // r#appended_child = r#element6.append_child(text3.into()).unwrap(); // <appendChild var="appendedChild" obj="element6" newChild="text3"/>
                // r#appended_child = r#element1.append_child(element6.into()).unwrap(); // <appendChild var="appendedChild" obj="element1" newChild="element6"/>
                // r#ent_ref = r#ent_ref.clone_node(false).as_entity_reference().unwrap(); // <cloneNode var="entRef" obj="entRef" deep="false"/>
                // r#text1 = r#text1.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text1" obj="text1" deep="false"/>
                // r#text2 = r#text2.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text2" obj="text2" deep="false"/>
                // r#text3 = r#text3.clone_node(false).as_text_node().unwrap(); // <cloneNode var="text3" obj="text3" deep="false"/>
                // r#appended_child = r#element7.append_child(ent_ref.into()).unwrap(); // <appendChild var="appendedChild" obj="element7" newChild="entRef"/>
                // r#appended_child = r#element7.append_child(text1.into()).unwrap(); // <appendChild var="appendedChild" obj="element7" newChild="text1"/>
                // r#appended_child = r#element7.append_child(text2.into()).unwrap(); // <appendChild var="appendedChild" obj="element7" newChild="text2"/>
                // r#appended_child = r#element7.append_child(text3.into()).unwrap(); // <appendChild var="appendedChild" obj="element7" newChild="text3"/>
                // r#appended_child = r#element1.append_child(element7.into()).unwrap(); // <appendChild var="appendedChild" obj="element1" newChild="element7"/>
                // r#element_list = r#element1.child_nodes(); // <childNodes var="elementList" obj="element1"/>

                // // unimplemented: // <assertSize size="6" collection="elementList" id="nodeNormalize01_1Bef"/>
                // r#element_list = r#element2.child_nodes(); // <childNodes var="elementList" obj="element2"/>

                // // unimplemented: // <assertSize size="3" collection="elementList" id="nodeNormalize01_2Bef"/>
                // r#element_list = r#element3.child_nodes(); // <childNodes var="elementList" obj="element3"/>

                // // unimplemented: // <assertSize size="3" collection="elementList" id="nodeNormalize01_3Bef"/>
                // r#element_list = r#element4.child_nodes(); // <childNodes var="elementList" obj="element4"/>

                // // unimplemented: // <assertSize size="3" collection="elementList" id="nodeNormalize01_4Bef"/>
                // r#element_list = r#element5.child_nodes(); // <childNodes var="elementList" obj="element5"/>

                // // unimplemented: // <assertSize size="3" collection="elementList" id="nodeNormalize01_5Bef"/>
                // r#element_list = r#element6.child_nodes(); // <childNodes var="elementList" obj="element6"/>

                // // unimplemented: // <assertSize size="3" collection="elementList" id="nodeNormalize01_6Bef"/>
                // r#element_list = r#element7.child_nodes(); // <childNodes var="elementList" obj="element7"/>

                // // unimplemented: // <assertSize size="4" collection="elementList" id="nodeNormalize01_7Bef"/>
                // r#new_doc.normalize(); // <normalize obj="newDoc"/>
                // r#element_list = r#element1.child_nodes(); // <childNodes var="elementList" obj="element1"/>

                // // unimplemented: // <assertSize size="6" collection="elementList" id="nodeNormalize01_1Aft"/>
                // r#element_list = r#element2.child_nodes(); // <childNodes var="elementList" obj="element2"/>

                // // unimplemented: // <assertSize size="1" collection="elementList" id="nodeNormalize01_2Aft"/>
                // r#element_list = r#element3.child_nodes(); // <childNodes var="elementList" obj="element3"/>

                // // unimplemented: // <assertSize size="2" collection="elementList" id="nodeNormalize01_3Aft"/>
                // r#element_list = r#element4.child_nodes(); // <childNodes var="elementList" obj="element4"/>

                // // unimplemented: // <assertSize size="2" collection="elementList" id="nodeNormalize01_4Aft"/>
                // r#element_list = r#element5.child_nodes(); // <childNodes var="elementList" obj="element5"/>

                // // unimplemented: // <assertSize size="2" collection="elementList" id="nodeNormalize01_5Aft"/>
                // r#element_list = r#element6.child_nodes(); // <childNodes var="elementList" obj="element6"/>

                // // unimplemented: // <assertSize size="2" collection="elementList" id="nodeNormalize01_6Aft"/>
                // r#element_list = r#element7.child_nodes(); // <childNodes var="elementList" obj="element7"/>

                // // unimplemented: // <assertSize size="2" collection="elementList" id="nodeNormalize01_7Aft"/>
            }
            // namednodemapsetnameditemns10.xml
            #[test]
            fn test_namednodemapsetnameditemns10() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entities" obj="docType"/>

                // // unimplemented: // <assertNotNull actual="entities" id="entitiesNotNull"/>
                // r#entity = r#entities.get_named_item("ent1".into()).unwrap(); // <getNamedItem var="entity" obj="entities" name="&quot;ent1&quot;"/>
                // r#element_list = r#doc
                //     .get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;" interface="Document"/>
                // r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                // r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>

                // // unimplemented: // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR"><HIERARCHY_REQUEST_ERR><setNamedItemNS var="newNode" obj="attributes" arg="entity"/></HIERARCHY_REQUEST_ERR></assertDOMException>
            }
            // namednodemapremovenameditemns02.xml
            #[test]
            fn test_namednodemapremovenameditemns02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                let mut r#element; // type: Node // <var name="element" type="Node"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "employee"); // <getElementsByTagNameNS var="elementList" obj="doc" localName="&quot;employee&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" interface="Document"/>
                r#element = r#element_list.item(1).unwrap(); // <item var="element" obj="elementList" index="1" interface="NodeList"/>
                r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>
                r#attribute = r#attributes
                    .remove_named_item_ns(None, "defaultAttr")
                    .unwrap(); // <removeNamedItemNS var="attribute" obj="attributes" namespaceURI="nullNS" localName="&quot;defaultAttr&quot;"/>
                r#attribute = r#attributes
                    .get_named_item_ns(None, "defaultAttr")
                    .unwrap()
                    .unwrap(); // <getNamedItemNS var="attribute" obj="attributes" namespaceURI="nullNS" localName="&quot;defaultAttr&quot;"/>
                r#attr_value = r#attribute.node_value().unwrap().to_string(); // <nodeValue var="attrValue" obj="attribute"/>
                // unimplemented: // <assertNotNull actual="attribute" id="namednodemapremovenameditemns02"/>
                assert_eq!(r#attr_value, "defaultVal"); // <assertEquals actual="attrValue" expected="&quot;defaultVal&quot;" id="namednodemapremovenameditemns02_attrValue" ignoreCase="false"/>
            }
            // getElementsByTagNameNS03.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s03() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                // let mut r#result; // type: List // <var name="result" type="List"/>
                // let mut r#expected_result; // type: List // <var name="expectedResult" type="List"><member>"employee"</member><member>"employeeId"</member><member>"name"</member><member>"position"</member><member>"salary"</member><member>"gender"</member><member>"address"</member><member>"emp:employee"</member><member>"emp:employeeId"</member><member>"emp:position"</member><member>"emp:salary"</member><member>"emp:gender"</member><member>"emp:address"</member><member>"address"</member></var>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#element_list =
                //     r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "*"); // <getElementsByTagNameNS interface="Document" obj="doc" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;*&quot;" var="elementList"/>

                // // unimplemented: // <for-each collection="elementList" member="child"><nodeName obj="child" var="childName"/><append collection="result" item="childName"/></for-each>
                // assert_eq!(r#result, expected_result); // <assertEquals actual="result" expected="expectedResult" id="nodeNames" ignoreCase="false"/>
            }
            // importNode04.xml
            #[test]
            fn test_import_node04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#children; // type: NodeList // <var name="children" type="NodeList"/>
                let mut r#child; // type: Node // <var name="child" type="Node"/>
                let mut r#child_value; // type: DOMString // <var name="childValue" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="true"/>
                r#a_new_doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="aNewDoc" href="staff" willBeModified="true"/>
                r#doc_frag = r#a_new_doc.create_document_fragment(); // <createDocumentFragment obj="aNewDoc" var="docFrag"/>
                r#comment = r#a_new_doc.create_comment("descendant1"); // <createComment obj="aNewDoc" var="comment" data="&quot;descendant1&quot;"/>
                r#a_node = r#doc_frag.append_child(comment.into()).unwrap(); // <appendChild obj="docFrag" var="aNode" newChild="comment"/>
                r#a_node = r#doc.import_node(r#doc_frag.into(), true).unwrap(); // <importNode obj="doc" var="aNode" importedNode="docFrag" deep="true"/>
                r#children = r#a_node.child_nodes(); // <childNodes obj="aNode" var="children"/>

                // unimplemented: // <assertSize collection="children" size="1" id="throw_Size"/>
                r#child = r#a_node.first_child().unwrap(); // <firstChild interface="Node" obj="aNode" var="child"/>
                r#child_value = r#child.node_value().unwrap().to_string(); // <nodeValue obj="child" var="childValue"/>
                assert_eq!(r#child_value, "descendant1"); // <assertEquals actual="childValue" expected="&quot;descendant1&quot;" id="descendant1" ignoreCase="false"/>
            }
            // prefix05.xml
            #[test]
            fn test_prefix05() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#addr_node; // type: Element // <var name="addrNode" type="Element"/>
                let mut r#addr_attr; // type: Attr // <var name="addrAttr" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                r#addr_node = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="addrNode"/>
                // unimplemented: // <assertNotNull actual="addrNode" id="empAddrNotNull"/>
                r#addr_attr = r#addr_node.get_attribute_node("emp:domestic").unwrap(); // <getAttributeNode obj="addrNode" name="&quot;emp:domestic&quot;" var="addrAttr"/>

                // unimplemented:
                // <assertDOMException id="throw_NAMESPACE_ERR">
                //  <NAMESPACE_ERR>
                //      <prefix obj="addrAttr" value="&quot;xmlns&quot;"/>
                //  </NAMESPACE_ERR>
                // </assertDOMException>
            }
            // localName04.xml
            #[test]
            fn test_local_name04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_employee; // type: Node // <var name="testEmployee" type="Node"/>
                let mut r#employee_local_name; // type: DOMString // <var name="employeeLocalName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#test_employee = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testEmployee"/>
                r#employee_local_name = r#test_employee.local_name().unwrap().to_string(); // <localName obj="testEmployee" var="employeeLocalName"/>
                assert_eq!(r#employee_local_name, "employee"); // <assertEquals actual="employeeLocalName" expected="&quot;employee&quot;" id="lname" ignoreCase="false"/>
            }
            // getNamedItemNS03.xml
            #[test]
            fn test_get_named_item_n_s03() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entities" obj="docType"/>

                // // unimplemented: // <assertNotNull actual="entities" id="entitiesNotNull"/>
                // r#entity = r#entities
                //     .get_named_item_ns(Some(r#null_ns), "ent1")
                //     .unwrap()
                //     .unwrap(); // <getNamedItemNS var="entity" obj="entities" namespaceURI="nullNS" localName="&quot;ent1&quot;"/>

                // // unimplemented: // <assertNull actual="entity" id="entityNull"/>
            }
            // setAttributeNodeNS01.xml
            #[test]
            fn test_set_attribute_node_n_s01() {
                // let mut r#namespace_uri = "http://www.newattr.com"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.newattr.com&quot;"/>
                // let mut r#qualified_name = "emp:newAttr"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;emp:newAttr&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_element; // type: Element // <var name="newElement" type="Element"/>
                // let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_addr; // type: Node // <var name="testAddr" type="Node"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#set_attr1; // type: Attr // <var name="setAttr1" type="Attr"/>
                // let mut r#set_attr2; // type: Attr // <var name="setAttr2" type="Attr"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;emp:address&quot;"/>
                // r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddr" index="0"/>

                // // unimplemented: // <assertNotNull actual="testAddr" id="empAddrNotNull"/>
                // r#new_element = r#doc.create_element("newElement".to_string()).unwrap(); // <createElement obj="doc" var="newElement" tagName="&quot;newElement&quot;"/>
                // r#appended_child = r#test_addr.append_child(new_element.into()).unwrap(); // <appendChild var="appendedChild" obj="testAddr" newChild="newElement"/>
                // r#new_attr = r#doc
                //     .create_attribute_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                //     .unwrap(); // <createAttributeNS obj="doc" var="newAttr" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                // r#set_attr1 = r#new_element
                //     .set_attribute_node_ns(r#new_attr)
                //     .unwrap()
                //     .unwrap(); // <setAttributeNodeNS var="setAttr1" obj="newElement" newAttr="newAttr"/>

                // // unimplemented: // <assertDOMException id="throw_INUSE_ATTRIBUTE_ERR"><INUSE_ATTRIBUTE_ERR><setAttributeNodeNS var="setAttr2" obj="testAddr" newAttr="newAttr"/></INUSE_ATTRIBUTE_ERR></assertDOMException>
            }
            // importNode13.xml
            #[test]
            fn test_import_node13() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                // let mut r#doc1_type; // type: DocumentType // <var name="doc1Type" type="DocumentType"/>
                // let mut r#notation_list; // type: NamedNodeMap // <var name="notationList" type="NamedNodeMap"/>
                // let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                // let mut r#a_node; // type: Notation // <var name="aNode" type="Notation"/>
                // let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                // let mut r#public_val; // type: DOMString // <var name="publicVal" type="DOMString"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                // r#doc1_type = r#a_new_doc.doctype().unwrap(); // <doctype obj="aNewDoc" var="doc1Type"/>

                // // unimplemented: // <notations obj="doc1Type" var="notationList"/>

                // // unimplemented: // <assertNotNull actual="notationList" id="notationsNotNull"/>
                // r#notation = r#notation_list.get_named_item("notation1".into()).unwrap(); // <getNamedItem obj="notationList" var="notation" name="&quot;notation1&quot;"/>
                // r#a_node = r#doc
                //     .import_node(r#notation.into(), false)
                //     .unwrap()
                //     .as_notation()
                //     .unwrap(); // <importNode obj="doc" var="aNode" importedNode="notation" deep="false"/>
                // r#owner_document = r#a_node.owner_document().unwrap(); // <ownerDocument obj="aNode" var="ownerDocument"/>
                // r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                // r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>

                // // unimplemented: // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="systemId"/>
                // r#public_val = r#a_node.public_id().unwrap().to_string(); // <publicId interface="Notation" obj="aNode" var="publicVal"/>
                // assert_eq!(r#public_val, "notation1File"); // <assertEquals actual="publicVal" expected="&quot;notation1File&quot;" id="publicId" ignoreCase="false"/>
                // r#system = r#a_node.system_id().unwrap().to_string(); // <systemId interface="Notation" obj="aNode" var="system"/>

                // // unimplemented: // <assertNull actual="system" id="notationSystemId"/>
            }
            // prefix01.xml
            #[test]
            fn test_prefix01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#created_node; // type: Node // <var name="createdNode" type="Node"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#created_node = r#doc.create_element("test:employee".to_string()).unwrap(); // <createElement obj="doc" tagName="&quot;test:employee&quot;" var="createdNode"/>
                r#prefix = r#created_node.prefix(); // <prefix obj="createdNode" var="prefix"/>
                assert!(prefix.is_none()); // <assertNull actual="prefix" id="throw_Null"/>
            }
            // documentimportnode12.xml
            #[test]
            fn test_documentimportnode12() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#imported; // type: Node // <var name="imported" type="Node"/>
                let mut r#address_elem; // type: Node // <var name="addressElem" type="Node"/>
                let mut r#address_elem_children; // type: NodeList // <var name="addressElemChildren" type="NodeList"/>
                let mut r#imported_children; // type: NodeList // <var name="importedChildren" type="NodeList"/>
                let mut r#address_elem_len; // type: int // <var name="addressElemLen" type="int"/>
                let mut r#imported_len; // type: int // <var name="importedLen" type="int"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#child_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "address"); // <getElementsByTagNameNS var="childList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" interface="Document"/>
                r#address_elem = r#child_list.item(0).unwrap(); // <item var="addressElem" obj="childList" index="0" interface="NodeList"/>
                r#imported = r#doc
                    .import_node(r#address_elem.clone().into(), true)
                    .unwrap(); // <importNode var="imported" obj="doc" importedNode="addressElem" deep="true"/>
                r#address_elem_children = r#address_elem.child_nodes(); // <childNodes var="addressElemChildren" obj="addressElem"/>
                r#imported_children = r#imported.child_nodes(); // <childNodes var="importedChildren" obj="imported"/>
                r#address_elem_len = r#address_elem_children.length(); // <length var="addressElemLen" obj="addressElemChildren" interface="NodeList"/>
                r#imported_len = r#imported_children.length(); // <length var="importedLen" obj="importedChildren" interface="NodeList"/>
                assert_eq!(r#address_elem_len, imported_len); // <assertEquals actual="addressElemLen" expected="importedLen" id="documentimportnode12" ignoreCase="false"/>
            }
            // documentimportnode13.xml
            #[test]
            fn test_documentimportnode13() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#imported; // type: Node // <var name="imported" type="Node"/>
                let mut r#imported_list; // type: NodeList // <var name="importedList" type="NodeList"/>
                let mut r#employee_elem; // type: Node // <var name="employeeElem" type="Node"/>
                let mut r#imported_len; // type: int // <var name="importedLen" type="int"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#child_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "employee"); // <getElementsByTagNameNS var="childList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;employee&quot;" interface="Document"/>
                r#employee_elem = r#child_list.item(0).unwrap(); // <item var="employeeElem" obj="childList" index="0" interface="NodeList"/>
                r#imported = r#doc.import_node(r#employee_elem.into(), false).unwrap(); // <importNode var="imported" obj="doc" importedNode="employeeElem" deep="false"/>
                r#imported_list = r#imported.child_nodes(); // <childNodes var="importedList" obj="imported"/>
                r#imported_len = r#imported_list.length(); // <length var="importedLen" obj="importedList" interface="NodeList"/>
                assert_eq!(r#imported_len, 0); // <assertEquals expected="0" actual="importedLen" id="documentimportnode13" ignoreCase="false"/>
            }
            // normalize01.xml
            #[test]
            fn test_normalize01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#root; // type: Element // <var name="root" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                let mut r#text_list; // type: NodeList // <var name="textList" type="NodeList"/>
                let mut r#text_node; // type: CharacterData // <var name="textNode" type="CharacterData"/>
                let mut r#data; // type: DOMString // <var name="data" type="DOMString"/>
                r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                r#root = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="root"/>
                r#root.normalize(); // <normalize obj="root"/>
                r#element_list = r#root.get_elements_by_tag_name("name"); // <getElementsByTagName interface="Element" obj="root" tagname="&quot;name&quot;" var="elementList"/>
                r#first_child = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" index="2" var="firstChild"/>
                r#text_list = r#first_child.child_nodes(); // <childNodes obj="firstChild" var="textList"/>
                r#text_node = r#text_list.item(0).unwrap().clone().as_text_node().unwrap(); // <item interface="NodeList" obj="textList" index="0" var="textNode"/>
                r#data = r#text_node.data().to_string(); // <data interface="CharacterData" obj="textNode" var="data"/>
                assert_eq!(r#data, "Roger\n Jones"); // <assertEquals actual="data" expected="&quot;Roger\n Jones&quot;" id="data" ignoreCase="false"/>
            }
            // namespaceURI01.xml
            #[test]
            fn test_namespace_ur_i01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#test_addr; // type: Element // <var name="testAddr" type="Element"/>
                let mut r#addr_attr; // type: Attr // <var name="addrAttr" type="Attr"/>
                let mut r#attr_namespace_uri; // type: DOMString // <var name="attrNamespaceURI" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:address"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;emp:address&quot;" var="elementList"/>
                r#test_addr = r#element_list.item(0).unwrap(); // <item interface="NodeList" obj="elementList" index="0" var="testAddr"/>
                r#addr_attr = r#test_addr
                    .get_attribute_node_ns(Some("http://www.nist.gov"), "district")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS obj="testAddr" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;district&quot;" var="addrAttr"/>
                r#attr_namespace_uri = r#addr_attr.namespace_uri().unwrap().to_string(); // <namespaceURI obj="addrAttr" var="attrNamespaceURI"/>
                assert_eq!(r#attr_namespace_uri, "http://www.nist.gov"); // <assertEquals actual="attrNamespaceURI" expected="&quot;http://www.nist.gov&quot;" id="namespaceURI" ignoreCase="false"/>
            }
            // importNode09.xml
            #[test]
            fn test_import_node09() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                // let mut r#doc1_type; // type: DocumentType // <var name="doc1Type" type="DocumentType"/>
                // let mut r#entity_list; // type: NamedNodeMap // <var name="entityList" type="NamedNodeMap"/>
                // let mut r#entity2; // type: Entity // <var name="entity2" type="Entity"/>
                // let mut r#entity1; // type: Entity // <var name="entity1" type="Entity"/>
                // let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                // let mut r#entity_name; // type: DOMString // <var name="entityName" type="DOMString"/>
                // let mut r#public_val; // type: DOMString // <var name="publicVal" type="DOMString"/>
                // let mut r#notation_name; // type: DOMString // <var name="notationName" type="DOMString"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                // r#doc_type = r#a_new_doc.doctype().unwrap(); // <doctype obj="aNewDoc" var="docType"/>

                // // unimplemented: // <entities obj="docType" var="entityList"/>

                // // unimplemented: // <assertNotNull actual="entityList" id="entitiesNotNull"/>
                // r#entity2 = r#entity_list.get_named_item("ent6".into()).unwrap(); // <getNamedItem obj="entityList" var="entity2" name="&quot;ent6&quot;"/>
                // r#entity1 = r#doc
                //     .import_node(r#entity2.into(), false)
                //     .unwrap()
                //     .as_entity()
                //     .unwrap(); // <importNode obj="doc" var="entity1" importedNode="entity2" deep="false"/>
                // r#owner_document = r#entity1.owner_document().unwrap(); // <ownerDocument obj="entity1" var="ownerDocument"/>
                // r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                // r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>

                // // unimplemented: // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="dtdSystemId"/>
                // r#entity_name = r#entity1.node_name().to_string(); // <nodeName obj="entity1" var="entityName"/>
                // assert_eq!(r#entity_name, "ent6"); // <assertEquals actual="entityName" expected="&quot;ent6&quot;" ignoreCase="false" id="entityName"/>
                // r#public_val = r#entity1.public_id().unwrap().to_string(); // <publicId interface="Entity" obj="entity1" var="publicVal"/>
                // assert_eq!(r#public_val, "uri"); // <assertEquals actual="publicVal" expected="&quot;uri&quot;" ignoreCase="false" id="entityPublicId"/>
                // r#system = r#entity1.system_id().unwrap().to_string(); // <systemId interface="Entity" obj="entity1" var="system"/>

                // // unimplemented: // <assertURIEquals actual="system" file="&quot;file&quot;" id="entitySystemId"/>
                // r#notation_name = r#entity1.notation_name().unwrap().to_string(); // <notationName obj="entity1" var="notationName"/>
                // assert_eq!(r#notation_name, "notation2"); // <assertEquals actual="notationName" expected="&quot;notation2&quot;" ignoreCase="false" id="notationName"/>
            }
            // getElementById02.xml
            #[test]
            fn test_get_element_by_id02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element = r#doc.get_element_by_id("Cancun".as_ref()); // <getElementById interface="Document" obj="doc" var="element" elementId="&quot;Cancun&quot;"/>
                assert!(element.is_none()); // <assertNull actual="element" id="throw_Null"/>
            }
            // attrgetownerelement03.xml
            #[test]
            fn test_attrgetownerelement03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#owner_element; // type: Node // <var name="ownerElement" type="Node"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#attr = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM"), "dom:attr".as_ref())
                    .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM&quot;" qualifiedName="&quot;dom:attr&quot;"/>
                r#owner_element = r#attr.owner_element(); // <ownerElement var="ownerElement" obj="attr"/>
                assert!(owner_element.is_none()); // <assertNull actual="ownerElement" id="attrgetownerelement03"/>
            }
            // elementgetattributens02.xml
            #[test]
            fn test_elementgetattributens02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#child_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "employee"); // <getElementsByTagNameNS var="childList" obj="doc" localName="&quot;employee&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" interface="Document"/>
                r#element = r#child_list.item(1).unwrap(); // <item var="element" obj="childList" index="1" interface="NodeList"/>
                r#attr_value = r#element.get_attribute_ns(None, "defaultAttr").unwrap(); // <getAttributeNS var="attrValue" obj="element" localName="&quot;defaultAttr&quot;" namespaceURI="nullNS"/>
                assert_eq!(r#attr_value, "defaultVal"); // <assertEquals actual="attrValue" expected="&quot;defaultVal&quot;" id="elementgetattributens02" ignoreCase="false"/>
            }
            // getElementsByTagNameNS06.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s06() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nomatch.com"), "address");
                // <getElementsByTagNameNS interface="Document" obj="doc" namespaceURI="&quot;http://www.nomatch.com&quot;" localName="&quot;address&quot;" var="elementList"/>

                // unimplemented: // <assertSize collection="elementList" size="0" id="matchSize"/>
            }
            // isSupported11.xml
            #[test]
            fn test_is_supported11() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                // r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>

                // // unimplemented: // <isSupported obj="rootNode" feature="&quot;XML&quot;" version="&quot;2.0&quot;" var="state"/>
                // assert!(r#state); // <assertTrue actual="state" id="throw_True"/>
            }
            // documentimportnode01.xml
            #[test]
            fn test_documentimportnode01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#imported_attr; // type: Node // <var name="importedAttr" type="Node"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#child_list =
                    r#doc.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="childList" obj="doc" localName="&quot;address&quot;" namespaceURI="&quot;http://www.nist.gov&quot;" interface="Document"/>
                r#element = r#child_list.item(1).unwrap(); // <item var="element" obj="childList" index="1" interface="NodeList"/>
                r#attr = r#element.get_attribute_node("street").unwrap(); // <getAttributeNode var="attr" obj="element" name="&quot;street&quot;"/>
                r#imported_attr = r#doc.import_node(r#attr.into(), false).unwrap(); // <importNode var="importedAttr" obj="doc" importedNode="attr" deep="false"/>
                r#node_name = r#imported_attr.node_name().to_string(); // <nodeName var="nodeName" obj="importedAttr"/>
                r#node_value = r#imported_attr.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="importedAttr"/>
                r#node_type = r#imported_attr.node_type(); // <nodeType var="nodeType" obj="importedAttr"/>
                assert_eq!(r#node_name, "street"); // <assertEquals expected="&quot;street&quot;" actual="nodeName" id="documentimportnode01_nodeName" ignoreCase="false"/>
                assert_eq!(r#node_type as i32, 2); // <assertEquals expected="2" actual="nodeType" id="documentimportnode01_nodeType" ignoreCase="false"/>
                assert_eq!(r#node_value, "Yes"); // <assertEquals expected="&quot;Yes&quot;" actual="nodeValue" id="documentimportnode01_nodeValue" ignoreCase="false"/>
            }
            // elementsetattributens03.xml
            #[test]
            fn test_elementsetattributens03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:employee"); // <getElementsByTagName var="elementList" obj="doc" tagname="&quot;emp:employee&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                // unimplemented: // <assertNotNull actual="element" id="empEmployeeNotNull"/>
                r#element
                    .set_attribute_ns(
                        Some("http://www.w3.org/DOM/Test/1"),
                        "defaultAttr",
                        "default1",
                    )
                    .unwrap(); // <setAttributeNS obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/1&quot;" qualifiedName="&quot;defaultAttr&quot;" value="&quot;default1&quot;"/>
                r#element
                    .set_attribute_ns(
                        Some("http://www.w3.org/DOM/Test/2"),
                        "defaultAttr",
                        "default2",
                    )
                    .unwrap(); // <setAttributeNS obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/2&quot;" qualifiedName="&quot;defaultAttr&quot;" value="&quot;default2&quot;"/>
                r#attribute = r#element
                    .get_attribute_node_ns(Some("http://www.w3.org/DOM/Test/1"), "defaultAttr")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attribute" obj="element" namespaceURI="&quot;http://www.w3.org/DOM/Test/1&quot;" localName="&quot;defaultAttr&quot;"/>
                r#attr_name = r#attribute.node_name().to_string(); // <nodeName var="attrName" obj="attribute"/>
                r#attr_value = r#attribute.node_value().unwrap().to_string(); // <nodeValue var="attrValue" obj="attribute"/>
                assert_eq!(r#attr_name, "defaultAttr"); // <assertEquals actual="attrName" expected="&quot;defaultAttr&quot;" id="elementsetattributens03_attrName" ignoreCase="false"/>
                assert_eq!(r#attr_value, "default1"); // <assertEquals actual="attrValue" expected="&quot;default1&quot;" id="elementsetattributens03_attrValue" ignoreCase="false"/>
            }
            // getElementsByTagNameNS09.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s09() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_list; // type: NodeList // <var name="newList" type="NodeList"/>
                let mut r#new_element; // type: Element // <var name="newElement" type="Element"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                let mut r#lname; // type: DOMString // <var name="lname" type="DOMString"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#new_list = r#doc_elem
                    .get_elements_by_tag_name_ns(Some("*"), "employee")
                    .unwrap(); // <getElementsByTagNameNS interface="Element" obj="docElem" var="newList" namespaceURI="&quot;*&quot;" localName="&quot;employee&quot;"/>

                // unimplemented: // <assertSize collection="newList" size="5" id="employeeCount"/>
                r#new_element = r#new_list.item(3).unwrap(); // <item interface="NodeList" obj="newList" var="newElement" index="3"/>
                r#prefix = r#new_element.prefix().unwrap().to_string(); // <prefix obj="newElement" var="prefix"/>
                assert_eq!(r#prefix, "emp"); // <assertEquals actual="prefix" expected="&quot;emp&quot;" id="prefix" ignoreCase="false"/>
                r#lname = r#new_element.local_name().unwrap().to_string(); // <localName obj="newElement" var="lname"/>
                assert_eq!(r#lname, "employee"); // <assertEquals actual="lname" expected="&quot;employee&quot;" id="lname" ignoreCase="false"/>
            }
            // documentimportnode19.xml
            #[test]
            fn test_documentimportnode19() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type_null; // type: DocumentType // <var name="docTypeNull" type="DocumentType" isNull="true"/>
                // let mut r#doc_imp: DocumentRef; // <var name="docImp" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#node_map; // type: NamedNodeMap // <var name="nodeMap" type="NamedNodeMap"/>
                // let mut r#entity2; // type: Entity // <var name="entity2" type="Entity"/>
                // let mut r#entity6; // type: Entity // <var name="entity6" type="Entity"/>
                // let mut r#entity_imp2; // type: Entity // <var name="entityImp2" type="Entity"/>
                // let mut r#entity_imp6; // type: Entity // <var name="entityImp6" type="Entity"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#system_id; // type: DOMString // <var name="systemId" type="DOMString"/>
                // let mut r#notation_name; // type: DOMString // <var name="notationName" type="DOMString"/>
                // let mut r#node_name_imp; // type: DOMString // <var name="nodeNameImp" type="DOMString"/>
                // let mut r#system_id_imp; // type: DOMString // <var name="systemIdImp" type="DOMString"/>
                // let mut r#notation_name_imp; // type: DOMString // <var name="notationNameImp" type="DOMString"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <createDocument var="docImp" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;a:b&quot;" doctype="docTypeNull"/>

                // // unimplemented: // <entities var="nodeMap" obj="docType"/>

                // // unimplemented: // <assertNotNull actual="nodeMap" id="entitiesNotNull"/>
                // r#entity2 = r#node_map.get_named_item("ent2".into()).unwrap(); // <getNamedItem var="entity2" obj="nodeMap" name="&quot;ent2&quot;"/>
                // r#entity6 = r#node_map.get_named_item("ent6".into()).unwrap(); // <getNamedItem var="entity6" obj="nodeMap" name="&quot;ent6&quot;"/>
                // r#entity_imp2 = r#doc_imp
                //     .import_node(r#entity2.into(), false)
                //     .unwrap()
                //     .as_entity()
                //     .unwrap(); // <importNode var="entityImp2" obj="docImp" importedNode="entity2" deep="false"/>
                // r#entity_imp6 = r#doc_imp
                //     .import_node(r#entity6.into(), true)
                //     .unwrap()
                //     .as_entity()
                //     .unwrap(); // <importNode var="entityImp6" obj="docImp" importedNode="entity6" deep="true"/>
                // r#node_name = r#entity2.node_name().to_string(); // <nodeName var="nodeName" obj="entity2"/>
                // r#node_name_imp = r#entity_imp2.node_name().to_string(); // <nodeName var="nodeNameImp" obj="entityImp2"/>
                // assert_eq!(r#node_name_imp, node_name); // <assertEquals expected="nodeName" actual="nodeNameImp" id="documentimportnode19_Ent2NodeName" ignoreCase="false"/>
                // r#node_name = r#entity6.node_name().to_string(); // <nodeName var="nodeName" obj="entity6"/>
                // r#node_name_imp = r#entity_imp6.node_name().to_string(); // <nodeName var="nodeNameImp" obj="entityImp6"/>
                // assert_eq!(r#node_name_imp, node_name); // <assertEquals expected="nodeName" actual="nodeNameImp" id="documentimportnode19_Ent6NodeName" ignoreCase="false"/>
                // r#system_id = r#entity2.system_id().unwrap().to_string(); // <systemId var="systemId" obj="entity2" interface="Entity"/>
                // r#system_id_imp = r#entity_imp2.system_id().unwrap().to_string(); // <systemId var="systemIdImp" obj="entityImp2" interface="Entity"/>
                // assert_eq!(r#system_id_imp, system_id); // <assertEquals expected="systemId" actual="systemIdImp" id="documentimportnode19_Ent2SystemId" ignoreCase="false"/>
                // r#system_id = r#entity6.system_id().unwrap().to_string(); // <systemId var="systemId" obj="entity6" interface="Entity"/>
                // r#system_id_imp = r#entity_imp6.system_id().unwrap().to_string(); // <systemId var="systemIdImp" obj="entityImp6" interface="Entity"/>
                // assert_eq!(r#system_id_imp, system_id); // <assertEquals expected="systemId" actual="systemIdImp" id="documentimportnode19_Ent6SystemId" ignoreCase="false"/>
                // r#notation_name = r#entity2.notation_name().unwrap(); // <notationName var="notationName" obj="entity2" interface="Entity"/>
                // r#notation_name_imp = r#entity_imp2.notation_name().unwrap(); // <notationName var="notationNameImp" obj="entityImp2" interface="Entity"/>
                // assert_eq!(r#notation_name_imp, notation_name); // <assertEquals expected="notationName" actual="notationNameImp" id="documentimportnode19_Ent2NotationName" ignoreCase="false"/>
                // r#notation_name = r#entity6.notation_name().unwrap(); // <notationName var="notationName" obj="entity6" interface="Entity"/>
                // r#notation_name_imp = r#entity_imp6.notation_name().unwrap(); // <notationName var="notationNameImp" obj="entityImp6" interface="Entity"/>
                // assert_eq!(r#notation_name_imp, notation_name); // <assertEquals expected="notationName" actual="notationNameImp" id="documentimportnode19_Ent6NotationName" ignoreCase="false"/>
            }
            // createDocumentType04.xml
            #[test]
            fn test_create_document_type04() {
                // let mut r#public_id; // type: DOMString // <var name="publicId" type="DOMString" value="&quot;http://www.example.com/&quot;"/>
                // let mut r#system_id; // type: DOMString // <var name="systemId" type="DOMString" value="&quot;myDoc.dtd&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType" isNull="true"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <assertDOMException id="throw_INVALID_CHARACTER_ERR"><INVALID_CHARACTER_ERR><createDocumentType obj="domImpl" var="docType" qualifiedName="&quot;&quot;" publicId="publicId" systemId="systemId"/></INVALID_CHARACTER_ERR></assertDOMException>
            }
            // prefix10.xml
            #[test]
            fn test_prefix10() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#employee_node; // type: Node // <var name="employeeNode" type="Node"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("employee"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;employee&quot;" var="elementList"/>
                r#employee_node = r#element_list.item(1).unwrap(); // <item interface="NodeList" obj="elementList" index="1" var="employeeNode"/>

                // unimplemented: // <assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><prefix obj="employeeNode" value="&quot;xml&quot;"/></NAMESPACE_ERR></assertDOMException>
            }
            // createAttributeNS03.xml
            #[test]
            fn test_create_attribute_n_s03() {
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.wedding.com/&quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                // let mut r#illegal_q_names; // type: List // <var name="illegalQNames" type="List"><member>"person:{"</member><member>"person:}"</member><member>"person:~"</member><member>"person:'"</member><member>"person:!"</member><member>"person:@"</member><member>"person:#"</member><member>"person:$"</member><member>"person:%"</member><member>"person:^"</member><member>"person:&amp;"</member><member>"person:*"</member><member>"person:("</member><member>"person:)"</member><member>"person:+"</member><member>"person:="</member><member>"person:["</member><member>"person:]"</member><member>"person:\\"</member><member>"person:/"</member><member>"person:;"</member><member>"person:`"</member><member>"person:&lt;"</member><member>"person:&gt;"</member><member>"person:,"</member><member>"person:a "</member><member>"person:\""</member></var>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <for-each collection="illegalQNames" member="qualifiedName"><assertDOMException id="throw_INVALID_CHARACTER_ERR"><INVALID_CHARACTER_ERR><createAttributeNS obj="doc" var="newAttr" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/></INVALID_CHARACTER_ERR></assertDOMException></for-each>
            }
            // getElementsByTagNameNS11.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s11() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                // let mut r#result; // type: List // <var name="result" type="List"/>
                // let mut r#expected_result; // type: List // <var name="expectedResult" type="List"><member>"address"</member><member>"address"</member><member>"address"</member><member>"emp:address"</member><member>"address"</member></var>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#element_list = r#doc_elem
                //     .get_elements_by_tag_name_ns(Some("*"), "address".into())
                //     .unwrap(); // <getElementsByTagNameNS interface="Element" obj="docElem" namespaceURI="&quot;*&quot;" localName="&quot;address&quot;" var="elementList"/>

                // // unimplemented: // <for-each collection="elementList" member="child"><nodeName obj="child" var="childName"/><append collection="result" item="childName"/></for-each>
                // assert_eq!(r#result, expected_result); // <assertEquals actual="result" expected="expectedResult" id="nodeNames" ignoreCase="false"/>
            }
            // getElementsByTagNameNS05.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s05() {
                let mut r#namespace_uri = "http://www.nist.gov"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.nist.gov&quot;"/>
                let mut r#local_name = "nomatch"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;nomatch&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#element_list =
                    r#doc.get_elements_by_tag_name_ns(Some(r#namespace_uri), r#local_name.as_ref()); // <getElementsByTagNameNS interface="Document" obj="doc" namespaceURI="namespaceURI" localName="localName" var="elementList"/>

                // unimplemented: // <assertSize collection="elementList" size="0" id="throw_Size"/>
            }
            // documentcreateelementNS06.xml
            #[test]
            fn test_documentcreateelement_n_s06() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType" isNull="true"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/xml/1998/namespace &quot;"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;xml:root&quot;"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;dom:doc&quot;" doctype="docType"/>

                // // unimplemented: // <assertDOMException id="documentcreateelementNS06"><NAMESPACE_ERR><createElementNS obj="newDoc" var="element" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/></NAMESPACE_ERR></assertDOMException>
            }
            // documentimportnode15.xml
            #[test]
            fn test_documentimportnode15() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_imp: DocumentRef; // <var name="docImp" type="Document"/>
                let mut r#text_import; // type: Node // <var name="textImport" type="Node"/>
                let mut r#text_to_import; // type: Node // <var name="textToImport" type="Node"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_imp = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="docImp" href="staffNS" willBeModified="true"/>
                r#text_to_import =
                    r#doc.create_text_node("Document.importNode test for a TEXT_NODE"); // <createTextNode var="textToImport" obj="doc" data="&quot;Document.importNode test for a TEXT_NODE&quot;"/>
                r#text_import = r#doc.import_node(r#text_to_import.into(), true).unwrap(); // <importNode var="textImport" obj="doc" importedNode="textToImport" deep="true"/>
                r#node_value = r#text_import.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="textImport"/>
                assert_eq!(r#node_value, "Document.importNode test for a TEXT_NODE");
                // <assertEquals expected="&quot;Document.importNode test for a TEXT_NODE&quot;" actual="nodeValue" id="documentimportnode15" ignoreCase="false"/>
            }
            // domimplementationcreatedocument07.xml
            #[test]
            fn test_domimplementationcreatedocument07() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/DOMTest/level2&quot;"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <assertDOMException id="domimplementationcreatedocument07"><NAMESPACE_ERR><createDocument obj="domImpl" var="newDoc" namespaceURI="namespaceURI" qualifiedName="&quot;:&quot;" doctype="docType"/></NAMESPACE_ERR></assertDOMException>
            }
            // namednodemapsetnameditemns11.xml
            #[test]
            fn test_namednodemapsetnameditemns11() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <notations var="notations" obj="docType"/>

                // // unimplemented: // <assertNotNull actual="notations" id="notationsNotNull"/>
                // r#notation = r#notations.get_named_item("notation1".into()).unwrap(); // <getNamedItem var="notation" obj="notations" name="&quot;notation1&quot;"/>
                // r#element_list = r#doc
                //     .get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address"); // <getElementsByTagNameNS var="elementList" obj="doc" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;" interface="Document"/>
                // r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                // r#attributes = r#element.attributes(); // <attributes var="attributes" obj="element"/>

                // // unimplemented: // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR"><HIERARCHY_REQUEST_ERR><setNamedItemNS var="newNode" obj="attributes" arg="notation"/></HIERARCHY_REQUEST_ERR></assertDOMException>
            }
            // documentgetelementsbytagnameNS01.xml
            #[test]
            fn test_documentgetelementsbytagname_n_s01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType" isNull="true"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="nullNS" qualifiedName="&quot;root&quot;" doctype="docType"/>
                // r#child_list = r#new_doc.get_elements_by_tag_name_ns(Some("*"), "*".into());
                // // <getElementsByTagNameNS var="childList" obj="newDoc" namespaceURI="&quot;*&quot;" localName="&quot;*&quot;" interface="Document"/>

                // // unimplemented: // <assertSize size="1" collection="childList" id="documentgetelementsbytagnameNS01"/>
            }
            // nodesetprefix03.xml
            #[test]
            fn test_nodesetprefix03() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element = r#doc.create_element("address".to_string()).unwrap(); // <createElement var="element" obj="doc" tagName="&quot;address&quot;"/>

                // unimplemented: // <assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><prefix obj="element" value="&quot;test&quot;"/></NAMESPACE_ERR></assertDOMException>
            }
            // nodeissupported01.xml
            #[test]
            fn test_nodeissupported01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#version; // type: DOMString // <var name="version" type="DOMString" value="&quot;&quot;"/>
                // let mut r#version1; // type: DOMString // <var name="version1" type="DOMString" value="&quot;1.0&quot;"/>
                // let mut r#version2; // type: DOMString // <var name="version2" type="DOMString" value="&quot;2.0&quot;"/>
                // let mut r#feature_core; // type: DOMString // <var name="featureCore" type="DOMString"/>
                // let mut r#feature_xml; // type: DOMString // <var name="featureXML" type="DOMString"/>
                // let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                // let mut r#features_xml; // type: List // <var name="featuresXML" type="List"><member>"XML"</member><member>"xmL"</member></var>
                // let mut r#features_core; // type: List // <var name="featuresCore" type="List"><member>"Core"</member><member>"CORE"</member></var>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                // r#element = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="element"/>

                // // unimplemented: // <for-each collection="featuresXML" member="featureXML"><isSupported obj="element" var="success" feature="featureXML" version="version"/><assertTrue actual="success" id="nodeissupported01_XML1"/><isSupported obj="element" var="success" feature="featureXML" version="version1"/><assertTrue actual="success" id="nodeissupported01_XML2"/></for-each>

                // // unimplemented: // <for-each collection="featuresCore" member="featureCore"><isSupported obj="element" var="success" feature="featureCore" version="version"/><assertTrue actual="success" id="nodeissupported01_Core1"/><!--   isSupported("Core", "1.0") is unspecified since "Core" was not defined in L1  --><isSupported obj="element" var="success" feature="featureCore" version="version1"/><isSupported obj="element" var="success" feature="featureCore" version="version2"/><assertTrue actual="success" id="nodeissupported01_Core3"/></for-each>
            }
            // documentimportnode05.xml
            #[test]
            fn test_documentimportnode05() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_imported: DocumentRef; // <var name="docImported" type="Document"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#imported_attr; // type: Node // <var name="importedAttr" type="Node"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#doc_imported = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="docImported" href="staff" willBeModified="true"/>
                r#attr = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/DOM/Test"), "a_:b0".as_ref())
                    .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;a_:b0&quot;"/>
                r#imported_attr = r#doc_imported.import_node(r#attr.into(), false).unwrap(); // <importNode var="importedAttr" obj="docImported" importedNode="attr" deep="false"/>
                r#node_name = r#imported_attr.node_name().to_string(); // <nodeName var="nodeName" obj="importedAttr"/>
                r#node_value = r#imported_attr.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="importedAttr"/>
                r#node_type = r#imported_attr.node_type(); // <nodeType var="nodeType" obj="importedAttr"/>
                r#namespace_uri = r#imported_attr.namespace_uri().unwrap().to_string(); // <namespaceURI var="namespaceURI" obj="importedAttr"/>
                assert_eq!(r#node_name, "a_:b0"); // <assertEquals expected="&quot;a_:b0&quot;" actual="nodeName" id="documentimportnode05_nodeName" ignoreCase="false"/>
                assert_eq!(r#node_type as i32, 2); // <assertEquals expected="2" actual="nodeType" id="documentimportnode05_nodeType" ignoreCase="false"/>
                assert_eq!(r#node_value, ""); // <assertEquals expected="&quot;&quot;" actual="nodeValue" id="documentimportnode05_nodeValue" ignoreCase="false"/>
                assert_eq!(r#namespace_uri, "http://www.w3.org/DOM/Test"); // <assertEquals expected="&quot;http://www.w3.org/DOM/Test&quot;" actual="namespaceURI" id="documentimportnode05_namespaceURI" ignoreCase="false"/>
            }
            // documentcreateattributeNS02.xml
            #[test]
            fn test_documentcreateattribute_n_s02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attribute1; // type: Attr // <var name="attribute1" type="Attr"/>
                let mut r#attribute2; // type: Attr // <var name="attribute2" type="Attr"/>
                let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#attribute1 = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/XML/1998/namespace"),
                        "xml:xml".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS obj="doc" var="attribute1" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:xml&quot;"/>
                r#name = r#attribute1.name().to_string(); // <name var="name" obj="attribute1" interface="Attr"/>
                r#node_name = r#attribute1.node_name().to_string(); // <nodeName var="nodeName" obj="attribute1"/>
                r#node_value = r#attribute1.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="attribute1"/>
                r#prefix = r#attribute1.prefix().unwrap().to_string(); // <prefix var="prefix" obj="attribute1"/>
                r#namespace_uri = r#attribute1.namespace_uri().unwrap().to_string(); // <namespaceURI var="namespaceURI" obj="attribute1"/>
                assert_eq!(r#name, "xml:xml"); // <assertEquals actual="name" expected="&quot;xml:xml&quot;" id="documentcreateattributeNS02_att1_name" ignoreCase="false"/>
                assert_eq!(r#node_name, "xml:xml"); // <assertEquals actual="nodeName" expected="&quot;xml:xml&quot;" id="documentcreateattributeNS02_att1_nodeName" ignoreCase="false"/>
                assert_eq!(r#node_value, ""); // <assertEquals actual="nodeValue" expected="&quot;&quot;" id="documentcreateattributeNS02_att1_nodeValue" ignoreCase="false"/>
                assert_eq!(r#prefix, "xml"); // <assertEquals actual="prefix" expected="&quot;xml&quot;" id="documentcreateattributeNS02_att1_prefix" ignoreCase="false"/>
                assert_eq!(r#namespace_uri, "http://www.w3.org/XML/1998/namespace"); // <assertEquals actual="namespaceURI" expected="&quot;http://www.w3.org/XML/1998/namespace&quot;" id="documentcreateattributeNS02_att1_namespaceURI" ignoreCase="false"/>
                r#attribute2 = r#doc
                    .create_attribute_ns(Some("http://www.w3.org/2000/xmlns/"), "xmlns".as_ref())
                    .unwrap(); // <createAttributeNS obj="doc" var="attribute2" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" qualifiedName="&quot;xmlns&quot;"/>
                r#name = r#attribute2.name().to_string(); // <name var="name" obj="attribute2" interface="Attr"/>
                r#node_name = r#attribute2.node_name().to_string(); // <nodeName var="nodeName" obj="attribute2"/>
                r#node_value = r#attribute2.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="attribute2"/>
                // r#prefix = r#attribute2.prefix(); // <prefix var="prefix" obj="attribute2"/>
                r#namespace_uri = r#attribute2.namespace_uri().unwrap().to_string(); // <namespaceURI var="namespaceURI" obj="attribute2"/>
                assert_eq!(r#name, "xmlns"); // <assertEquals actual="name" expected="&quot;xmlns&quot;" id="documentcreateattributeNS02_att2_name" ignoreCase="false"/>
                assert_eq!(r#node_name, "xmlns"); // <assertEquals actual="nodeName" expected="&quot;xmlns&quot;" id="documentcreateattributeNS02_att2_nodeName" ignoreCase="false"/>
                assert_eq!(r#node_value, ""); // <assertEquals actual="nodeValue" expected="&quot;&quot;" id="documentcreateattributeNS02_att2_nodeValue" ignoreCase="false"/>
                assert_eq!(r#namespace_uri, "http://www.w3.org/2000/xmlns/"); // <assertEquals actual="namespaceURI" expected="&quot;http://www.w3.org/2000/xmlns/&quot;" id="documentcreateattributeNS02_att2_namespaceURI" ignoreCase="false"/>
            }
            // isSupported02.xml
            #[test]
            fn test_is_supported02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#root_node; // type: Node // <var name="rootNode" type="Node"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = staff_xml(STAFF_XML).unwrap(); // staff.xml // <load var="doc" href="staff" willBeModified="false"/>
                // r#root_node = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="rootNode"/>

                // // unimplemented: // <isSupported obj="rootNode" feature="&quot;XML&quot;" version="&quot;9.0&quot;" var="state"/>
                // assert!(!r#state); // <assertFalse actual="state" id="throw_False"/>
            }
            // createAttributeNS05.xml
            #[test]
            fn test_create_attribute_n_s05() {
                let mut r#namespace_uri = "http://www.ecommerce.org/"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.ecommerce.org/&quot;"/>
                let mut r#qualified_name = "econm:local"; // type: DOMString // <var name="qualifiedName" type="DOMString" value="&quot;econm:local&quot;"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                let mut r#attr_name; // type: DOMString // <var name="attrName" type="DOMString"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#new_attr = r#doc
                    .create_attribute_ns(Some(r#namespace_uri), r#qualified_name.as_ref())
                    .unwrap(); // <createAttributeNS obj="doc" var="newAttr" namespaceURI="namespaceURI" qualifiedName="qualifiedName"/>
                r#attr_name = r#new_attr.name().to_string(); // <name interface="Attr" obj="newAttr" var="attrName"/>
                assert_eq!(r#attr_name, qualified_name); // <assertEquals actual="attrName" expected="qualifiedName" id="throw_Equals" ignoreCase="false"/>
            }
            // removeNamedItemNS03.xml
            #[test]
            fn test_remove_named_item_n_s03() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#namespace_uri = "http://www.w3.org/2000/xmlns/"; // type: DOMString // <var name="namespaceURI" type="DOMString" value="&quot;http://www.w3.org/2000/xmlns/&quot;"/>
                // let mut r#local_name = "local1"; // type: DOMString // <var name="localName" type="DOMString" value="&quot;local1&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#test_address; // type: Node // <var name="testAddress" type="Node"/>
                // let mut r#n_list; // type: NodeList // <var name="nList" type="NodeList"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#n2_list; // type: NodeList // <var name="n2List" type="NodeList"/>
                // let mut r#child2; // type: Node // <var name="child2" type="Node"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                // let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element_list = r#doc.get_elements_by_tag_name("gender"); // <getElementsByTagName interface="Document" obj="doc" var="elementList" tagname="&quot;gender&quot;"/>
                // r#test_address = r#element_list.item(2).unwrap(); // <item interface="NodeList" obj="elementList" var="testAddress" index="2"/>
                // r#n_list = r#test_address.child_nodes(); // <childNodes obj="testAddress" var="nList"/>
                // r#child = r#n_list[0].clone(); // <item interface="NodeList" obj="nList" var="child" index="0"/>
                // r#node_type = r#child.node_type(); // <nodeType var="nodeType" obj="child"/>

                // // unimplemented: // <if><equals actual="nodeType" expected="1" ignoreCase="false"/>	<createEntityReference var="child" name="&quot;ent4&quot;" obj="doc"/>	<assertNotNull actual="child" id="createdEntRefNotNull"/></if>
                // r#n2_list = r#child.child_nodes(); // <childNodes obj="child" var="n2List"/>
                // r#child2 = r#n2_list[0].clone(); // <item interface="NodeList" obj="n2List" var="child2" index="0"/>

                // // unimplemented: // <assertNotNull actual="child2" id="notnull"/>
                // r#attributes = r#child2.attributes(); // <attributes obj="child2" var="attributes"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR"><NO_MODIFICATION_ALLOWED_ERR><removeNamedItemNS var="removedNode" interface="NamedNodeMap" obj="attributes" namespaceURI="namespaceURI" localName="localName"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // importNode01.xml
            #[test]
            fn test_import_node01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#a_new_doc: DocumentRef; // <var name="aNewDoc" type="Document"/>
                // let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                // let mut r#imported_child; // type: Text // <var name="importedChild" type="Text"/>
                // let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                // let mut r#owner_document: DocumentRef; // <var name="ownerDocument" type="Document"/>
                // let mut r#attr_owner_element; // type: Element // <var name="attrOwnerElement" type="Element"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#system; // type: DOMString // <var name="system" type="DOMString"/>
                // let mut r#specified; // type: boolean // <var name="specified" type="boolean"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#child_value; // type: DOMString // <var name="childValue" type="DOMString"/>
                // let mut r#result; // type: List // <var name="result" type="List"/>
                // let mut r#expected_result; // type: List // <var name="expectedResult" type="List"><member>"elem:attr1"</member><member>"importedText"</member></var>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#a_new_doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="aNewDoc" href="staffNS" willBeModified="true"/>
                // r#new_attr = r#a_new_doc
                //     .create_attribute("elem:attr1".to_string())
                //     .unwrap(); // <createAttribute obj="aNewDoc" var="newAttr" name="&quot;elem:attr1&quot;"/>
                // r#imported_child = r#a_new_doc.create_text_node("importedText"); // <createTextNode obj="aNewDoc" var="importedChild" data="&quot;importedText&quot;"/>
                // r#a_node = r#new_attr.append_child(imported_child.into()).unwrap(); // <appendChild obj="newAttr" var="aNode" newChild="importedChild"/>
                // let r#a_node = r#doc
                //     .import_node(r#new_attr.into(), false)
                //     .unwrap()
                //     .as_attribute()
                //     .unwrap(); // <importNode obj="doc" var="aNode" importedNode="newAttr" deep="false"/>
                // r#owner_document = r#a_node.owner_document().unwrap(); // <ownerDocument obj="aNode" var="ownerDocument"/>
                // r#doc_type = r#owner_document.doctype().unwrap(); // <doctype obj="ownerDocument" var="docType"/>
                // r#system = r#doc_type.system_id().unwrap().to_string(); // <systemId interface="DocumentType" obj="docType" var="system"/>

                // // unimplemented: // <assertNotNull actual="aNode" id="aNode"/>

                // // unimplemented: // <assertURIEquals actual="system" file="&quot;staffNS.dtd&quot;" id="systemId"/>
                // r#attr_owner_element = r#a_node.owner_element().unwrap(); // <ownerElement obj="aNode" var="attrOwnerElement"/>

                // // unimplemented: // <assertNull actual="attrOwnerElement" id="ownerElement"/>
                // r#specified = r#a_node.specified(); // <specified obj="aNode" var="specified"/>
                // assert!(r#specified); // <assertTrue actual="specified" id="specified"/>
                // r#child_list = r#a_node.child_nodes(); // <childNodes obj="aNode" var="childList"/>

                // // unimplemented: // <assertSize collection="childList" size="1" id="childList"/>
                // r#node_name = r#a_node.node_name().to_string(); // <nodeName obj="aNode" var="nodeName"/>
                // assert_eq!(r#node_name, "elem:attr1"); // <assertEquals actual="nodeName" id="nodeName" ignoreCase="false" expected="&quot;elem:attr1&quot;"/>
                // r#child = r#a_node.first_child().unwrap(); // <firstChild interface="Node" obj="aNode" var="child"/>
                // r#child_value = r#child.node_value().unwrap().to_string(); // <nodeValue obj="child" var="childValue"/>
                // assert_eq!(r#child_value, "importedText"); // <assertEquals actual="childValue" id="childValue" ignoreCase="false" expected="&quot;importedText&quot;"/>
            }
            // nodesetprefix04.xml
            #[test]
            fn test_nodesetprefix04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attribute; // type: Attr // <var name="attribute" type="Attr"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                r#element_list = r#doc.get_elements_by_tag_name("emp:employee"); // <getElementsByTagName var="elementList" obj="doc" tagname="&quot;emp:employee&quot;" interface="Document"/>
                r#element = r#element_list.item(0).unwrap(); // <item var="element" obj="elementList" index="0" interface="NodeList"/>
                // unimplemented: // <assertNotNull actual="element" id="empEmployeeNotNull"/>
                r#attribute = r#element
                    .get_attribute_node_ns(None, "defaultAttr")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attribute" obj="element" namespaceURI="nullNS" localName="&quot;defaultAttr&quot;"/>

                // unimplemented: // <assertDOMException id="nodesetprefix04"><NAMESPACE_ERR><prefix obj="attribute" value="&quot;test&quot;"/></NAMESPACE_ERR></assertDOMException>
            }
            // documentimportnode14.xml
            #[test]
            fn test_documentimportnode14() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#imported; // type: Node // <var name="imported" type="Node"/>
                // let mut r#employee_elem; // type: Node // <var name="employeeElem" type="Node"/>
                // let mut r#attr_node; // type: Attr // <var name="attrNode" type="Attr"/>
                // let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#child_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "employee"); // <getElementsByTagNameNS var="childList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;employee&quot;" interface="Document"/>
                // r#employee_elem = r#child_list.item(3).unwrap().clone(); // <item var="employeeElem" obj="childList" index="3" interface="NodeList"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="nullNS" qualifiedName="&quot;staff&quot;" doctype="nullDocType"/>
                // r#imported = r#new_doc
                //     .import_node(r#employee_elem.into(), true)
                //     .unwrap()
                //     .as_element()
                //     .unwrap(); // <importNode var="imported" obj="newDoc" importedNode="employeeElem" deep="true"/>
                // r#attr_node = r#imported
                //     .get_attribute_node_ns(Some(r#null_ns), "defaultAttr".into())
                //     .unwrap()
                //     .unwrap(); // <getAttributeNodeNS var="attrNode" obj="imported" namespaceURI="nullNS" localName="&quot;defaultAttr&quot;"/>

                // // unimplemented: // <assertNull actual="attrNode" id="defaultAttrNotImported"/>
                // r#attr_value = r#imported
                //     .get_attribute_ns(Some("http://www.w3.org/2000/xmlns/".into()), "emp".into())
                //     .unwrap()
                //     .unwrap(); // <getAttributeNS var="attrValue" obj="imported" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" localName="&quot;emp&quot;"/>
                // assert_eq!(r#attr_value, "http://www.nist.gov"); // <assertEquals actual="attrValue" expected="&quot;http://www.nist.gov&quot;" ignoreCase="false" id="explicitAttrImported"/>
            }
            // documentgetelementsbytagnameNS05.xml
            #[test]
            fn test_documentgetelementsbytagname_n_s05() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#child_list = r#doc.get_elements_by_tag_name_ns(Some("null"), "elementId"); // <getElementsByTagNameNS var="childList" obj="doc" namespaceURI="&quot;null&quot;" localName="&quot;elementId&quot;" interface="Document"/>

                // unimplemented: // <assertSize size="0" collection="childList" id="documentgetelementsbytagnameNS05"/>
            }
            // nodesetprefix09.xml
            #[test]
            fn test_nodesetprefix09() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#value; // type: DOMString // <var name="value" type="DOMString" value="&quot;#$%&amp;'()@&quot;"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="true"/>
                // r#element = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/DOM/Test/L2"),
                //         "dom:elem".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test/L2&quot;" qualifiedName="&quot;dom:elem&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_INVALID_CHARACTER_ERR"><INVALID_CHARACTER_ERR><prefix obj="element" value="value"/></INVALID_CHARACTER_ERR></assertDOMException>
            }
            // getElementsByTagNameNS14.xml
            #[test]
            fn test_get_elements_by_tag_name_n_s14() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                r#doc = staff_ns_xml(STAFF_NS_XML).unwrap(); // staffNS.xml // <load var="doc" href="staffNS" willBeModified="false"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#element_list =
                    r#doc_elem.get_elements_by_tag_name_ns(Some("http://www.nist.gov"), "address");
                // <getElementsByTagNameNS interface="Element" obj="docElem" namespaceURI="&quot;http://www.nist.gov&quot;" localName="&quot;address&quot;" var="elementList"/>

                // unimplemented: // <assertSize collection="elementList" size="3" id="addresses"/>
            }
        }
    }
    mod level3 {
        use super::*;
        mod core {
            use exml::dom::{named_node_map::NamedNodeMap, node_list::NodeList};

            use super::*;
            // documentadoptnode05.xml
            #[test]
            fn test_documentadoptnode05() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#element_emp; // type: Element // <var name="elementEmp" type="Element"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#dir; // type: Attr // <var name="dir" type="Attr"/>
                // let mut r#adopted_attr; // type: Node // <var name="adoptedAttr" type="Node"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#node_namespace_uri; // type: DOMString // <var name="nodeNamespaceURI" type="DOMString"/>
                // let mut r#node_prefix; // type: DOMString // <var name="nodePrefix" type="DOMString"/>
                // let mut r#attr_owner_elem; // type: Element // <var name="attrOwnerElem" type="Element"/>
                // let mut r#is_specified; // type: boolean // <var name="isSpecified" type="boolean"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#child_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#element_emp = r#child_list.item(3).unwrap().clone(); // <item var="elementEmp" obj="childList" index="3" interface="NodeList"/>
                // r#dir = r#element_emp.get_attribute_node("dir").unwrap(); // <getAttributeNode var="dir" obj="elementEmp" name="&quot;dir&quot;"/>
                // r#adopted_attr = r#new_doc.adopt_node(r#dir.into()); // <adoptNode var="adoptedAttr" obj="newDoc" source="dir"/>

                // // unimplemented: // <if><notNull obj="adoptedAttr"/><nodeName var="nodeName" obj="adoptedAttr"/><namespaceURI var="nodeNamespaceURI" obj="adoptedAttr" interface="Node"/><prefix var="nodePrefix" obj="adoptedAttr"/><ownerElement var="attrOwnerElem" obj="adoptedAttr" interface="Attr"/><specified var="isSpecified" obj="adoptedAttr"/><assertEquals expected="&quot;dir&quot;" actual="nodeName" id="documentadoptnode05_nodeName" ignoreCase="false"/><assertNull actual="nodeNamespaceURI" id="documentadoptnode05_namespaceURI"/><assertNull actual="nodePrefix" id="documentadoptnode05_prefix"/><assertNull actual="attrOwnerElem" id="documentadoptnode05_ownerDoc"/><assertTrue actual="isSpecified" id="documentadoptnode05_specified"/></if>
            }
            // nodelookupprefix18.xml
            #[test]
            fn test_nodelookupprefix18() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#elem = r#elem_list.item(3).unwrap(); // <item var="elem" obj="elemList" index="3" interface="NodeList"/>
                r#attributes_map = r#elem.attributes(); // <attributes var="attributesMap" obj="elem"/>
                r#attr = r#attributes_map.get_named_item("dir").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;dir&quot;"/>
                r#prefix = r#attr
                    .lookup_prefix("http://www.w3.org/1999/xhtml")
                    .unwrap()
                    .to_string(); // <lookupPrefix var="prefix" obj="attr" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>

                // unimplemented: // <assertNull actual="prefix" id="xhtmlPrefixIsNull"/>
                r#prefix = r#attr
                    .lookup_prefix("http://www.altavista.com")
                    .unwrap()
                    .to_string(); // <lookupPrefix var="prefix" obj="attr" namespaceURI="&quot;http://www.altavista.com&quot;"/>
                assert_eq!(r#prefix, "nm"); // <assertEquals actual="prefix" expected="&quot;nm&quot;" id="nodelookupprefixB18" ignoreCase="false"/>
            }
            // nodeinsertbefore25.xml
            #[test]
            fn test_nodeinsertbefore25() {
                // // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#e_ref; // type: EntityReference // <var name="eRef" type="EntityReference"/>
                // let mut r#span; // type: Element // <var name="span" type="Element"/>
                // let mut r#span_text; // type: Text // <var name="spanText" type="Text"/>
                // let mut r#new_node; // type: Element // <var name="newNode" type="Element"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#inserted; // type: Node // <var name="inserted" type="Node"/>
                // r#doc = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#child_list = r#doc.get_elements_by_tag_name("var"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;var&quot;" interface="Document"/>
                // r#element = r#child_list.item(2).unwrap().clone(); // <item var="element" obj="childList" index="2" interface="NodeList"/>
                // r#e_ref = r#element.first_child().unwrap(); // <firstChild var="eRef" obj="element" interface="Node"/>
                // r#span = r#e_ref.first_child().unwrap(); // <firstChild var="span" obj="eRef" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="span" id="spanNotNull"/>
                // r#span_text = r#span.first_child().unwrap(); // <firstChild var="spanText" obj="span" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="spanText" id="spanTextNotNull"/>
                // r#new_node = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "span".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="newNode" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;span&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR"><NO_MODIFICATION_ALLOWED_ERR><insertBefore obj="span" var="inserted" refChild="spanText" newChild="newNode"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // typeinfoisderivedfrom05.xml
            #[test]
            fn test_typeinfoisderivedfrom05() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(0).unwrap(); // <item var="acronymElem" obj="elemList" index="0" interface="NodeList"/>
                // r#attr = r#acronym_elem.get_attribute_node("title").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;title&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "string"); // <assertEquals actual="typeName" expected="&quot;string&quot;" ignoreCase="false" id="nameIsString"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anyType&quot;" derivationMethod="1"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromAnyTypeRestrictionOnly"/>
            }
            // nodeisdefaultnamespace08.xml
            #[test]
            fn test_nodeisdefaultnamespace08() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#is_default; // type: boolean // <var name="isDefault" type="boolean"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#elem = r#elem_list.item(3).unwrap(); // <item var="elem" obj="elemList" index="3" interface="NodeList"/>
                r#is_default = r#elem.is_default_namespace("http://www.altavista.com"); // <isDefaultNamespace var="isDefault" obj="elem" namespaceURI="&quot;http://www.altavista.com&quot;"/>
                assert!(!r#is_default); // <assertFalse actual="isDefault" id="nodeisdefaultnamespace08"/>
            }
            // datatypenormalization03.xml
            #[test]
            fn test_datatypenormalization03() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#str; // type: DOMString // <var name="str" type="DOMString"/>
                // let mut r#can_set_normalization; // type: boolean // <var name="canSetNormalization" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#can_set_xml_schema; // type: boolean // <var name="canSetXMLSchema" type="boolean"/>
                // let mut r#xsd_ns; // type: DOMString // <var name="xsdNS" type="DOMString" value="&quot;http://www.w3.org/2001/XMLSchema&quot;"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // r#doc = todo!(); // datatype_normalization.xml // <load var="doc" href="datatype_normalization" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetNormalization" obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetValidate" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetXMLSchema" obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>

                // // unimplemented: // <if>	<and>		<isTrue value="canSetNormalization"/>		<isTrue value="canSetValidate"/>		<isTrue value="canSetXMLSchema"/>	</and>	<setParameter obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>		<normalizeDocument obj="doc"/>	<!--  fail test if normalize had any errors or fatal errors   -->	<assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>		<getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;http://www.w3.org/2001/DOM-Test-Suite/Level-3/datatype_normalization&quot;" localName="&quot;boolean&quot;" interface="Document"/>	<item var="element" obj="elemList" interface="NodeList" index="0"/>	<getAttribute var="str" obj="element" name="&quot;value&quot;"/>	<assertEquals actual="str" expected="&quot;true&quot;" ignoreCase="false" id="firstValue"/>	<getAttribute var="str" obj="element" name="&quot;union&quot;"/>	<assertEquals actual="str" expected="&quot;false&quot;" ignoreCase="false" id="firstUnion"/>	<textContent var="str" obj="element"/>	<assertEquals actual="str" expected="&quot;false true false&quot;" ignoreCase="false" id="firstList"/>		<item var="element" obj="elemList" interface="NodeList" index="1"/>	<getAttribute var="str" obj="element" name="&quot;value&quot;"/>	<assertEquals actual="str" expected="&quot;1&quot;" ignoreCase="false" id="secondValue"/>	<getAttribute var="str" obj="element" name="&quot;union&quot;"/>	<assertEquals actual="str" expected="&quot;0&quot;" ignoreCase="false" id="secondUnion"/>	<textContent var="str" obj="element"/>	<assertEquals actual="str" expected="&quot;0 1 0&quot;" ignoreCase="false" id="secondList"/>	</if>
            }
            // nodeisequalnode26.xml
            #[test]
            fn test_nodeisequalnode26() {
                // let mut r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                // let mut r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                // let mut r#doc_type1; // type: DocumentType // <var name="docType1" type="DocumentType"/>
                // let mut r#doc_type2; // type: DocumentType // <var name="docType2" type="DocumentType"/>
                // let mut r#notations_map1; // type: NamedNodeMap // <var name="notationsMap1" type="NamedNodeMap"/>
                // let mut r#notations_map2; // type: NamedNodeMap // <var name="notationsMap2" type="NamedNodeMap"/>
                // let mut r#notation1; // type: Notation // <var name="notation1" type="Notation"/>
                // let mut r#notation2; // type: Notation // <var name="notation2" type="Notation"/>
                // let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                // r#doc1 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc1" href="hc_staff" willBeModified="false"/>
                // r#doc2 = hc_staff_xml(HC_STAFF_XML).unwrap(); // hc_staff.xml // <load var="doc2" href="hc_staff" willBeModified="false"/>
                // r#doc_type1 = r#doc1.doctype().unwrap(); // <doctype var="docType1" obj="doc1"/>
                // r#doc_type2 = r#doc2.doctype().unwrap(); // <doctype var="docType2" obj="doc2"/>

                // // unimplemented: // <notations var="notationsMap1" obj="docType1"/>

                // // unimplemented: // <notations var="notationsMap2" obj="docType2"/>
                // r#notation1 = r#notations_map1.get_named_item("notation1".into()).unwrap(); // <getNamedItem var="notation1" obj="notationsMap1" name="&quot;notation1&quot;"/>
                // r#notation2 = r#notations_map2.get_named_item("notation1".into()).unwrap(); // <getNamedItem var="notation2" obj="notationsMap2" name="&quot;notation1&quot;"/>
                // r#is_equal = r#notation1.is_equal_node(&r#notation2.into()); // <isEqualNode var="isEqual" obj="notation1" arg="notation2"/>
                // assert!(r#is_equal); // <assertTrue actual="isEqual" id="nodeisequalnode26"/>
            }
            // nodeisdefaultnamespace01.xml
            #[test]
            fn test_nodeisdefaultnamespace01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#is_default; // type: boolean // <var name="isDefault" type="boolean"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#doc_elem_ns; // type: DOMString // <var name="docElemNS" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#doc_elem_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="docElemNS" obj="docElem" interface="Node"/>
                r#is_default = r#doc.is_default_namespace(r#doc_elem_ns.as_ref()); // <isDefaultNamespace var="isDefault" obj="doc" namespaceURI="docElemNS"/>
                assert!(r#is_default); // <assertTrue actual="isDefault" id="nodeisdefaultnamespace01"/>
            }
            // canonicalform04.xml
            #[test]
            fn test_canonicalform04() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#xmlns_attr; // type: Attr // <var name="xmlnsAttr" type="Attr"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;canonical-form&quot;" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/><setParameter obj="domConfig" name="&quot;canonical-form&quot;" value="true"/><normalizeDocument obj="doc"/><!--  fail test if normalize had any errors or fatal errors   --><assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/><documentElement var="docElem" obj="doc"/><getAttributeNode var="xmlnsAttr" obj="docElem" name="&quot;xmlns&quot;"/><assertNotNull actual="xmlnsAttr" id="xmlnsAttrNotNull"/></if>
            }
            // entities01.xml
            #[test]
            fn test_entities01() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#ent2; // type: Entity // <var name="ent2" type="Entity"/>
                // let mut r#doctype; // type: DocumentType // <var name="doctype" type="DocumentType"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;entities&quot;" value="true"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" interface="NodeList" index="0"/>
                // r#ent_ref = r#doc.create_entity_reference("ent1".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent1&quot;"/>
                // r#child = r#p_elem.append_child(ent_ref.into()).unwrap(); // <appendChild var="child" obj="pElem" newChild="entRef"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" interface="NodeList" index="0"/>
                // r#child = r#p_elem.last_child().unwrap(); // <lastChild var="child" obj="pElem" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="child" id="lastChildNotNull"/>
                // r#child_name = r#child.node_name().to_string(); // <nodeName var="childName" obj="child"/>
                // assert_eq!(r#child_name, "ent1"); // <assertEquals actual="childName" expected="&quot;ent1&quot;" ignoreCase="false" id="firstChild"/>
                // r#doctype = r#doc.doctype().unwrap(); // <doctype var="doctype" obj="doc"/>

                // // unimplemented: // <entities var="entities" obj="doctype"/>
                // r#ent2 = r#entities.get_named_item("ent2".into()).unwrap(); // <getNamedItem var="ent2" obj="entities" name="&quot;ent2&quot;"/>

                // // unimplemented: // <assertNotNull actual="ent2" id="ent2NotNull"/>
            }
            // nodeisequalnode18.xml
            #[test]
            fn test_nodeisequalnode18() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#attr1; // type: Attr // <var name="attr1" type="Attr"/>
                // let mut r#attr2; // type: Attr // <var name="attr2" type="Attr"/>
                // let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#null_nsuri; // type: DOMString // <var name="nullNSURI" type="DOMString" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#attr1 = r#doc
                //     .create_attribute_ns(Some(r#null_nsuri.as_ref()), "title".as_ref())
                //     .unwrap(); // <createAttributeNS var="attr1" obj="doc" namespaceURI="nullNSURI" qualifiedName="&quot;title&quot;"/>
                // r#attr2 = r#new_doc.adopt_node(r#attr1.into()); // <adoptNode var="attr2" obj="newDoc" source="attr1"/>

                // // unimplemented: // <if><notNull obj="attr2"/><isEqualNode var="isEqual" obj="attr1" arg="attr2"/><assertTrue actual="isEqual" id="nodeisequalnode18"/></if>
            }
            // nodeisdefaultnamespace07.xml
            #[test]
            fn test_nodeisdefaultnamespace07() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#is_default; // type: boolean // <var name="isDefault" type="boolean"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>
                r#is_default = r#elem.is_default_namespace("http://www.w3.org/1999/xhtml"); // <isDefaultNamespace var="isDefault" obj="elem" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>
                assert!(r#is_default); // <assertTrue actual="isDefault" id="nodeisdefaultnamespace07_1"/>
                r#is_default = r#elem.is_default_namespace("http://www.usa.com"); // <isDefaultNamespace var="isDefault" obj="elem" namespaceURI="&quot;http://www.usa.com&quot;"/>
                assert!(!r#is_default); // <assertFalse actual="isDefault" id="nodeisdefaultnamespace07_2"/>
            }
            // documentsetxmlversion05.xml
            #[test]
            fn test_documentsetxmlversion05() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_SUPPORTED_ERR">	<NOT_SUPPORTED_ERR>		<xmlVersion obj="newDoc" value="&quot;-&quot;" interface="Document"/>	</NOT_SUPPORTED_ERR></assertDOMException>
            }
            // nodegettextcontent02.xml
            #[test]
            fn test_nodegettextcontent02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#text_content = r#new_doc.text_content().unwrap(); // <textContent var="textContent" obj="newDoc"/>

                // // unimplemented: // <assertNull actual="textContent" id="nodegettextcontent02"/>
            }
            // elementsetidattributenode04.xml
            #[test]
            fn test_elementsetidattributenode04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#name_elem; // type: Element // <var name="nameElem" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#name_elem = r#elem_list.item(1).unwrap(); // <item var="nameElem" obj="elemList" index="1" interface="NodeList"/>
                r#name_elem
                    .set_attribute_ns(
                        Some("http://www.w3.org/2000/xmlns/"),
                        "xmlns:middle",
                        "http://www.example.com/middle",
                    )
                    .unwrap(); // <setAttributeNS obj="nameElem" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" qualifiedName="&quot;xmlns:middle&quot;" value="&quot;http://www.example.com/middle&quot;"/>
                r#attributes_map = r#name_elem.attributes(); // <attributes var="attributesMap" obj="nameElem"/>
                r#attr = r#attributes_map.get_named_item("xmlns:middle").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;xmlns:middle&quot;"/>
                r#name_elem.set_id_attribute_node(r#attr, true).unwrap(); // <setIdAttributeNode obj="nameElem" idAttr="attr" isId="true"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributenodeIsIdTrue04"/>
                r#elem = r#doc
                    .get_element_by_id("http://www.example.com/middle".as_ref())
                    .unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;http://www.example.com/middle&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "strong"); // <assertEquals actual="elemName" expected="&quot;strong&quot;" id="elementsetidattributenodeGetElementById04" ignoreCase="false"/>
                r#elem.set_id_attribute_node(r#attr, false).unwrap(); // <setIdAttributeNode obj="elem" idAttr="attr" isId="false"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(!r#id); // <assertFalse actual="id" id="elementsetidattributenodeIsIdFalse04"/>
            }
            // nodegettextcontent10.xml
            #[test]
            fn test_nodegettextcontent10() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>
                r#txt = r#elem.first_child().unwrap(); // <firstChild var="txt" obj="elem" interface="Node"/>
                r#text_content = r#txt.text_content().unwrap(); // <textContent var="textContent" obj="txt"/>
                assert_eq!(r#text_content, "EMP0001"); // <assertEquals actual="textContent" expected="&quot;EMP0001&quot;" id="nodegettextcontent10" ignoreCase="false"/>
            }
            // textreplacewholetext07.xml
            #[test]
            fn test_textreplacewholetext07() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#item_list; // type: NodeList // <var name="itemList" type="NodeList"/>
                let mut r#element_name; // type: Element // <var name="elementName" type="Element"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#eref_node; // type: EntityReference // <var name="erefNode" type="EntityReference"/>
                let mut r#replaced_text; // type: Text // <var name="replacedText" type="Text"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#node; // type: Node // <var name="node" type="Node"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#item_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="itemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#element_name = r#item_list.item(0).unwrap(); // <item var="elementName" obj="itemList" index="0" interface="NodeList"/>
                r#eref_node = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference var="erefNode" obj="doc" name="&quot;ent4&quot;"/>
                r#text_node = r#doc.create_text_node("New Text"); // <createTextNode var="textNode" obj="doc" data="&quot;New Text&quot;"/>
                r#appended_child = r#element_name.append_child(eref_node.into()).unwrap(); // <appendChild obj="elementName" var="appendedChild" newChild="erefNode"/>
                r#appended_child = r#element_name.append_child(text_node.into()).unwrap(); // <appendChild obj="elementName" var="appendedChild" newChild="textNode"/>
                r#text_node = r#element_name
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild var="textNode" obj="elementName" interface="Node"/>
                r#replaced_text = r#text_node
                    .replace_whole_text("New Text and Cdata")
                    .unwrap()
                    .unwrap(); // <replaceWholeText obj="textNode" var="replacedText" content="&quot;New Text and Cdata&quot;"/>
                r#text_node = r#element_name
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild var="textNode" obj="elementName" interface="Node"/>

                // unimplemented: // <assertSame expected="textNode" actual="replacedText" id="retval_same"/>
                r#node_value = r#text_node.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="textNode"/>
                assert_eq!(r#node_value, "New Text and Cdata"); // <assertEquals actual="nodeValue" expected="&quot;New Text and Cdata&quot;" id="nodeValueSame" ignoreCase="false"/>
                r#node = r#text_node.next_sibling().unwrap(); // <nextSibling var="node" obj="textNode" interface="Node"/>

                // unimplemented: // <assertNotNull actual="node" id="secondChildNotNull"/>
                r#node_type = r#node.node_type(); // <nodeType var="nodeType" obj="node"/>
                assert_eq!(r#node_type as i32, 5); // <assertEquals actual="nodeType" expected="5" id="secondChildIsEntRef" ignoreCase="false"/>
            }
            // domstringlistcontains01.xml
            #[test]
            fn test_domstringlistcontains01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#param_list; // type: DOMStringList // <var name="paramList" type="DOMStringList"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#contains; // type: boolean // <var name="contains" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <parameterNames obj="domConfig" var="paramList"/>

                // // unimplemented: // <contains var="contains" obj="paramList" str="&quot;comments&quot;" interface="DOMStringList"/>
                // assert!(r#contains); // <assertTrue actual="contains" id="paramsContainComments"/>

                // // unimplemented: // <contains var="contains" obj="paramList" str="&quot;&quot;" interface="DOMStringList"/>
                // assert!(!r#contains); // <assertFalse actual="contains" id="paramsDoesntContainEmpty"/>
            }
            // nodegettextcontent15.xml
            #[test]
            fn test_nodegettextcontent15() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // unimplemented: // <implementationAttribute name="expandEntityReferences" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#cdata; // type: CDATASection // <var name="cdata" type="CDATASection"/>
                let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test"), "dom3:elem".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;dom3:elem&quot;"/>
                r#txt = r#doc.create_text_node("Text "); // <createTextNode var="txt" obj="doc" data="&quot;Text &quot;"/>
                r#comment = r#doc.create_comment("Comment "); // <createComment var="comment" obj="doc" data="&quot;Comment &quot;"/>
                r#ent_ref = r#doc.create_entity_reference("beta".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;beta&quot;"/>
                r#pi = r#doc
                    .create_processing_instruction("PIT", Some("PIData "))
                    .unwrap(); // <createProcessingInstruction var="pi" obj="doc" target="&quot;PIT&quot;" data="&quot;PIData &quot;"/>
                r#cdata = r#doc.create_cdata_section("CData").unwrap(); // <createCDATASection var="cdata" obj="doc" data="&quot;CData&quot;"/>
                r#appended_child = r#elem.append_child(txt.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="txt"/>
                r#appended_child = r#elem.append_child(comment.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="comment"/>
                r#appended_child = r#elem.append_child(ent_ref.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="entRef"/>
                r#appended_child = r#elem.append_child(pi.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="pi"/>
                r#appended_child = r#elem.append_child(cdata.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="cdata"/>
                r#text_content = r#elem.text_content().unwrap(); // <textContent var="textContent" obj="elem"/>
                r#doc.normalize_document(); // <normalizeDocument obj="doc"/>
                assert_eq!(r#text_content, "Text CData"); // <assertEquals actual="textContent" expected="&quot;Text CData&quot;" id="nodegettextcontent15" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom56.xml
            #[test]
            fn test_typeinfoisderivedfrom56() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // typeinfo.xml // <load var="doc" href="typeinfo" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anyType&quot;" derivationMethod="2"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromAnyExtension"/>
            }
            // nodeisequalnode28.xml
            #[test]
            fn test_nodeisequalnode28() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#text1; // type: Text // <var name="text1" type="Text"/>
                let mut r#text2; // type: Text // <var name="text2" type="Text"/>
                let mut r#text3; // type: Text // <var name="text3" type="Text"/>
                let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#text1 = r#doc.create_text_node(""); // <createTextNode var="text1" obj="doc" data="&quot;&quot;"/>
                r#text2 = r#doc.create_text_node(""); // <createTextNode var="text2" obj="doc" data="&quot;&quot;"/>
                r#text3 = r#doc.create_text_node("#Text"); // <createTextNode var="text3" obj="doc" data="&quot;#Text&quot;"/>
                r#is_equal = r#text1.is_equal_node(&r#text2.into()); // <isEqualNode var="isEqual" obj="text1" arg="text2"/>
                assert!(r#is_equal); // <assertTrue actual="isEqual" id="nodeisequalnodeTrue28"/>
                r#is_equal = r#text1.is_equal_node(&r#text3.into()); // <isEqualNode var="isEqual" obj="text1" arg="text3"/>
                assert!(!r#is_equal); // <assertFalse actual="isEqual" id="nodeisequalnodeFalse28"/>
            }
            // nodeisequalnode05.xml
            #[test]
            fn test_nodeisequalnode05() {
                let mut r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let mut r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                r#doc1 = todo!(); // barfoo_standalone_yes.xml // <load var="doc1" href="barfoo_standalone_yes" willBeModified="false"/>
                r#doc2 = todo!(); // barfoo.xml // <load var="doc2" href="barfoo" willBeModified="false"/>
                r#is_equal = r#doc1.is_equal_node(&r#doc2.into()); // <isEqualNode var="isEqual" obj="doc1" arg="doc2"/>
                assert!(!r#is_equal); // <assertFalse actual="isEqual" id="nodeisequalnode05"/>
            }
            // documentsetdocumenturi02.xml
            #[test]
            fn test_documentsetdocumenturi02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_uri; // type: DOMString // <var name="docURI" type="DOMString"/>
                // let mut r#null_value; // type: DOMString // <var name="nullValue" type="DOMString" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc.set_document_uri(r#null_value).unwrap(); // <documentURI obj="doc" value="nullValue"/>
                // r#doc_uri = r#doc.document_uri().unwrap().to_string(); // <documentURI var="docURI" obj="doc"/>

                // // unimplemented: // <assertNull actual="docURI" id="documentsetdocumenturi02"/>
            }
            // typeinfoisderivedfrom36.xml
            #[test]
            fn test_typeinfoisderivedfrom36() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anyType&quot;" derivationMethod="15"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromAnyTypeAnyMethod"/>
            }
            // nodegetbaseuri12.xml
            #[test]
            fn test_nodegetbaseuri12() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#base_uri; // type: DOMString // <var name="baseURI" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#entity = r#entities_map.get_named_item("epsilon".into()).unwrap(); // <getNamedItem var="entity" obj="entitiesMap" name="&quot;epsilon&quot;"/>
                // r#base_uri = r#entity.base_uri().unwrap().to_string(); // <baseURI var="baseURI" obj="entity" interface="Node"/>

                // // unimplemented: // <assertURIEquals actual="baseURI" id="entityBase" isAbsolute="true" name="&quot;hc_staff&quot;"/>
            }
            // typeinfoisderivedfrom59.xml
            #[test]
            fn test_typeinfoisderivedfrom59() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#code_elem; // type: Element // <var name="codeElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // typeinfo.xml // <load var="doc" href="typeinfo" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("code"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;code&quot;" interface="Document"/>
                // r#code_elem = r#elem_list.item(0).unwrap(); // <item var="codeElem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="codeElem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;integer&quot;" derivationMethod="4"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="isDerived"/>
            }
            // nodeisequalnode08.xml
            #[test]
            fn test_nodeisequalnode08() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // unimplemented: // <implementationAttribute name="ignoringElementContentWhitespace" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem1; // type: Element // <var name="elem1" type="Element"/>
                let mut r#elem2; // type: Element // <var name="elem2" type="Element"/>
                let mut r#employee_list; // type: NodeList // <var name="employeeList" type="NodeList"/>
                let mut r#text; // type: Text // <var name="text" type="Text"/>
                let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#employee_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="employeeList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                r#elem1 = r#employee_list.item(0).unwrap(); // <item var="elem1" obj="employeeList" index="0" interface="NodeList"/>
                r#elem2 = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "em".as_ref())
                    .unwrap(); // <createElementNS var="elem2" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;em&quot;"/>
                r#text = r#doc.create_text_node("EMP0001"); // <createTextNode var="text" obj="doc" data="&quot;EMP0001&quot;"/>
                r#appended_child = r#elem2.append_child(text.into()).unwrap(); // <appendChild obj="elem2" var="appendedChild" newChild="text"/>
                r#is_equal = r#elem1.is_equal_node(&r#elem2.into()); // <isEqualNode var="isEqual" obj="elem1" arg="elem2"/>
                assert!(r#is_equal); // <assertTrue actual="isEqual" id="nodeisequalnode08"/>
            }
            // nodeinsertbefore14.xml
            #[test]
            fn test_nodeinsertbefore14() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                // let mut r#inserted; // type: Node // <var name="inserted" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                // r#new_attr = r#doc
                //     .create_attribute_ns(
                //         Some("http://www.w3.org/DOM/Test"),
                //         "dom3:attr".as_ref(),
                //     )
                //     .unwrap(); // <createAttributeNS var="newAttr" obj="doc" qualifiedName="&quot;dom3:attr&quot;" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;"/>

                // // unimplemented: // <assertDOMException id="NO_MODIFICATION_ALLOWED_ERR_nodeinsertbefore14"><NO_MODIFICATION_ALLOWED_ERR><insertBefore obj="docType" var="inserted" newChild="newAttr" refChild="docType"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // documentgetxmlencoding02.xml
            #[test]
            fn test_documentgetxmlencoding02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#encoding_name; // type: DOMString // <var name="encodingName" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#encoding_name = r#new_doc.xml_encoding().unwrap().to_string();
                // // <xmlEncoding obj="newDoc" var="encodingName" interface="Document"/>

                // // unimplemented: // <assertNull actual="encodingName" id="documentgetxmlencoding02"/>
            }
            // elementsetidattributenode03.xml
            #[test]
            fn test_elementsetidattributenode03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#name_elem; // type: Element // <var name="nameElem" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#name_elem = r#elem_list.item(1).unwrap(); // <item var="nameElem" obj="elemList" index="1" interface="NodeList"/>
                r#name_elem.set_attribute("title", "Karen").unwrap(); // <setAttribute obj="nameElem" name="&quot;title&quot;" value="&quot;Karen&quot;"/>
                r#attributes_map = r#name_elem.attributes(); // <attributes var="attributesMap" obj="nameElem"/>
                r#attr = r#attributes_map.get_named_item("title").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;title&quot;"/>
                r#name_elem.set_id_attribute_node(r#attr, true).unwrap(); // <setIdAttributeNode obj="nameElem" idAttr="attr" isId="true"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributenodeIsIdTrue03"/>
                r#elem = r#doc.get_element_by_id("Karen".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;Karen&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "strong"); // <assertEquals actual="elemName" expected="&quot;strong&quot;" id="elementsetidattributenodeGetElementById03" ignoreCase="false"/>
                r#elem.set_id_attribute_node(r#attr, false).unwrap(); // <setIdAttributeNode obj="elem" idAttr="attr" isId="false"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(!r#id); // <assertFalse actual="id" id="elementsetidattributenodeIsIdFalse03"/>
            }
            // documentadoptnode15.xml
            #[test]
            fn test_documentadoptnode15() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_fragment; // type: DocumentFragment // <var name="docFragment" type="DocumentFragment"/>
                // let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                // let mut r#adopted_doc_frag; // type: Node // <var name="adoptedDocFrag" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment var="docFragment" obj="doc"/>
                // r#adopted_doc_frag = r#doc.adopt_node(r#doc_fragment.into()); // <adoptNode var="adoptedDocFrag" obj="doc" source="docFragment"/>

                // // unimplemented: // <if><notNull obj="adoptedDocFrag"/><hasChildNodes var="success" obj="adoptedDocFrag"/><assertFalse actual="success" id="documentadoptnode15"/></if>
            }
            // nodegetfeature03.xml
            #[test]
            fn test_nodegetfeature03() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // let mut r#feature_impl; // type: Node // <var name="featureImpl" type="Node"/>
                // let mut r#is_supported; // type: boolean // <var name="isSupported" type="boolean"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#node = r#doc.doctype().unwrap(); // <doctype var="node" obj="doc"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Core&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="coreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="cOrEUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;+cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="PlusCoreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;org.w3c.domts.bogus.feature&quot;" version="nullVersion"/>

                // // unimplemented: // <assertNull actual="featureImpl" id="unrecognizedFeature"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;2.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core20"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;3.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core30"/>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="SVGUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="HTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="EventsUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSAsyncUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XPathUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusHTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusSVGUnspecified"/></if>
            }
            // noderemovechild21.xml
            #[test]
            fn test_noderemovechild21() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#parent; // type: Element // <var name="parent" type="Element"/>
                // let mut r#child; // type: Element // <var name="child" type="Element"/>
                // let mut r#removed; // type: Element // <var name="removed" type="Element"/>
                // let mut r#removed_name; // type: DOMString // <var name="removedName" type="DOMString"/>
                // let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#parent = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "dom3:p".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="parent" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:p&quot;"/>
                // r#child = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "dom3:br".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="child" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:br&quot;"/>
                // r#appended_child = r#parent.append_child(child.into()).unwrap(); // <appendChild obj="parent" var="appendedChild" newChild="child"/>
                // r#appended_child = r#doc_elem.append_child(parent.into()).unwrap(); // <appendChild obj="docElem" var="appendedChild" newChild="parent"/>
                // r#removed = r#parent.remove_child(child.into()).unwrap(); // <removeChild var="removed" obj="parent" oldChild="child"/>
                // r#removed_name = r#removed.node_name().to_string(); // <nodeName obj="removed" var="removedName"/>
                // assert_eq!(r#removed_name, "dom3:br"); // <assertEquals actual="removedName" expected="&quot;dom3:br&quot;" id="noderemovechild21" ignoreCase="false"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR">	<NOT_FOUND_ERR>		<removeChild obj="docElem" var="removedNode" oldChild="child"/>	</NOT_FOUND_ERR></assertDOMException>
            }
            // nodegetbaseuri09.xml
            #[test]
            fn test_nodegetbaseuri09() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#body_elem; // type: Element // <var name="bodyElem" type="Element"/>
                let mut r#body_list; // type: NodeList // <var name="bodyList" type="NodeList"/>
                let mut r#base_uri; // type: DOMString // <var name="baseURI" type="DOMString"/>
                r#doc = todo!(); // barfoo_base.xml // <load var="doc" href="barfoo_base" willBeModified="false"/>
                r#body_list = r#doc.get_elements_by_tag_name("body"); // <getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/>
                r#body_elem = r#body_list.item(0).unwrap(); // <item var="bodyElem" obj="bodyList" index="0" interface="NodeList"/>
                r#base_uri = r#body_elem.base_uri().unwrap().to_string(); // <baseURI var="baseURI" obj="bodyElem" interface="Node"/>
                assert_eq!(r#base_uri, "http://www.w3.org/DOM/EmployeeID"); // <assertEquals actual="baseURI" expected="&quot;http://www.w3.org/DOM/EmployeeID&quot;" id="nodegetbaseuri09" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom32.xml
            #[test]
            fn test_typeinfoisderivedfrom32() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;part1&quot;" derivationMethod="15"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromPart1AnyMethod"/>
            }
            // elementsetidattribute06.xml
            #[test]
            fn test_elementsetidattribute06() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#name_elem; // type: Element // <var name="nameElem" type="Element"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#name_elem = r#elem_list.item(2).unwrap(); // <item var="nameElem" obj="elemList" index="2" interface="NodeList"/>

                // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR"><NOT_FOUND_ERR><setIdAttribute obj="nameElem" name="&quot;class&quot;" isId="true"/></NOT_FOUND_ERR></assertDOMException>
            }
            // nodereplacechild36.xml
            #[test]
            fn test_nodereplacechild36() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#parent; // type: Attr // <var name="parent" type="Attr"/>
                // let mut r#old_child; // type: EntityReference // <var name="oldChild" type="EntityReference"/>
                // let mut r#new_child; // type: Text // <var name="newChild" type="Text"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#parent = r#doc
                //     .create_attribute_ns(
                //         Some("http://www.w3.org/XML/1998/namespace"),
                //         "xml:lang".as_ref(),
                //     )
                //     .unwrap(); // <createAttributeNS var="parent" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>
                // r#old_child = r#doc.create_entity_reference("delta".to_string()).unwrap(); // <createEntityReference var="oldChild" obj="doc" name="&quot;delta&quot;"/>
                // r#new_child = r#doc.create_text_node("Text"); // <createTextNode var="newChild" obj="doc" data="&quot;Text&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR"><NOT_FOUND_ERR><replaceChild obj="parent" var="replaced" oldChild="oldChild" newChild="newChild"/></NOT_FOUND_ERR></assertDOMException>
            }
            // elementsetidattributens03.xml
            #[test]
            fn test_elementsetidattributens03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#employee_id_elem; // type: Element // <var name="employeeIdElem" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                r#employee_id_elem = r#elem_list.item(0).unwrap(); // <item var="employeeIdElem" obj="elemList" index="0" interface="NodeList"/>
                r#employee_id_elem
                    .set_attribute_ns(
                        Some("http://www.w3.org/2000/xmlns/"),
                        "xmlns:newAttr",
                        "newValue",
                    )
                    .unwrap(); // <setAttributeNS obj="employeeIdElem" qualifiedName="&quot;xmlns:newAttr&quot;" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" value="&quot;newValue&quot;"/>
                r#employee_id_elem
                    .set_id_attribute_ns(Some("http://www.w3.org/2000/xmlns/"), "newAttr", true)
                    .unwrap(); // <setIdAttributeNS obj="employeeIdElem" localName="&quot;newAttr&quot;" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" isId="true"/>
                r#attributes_map = r#employee_id_elem.attributes(); // <attributes var="attributesMap" obj="employeeIdElem"/>
                r#attr = r#attributes_map.get_named_item("xmlns:newAttr").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;xmlns:newAttr&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributensIsIdTrue03"/>
                r#elem = r#doc.get_element_by_id("newValue".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;newValue&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "em"); // <assertEquals actual="elemName" expected="&quot;em&quot;" id="elementsetidattributensGetElementById03" ignoreCase="false"/>
                r#employee_id_elem
                    .set_id_attribute_ns(Some("http://www.w3.org/2000/xmlns/"), "newAttr", false)
                    .unwrap(); // <setIdAttributeNS obj="employeeIdElem" localName="&quot;newAttr&quot;" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" isId="false"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(!r#id); // <assertFalse actual="id" id="elementsetidattributensIsIdFalse03"/>
            }
            // nodecomparedocumentposition34.xml
            #[test]
            fn test_nodecomparedocumentposition34() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_main; // type: Element // <var name="elemMain" type="Element"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                let mut r#element_to_txt_position; // type: int // <var name="elementToTxtPosition" type="int"/>
                let mut r#txt_to_pi_position; // type: int // <var name="txtToPiPosition" type="int"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_main = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "p".as_ref())
                    .unwrap(); // <createElementNS var="elemMain" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;p&quot;"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "br".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;br&quot;"/>
                r#txt = r#doc.create_text_node("TEXT"); // <createTextNode var="txt" obj="doc" data="&quot;TEXT&quot;"/>
                r#pi = r#doc
                    .create_processing_instruction("PIT", Some("PID"))
                    .unwrap(); // <createProcessingInstruction var="pi" obj="doc" data="&quot;PID&quot;" target="&quot;PIT&quot;"/>
                r#appended_child = r#elem_main.append_child(txt.into()).unwrap(); // <appendChild obj="elemMain" var="appendedChild" newChild="txt"/>
                r#appended_child = r#elem_main.append_child(elem.into()).unwrap(); // <appendChild obj="elemMain" var="appendedChild" newChild="elem"/>
                r#appended_child = r#elem_main.append_child(pi.into()).unwrap(); // <appendChild obj="elemMain" var="appendedChild" newChild="pi"/>
                r#element_to_txt_position = r#txt.compare_document_position(&r#elem.into()); // <compareDocumentPosition var="elementToTxtPosition" obj="txt" other="elem"/>
                assert_eq!(u16::from(r#element_to_txt_position), 4); // <assertEquals actual="elementToTxtPosition" expected="4" id="nodecomparedocumentpositionFollowing34" ignoreCase="false"/>
                r#txt_to_pi_position = r#pi.compare_document_position(&r#txt.into()); // <compareDocumentPosition var="txtToPiPosition" obj="pi" other="txt"/>
                assert_eq!(u16::from(r#txt_to_pi_position), 2); // <assertEquals actual="txtToPiPosition" expected="2" id="nodecomparedocumentpositionPRECEDING34" ignoreCase="false"/>
            }
            // documentadoptnode27.xml
            #[test]
            fn test_documentadoptnode27() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#new_elem; // type: Element // <var name="newElem" type="Element"/>
                // let mut r#new_imp_elem; // type: Element // <var name="newImpElem" type="Element"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#adopted_node; // type: Node // <var name="adoptedNode" type="Node"/>
                // let mut r#adopted_name; // type: DOMString // <var name="adoptedName" type="DOMString"/>
                // let mut r#adopted_ns; // type: DOMString // <var name="adoptedNS" type="DOMString"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_tagname; // type: DOMString // <var name="rootTagname" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_tagname = r#doc_elem.tag_name().to_string(); // <tagName var="rootTagname" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootTagname" doctype="nullDocType"/>
                // r#new_elem = r#new_doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "xhtml:head".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="newElem" obj="newDoc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:head&quot;"/>
                // r#new_elem
                //     .set_attribute_ns(
                //         Some("http://www.w3.org/XML/1998/namespace".into()),
                //         "xml:lang".into(),
                //         "en-US",
                //     )
                //     .unwrap(); // <setAttributeNS obj="newElem" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;" value="&quot;en-US&quot;"/>
                // r#doc_elem = r#new_doc.document_element().unwrap(); // <documentElement obj="newDoc" var="docElem"/>
                // r#appended_child = r#doc_elem.append_child(new_elem.into()).unwrap(); // <appendChild obj="docElem" var="appendedChild" newChild="newElem"/>
                // r#new_imp_elem = r#doc.import_node(r#new_elem.into(), true).unwrap(); // <importNode var="newImpElem" obj="doc" importedNode="newElem" deep="true"/>
                // r#adopted_node = r#doc.adopt_node(r#new_imp_elem.into()); // <adoptNode var="adoptedNode" obj="doc" source="newImpElem"/>

                // // unimplemented: // <if><notNull obj="adoptedNode"/><nodeName var="adoptedName" obj="adoptedNode"/><namespaceURI var="adoptedNS" obj="adoptedNode" interface="Node"/><assertEquals actual="adoptedName" expected="&quot;xhtml:head&quot;" id="documentadoptnode27_1" ignoreCase="false"/><assertEquals actual="adoptedNS" expected="&quot;http://www.w3.org/1999/xhtml&quot;" id="documentadoptnode27_2" ignoreCase="false"/></if>
            }
            // domimplementationregistry21.xml
            #[test]
            fn test_domimplementationregistry21() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#has_feature; // type: boolean // <var name="hasFeature" type="boolean"/>
                // let mut r#base_impl; // type: DOMImplementation // <var name="baseImpl" type="DOMImplementation"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // let mut r#dom_impl_list; // type: DOMImplementationList // <var name="domImplList" type="DOMImplementationList"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementationList var="domImplList" obj="domImplRegistry" features="&quot;LS&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <length var="length" obj="domImplList" interface="DOMImplementationList"/>

                // // unimplemented: // <if>	<equals actual="length" expected="0" ignoreCase="false"/>	<implementation var="baseImpl"/>	<hasFeature var="hasFeature" feature="&quot;LS&quot;" version="nullVersion"/>	<assertFalse actual="hasFeature" id="baseImplSupportsLS"/>	<else>		<for-each collection="domImplList" member="domImpl">			<hasFeature var="hasFeature" obj="domImpl" feature="&quot;LS&quot;" version="nullVersion"/>			<assertTrue actual="hasFeature" id="hasCore"/>		</for-each>	</else></if>
            }
            // noderemovechild03.xml
            #[test]
            fn test_noderemovechild03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#removed_child; // type: Element // <var name="removedChild" type="Element"/>
                let mut r#removed; // type: Node // <var name="removed" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#removed = r#doc.remove_child(doc_elem.into()).unwrap(); // <removeChild obj="doc" var="removed" oldChild="docElem"/>
                r#removed_child = r#doc.document_element().unwrap(); // <documentElement var="removedChild" obj="doc"/>

                // unimplemented: // <assertNull actual="removedChild" id="noderemovechild03"/>

                // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR"><NOT_FOUND_ERR><removeChild obj="docElem" var="removed" oldChild="doc"/></NOT_FOUND_ERR></assertDOMException>
            }
            // domconfigurationcansetparameter02.xml
            #[test]
            fn test_domconfigurationcansetparameter02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#param_val; // type: boolean // <var name="paramVal" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter obj="domConfig" var="canSet" name="&quot;cdata-sections&quot;" value="false"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetFalse"/>

                // // unimplemented: // <getParameter var="paramVal" obj="domConfig" name="&quot;cdata-sections&quot;"/>
                // assert!(r#param_val); // <assertTrue actual="paramVal" id="valueStillTrue"/>

                // // unimplemented: // <canSetParameter obj="domConfig" var="canSet" name="&quot;cdata-sections&quot;" value="true"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetTrue"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;cdata-sections&quot;" value="false"/>

                // // unimplemented: // <canSetParameter obj="domConfig" var="canSet" name="&quot;cdata-sections&quot;" value="true"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetTrueFromFalse"/>

                // // unimplemented: // <getParameter var="paramVal" obj="domConfig" name="&quot;cdata-sections&quot;"/>
                // assert!(!r#param_val); // <assertFalse actual="paramVal" id="valueStillFalse"/>

                // // unimplemented: // <canSetParameter obj="domConfig" var="canSet" name="&quot;cdata-sections&quot;" value="false"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetFalseFromFalse"/>
            }
            // nodeisequalnode10.xml
            #[test]
            fn test_nodeisequalnode10() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem1; // type: Element // <var name="elem1" type="Element"/>
                let mut r#elem2; // type: Element // <var name="elem2" type="Element"/>
                let mut r#employee_list; // type: NodeList // <var name="employeeList" type="NodeList"/>
                let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#employee_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="employeeList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                r#elem1 = r#employee_list.item(0).unwrap(); // <item var="elem1" obj="employeeList" index="0" interface="NodeList"/>
                r#elem2 = r#employee_list.item(1).unwrap(); // <item var="elem2" obj="employeeList" index="1" interface="NodeList"/>
                r#is_equal = r#elem1.is_equal_node(&r#elem2.into()); // <isEqualNode var="isEqual" obj="elem1" arg="elem2"/>
                assert!(!r#is_equal); // <assertFalse actual="isEqual" id="nodeisequalnode10"/>
            }
            // hasFeature04.xml
            #[test]
            fn test_has_feature04() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#impl; // type: DOMImplementation // <var name="impl" type="DOMImplementation"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>

                // // unimplemented: // <implementation var="impl"/>

                // // unimplemented: // <hasFeature var="state" obj="impl" feature="&quot;+xMl&quot;" version="&quot;3.0&quot;"/>
                // assert!(r#state); // <assertTrue id="hasXML30" actual="state"/>
            }
            // elementcontentwhitespace03.xml
            #[test]
            fn test_elementcontentwhitespace03() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#body_list; // type: NodeList // <var name="bodyList" type="NodeList"/>
                // let mut r#body; // type: Element // <var name="body" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <if><implementationAttribute name="ignoringElementContentWhitespace" value="true"/>	<getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/>	<item var="body" obj="bodyList" interface="NodeList" index="0"/>	<firstChild var="child" obj="body" interface="Node"/>	<createTextNode var="text" obj="doc" data="&quot;    &quot;"/>	<insertBefore var="child" obj="body" newChild="text" refChild="child"/></if>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;element-content-whitespace&quot;" value="false"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;element-content-whitespace&quot;" value="false"/><setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/><normalize obj="doc"/><!--  fail test if normalize had any errors or fatal errors   --><assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/><getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/><item var="body" obj="bodyList" interface="NodeList" index="0"/><firstChild var="child" obj="body" interface="Node"/><assertNotNull actual="child" id="firstChildNotNull"/><!--   this should be a Text node  --><nodeName var="childName" obj="child"/><assertEquals actual="childName" expected="&quot;#text&quot;" ignoreCase="false" id="firstChild"/><nextSibling var="child" obj="child" interface="Node"/><assertNotNull actual="child" id="secondChildNotNull"/><nodeName var="childName" obj="child"/><assertEquals actual="childName" expected="&quot;p&quot;" ignoreCase="false" id="secondChild"/></if>
            }
            // documentadoptnode18.xml
            #[test]
            fn test_documentadoptnode18() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entity_map; // type: NamedNodeMap // <var name="entityMap" type="NamedNodeMap"/>
                // let mut r#ent; // type: Entity // <var name="ent" type="Entity"/>
                // let mut r#adopted_ent; // type: Node // <var name="adoptedEnt" type="Node"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entityMap" obj="docType"/>
                // r#ent = r#entity_map.get_named_item("delta".into()).unwrap(); // <getNamedItem var="ent" obj="entityMap" name="&quot;delta&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR"><NO_MODIFICATION_ALLOWED_ERR><adoptNode var="adoptedEnt" obj="newDoc" source="ent"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // attrgetschematypeinfo04.xml
            #[test]
            fn test_attrgetschematypeinfo04() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#type_ns; // type: DOMString // <var name="typeNS" type="DOMString"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>
                // r#attr = r#acronym_elem.get_attribute_node("id").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;id&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "ID"); // <assertEquals actual="typeName" expected="&quot;ID&quot;" ignoreCase="false" id="nameIsID"/>

                // // unimplemented: // <typeNamespace var="typeNS" obj="typeInfo"/>
                // assert_eq!(r#type_ns, "http://www.w3.org/2001/XMLSchema"); // <assertEquals actual="typeNS" expected="&quot;http://www.w3.org/2001/XMLSchema&quot;" ignoreCase="false" id="nsIsXmlSchema"/>
            }
            // domconfigcanonicalform1.xml
            #[test]
            fn test_domconfigcanonicalform1() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // let mut r#parameter; // type: DOMString // <var name="parameter" type="DOMString" value="&quot;cAnOnical-form&quot;"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDocType"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(!r#state); // <assertFalse actual="state" id="defaultFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="false"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="true"/>

                // // unimplemented: // <if>  	  <isTrue value="canSet"/>  	  <setParameter obj="domConfig" name="parameter" value="true"/>  	  <getParameter var="state" obj="domConfig" name="parameter"/>  	  <assertTrue actual="state" id="setTrueEffective"/>  	  <else>  	  	  <assertDOMException id="throw_NOT_SUPPORTED_ERR">  	  	  	<NOT_SUPPORTED_ERR>  	  			<setParameter obj="domConfig" name="parameter" value="true"/>  	  		</NOT_SUPPORTED_ERR>  	  	  </assertDOMException>  	  	  <!--  should still be false after failed attempt  -->  	  	  <getParameter var="state" obj="domConfig" name="parameter"/>  	      <assertFalse actual="state" id="setTrueNotEffective"/>  	  </else>  </if>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="false"/>
            }
            // nodereplacechild17.xml
            #[test]
            fn test_nodereplacechild17() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                let mut r#cmt; // type: Comment // <var name="cmt" type="Comment"/>
                let mut r#replaced_cmt; // type: Comment // <var name="replacedCmt" type="Comment"/>
                let mut r#replaced_pi; // type: ProcessingInstruction // <var name="replacedPi" type="ProcessingInstruction"/>
                let mut r#data; // type: DOMString // <var name="data" type="DOMString"/>
                let mut r#target; // type: DOMString // <var name="target" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#cmt = r#doc.create_comment("Comment"); // <createComment var="cmt" obj="doc" data="&quot;Comment&quot;"/>
                r#pi = r#doc
                    .create_processing_instruction("target", Some("Comment"))
                    .unwrap(); // <createProcessingInstruction var="pi" obj="doc" target="&quot;target&quot;" data="&quot;Comment&quot;"/>
                r#appended_child = r#doc_frag.append_child(pi.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="pi"/>
                r#appended_child = r#doc_frag.append_child(cmt.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="cmt"/>
                r#replaced_cmt = r#doc_frag
                    .replace_child(pi.into(), cmt.into())
                    .unwrap()
                    .as_comment()
                    .unwrap(); // <replaceChild var="replacedCmt" obj="docFrag" oldChild="cmt" newChild="pi"/>
                r#data = r#replaced_cmt.data().to_string(); // <data var="data" obj="replacedCmt" interface="CharacterData"/>
                assert_eq!(r#data, "Comment"); // <assertEquals actual="data" expected="&quot;Comment&quot;" id="nodereplacechild17_1" ignoreCase="false"/>
                r#replaced_pi = r#doc_frag
                    .replace_child(cmt.into(), pi.into())
                    .unwrap()
                    .as_processing_instruction()
                    .unwrap(); // <replaceChild var="replacedPi" obj="docFrag" oldChild="pi" newChild="cmt"/>
                r#target = r#replaced_pi.target().to_string(); // <target var="target" obj="replacedPi" interface="ProcessingInstruction"/>
                assert_eq!(r#target, "target"); // <assertEquals actual="target" expected="&quot;target&quot;" id="nodereplacechild17_2" ignoreCase="false"/>
            }
            // nodesettextcontent01.xml
            #[test]
            fn test_nodesettextcontent01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc.set_text_content("textContent").unwrap(); // <textContent value="&quot;textContent&quot;" obj="doc"/>
                r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#elem = r#elem_list.item(3).unwrap(); // <item var="elem" obj="elemList" index="3" interface="NodeList"/>

                // unimplemented: // <assertNotNull actual="elem" id="stillHasAcronyms"/>
                r#node_name = r#elem.node_name().to_string(); // <nodeName var="nodeName" obj="elem"/>
                assert_eq!(r#node_name, "acronym"); // <assertEquals actual="nodeName" expected="&quot;acronym&quot;" id="nodesettextcontent01" ignoreCase="false"/>
            }
            // nodelookupnamespaceuri13.xml
            #[test]
            fn test_nodelookupnamespaceuri13() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "dom3:p".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:p&quot;"/>
                r#txt = r#doc.create_text_node("Text"); // <createTextNode var="txt" obj="doc" data="&quot;Text&quot;"/>
                r#appended_child = r#elem.append_child(txt.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="txt"/>
                r#appended_child = r#doc_elem.append_child(elem.into()).unwrap(); // <appendChild obj="docElem" var="appendedChild" newChild="elem"/>
                r#namespace_uri = r#txt.lookup_namespace_uri("dom3").unwrap().to_string(); // <lookupNamespaceURI var="namespaceURI" obj="txt" prefix="&quot;dom3&quot;" interface="Node"/>
                assert_eq!(r#namespace_uri, "http://www.w3.org/1999/xhtml"); // <assertEquals actual="namespaceURI" expected="&quot;http://www.w3.org/1999/xhtml&quot;" id="nodelookupnamespaceuri13" ignoreCase="false"/>
            }
            // domconfigparameternames01.xml
            #[test]
            fn test_domconfigparameternames01() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#config; // type: DOMConfiguration // <var name="config" type="DOMConfiguration"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // let mut r#parameter_names; // type: DOMStringList // <var name="parameterNames" type="DOMStringList"/>
                // let mut r#parameter_name; // type: DOMString // <var name="parameterName" type="DOMString"/>
                // let mut r#match_count; // type: int // <var name="matchCount" type="int" value="0"/>
                // let mut r#param_value; // type: DOMUserData // <var name="paramValue" type="DOMUserData"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>

                // // unimplemented: // <domConfig var="config" obj="doc" interface="Document"/>

                // // unimplemented: // <assertNotNull actual="config" id="configNotNull"/>

                // // unimplemented: // <parameterNames var="parameterNames" obj="config"/>

                // // unimplemented: // <assertNotNull actual="parameterNames" id="parameterNamesNotNull"/>

                // // unimplemented: // <for-each collection="parameterNames" member="parameterName">  		<!--  get the default value of this parameter   -->  		<getParameter var="paramValue" obj="config" name="parameterName"/>  		<!--  should be able to set to default value    -->  		<canSetParameter var="canSet" obj="config" name="parameterName" value="paramValue"/>  		<assertTrue actual="canSet" id="canSetToDefaultValue"/>  		<setParameter obj="config" name="parameterName" value="paramValue"/>  		<if>  			<or>  				<equals actual="parameterName" expected="&quot;canonical-form&quot;" ignoreCase="true"/>  				<equals actual="parameterName" expected="&quot;cdata-sections&quot;" ignoreCase="true"/>  				<equals actual="parameterName" expected="&quot;check-character-normalization&quot;" ignoreCase="true"/>  				<equals actual="parameterName" expected="&quot;comments&quot;" ignoreCase="true"/>  				<equals actual="parameterName" expected="&quot;datatype-normalization&quot;" ignoreCase="true"/>  				<equals actual="parameterName" expected="&quot;entities&quot;" ignoreCase="true"/>  				<equals actual="parameterName" expected="&quot;error-handler&quot;" ignoreCase="true"/>  				<equals actual="parameterName" expected="&quot;infoset&quot;" ignoreCase="true"/>  				<equals actual="parameterName" expected="&quot;namespaces&quot;" ignoreCase="true"/>  				<equals actual="parameterName" expected="&quot;namespace-declarations&quot;" ignoreCase="true"/>  				<equals actual="parameterName" expected="&quot;normalize-characters&quot;" ignoreCase="true"/>  				<equals actual="parameterName" expected="&quot;split-cdata-sections&quot;" ignoreCase="true"/>  				<equals actual="parameterName" expected="&quot;validate&quot;" ignoreCase="true"/>  				<equals actual="parameterName" expected="&quot;validate-if-schema&quot;" ignoreCase="true"/>  				<equals actual="parameterName" expected="&quot;well-formed&quot;" ignoreCase="true"/>  				<equals actual="parameterName" expected="&quot;element-content-whitespace&quot;" ignoreCase="true"/>  			</or>  			<increment var="matchCount" value="1"/>  		</if>  </for-each>
                // assert_eq!(r#match_count, 16); // <assertEquals actual="matchCount" expected="16" id="definedParameterCount" ignoreCase="false"/>
            }
            // nodegetfeature01.xml
            #[test]
            fn test_nodegetfeature01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // let mut r#feature_impl; // type: Node // <var name="featureImpl" type="Node"/>
                // let mut r#is_supported; // type: boolean // <var name="isSupported" type="boolean"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <assign var="node" value="doc"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Core&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="coreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="cOrEUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;+cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="PlusCoreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;org.w3c.domts.bogus.feature&quot;" version="nullVersion"/>

                // // unimplemented: // <assertNull actual="featureImpl" id="unrecognizedFeature"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;2.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core20"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;3.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core30"/>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="doc" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="doc" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="SVGUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="doc" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="HTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="doc" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="EventsUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="doc" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="doc" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSAsyncUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="doc" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XPathUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="doc" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusHTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="doc" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusSVGUnspecified"/></if>
            }
            // elementsetidattribute03.xml
            #[test]
            fn test_elementsetidattribute03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>
                r#acronym_elem.set_attribute("class", "Maybe").unwrap(); // <setAttribute obj="acronymElem" name="&quot;class&quot;" value="&quot;Maybe&quot;"/>
                r#acronym_elem.set_id_attribute("class", true).unwrap(); // <setIdAttribute obj="acronymElem" name="&quot;class&quot;" isId="true"/>
                r#attributes_map = r#acronym_elem.attributes(); // <attributes var="attributesMap" obj="acronymElem"/>
                r#attr = r#attributes_map.get_named_item("class").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;class&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributeIsIdTrue03"/>
                r#elem = r#doc.get_element_by_id("Maybe".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;Maybe&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "acronym"); // <assertEquals actual="elemName" expected="&quot;acronym&quot;" id="elementsetidattributeGetElementById03" ignoreCase="false"/>
                r#acronym_elem.set_id_attribute("class", false).unwrap(); // <setIdAttribute obj="acronymElem" name="&quot;class&quot;" isId="false"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(!r#id); // <assertFalse actual="id" id="elementsetidattributeIsIdFalse03"/>
            }
            // nodeisequalnode09.xml
            #[test]
            fn test_nodeisequalnode09() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // // unimplemented: // <implementationAttribute name="ignoringElementContentWhitespace" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#elem1; // type: Element // <var name="elem1" type="Element"/>
                // let mut r#elem2; // type: Element // <var name="elem2" type="Element"/>
                // let mut r#employee_list; // type: NodeList // <var name="employeeList" type="NodeList"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.local_name().unwrap().to_string(); // <localName var="rootName" obj="docElem" interface="Node"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#employee_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="employeeList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                // r#elem1 = r#employee_list.item(0).unwrap(); // <item var="elem1" obj="employeeList" index="0" interface="NodeList"/>
                // r#elem2 = r#new_doc
                //     .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "em".as_ref())
                //     .unwrap(); // <createElementNS var="elem2" obj="newDoc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;em&quot;"/>
                // r#text = r#new_doc.create_text_node("EMP0001"); // <createTextNode var="text" obj="newDoc" data="&quot;EMP0001&quot;"/>
                // r#appended_child = r#elem2.append_child(text.into()).unwrap(); // <appendChild obj="elem2" var="appendedChild" newChild="text"/>
                // r#is_equal = r#elem1.is_equal_node(&r#elem2.into()); // <isEqualNode var="isEqual" obj="elem1" arg="elem2"/>
                // assert!(r#is_equal); // <assertTrue actual="isEqual" id="nodesAreEqual"/>
            }
            // datatypenormalization01.xml
            #[test]
            fn test_datatypenormalization01() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#str; // type: DOMString // <var name="str" type="DOMString"/>
                // let mut r#can_set_normalization; // type: boolean // <var name="canSetNormalization" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#can_set_xml_schema; // type: boolean // <var name="canSetXMLSchema" type="boolean"/>
                // let mut r#xsd_ns; // type: DOMString // <var name="xsdNS" type="DOMString" value="&quot;http://www.w3.org/2001/XMLSchema&quot;"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // r#doc = todo!(); // datatype_normalization.xml // <load var="doc" href="datatype_normalization" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetNormalization" obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetValidate" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetXMLSchema" obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>

                // // unimplemented: // <if>	<and>		<isTrue value="canSetNormalization"/>		<isTrue value="canSetValidate"/>		<isTrue value="canSetXMLSchema"/>	</and>	<setParameter obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>	<normalizeDocument obj="doc"/>	<!--  fail test if normalize had any errors or fatal errors   -->	<assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>	<getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;http://www.w3.org/2001/DOM-Test-Suite/Level-3/datatype_normalization&quot;" localName="&quot;double&quot;" interface="Document"/>	<item var="element" obj="elemList" interface="NodeList" index="0"/>	<getAttribute var="str" obj="element" name="&quot;value&quot;"/>	<assertEquals actual="str" expected="&quot;+0003.141592600E+0000&quot;" ignoreCase="false" id="firstValue"/>	<getAttribute var="str" obj="element" name="&quot;union&quot;"/>	<assertEquals actual="str" expected="&quot;+0003.141592600E+0000&quot;" ignoreCase="false" id="firstUnion"/>	<textContent var="str" obj="element"/>	<assertEquals actual="str" expected="&quot;-31415926.00E-7 2.718&quot;" ignoreCase="false" id="firstList"/>		<item var="element" obj="elemList" interface="NodeList" index="1"/>	<getAttribute var="str" obj="element" name="&quot;value&quot;"/>	<assertEquals actual="str" expected="&quot;NaN&quot;" ignoreCase="false" id="secondValue"/>	<getAttribute var="str" obj="element" name="&quot;union&quot;"/>	<assertEquals actual="str" expected="&quot;NaN&quot;" ignoreCase="false" id="secondUnion"/>	<textContent var="str" obj="element"/>	<assertEquals actual="str" expected="&quot;INF -INF&quot;" ignoreCase="false" id="secondList"/>		<item var="element" obj="elemList" interface="NodeList" index="2"/>	<getAttribute var="str" obj="element" name="&quot;value&quot;"/>	<assertEquals actual="str" expected="&quot;1&quot;" ignoreCase="false" id="thirdValue"/>	<getAttribute var="str" obj="element" name="&quot;union&quot;"/>	<assertEquals actual="str" expected="&quot;1&quot;" ignoreCase="false" id="thirdUnion"/>	<textContent var="str" obj="element"/>	<assertEquals actual="str" expected="&quot;-0&quot;" ignoreCase="false" id="thirdList"/>	</if>
            }
            // domconfigerrorhandler1.xml
            #[test]
            fn test_domconfigerrorhandler1() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#orig_handler; // type: DOMErrorHandler // <var name="origHandler" type="DOMErrorHandler"/>
                // let mut r#state; // type: DOMErrorHandler // <var name="state" type="DOMErrorHandler"/>
                // let mut r#parameter; // type: DOMString // <var name="parameter" type="DOMString" value="&quot;eRrOr-handler&quot;"/>
                // let mut r#error_handler; // type: DOMErrorHandler // <var name="errorHandler" type="DOMErrorHandler">      <handleError>      	  <return value="true"/>      </handleError>  </var>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDocType"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <getParameter var="origHandler" obj="domConfig" name="parameter"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="errorHandler"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetNewHandler"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="origHandler"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetOrigHandler"/>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="errorHandler"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>

                // // unimplemented: // <assertSame expected="errorHandler" actual="state" id="setToNewHandlerEffective"/>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="origHandler"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>

                // // unimplemented: // <assertSame expected="origHandler" actual="state" id="setToOrigHandlerEffective"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/>  	  <setParameter obj="domConfig" name="parameter" value="true"/>  </if>
            }
            // entities04.xml
            #[test]
            fn test_entities04() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#ent2; // type: Entity // <var name="ent2" type="Entity"/>
                // let mut r#doctype; // type: DocumentType // <var name="doctype" type="DocumentType"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;entities&quot;" value="false"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" interface="NodeList" index="0"/>
                // r#ent_ref = r#doc.create_entity_reference("ent1".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent1&quot;"/>
                // r#child = r#p_elem.append_child(ent_ref.into()).unwrap(); // <appendChild var="child" obj="pElem" newChild="entRef"/>
                // r#doc.normalize(); // <normalize obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" interface="NodeList" index="0"/>
                // r#child = r#p_elem.last_child().unwrap(); // <lastChild var="child" obj="pElem" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="child" id="lastChildNotNull"/>
                // r#child_name = r#child.node_name().to_string(); // <nodeName var="childName" obj="child"/>
                // assert_eq!(r#child_name, "ent1"); // <assertEquals actual="childName" expected="&quot;ent1&quot;" ignoreCase="false" id="firstChild"/>
                // r#doctype = r#doc.doctype().unwrap(); // <doctype var="doctype" obj="doc"/>

                // // unimplemented: // <entities var="entities" obj="doctype"/>
                // r#ent2 = r#entities.get_named_item("ent2".into()).unwrap(); // <getNamedItem var="ent2" obj="entities" name="&quot;ent2&quot;"/>

                // // unimplemented: // <assertNotNull actual="ent2" id="ent2NotNull"/>
            }
            // nodegetuserdata07.xml
            #[test]
            fn test_nodegetuserdata07() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                // let mut r#user_data; // type: DOMUserData // <var name="userData" type="DOMUserData"/>
                // let mut r#ret_user_data; // type: DOMUserData // <var name="retUserData" type="DOMUserData"/>
                // let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                // let mut r#null_handler; // type: UserDataHandler // <var name="nullHandler" type="UserDataHandler" isNull="true"/>
                // let mut r#prev_user_data; // type: DOMUserData // <var name="prevUserData" type="DOMUserData"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#pi = r#doc
                //     .create_processing_instruction("PITARGET", Some("PIDATA"))
                //     .unwrap(); // <createProcessingInstruction var="pi" obj="doc" data="&quot;PIDATA&quot;" target="&quot;PITARGET&quot;"/>

                // // unimplemented: // <setUserData obj="pi" var="prevUserData" key="&quot;key&quot;" data="pi" handler="nullHandler"/>

                // // unimplemented: // <getUserData var="retUserData" obj="pi" key="&quot;key&quot;"/>
                // r#success = r#ret_user_data.is_equal_node(&r#pi.into()); // <isEqualNode var="success" obj="retUserData" arg="pi"/>
                // assert!(r#success); // <assertTrue actual="success" id="nodegetuserdata07"/>
            }
            // handleerror01.xml
            #[test]
            fn test_handleerror01() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#new_child; // type: CDATASection // <var name="newChild" type="CDATASection"/>
                // let mut r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#child_value; // type: DOMString // <var name="childValue" type="DOMString"/>
                // let mut r#child_type; // type: int // <var name="childType" type="int"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#errors; // type: List // <var name="errors" type="List"/>
                // let mut r#error_handler; // type: DOMErrorHandler // <var name="errorHandler" type="DOMErrorHandler">    <handleError>          <!--  returning false should stop processing  -->    	  <return value="false"/>    </handleError></var>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>
                // r#old_child = r#elem.first_child().unwrap(); // <firstChild var="oldChild" obj="elem" interface="Node"/>
                // r#new_child = r#doc.create_cdata_section("this is not ]]> good").unwrap(); // <createCDATASection var="newChild" obj="doc" data="&quot;this is not ]]&gt; good&quot;"/>
                // r#retval = r#elem
                //     .replace_child(new_child.into(), old_child)
                //     .unwrap(); // <replaceChild var="retval" obj="elem" newChild="newChild" oldChild="oldChild"/>
                // r#new_child = r#doc.create_cdata_section("this is not ]]> bad").unwrap(); // <createCDATASection var="newChild" obj="doc" data="&quot;this is not ]]&gt; bad&quot;"/>
                // r#retval = r#elem.append_child(new_child).unwrap(); // <appendChild var="retval" obj="elem" newChild="newChild"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;split-cdata-sections&quot;" value="true"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorHandler"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>
                // r#child = r#elem.last_child().unwrap(); // <lastChild var="child" obj="elem" interface="Node"/>
                // r#child_value = r#child.node_value().unwrap().to_string(); // <nodeValue var="childValue" obj="child"/>

                // // unimplemented: // <if>    <!--  if last child matches original test  -->	<equals actual="childValue" expected="&quot;this is not ]]&gt; bad&quot;" ignoreCase="false"/>    <!--  check that it is a CDATASection      -->	<nodeType var="childType" obj="child"/>	<assertEquals actual="childType" expected="4" ignoreCase="false" id="lastChildCDATA"/>    <!--  check that first child is not intact  -->	<firstChild var="child" obj="elem" interface="Node"/>	<nodeValue var="childValue" obj="child"/>	<assertNotEquals actual="childValue" expected="&quot;this is not ]]&gt; good&quot;" ignoreCase="false" id="firstChildNotIntact"/>	<else>	    <!-- last child was split, check that first child is intact  -->		<firstChild var="child" obj="elem" interface="Node"/>		<nodeValue var="childValue" obj="child"/>		<assertEquals actual="childValue" expected="&quot;this is not ]]&gt; good&quot;" ignoreCase="false" id="firstChildIntact"/>	</else></if>
            }
            // noderemovechild17.xml
            #[test]
            fn test_noderemovechild17() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#parent_list; // type: NodeList // <var name="parentList" type="NodeList"/>
                // let mut r#parent; // type: Element // <var name="parent" type="Element"/>
                // let mut r#child; // type: Text // <var name="child" type="Text"/>
                // let mut r#removed; // type: Text // <var name="removed" type="Text"/>
                // let mut r#removed_value; // type: DOMString // <var name="removedValue" type="DOMString"/>
                // let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#parent_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="parentList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                // r#parent = r#parent_list[0].clone(); // <item var="parent" obj="parentList" index="0" interface="NodeList"/>
                // r#child = r#parent.first_child().unwrap(); // <firstChild var="child" obj="parent" interface="Node"/>
                // r#removed = r#parent.remove_child(child.into()).unwrap(); // <removeChild var="removed" obj="parent" oldChild="child"/>
                // r#removed_value = r#removed.node_value().unwrap().to_string(); // <nodeValue obj="removed" var="removedValue"/>
                // assert_eq!(r#removed_value, "EMP0001"); // <assertEquals actual="removedValue" expected="&quot;EMP0001&quot;" id="noderemovechild17" ignoreCase="false"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR"><NOT_FOUND_ERR><removeChild obj="child" var="removedNode" oldChild="parent"/></NOT_FOUND_ERR></assertDOMException>
            }
            // attrisid02.xml
            #[test]
            fn test_attrisid02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#xml_ns; // type: DOMString // <var name="xmlNS" type="DOMString" value="&quot;http://www.w3.org/XML/1998/namespace&quot;"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>
                // r#acronym_elem
                //     .set_attribute_ns(Some(r#xml_ns), "xml:lang".into(), "FR-fr")
                //     .unwrap(); // <setAttributeNS obj="acronymElem" namespaceURI="xmlNS" qualifiedName="&quot;xml:lang&quot;" value="&quot;FR-fr&quot;"/>
                // r#acronym_elem
                //     .set_id_attribute_ns(Some(r#xml_ns), "lang".into(), true)
                //     .unwrap(); // <setIdAttributeNS obj="acronymElem" localName="&quot;lang&quot;" namespaceURI="xmlNS" isId="true"/>
                // r#attr = r#acronym_elem
                //     .get_attribute_node_ns(Some(r#xml_ns), "lang".into())
                //     .unwrap()
                //     .unwrap(); // <getAttributeNodeNS var="attr" obj="acronymElem" namespaceURI="xmlNS" localName="&quot;lang&quot;"/>
                // r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                // assert!(r#id); // <assertTrue actual="id" id="AttrIsIDTrue02"/>
            }
            // nodegetbaseuri06.xml
            #[test]
            fn test_nodegetbaseuri06() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_element; // type: Element // <var name="newElement" type="Element"/>
                let mut r#base_uri; // type: DOMString // <var name="baseURI" type="DOMString"/>
                r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>
                r#new_element = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "br".as_ref())
                    .unwrap(); // <createElementNS var="newElement" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;br&quot;"/>
                r#base_uri = r#doc.base_uri().unwrap().to_string(); // <baseURI var="baseURI" obj="doc" interface="Node"/>

                // unimplemented: // <assertNotNull actual="baseURI" id="nodegetbaseuri06"/>
            }
            // nodegettextcontent19.xml
            #[test]
            fn test_nodegettextcontent19() {
                // unimplemented: // <implementationAttribute name="ignoringElementContentWhitespace" value="false"/>

                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("body"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;body&quot;" interface="Document"/>
                r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>
                r#text_content = r#elem.text_content().unwrap(); // <textContent var="textContent" obj="elem"/>
                assert_eq!(r#text_content, "bar"); // <assertEquals actual="textContent" expected="&quot;bar&quot;" id="textContent" ignoreCase="false"/>
            }
            // nodeinsertbefore20.xml
            #[test]
            fn test_nodeinsertbefore20() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#ref_node; // type: Node // <var name="refNode" type="Node"/>
                // let mut r#new_node; // type: Attr // <var name="newNode" type="Attr"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#inserted; // type: Node // <var name="inserted" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#child_list = r#doc.get_elements_by_tag_name("var"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;var&quot;" interface="Document"/>
                // r#element = r#child_list.item(2).unwrap().clone(); // <item var="element" obj="childList" index="2" interface="NodeList"/>
                // r#ref_node = r#element.first_child().unwrap(); // <firstChild var="refNode" obj="element" interface="Node"/>
                // r#new_node = r#doc
                //     .create_attribute_ns(
                //         Some("http://www.w3.org/XML/1998/namespace"),
                //         "xml:lang".as_ref(),
                //     )
                //     .unwrap(); // <createAttributeNS var="newNode" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR"><HIERARCHY_REQUEST_ERR><insertBefore obj="element" var="inserted" refChild="refNode" newChild="newNode"/></HIERARCHY_REQUEST_ERR></assertDOMException>
            }
            // nodelookupnamespaceuri05.xml
            #[test]
            fn test_nodelookupnamespaceuri05() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // let mut r#qname; // type: DOMString // <var name="qname" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <plus var="qname" op1="&quot;dom3:&quot;" op2="rootName"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="qname" doctype="nullDocType"/>
                // r#elem = r#new_doc.document_element().unwrap(); // <documentElement var="elem" obj="newDoc"/>
                // r#namespace_uri = r#elem.lookup_namespace_uri("dom3").unwrap().to_string(); // <lookupNamespaceURI var="namespaceURI" obj="elem" prefix="&quot;dom3&quot;" interface="Node"/>
                // assert_eq!(r#namespace_uri, root_ns); // <assertEquals actual="namespaceURI" expected="rootNS" id="nodelookupnamespaceuri05" ignoreCase="false"/>
            }
            // nodecomparedocumentposition38.xml
            #[test]
            fn test_nodecomparedocumentposition38() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#attr_position; // type: int // <var name="attrPosition" type="int"/>
                let mut r#attr_child_position; // type: int // <var name="attrChildPosition" type="int"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#elem = r#elem_list.item(3).unwrap(); // <item var="elem" obj="elemList" index="3" interface="NodeList"/>
                r#attr = r#elem.get_attribute_node("class").unwrap(); // <getAttributeNode var="attr" obj="elem" name="&quot;class&quot;"/>
                r#txt = r#attr.first_child().unwrap(); // <firstChild var="txt" obj="attr" interface="Node"/>
                r#attr_position = r#attr.compare_document_position(&r#txt); // <compareDocumentPosition var="attrPosition" obj="attr" other="txt"/>
                assert_eq!(u16::from(r#attr_position), 20); // <assertEquals actual="attrPosition" expected="20" id="nodecomparedocumentpositionIsContainsFollowing38" ignoreCase="false"/>
                r#attr_child_position = r#txt.compare_document_position(&r#attr.into()); // <compareDocumentPosition var="attrChildPosition" obj="txt" other="attr"/>
                assert_eq!(u16::from(r#attr_child_position), 10); // <assertEquals actual="attrChildPosition" expected="10" id="nodecomparedocumentpositionContainsPRECEDING38" ignoreCase="false"/>
            }
            // nodecomparedocumentposition28.xml
            #[test]
            fn test_nodecomparedocumentposition28() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#var_list; // type: NodeList // <var name="varList" type="NodeList"/>
                // let mut r#var_elem; // type: Element // <var name="varElem" type="Element"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#ent_ref_child1; // type: Element // <var name="entRefChild1" type="Element"/>
                // let mut r#ent_ref_child2; // type: ProcessingInstruction // <var name="entRefChild2" type="ProcessingInstruction"/>
                // let mut r#ent_ref_child1_position; // type: int // <var name="entRefChild1Position" type="int"/>
                // let mut r#ent_ref_child2_position; // type: int // <var name="entRefChild2Position" type="int"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <if>	<implementationAttribute name="expandEntityReferences" value="false"/>	<getElementsByTagName var="varList" obj="doc" tagname="&quot;var&quot;" interface="Document"/>	<item var="varElem" obj="varList" index="2" interface="NodeList"/>	<assertNotNull actual="varElem" id="varElemNotNull"/>	<firstChild var="entRef" obj="varElem" interface="Node"/>	<assertNotNull actual="entRef" id="entRefNotNull"/>	<else>		<createEntityReference name="&quot;ent4&quot;" obj="doc" var="entRef"/>	</else></if>
                // r#ent_ref_child1 = r#ent_ref.first_child().unwrap(); // <firstChild obj="entRef" var="entRefChild1" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="entRefChild1" id="entRefChild1NotNull"/>
                // r#ent_ref_child2 = r#ent_ref.last_child().unwrap(); // <lastChild obj="entRef" var="entRefChild2" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="entRefChild2" id="entRefChild2NotNull"/>
                // r#ent_ref_child1_position =
                //     r#ent_ref_child1.compare_document_position(&r#ent_ref_child2.into()); // <compareDocumentPosition var="entRefChild1Position" obj="entRefChild1" other="entRefChild2"/>
                // assert_eq!(u16::from(r#ent_ref_child1_position), 4); // <assertEquals actual="entRefChild1Position" expected="4" id="nodecomparedocumentpositionFollowing28" ignoreCase="false"/>
                // r#ent_ref_child2_position =
                //     r#ent_ref_child2.compare_document_position(&r#ent_ref_child1.into()); // <compareDocumentPosition var="entRefChild2Position" obj="entRefChild2" other="entRefChild1"/>
                // assert_eq!(u16::from(r#ent_ref_child2_position), 2); // <assertEquals actual="entRefChild2Position" expected="2" id="nodecomparedocumentpositionPRECEDING28" ignoreCase="false"/>
            }
            // nodeinsertbefore19.xml
            #[test]
            fn test_nodeinsertbefore19() {
                // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#ref_node; // type: Node // <var name="refNode" type="Node"/>
                let mut r#new_node; // type: EntityReference // <var name="newNode" type="EntityReference"/>
                let mut r#inserted; // type: EntityReference // <var name="inserted" type="EntityReference"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#child_list = r#doc.get_elements_by_tag_name("var"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;var&quot;" interface="Document"/>
                r#element = r#child_list.item(2).unwrap(); // <item var="element" obj="childList" index="2" interface="NodeList"/>
                r#ref_node = r#element.first_child().unwrap(); // <firstChild var="refNode" obj="element" interface="Node"/>
                r#new_node = r#doc.create_entity_reference("alpha".to_string()).unwrap(); // <createEntityReference var="newNode" obj="doc" name="&quot;alpha&quot;"/>
                r#inserted = r#element
                    .insert_before(new_node.into(), ref_node.into())
                    .unwrap(); // <insertBefore obj="element" var="inserted" refChild="refNode" newChild="newNode"/>
                r#node_name = r#inserted.node_name().to_string(); // <nodeName var="nodeName" obj="inserted"/>
                assert_eq!(r#node_name, "alpha"); // <assertEquals actual="nodeName" expected="&quot;alpha&quot;" id="nodeinsertbefore19" ignoreCase="false"/>
            }
            // nodecomparedocumentposition03.xml
            #[test]
            fn test_nodecomparedocumentposition03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_comp: DocumentRef; // <var name="docComp" type="Document"/>
                let mut r#document_position1; // type: int // <var name="documentPosition1" type="int"/>
                let mut r#document_position2; // type: int // <var name="documentPosition2" type="int"/>
                let mut r#document_position3; // type: int // <var name="documentPosition3" type="int"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#doc_comp = todo!(); // hc_staff.xml // <load var="docComp" href="hc_staff" willBeModified="false"/>
                r#document_position1 = r#doc.compare_document_position(&r#doc_comp.into()); // <compareDocumentPosition var="documentPosition1" obj="doc" other="docComp"/>
                assert_eq!(u16::from(r#document_position1), 33); // <assertEquals bitmask="57" actual="documentPosition1" expected="33" id="isImplSpecificDisconnected1" ignoreCase="false"/>
                r#document_position2 = r#doc_comp.compare_document_position(&r#doc.into()); // <compareDocumentPosition var="documentPosition2" obj="docComp" other="doc"/>

                // unimplemented: // <assertNotEquals bitmask="2" actual="documentPosition2" expected="documentPosition1" id="notBothPreceding" ignoreCase="false"/>

                // unimplemented: // <assertNotEquals bitmask="4" actual="documentPosition2" expected="documentPosition1" id="notBothFollowing" ignoreCase="false"/>
                assert_eq!(u16::from(r#document_position2), 33); // <assertEquals bitmask="57" actual="documentPosition2" expected="33" id="isImplSpecificDisconnected2" ignoreCase="false"/>
                r#document_position3 = r#doc.compare_document_position(&r#doc_comp.into()); // <compareDocumentPosition var="documentPosition3" obj="doc" other="docComp"/>
                assert_eq!(r#document_position3, document_position1); // <assertEquals actual="documentPosition3" expected="documentPosition1" id="isConsistent" ignoreCase="false"/>
            }
            // nodereplacechild13.xml
            #[test]
            fn test_nodereplacechild13() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#new_doc_type; // type: DocumentType // <var name="newDocType" type="DocumentType"/>
                // let mut r#replaced; // type: DocumentType // <var name="replaced" type="DocumentType"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#null_pub_id; // type: DOMString // <var name="nullPubId" type="DOMString" isNull="true"/>
                // let mut r#null_sys_id; // type: DOMString // <var name="nullSysId" type="DOMString" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#doc_elem_name; // type: DOMString // <var name="docElemName" type="DOMString"/>
                // let mut r#doc_elem_ns; // type: DOMString // <var name="docElemNS" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#doc_elem_name = r#doc_elem.tag_name().to_string(); // <tagName var="docElemName" obj="docElem"/>
                // r#doc_elem_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="docElemNS" obj="docElem" interface="Node"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocumentType var="newDocType" obj="domImpl" qualifiedName="docElemName" publicId="nullPubId" systemId="nullSysId"/>

                // // unimplemented: // <try>	<replaceChild var="replaced" obj="doc" oldChild="docType" newChild="newDocType"/>	<catch>		<DOMException code="NOT_SUPPORTED_ERR">			<return/>		</DOMException>	</catch></try>
                // r#node_name = r#replaced.node_name().to_string(); // <nodeName var="nodeName" obj="replaced"/>
                // assert_eq!(r#node_name, doc_elem_name); // <assertEquals actual="nodeName" expected="docElemName" id="nodereplacechild13" ignoreCase="false"/>
            }
            // documentadoptnode01.xml
            #[test]
            fn test_documentadoptnode01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#attr_owner_elem; // type: Element // <var name="attrOwnerElem" type="Element"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#adoptedclass; // type: Node // <var name="adoptedclass" type="Node"/>
                // let mut r#attrs_parent; // type: Node // <var name="attrsParent" type="Node"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // let mut r#first_child; // type: Text // <var name="firstChild" type="Text"/>
                // let mut r#first_child_value; // type: DOMString // <var name="firstChildValue" type="DOMString"/>
                // let mut r#second_child; // type: EntityReference // <var name="secondChild" type="EntityReference"/>
                // let mut r#second_child_type; // type: int // <var name="secondChildType" type="int"/>
                // let mut r#second_child_name; // type: DOMString // <var name="secondChildName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#child_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#element = r#child_list.item(3).unwrap().clone(); // <item var="element" obj="childList" index="3" interface="NodeList"/>
                // r#attr = r#element.get_attribute_node("class").unwrap(); // <getAttributeNode var="attr" obj="element" name="&quot;class&quot;"/>
                // r#adoptedclass = r#doc.adopt_node(r#attr.into()).unwrap(); // <adoptNode var="adoptedclass" obj="doc" source="attr"/>

                // // unimplemented: // <if><notNull obj="adoptedclass"/><nodeName var="nodeName" obj="adoptedclass"/><nodeValue var="nodeValue" obj="adoptedclass"/><nodeType var="nodeType" obj="adoptedclass"/><ownerElement var="attrOwnerElem" obj="adoptedclass" interface="Attr"/><assertEquals expected="&quot;class&quot;" actual="nodeName" id="documentadoptode01_nodeName" ignoreCase="false"/><assertEquals expected="2" actual="nodeType" id="documentadoptNode01_nodeType" ignoreCase="false"/><assertNull actual="attrOwnerElem" id="documentadoptnode01_ownerDoc"/><!--  The attribute's child list can either be a text node "Y&#945;" or           an text node "Y" and a entity reference to "alpha"  --><firstChild var="firstChild" obj="adoptedclass" interface="Node"/><assertNotNull actual="firstChild" id="firstChildNotNull"/><nodeValue var="firstChildValue" obj="firstChild"/><if>	<equals actual="firstChildValue" expected="&quot;Y&quot;" ignoreCase="false"/>	<nextSibling var="secondChild" obj="firstChild" interface="Node"/>	<assertNotNull actual="secondChild" id="secondChildNotNull"/>	<nodeType var="secondChildType" obj="secondChild"/>	<assertEquals actual="secondChildType" expected="5" id="secondChildIsEntityReference" ignoreCase="false"/>	<nodeName var="secondChildName" obj="secondChild"/>	<assertEquals actual="secondChildName" expected="&quot;alpha&quot;" id="secondChildIsEnt1Reference" ignoreCase="false"/>	<else>		<assertEquals expected="&quot;Y&quot;" actual="nodeValue" id="documentadoptnode01_nodeValue" ignoreCase="false"/>	</else></if></if>
            }
            // domconfigwellformed1.xml
            #[test]
            fn test_domconfigwellformed1() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // let mut r#parameter; // type: DOMString // <var name="parameter" type="DOMString" value="&quot;wElL-formed&quot;"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDocType"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(r#state); // <assertTrue actual="state" id="defaultFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="true"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetTrue"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="false"/>

                // // unimplemented: // <if>  	  <isTrue value="canSet"/>  	  <setParameter obj="domConfig" name="parameter" value="false"/>  	  <getParameter var="state" obj="domConfig" name="parameter"/>  	  <assertFalse actual="state" id="setFalseEffective"/>  	  <else>  	  	  <assertDOMException id="throw_NOT_SUPPORTED_ERR">  	  	  	<NOT_SUPPORTED_ERR>  	  			<setParameter obj="domConfig" name="parameter" value="false"/>  	  		</NOT_SUPPORTED_ERR>  	  	  </assertDOMException>  	  	  <getParameter var="state" obj="domConfig" name="parameter"/>  	      <assertTrue actual="state" id="setFalseNotEffective"/>  	  </else>  </if>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="true"/>
            }
            // typeinfoisderivedfrom21.xml
            #[test]
            fn test_typeinfoisderivedfrom21() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "emType"); // <assertEquals actual="typeName" expected="&quot;emType&quot;" ignoreCase="false" id="typeName"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;emType&quot;" derivationMethod="1"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromSelfByRestriction"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;emType&quot;" derivationMethod="14"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="notDerivedFromSelfOtherMethod"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;emType&quot;" derivationMethod="0"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromSelfByAny"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;emType&quot;" derivationMethod="15"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromSelfByAll"/>
            }
            // documentrenamenode22.xml
            #[test]
            fn test_documentrenamenode22() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#renamed_node; // type: Node // <var name="renamedNode" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#attr = r#doc
                //     .create_attribute_ns(
                //         Some("http://www.w3.org/XML/1998/namespace"),
                //         "xml:lang".as_ref(),
                //     )
                //     .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><renameNode var="renamedNode" obj="doc" n="attr" namespaceURI="&quot;http://www.w3.org/1999/xmlns/&quot;" qualifiedName="&quot;xmlns&quot;"/></NAMESPACE_ERR></assertDOMException>
            }
            // elementsetidattributens12.xml
            #[test]
            fn test_elementsetidattributens12() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#acronym_elem1; // type: Element // <var name="acronymElem1" type="Element"/>
                let mut r#acronym_elem2; // type: Element // <var name="acronymElem2" type="Element"/>
                let mut r#acronym_elem3; // type: Element // <var name="acronymElem3" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "acronym"); // <getElementsByTagNameNS var="elemList" obj="doc" localName="&quot;acronym&quot;" namespaceURI="&quot;*&quot;" interface="Document"/>
                r#acronym_elem1 = r#elem_list.item(0).unwrap(); // <item var="acronymElem1" obj="elemList" index="0" interface="NodeList"/>
                r#acronym_elem2 = r#elem_list.item(1).unwrap(); // <item var="acronymElem2" obj="elemList" index="1" interface="NodeList"/>
                r#acronym_elem3 = r#elem_list.item(2).unwrap(); // <item var="acronymElem3" obj="elemList" index="2" interface="NodeList"/>
                r#acronym_elem1
                    .set_attribute_ns(
                        Some("http://www.w3.org/2001/XMLSchema-instance"),
                        "xsi:noNamespaceSchemaLocation",
                        "No",
                    )
                    .unwrap(); // <setAttributeNS obj="acronymElem1" qualifiedName="&quot;xsi:noNamespaceSchemaLocation&quot;" namespaceURI="&quot;http://www.w3.org/2001/XMLSchema-instance&quot;" value="&quot;No&quot;"/>
                r#acronym_elem1
                    .set_id_attribute_ns(
                        Some("http://www.w3.org/2001/XMLSchema-instance"),
                        "noNamespaceSchemaLocation",
                        true,
                    )
                    .unwrap(); // <setIdAttributeNS obj="acronymElem1" localName="&quot;noNamespaceSchemaLocation&quot;" namespaceURI="&quot;http://www.w3.org/2001/XMLSchema-instance&quot;" isId="true"/>
                r#acronym_elem2
                    .set_id_attribute_ns(
                        Some("http://www.w3.org/2001/XMLSchema-instance"),
                        "noNamespaceSchemaLocation",
                        true,
                    )
                    .unwrap(); // <setIdAttributeNS obj="acronymElem2" localName="&quot;noNamespaceSchemaLocation&quot;" namespaceURI="&quot;http://www.w3.org/2001/XMLSchema-instance&quot;" isId="true"/>
                r#acronym_elem3
                    .set_id_attribute_ns(
                        Some("http://www.w3.org/2001/XMLSchema-instance"),
                        "noNamespaceSchemaLocation",
                        true,
                    )
                    .unwrap(); // <setIdAttributeNS obj="acronymElem3" localName="&quot;noNamespaceSchemaLocation&quot;" namespaceURI="&quot;http://www.w3.org/2001/XMLSchema-instance&quot;" isId="true"/>
                r#attributes_map = r#acronym_elem1.attributes(); // <attributes var="attributesMap" obj="acronymElem1"/>
                r#attr = r#attributes_map
                    .get_named_item("xsi:noNamespaceSchemaLocation")
                    .unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;xsi:noNamespaceSchemaLocation&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributensIsId1True12"/>
                r#attributes_map = r#acronym_elem2.attributes(); // <attributes var="attributesMap" obj="acronymElem2"/>
                r#attr = r#attributes_map
                    .get_named_item("xsi:noNamespaceSchemaLocation")
                    .unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;xsi:noNamespaceSchemaLocation&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributensIsId2True12"/>
                r#attributes_map = r#acronym_elem3.attributes(); // <attributes var="attributesMap" obj="acronymElem3"/>
                r#attr = r#attributes_map
                    .get_named_item("xsi:noNamespaceSchemaLocation")
                    .unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;xsi:noNamespaceSchemaLocation&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributensIsId3True12"/>
                r#elem = r#doc.get_element_by_id("No".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;No&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "acronym"); // <assertEquals actual="elemName" expected="&quot;acronym&quot;" id="elementsetidattributensGetElementById10" ignoreCase="false"/>
            }
            // documentrenamenode27.xml
            #[test]
            fn test_documentrenamenode27() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                // let mut r#cdata; // type: CDATASection // <var name="cdata" type="CDATASection"/>
                // let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                // let mut r#entref; // type: EntityReference // <var name="entref" type="EntityReference"/>
                // let mut r#renamed_txt; // type: Node // <var name="renamedTxt" type="Node"/>
                // let mut r#renamed_comment; // type: Node // <var name="renamedComment" type="Node"/>
                // let mut r#renamed_cdata; // type: Node // <var name="renamedCdata" type="Node"/>
                // let mut r#renamed_pi; // type: Node // <var name="renamedPi" type="Node"/>
                // let mut r#renamed_ent_ref; // type: Node // <var name="renamedEntRef" type="Node"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#text = r#new_doc.create_text_node("text"); // <createTextNode var="text" obj="newDoc" data="&quot;text&quot;"/>
                // r#comment = r#new_doc.create_comment("comment"); // <createComment var="comment" obj="newDoc" data="&quot;comment&quot;"/>
                // r#cdata = r#new_doc.create_cdata_section("cdata").unwrap(); // <createCDATASection var="cdata" obj="newDoc" data="&quot;cdata&quot;"/>
                // r#pi = r#new_doc
                //     .create_processing_instruction("pit", Some("pid"))
                //     .unwrap(); // <createProcessingInstruction var="pi" obj="newDoc" target="&quot;pit&quot;" data="&quot;pid&quot;"/>
                // r#entref = r#new_doc
                //     .create_entity_reference("alpha".to_string())
                //     .unwrap(); // <createEntityReference var="entref" obj="newDoc" name="&quot;alpha&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_SUPPORTED_ERR_1"><NOT_SUPPORTED_ERR><renameNode var="renamedTxt" obj="newDoc" n="text" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;text&quot;"/></NOT_SUPPORTED_ERR></assertDOMException>

                // // unimplemented: // <assertDOMException id="throw_NOT_SUPPORTED_ERR_2"><NOT_SUPPORTED_ERR><renameNode var="renamedComment" obj="newDoc" n="comment" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;comment&quot;"/></NOT_SUPPORTED_ERR></assertDOMException>

                // // unimplemented: // <assertDOMException id="throw_NOT_SUPPORTED_ERR_3"><NOT_SUPPORTED_ERR><renameNode var="renamedCdata" obj="newDoc" n="cdata" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;cdata&quot;"/></NOT_SUPPORTED_ERR></assertDOMException>

                // // unimplemented: // <assertDOMException id="throw_NOT_SUPPORTED_ERR_4"><NOT_SUPPORTED_ERR><renameNode var="renamedPi" obj="newDoc" n="pi" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;pi&quot;"/></NOT_SUPPORTED_ERR></assertDOMException>

                // // unimplemented: // <assertDOMException id="throw_NOT_SUPPORTED_ERR_5"><NOT_SUPPORTED_ERR><renameNode var="renamedEntRef" obj="newDoc" n="entref" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;entref&quot;"/></NOT_SUPPORTED_ERR></assertDOMException>
            }
            // nodelookupprefix13.xml
            #[test]
            fn test_nodelookupprefix13() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#body_elem; // type: Element // <var name="bodyElem" type="Element"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#body_list; // type: NodeList // <var name="bodyList" type="NodeList"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#body_list = r#doc.get_elements_by_tag_name("body"); // <getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/>
                r#body_elem = r#body_list.item(0).unwrap(); // <item var="bodyElem" obj="bodyList" index="0" interface="NodeList"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "dom3:p".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:p&quot;"/>
                r#txt = r#doc.create_text_node("Text"); // <createTextNode var="txt" obj="doc" data="&quot;Text&quot;"/>
                r#appended_child = r#elem.append_child(txt.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="txt"/>
                r#appended_child = r#body_elem.append_child(elem.into()).unwrap(); // <appendChild obj="bodyElem" var="appendedChild" newChild="elem"/>
                r#prefix = r#txt
                    .lookup_prefix("http://www.w3.org/1999/xhtml")
                    .unwrap()
                    .to_string(); // <lookupPrefix var="prefix" obj="txt" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>
                assert_eq!(r#prefix, "dom3"); // <assertEquals actual="prefix" expected="&quot;dom3&quot;" id="nodelookupprefix13" ignoreCase="false"/>
            }
            // nodelookupprefix20.xml
            #[test]
            fn test_nodelookupprefix20() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#elem = r#elem_list.item(3).unwrap(); // <item var="elem" obj="elemList" index="3" interface="NodeList"/>
                r#attributes_map = r#elem.attributes(); // <attributes var="attributesMap" obj="elem"/>
                r#attr = r#attributes_map.get_named_item("xmlns:nm").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;xmlns:nm&quot;"/>
                r#prefix = r#attr
                    .lookup_prefix("http://www.altavista.com")
                    .unwrap()
                    .to_string(); // <lookupPrefix var="prefix" obj="attr" namespaceURI="&quot;http://www.altavista.com&quot;"/>
                assert_eq!(r#prefix, "nm"); // <assertEquals actual="prefix" expected="&quot;nm&quot;" id="nodelookupprefix20" ignoreCase="false"/>
            }
            // elementsetidattribute10.xml
            #[test]
            fn test_elementsetidattribute10() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>
                // r#acronym_elem
                //     .set_id_attribute("class".into(), true)
                //     .unwrap(); // <setIdAttribute obj="acronymElem" name="&quot;class&quot;" isId="true"/>
                // r#attributes_map = r#acronym_elem.attributes(); // <attributes var="attributesMap" obj="acronymElem"/>
                // r#attr = r#attributes_map.get_named_item("class").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;class&quot;"/>
                // r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                // assert!(r#id); // <assertTrue actual="id" id="elementsetidattributeIsId1True10"/>
                // r#acronym_elem
                //     .set_id_attribute("class".into(), true)
                //     .unwrap(); // <setIdAttribute obj="acronymElem" name="&quot;class&quot;" isId="true"/>
                // r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                // assert!(r#id); // <assertTrue actual="id" id="elementsetidattributeIsId2True10"/>
                // r#acronym_elem
                //     .set_id_attribute("class".into(), false)
                //     .unwrap(); // <setIdAttribute obj="acronymElem" name="&quot;class&quot;" isId="false"/>
                // r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                // assert!(!r#id); // <assertFalse actual="id" id="elementsetidattributeIsIdFalse10"/>
                // r#elem = r#doc.get_element_by_id("No".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;No&quot;"/>

                // // unimplemented: // <assertNull actual="elem" id="elementsetidattributeGetElementByIdNull10"/>
            }
            // nodegettextcontent17.xml
            #[test]
            fn test_nodegettextcontent17() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem = r#doc.document_element().unwrap(); // <documentElement var="elem" obj="doc"/>
                r#ent_ref = r#doc.create_entity_reference("beta".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;beta&quot;"/>
                r#appended_child = r#elem.append_child(ent_ref.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="entRef"/>
                r#text_content = r#ent_ref.text_content().unwrap(); // <textContent var="textContent" obj="entRef"/>
                assert_eq!(r#text_content, ""); // <assertEquals actual="textContent" expected="&quot;&quot;" id="nodegettextcontent17" ignoreCase="false"/>
            }
            // documentadoptnode26.xml
            #[test]
            fn test_documentadoptnode26() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#new_elem; // type: Element // <var name="newElem" type="Element"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#adopted_node; // type: Node // <var name="adoptedNode" type="Node"/>
                // let mut r#adopted_name; // type: DOMString // <var name="adoptedName" type="DOMString"/>
                // let mut r#adopted_ns; // type: DOMString // <var name="adoptedNS" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_tagname; // type: DOMString // <var name="rootTagname" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_tagname = r#doc_elem.tag_name().to_string(); // <tagName var="rootTagname" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootTagname" doctype="nullDocType"/>
                // r#new_elem = r#new_doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "head".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="newElem" obj="newDoc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;head&quot;"/>
                // r#new_elem
                //     .set_attribute_ns(
                //         Some("http://www.w3.org/XML/1998/namespace".into()),
                //         "xml:lang".into(),
                //         "en-US",
                //     )
                //     .unwrap(); // <setAttributeNS obj="newElem" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;" value="&quot;en-US&quot;"/>
                // r#doc_elem = r#new_doc.document_element().unwrap(); // <documentElement obj="newDoc" var="docElem"/>
                // r#appended_child = r#doc_elem.append_child(new_elem.into()).unwrap(); // <appendChild obj="docElem" var="appendedChild" newChild="newElem"/>
                // r#adopted_node = r#doc.adopt_node(r#new_elem.into()); // <adoptNode var="adoptedNode" obj="doc" source="newElem"/>

                // // unimplemented: // <if><notNull obj="adoptedNode"/><nodeName var="adoptedName" obj="adoptedNode"/><namespaceURI var="adoptedNS" obj="adoptedNode" interface="Node"/><assertEquals actual="adoptedName" expected="&quot;head&quot;" id="documentadoptnode26_1" ignoreCase="false"/><assertEquals actual="adoptedNS" expected="&quot;http://www.w3.org/1999/xhtml&quot;" id="documentadoptnode26_2" ignoreCase="false"/></if>
            }
            // nodesettextcontent10.xml
            #[test]
            fn test_nodesettextcontent10() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // unimplemented: // <implementationAttribute name="expandEntityReferences" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#cdata; // type: CDATASection // <var name="cdata" type="CDATASection"/>
                let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test"), "dom3:elem".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;dom3:elem&quot;"/>
                r#txt = r#doc.create_text_node("Text "); // <createTextNode var="txt" obj="doc" data="&quot;Text &quot;"/>
                r#comment = r#doc.create_comment("Comment "); // <createComment var="comment" obj="doc" data="&quot;Comment &quot;"/>
                r#ent_ref = r#doc.create_entity_reference("ent1".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent1&quot;"/>
                r#pi = r#doc
                    .create_processing_instruction("PIT", Some("PIData "))
                    .unwrap(); // <createProcessingInstruction var="pi" obj="doc" target="&quot;PIT&quot;" data="&quot;PIData &quot;"/>
                r#cdata = r#doc.create_cdata_section("CData").unwrap(); // <createCDATASection var="cdata" obj="doc" data="&quot;CData&quot;"/>
                r#appended_child = r#elem.append_child(txt.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="txt"/>
                r#appended_child = r#elem.append_child(comment.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="comment"/>
                r#appended_child = r#elem.append_child(ent_ref.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="entRef"/>
                r#appended_child = r#elem.append_child(pi.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="pi"/>
                r#appended_child = r#elem.append_child(cdata.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="cdata"/>
                r#elem.set_text_content("ELEMENT").unwrap(); // <textContent obj="elem" value="&quot;ELEMENT&quot;"/>
                r#text_content = r#elem.text_content().unwrap(); // <textContent var="textContent" obj="elem"/>
                assert_eq!(r#text_content, "ELEMENT"); // <assertEquals actual="textContent" expected="&quot;ELEMENT&quot;" id="nodesettextcontent10" ignoreCase="false"/>
            }
            // noderemovechild04.xml
            #[test]
            fn test_noderemovechild04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#removed_doc_type; // type: DocumentType // <var name="removedDocType" type="DocumentType"/>
                let mut r#removed; // type: Node // <var name="removed" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                r#removed = r#doc.remove_child(doc_type.into()).unwrap(); // <removeChild obj="doc" var="removed" oldChild="docType"/>
                r#removed_doc_type = r#doc.doctype().unwrap(); // <doctype var="removedDocType" obj="doc"/>

                // unimplemented: // <assertNull actual="removedDocType" id="noderemovechild04"/>

                // unimplemented: // <assertDOMException id="NOT_FOUND_ERR_noderemovechild04"><NOT_FOUND_ERR><removeChild obj="docType" var="removed" oldChild="doc"/></NOT_FOUND_ERR></assertDOMException>
            }
            // documentgetinputencoding04.xml
            #[test]
            fn test_documentgetinputencoding04() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#cloned: DocumentRef; // <var name="cloned" type="Document"/>
                // let mut r#encoding_name; // type: DOMString // <var name="encodingName" type="DOMString"/>
                // r#doc = todo!(); // barfoo_utf8.xml // <load var="doc" href="barfoo_utf8" willBeModified="false"/>
                // r#cloned = r#doc.clone_node(true).as_document().unwrap(); // <cloneNode var="cloned" obj="doc" deep="true"/>
                // r#encoding_name = r#cloned.input_encoding().unwrap().to_string();
                // // <inputEncoding obj="cloned" var="encodingName" interface="Document"/>

                // // unimplemented: // <assertTrue id="documentgetinputencoding04"><or><equals expected="&quot;UTF-8&quot;" actual="encodingName" ignoreCase="true"/><isNull obj="encodingName"/></or></assertTrue>
            }
            // noderemovechild12.xml
            #[test]
            fn test_noderemovechild12() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#e_ref; // type: EntityReference // <var name="eRef" type="EntityReference"/>
                let mut r#removed_e_ref; // type: EntityReference // <var name="removedERef" type="EntityReference"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#removed_child; // type: Node // <var name="removedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#e_ref = r#doc.create_entity_reference("ent1".to_string()).unwrap(); // <createEntityReference var="eRef" obj="doc" name="&quot;ent1&quot;"/>
                r#appended_child = r#doc_frag.append_child(e_ref.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="eRef"/>
                r#removed_child = r#doc_frag.remove_child(e_ref.into()).unwrap(); // <removeChild obj="docFrag" var="removedChild" oldChild="eRef"/>
                r#removed_e_ref = r#doc_frag.first_child().unwrap(); // <firstChild var="removedERef" obj="docFrag" interface="Node"/>

                // unimplemented: // <assertNull actual="removedERef" id="noderemovechild12"/>

                // unimplemented: // <try>        <removeChild obj="eRef" var="removedChild" oldChild="docFrag"/>        <catch>                <DOMException code="NOT_FOUND_ERR"/>                <DOMException code="NO_MODIFICATION_ALLOWED_ERR"/>        </catch></try>
            }
            // attrisid05.xml
            #[test]
            fn test_attrisid05() {
                // // unimplemented: // <implementationAttribute name="validating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#clonedacronym_elem; // type: Element // <var name="clonedacronymElem" type="Element"/>
                // let mut r#acronym_parent_elem; // type: Element // <var name="acronymParentElem" type="Element"/>
                // let mut r#appended_node; // type: Node // <var name="appendedNode" type="Node"/>
                // let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(3).unwrap(); // <item var="acronymElem" obj="elemList" index="3" interface="NodeList"/>
                // r#acronym_parent_elem = r#acronym_elem.parent_node().unwrap(); // <parentNode var="acronymParentElem" obj="acronymElem" interface="Node"/>
                // r#clonedacronym_elem = r#acronym_elem.clone_node(true); // <cloneNode var="clonedacronymElem" obj="acronymElem" deep="true"/>
                // r#appended_node = r#acronym_parent_elem
                //     .append_child(clonedacronym_elem.into())
                //     .unwrap(); // <appendChild var="appendedNode" obj="acronymParentElem" newChild="clonedacronymElem"/>
                // r#attr = r#acronym_elem.get_attribute_node("id").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;id&quot;"/>
                // r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                // assert!(r#id); // <assertTrue actual="id" id="AttrIsIDTrue05"/>
            }
            // documentgetxmlversion03.xml
            #[test]
            fn test_documentgetxmlversion03() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#version_value; // type: DOMString // <var name="versionValue" type="DOMString"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>
                // r#version_value = r#doc.xml_version().unwrap().to_string(); // <xmlVersion var="versionValue" obj="doc" interface="Document"/>
                // assert_eq!(r#version_value, "1.0"); // <assertEquals actual="versionValue" expected="&quot;1.0&quot;" id="documentgetxmlversion03" ignoreCase="true"/>
            }
            // nodereplacechild33.xml
            #[test]
            fn test_nodereplacechild33() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#parent; // type: Attr // <var name="parent" type="Attr"/>
                let mut r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                let mut r#new_child; // type: EntityReference // <var name="newChild" type="EntityReference"/>
                let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#new_child = r#doc.create_entity_reference("delta".to_string()).unwrap(); // <createEntityReference var="newChild" obj="doc" name="&quot;delta&quot;"/>
                r#child_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#elem = r#child_list.item(3).unwrap(); // <item var="elem" obj="childList" index="3" interface="NodeList"/>
                r#parent = r#elem.get_attribute_node("dir").unwrap(); // <getAttributeNode var="parent" obj="elem" name="&quot;dir&quot;"/>
                r#old_child = r#parent.last_child().unwrap(); // <lastChild var="oldChild" obj="parent" interface="Node"/>
                r#replaced = r#parent.replace_child(new_child.into(), old_child).unwrap(); // <replaceChild var="replaced" obj="parent" oldChild="oldChild" newChild="newChild"/>
                r#node_value = r#replaced.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="replaced"/>
                assert_eq!(r#node_value, "rtl"); // <assertEquals actual="nodeValue" expected="&quot;rtl&quot;" id="nodereplacechild33" ignoreCase="false"/>
            }
            // attrgetschematypeinfo01.xml
            #[test]
            fn test_attrgetschematypeinfo01() {
                // // unimplemented: // <implementationAttribute name="validating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#type_ns; // type: DOMString // <var name="typeNS" type="DOMString"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(0).unwrap(); // <item var="acronymElem" obj="elemList" index="0" interface="NodeList"/>
                // r#attr = r#acronym_elem.get_attribute_node("title").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;title&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "CDATA"); // <assertEquals actual="typeName" expected="&quot;CDATA&quot;" ignoreCase="false" id="nameIsCDATA"/>

                // // unimplemented: // <typeNamespace var="typeNS" obj="typeInfo"/>
                // assert_eq!(r#type_ns, "http://www.w3.org/TR/REC-xml"); // <assertEquals actual="typeNS" expected="&quot;http://www.w3.org/TR/REC-xml&quot;" ignoreCase="false" id="nsIsXML"/>
            }
            // nodecomparedocumentposition09.xml
            #[test]
            fn test_nodecomparedocumentposition09() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#new_elem; // type: Element // <var name="newElem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#document_position; // type: int // <var name="documentPosition" type="int"/>
                let mut r#document_element_position; // type: int // <var name="documentElementPosition" type="int"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#elem = r#elem_list.item(3).unwrap(); // <item var="elem" obj="elemList" index="3" interface="NodeList"/>
                r#new_elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "br".as_ref())
                    .unwrap(); // <createElementNS var="newElem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;br&quot;"/>
                r#appended_child = r#elem.append_child(new_elem.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="newElem"/>
                r#document_position = r#doc.compare_document_position(&r#new_elem.into()); // <compareDocumentPosition var="documentPosition" obj="doc" other="newElem"/>
                assert_eq!(u16::from(r#document_position), 20); // <assertEquals actual="documentPosition" expected="20" id="nodecomparedocumentpositionIsContainedFollowing09" ignoreCase="false"/>
                r#document_element_position = r#new_elem.compare_document_position(&r#doc.into()); // <compareDocumentPosition var="documentElementPosition" obj="newElem" other="doc"/>
                assert_eq!(u16::from(r#document_element_position), 10); // <assertEquals actual="documentElementPosition" expected="10" id="nodecomparedocumentpositionContainsPRECEDING09" ignoreCase="false"/>
            }
            // domconfigurationcansetparameter03.xml
            #[test]
            fn test_domconfigurationcansetparameter03() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#null_ns; // type: DOMString // <var name="nullNS" type="DOMString" isNull="true"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#entity_name; // type: DOMString // <var name="entityName" type="DOMString"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter obj="domConfig" var="canSet" name="&quot;entities&quot;" value="false"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetFalse"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype obj="doc" var="docType" interface="Document"/>

                // // unimplemented: // <entities obj="docType" var="entitiesMap" interface="DocumentType"/>
                // r#entity = r#entities_map.get_named_item("epsilon".into()).unwrap(); // <getNamedItem var="entity" obj="entitiesMap" name="&quot;epsilon&quot;"/>

                // // unimplemented: // <assertNotNull actual="entity" id="entityNotNull"/>
                // r#entity_name = r#entity.node_name().to_string(); // <nodeName obj="entity" var="entityName" interface="Node"/>
                // assert_eq!(r#entity_name, "epsilon"); // <assertEquals actual="entityName" expected="&quot;epsilon&quot;" id="entityName" ignoreCase="false"/>
            }
            // nodeisequalnode21.xml
            #[test]
            fn test_nodeisequalnode21() {
                let mut r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let mut r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let mut r#doc_type1; // type: DocumentType // <var name="docType1" type="DocumentType"/>
                let mut r#doc_type2; // type: DocumentType // <var name="docType2" type="DocumentType"/>
                let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                r#doc1 = todo!(); // hc_staff.xml // <load var="doc1" href="hc_staff" willBeModified="false"/>
                r#doc2 = todo!(); // hc_staff.xml // <load var="doc2" href="hc_staff" willBeModified="false"/>
                r#doc_type1 = r#doc1.doctype().unwrap(); // <doctype var="docType1" obj="doc1"/>
                r#doc_type2 = r#doc2.doctype().unwrap(); // <doctype var="docType2" obj="doc2"/>
                r#is_equal = r#doc_type1.is_equal_node(&r#doc_type2.into()); // <isEqualNode var="isEqual" obj="docType1" arg="docType2"/>
                assert!(r#is_equal); // <assertTrue actual="isEqual" id="nodeisequalnode21"/>
            }
            // nodegetbaseuri19.xml
            #[test]
            fn test_nodegetbaseuri19() {
                // // unimplemented: // <implementationAttribute name="validating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#base_uri; // type: DOMString // <var name="baseURI" type="DOMString"/>
                // let mut r#ent_base_uri; // type: DOMString // <var name="entBaseURI" type="DOMString"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                // r#doc = todo!(); // external_barfoo.xml // <load var="doc" href="external_barfoo" willBeModified="true"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" index="0" interface="NodeList"/>

                // // unimplemented: // <assertNotNull actual="pElem" id="pElemNotNull"/>

                // // unimplemented: // <if>    <implementationAttribute name="expandEntityReferences" value="true"/>    <firstChild var="textNode" obj="pElem" interface="Node"/>    <assertNotNull actual="textNode" id="expansionNotNull"/>    <else>		<lastChild var="entRef" obj="pElem" interface="Node"/>		<assertNotNull actual="entRef" id="entRefNotNull"/>		<firstChild var="textNode" obj="entRef" interface="Node"/>		<assertNotNull actual="textNode" id="entRefTextNotNull"/>	</else></if>
                // r#base_uri = r#text_node.base_uri().unwrap().to_string(); // <baseURI var="baseURI" obj="textNode" interface="Node"/>

                // // unimplemented: // <assertNull actual="baseURI" id="baseURI"/>
            }
            // attrisid04.xml
            #[test]
            fn test_attrisid04() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#acronym_elem = r#elem_list.item(3).unwrap(); // <item var="acronymElem" obj="elemList" index="3" interface="NodeList"/>
                r#attr = r#acronym_elem.get_attribute_node("id").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;id&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="AttrIsIDTrue04"/>
            }
            // domimplementationgetfeature02.xml
            #[test]
            fn test_domimplementationgetfeature02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#dom_impl_returned; // type: DOMImplementation // <var name="domImplReturned" type="DOMImplementation"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <getFeature var="domImplReturned" obj="domImpl" feature="&quot;Core&quot;" version="&quot;&quot;" interface="DOMImplementation"/>

                // // unimplemented: // <assertNotNull actual="domImplReturned" id="domimplementationgetfeature02"/>
            }
            // typeinfoisderivedfrom65.xml
            #[test]
            fn test_typeinfoisderivedfrom65() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#elem_type_info; // type: Element // <var name="elemTypeInfo" type="Element"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#strong_elem; // type: Element // <var name="strongElem" type="Element"/>
                // let mut r#attr_type_info; // type: TypeInfo // <var name="attrTypeInfo" type="TypeInfo"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // let mut r#ret_value; // type: boolean // <var name="retValue" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                // r#strong_elem = r#elem_list.item(0).unwrap(); // <item var="strongElem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="elemTypeInfo" obj="strongElem" interface="Element"/>

                // // unimplemented: // <isDerivedFrom obj="elemTypeInfo" var="retValue" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;string&quot;" derivationMethod="8"/>
                // assert!(r#ret_value); // <assertTrue actual="retValue" id="lisrDerivedFromString"/>
            }
            // documentgetxmlencoding04.xml
            #[test]
            fn test_documentgetxmlencoding04() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#encoding_name; // type: DOMString // <var name="encodingName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#encoding_name = r#doc.xml_encoding().unwrap().to_string(); // <xmlEncoding obj="doc" var="encodingName" interface="Document"/>

                // // unimplemented: // <assertNull actual="encodingName" id="documentgetxmlencoding04"/>
            }
            // nodeinsertbefore17.xml
            #[test]
            fn test_nodeinsertbefore17() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>

                // // unimplemented: // <implementationAttribute name="coalescing" value="true"/>

                // // unimplemented: // <implementationAttribute name="ignoringElementContentWhitespace" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#new_text; // type: Text // <var name="newText" type="Text"/>
                // let mut r#ref_node; // type: Node // <var name="refNode" type="Node"/>
                // let mut r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                // let mut r#inserted_text; // type: Text // <var name="insertedText" type="Text"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#inserted; // type: Node // <var name="inserted" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#child_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "p"); // <getElementsByTagNameNS var="childList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;p&quot;" interface="Document"/>
                // r#element = r#child_list.item(1).unwrap().clone(); // <item var="element" obj="childList" index="1" interface="NodeList"/>
                // r#ref_node = r#element.first_child().unwrap(); // <firstChild var="refNode" obj="element" interface="Node"/>
                // r#new_text = r#doc.create_text_node("newText"); // <createTextNode var="newText" obj="doc" data="&quot;newText&quot;" interface="Document"/>
                // r#inserted = r#element
                //     .insert_before(new_text.into(), ref_node.into())
                //     .unwrap(); // <insertBefore obj="element" var="inserted" refChild="refNode" newChild="newText"/>
                // r#inserted_text = r#element.first_child().unwrap(); // <firstChild var="insertedText" obj="element" interface="Node"/>
                // r#node_name = r#inserted_text.node_name().to_string(); // <nodeName var="nodeName" obj="insertedText"/>
                // assert_eq!(r#node_name, "#text"); // <assertEquals actual="nodeName" expected="&quot;#text&quot;" id="nodeinsertbefore17" ignoreCase="false"/>
            }
            // nodeisequalnode14.xml
            #[test]
            fn test_nodeisequalnode14() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attr1; // type: Attr // <var name="attr1" type="Attr"/>
                let mut r#attr2; // type: Attr // <var name="attr2" type="Attr"/>
                let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#attr1 = r#doc.create_attribute("root".to_string()).unwrap(); // <createAttribute var="attr1" obj="doc" name="&quot;root&quot;"/>
                r#attr2 = r#doc.create_attribute_ns(None, "root".as_ref()).unwrap(); // <createAttributeNS var="attr2" obj="doc" namespaceURI="nullNSURI" qualifiedName="&quot;root&quot;"/>
                r#is_equal = r#attr1.is_equal_node(&r#attr2.into()); // <isEqualNode var="isEqual" obj="attr1" arg="attr2"/>
                assert!(!r#is_equal); // <assertFalse actual="isEqual" id="nodeisequalnode14"/>
            }
            // nodeisequalnode20.xml
            #[test]
            fn test_nodeisequalnode20() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attr1; // type: Attr // <var name="attr1" type="Attr"/>
                let mut r#elem1; // type: Element // <var name="elem1" type="Element"/>
                let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem1 = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "xhtml:html".as_ref())
                    .unwrap(); // <createElementNS var="elem1" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:html&quot;"/>
                r#attr1 = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/1999/xhtml"),
                        "xhtml:html".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="attr1" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:html&quot;"/>
                r#is_equal = r#attr1.is_equal_node(&r#elem1.into()); // <isEqualNode var="isEqual" obj="attr1" arg="elem1"/>
                assert!(!r#is_equal); // <assertFalse actual="isEqual" id="nodeisequalnode20"/>
            }
            // noderemovechild24.xml
            #[test]
            fn test_noderemovechild24() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#alpha_entity; // type: Entity // <var name="alphaEntity" type="Entity"/>
                // let mut r#alpha_text; // type: Text // <var name="alphaText" type="Text"/>
                // let mut r#removed; // type: Text // <var name="removed" type="Text"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#alpha_entity = r#entities_map.get_named_item("alpha".into()).unwrap(); // <getNamedItem var="alphaEntity" obj="entitiesMap" name="&quot;alpha&quot;" interface="NamedNodeMap"/>

                // // unimplemented: // <assertNotNull actual="alphaEntity" id="alphaEntityNotNull"/>
                // r#alpha_text = r#alpha_entity.first_child().unwrap(); // <firstChild var="alphaText" obj="alphaEntity" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="alphaText" id="alphaTextNotNull"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">	<NO_MODIFICATION_ALLOWED_ERR>		<removeChild var="removed" obj="alphaEntity" oldChild="alphaText"/>	</NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // textreplacewholetext03.xml
            #[test]
            fn test_textreplacewholetext03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#replaced_text; // type: Text // <var name="replacedText" type="Text"/>
                let mut r#whole_text; // type: DOMString // <var name="wholeText" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#text_node = r#doc.create_text_node("New Text"); // <createTextNode var="textNode" obj="doc" data="&quot;New Text&quot;"/>
                r#replaced_text = r#text_node
                    .replace_whole_text(" a b c b ")
                    .unwrap()
                    .unwrap(); // <replaceWholeText obj="textNode" var="replacedText" content="&quot; a b c b &quot;"/>
                r#whole_text = r#replaced_text.whole_text().to_string(); // <wholeText var="wholeText" obj="replacedText"/>
                assert_eq!(r#whole_text, " a b c b "); // <assertEquals expected="&quot; a b c b &quot;" actual="wholeText" id="textreplacewholetext03" ignoreCase="false"/>
            }
            // nodegetfeature09.xml
            #[test]
            fn test_nodegetfeature09() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // let mut r#feature_impl; // type: Node // <var name="featureImpl" type="Node"/>
                // let mut r#is_supported; // type: boolean // <var name="isSupported" type="boolean"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#node = r#doc.create_comment("test comment"); // <createComment var="node" obj="doc" data="&quot;test comment&quot;"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Core&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="coreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="cOrEUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;+cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="PlusCoreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;org.w3c.domts.bogus.feature&quot;" version="nullVersion"/>

                // // unimplemented: // <assertNull actual="featureImpl" id="unrecognizedFeature"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;2.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core20"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;3.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core30"/>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="SVGUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="HTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="EventsUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSAsyncUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XPathUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusHTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusSVGUnspecified"/></if>
            }
            // entitygetinputencoding02.xml
            #[test]
            fn test_entitygetinputencoding02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#encoding_name; // type: DOMString // <var name="encodingName" type="DOMString"/>
                // r#doc = todo!(); // barfoo_utf16.xml // <load var="doc" href="barfoo_utf16" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#entity = r#entities_map.get_named_item("ent5".into()).unwrap(); // <getNamedItem var="entity" obj="entitiesMap" name="&quot;ent5&quot;"/>
                // r#encoding_name = r#entity.input_encoding().unwrap().to_string();
                // // <inputEncoding obj="entity" var="encodingName" interface="Entity"/>

                // // unimplemented: // <assertNull actual="encodingName" id="entitygetinputencoding02"/>
            }
            // nodesetuserdata07.xml
            #[test]
            fn test_nodesetuserdata07() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                // let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                // let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                // let mut r#user_data; // type: DOMUserData // <var name="userData" type="DOMUserData"/>
                // let mut r#returned; // type: DOMUserData // <var name="returned" type="DOMUserData"/>
                // let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                // let mut r#ret_user_data; // type: DOMUserData // <var name="retUserData" type="DOMUserData"/>
                // let mut r#null_handler; // type: UserDataHandler // <var name="nullHandler" type="UserDataHandler" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <notations var="notations" obj="docType"/>
                // r#notation = r#notations.get_named_item("notation1".into()).unwrap(); // <getNamedItem var="notation" obj="notations" name="&quot;notation1&quot;"/>
                // r#comment = r#doc.create_comment("COMMENT_NODE"); // <createComment var="comment" obj="doc" data="&quot;COMMENT_NODE&quot;"/>

                // // unimplemented: // <setUserData obj="notation" var="retUserData" key="&quot;Key1&quot;" data="comment" handler="nullHandler"/>

                // // unimplemented: // <setUserData var="returned" obj="notation" key="&quot;Key1&quot;" data="comment" handler="nullHandler"/>
                // r#success = r#returned.is_equal_node(&r#comment.into()); // <isEqualNode var="success" obj="returned" arg="comment"/>
                // assert!(r#success); // <assertTrue actual="success" id="nodesetuserdata07"/>
            }
            // documentadoptnode33.xml
            #[test]
            fn test_documentadoptnode33() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#new_cdata; // type: Node // <var name="newCDATA" type="Node"/>
                // let mut r#adopted_cdata; // type: Node // <var name="adoptedCDATA" type="Node"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#new_cdata = r#new_doc
                //     .create_cdata_section("Document.adoptNode test for a CDATASECTION_NODE")
                //     .unwrap(); // <createCDATASection var="newCDATA" obj="newDoc" data="&quot;Document.adoptNode test for a CDATASECTION_NODE&quot;"/>
                // r#adopted_cdata = r#doc.adopt_node(r#new_cdata.into()); // <adoptNode var="adoptedCDATA" obj="doc" source="newCDATA"/>

                // // unimplemented: // <if><notNull obj="adoptedCDATA"/><nodeValue var="nodeValue" obj="adoptedCDATA"/><assertEquals actual="nodeValue" expected="&quot;Document.adoptNode test for a CDATASECTION_NODE&quot;" id="documentadoptnode33" ignoreCase="false"/></if>
            }
            // elementsetidattributenode06.xml
            #[test]
            fn test_elementsetidattributenode06() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list1; // type: NodeList // <var name="elemList1" type="NodeList"/>
                // let mut r#elem_list2; // type: NodeList // <var name="elemList2" type="NodeList"/>
                // let mut r#name_elem; // type: Element // <var name="nameElem" type="Element"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#name_element; // type: Element // <var name="nameElement" type="Element"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#elem_list1 = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList1" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                // r#elem_list2 = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList2" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#name_elem = r#elem_list1.item(1).unwrap(); // <item var="nameElem" obj="elemList1" index="1" interface="NodeList"/>
                // r#acronym_elem = r#elem_list2.item(1).unwrap(); // <item var="acronymElem" obj="elemList2" index="1" interface="NodeList"/>
                // r#attributes_map = r#acronym_elem.attributes(); // <attributes var="attributesMap" obj="acronymElem"/>
                // r#attr = r#attributes_map
                //     .get_named_item("xsi:noNamespaceSchemaLocation")
                //     .unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;xsi:noNamespaceSchemaLocation&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR"><NOT_FOUND_ERR><setIdAttributeNode obj="nameElem" idAttr="attr" isId="true"/></NOT_FOUND_ERR></assertDOMException>
            }
            // nodeinsertbefore01.xml
            #[test]
            fn test_nodeinsertbefore01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#new_comment; // type: Comment // <var name="newComment" type="Comment"/>
                let mut r#inserted_comment; // type: Comment // <var name="insertedComment" type="Comment"/>
                let mut r#data; // type: DOMString // <var name="data" type="DOMString"/>
                let mut r#new_pi; // type: ProcessingInstruction // <var name="newPI" type="ProcessingInstruction"/>
                let mut r#inserted_pi; // type: ProcessingInstruction // <var name="insertedPI" type="ProcessingInstruction"/>
                let mut r#target; // type: DOMString // <var name="target" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#new_comment = r#doc.create_comment("Comment"); // <createComment var="newComment" obj="doc" data="&quot;Comment&quot;"/>
                r#new_pi = r#doc
                    .create_processing_instruction("PITarget", Some("PIData"))
                    .unwrap(); // <createProcessingInstruction var="newPI" obj="doc" target="&quot;PITarget&quot;" data="&quot;PIData&quot;"/>
                r#inserted_comment = r#doc
                    .insert_before(new_comment.into(), Some(doc_elem.into()))
                    .unwrap()
                    .as_comment()
                    .unwrap(); // <insertBefore var="insertedComment" obj="doc" newChild="newComment" refChild="docElem"/>
                r#data = r#inserted_comment.data().to_string(); // <data var="data" obj="insertedComment" interface="CharacterData"/>
                assert_eq!(r#data, "Comment"); // <assertEquals actual="data" expected="&quot;Comment&quot;" id="nodeinsertbefore01_1" ignoreCase="false"/>
                r#inserted_pi = r#doc
                    .insert_before(new_pi.into(), Some(new_comment.into()))
                    .unwrap()
                    .as_processing_instruction()
                    .unwrap(); // <insertBefore var="insertedPI" obj="doc" newChild="newPI" refChild="newComment"/>
                r#target = r#inserted_pi.target().to_string(); // <target var="target" obj="insertedPI" interface="ProcessingInstruction"/>
                assert_eq!(r#target, "PITarget"); // <assertEquals actual="target" expected="&quot;PITarget&quot;" id="nodeinsertbefore01_2" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom27.xml
            #[test]
            fn test_typeinfoisderivedfrom27() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "strongType"); // <assertEquals actual="typeName" expected="&quot;strongType&quot;" ignoreCase="false" id="typeName"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anyType&quot;" derivationMethod="6"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="derivedFromAnyType"/>
            }
            // domconfigschematype1.xml
            #[test]
            fn test_domconfigschematype1() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#state; // type: DOMString // <var name="state" type="DOMString"/>
                // let mut r#parameter; // type: DOMString // <var name="parameter" type="DOMString" value="&quot;sChEma-type&quot;"/>
                // let mut r#xml_schema_type; // type: DOMString // <var name="xmlSchemaType" type="DOMString" value="&quot;http://www.w3.org/2001/XMLSchema&quot;"/>
                // let mut r#dtd_type; // type: DOMString // <var name="dtdType" type="DOMString" value="&quot;http://www.w3.org/TR/REC-xml&quot;"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDocType"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="true"/>
                // assert!(!r#can_set); // <assertFalse actual="canSet" id="canSetTrue"/>

                // // unimplemented: // <try>  	<getParameter var="state" obj="domConfig" name="parameter"/>  	<catch>  		<DOMException code="NOT_FOUND_ERR">  			<return/>  		</DOMException>  	</catch>  </try>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="dtdType"/>

                // // unimplemented: // <if>  	<isTrue value="canSet"/>  	<setParameter obj="domConfig" name="parameter" value="dtdType"/>  	<getParameter var="state" obj="domConfig" name="parameter"/>  	<assertEquals actual="state" expected="dtdType" ignoreCase="false" id="setDTDEffective"/>  	<else>  		<assertDOMException id="throw_NOT_SUPPORTED_ERR_dtd">  			<NOT_SUPPORTED_ERR>  				<setParameter obj="domConfig" name="parameter" value="dtdType"/>  			</NOT_SUPPORTED_ERR>  		</assertDOMException>  	</else>  </if>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="xmlSchemaType"/>

                // // unimplemented: // <if>  	<isTrue value="canSet"/>  	<setParameter obj="domConfig" name="parameter" value="xmlSchemaType"/>  	<getParameter var="state" obj="domConfig" name="parameter"/>  	<assertEquals actual="state" expected="xmlSchemaType" ignoreCase="false" id="setSchemaEffective"/>  	<else>  		<assertDOMException id="throw_NOT_SUPPORTED_ERR_schema">  			<NOT_SUPPORTED_ERR>  				<setParameter obj="domConfig" name="parameter" value="xmlSchemaType"/>  			</NOT_SUPPORTED_ERR>  		</assertDOMException>  	</else>  </if>
            }
            // elementsetidattributens08.xml
            #[test]
            fn test_elementsetidattributens08() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#employee_elem; // type: Element // <var name="employeeElem" type="Element"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#employee_elem = r#elem_list.item(1).unwrap(); // <item var="employeeElem" obj="elemList" index="1" interface="NodeList"/>

                // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR"><NOT_FOUND_ERR><setIdAttributeNS obj="employeeElem" localName="&quot;usa&quot;" namespaceURI="&quot;http://www.usa.com&quot;" isId="true"/></NOT_FOUND_ERR></assertDOMException>
            }
            // nodegetfeature04.xml
            #[test]
            fn test_nodegetfeature04() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // let mut r#feature_impl; // type: Node // <var name="featureImpl" type="Node"/>
                // let mut r#is_supported; // type: boolean // <var name="isSupported" type="boolean"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#node = r#doc.create_entity_reference("ent1".to_string()).unwrap();
                // // <createEntityReference var="node" obj="doc" name="&quot;ent1&quot;"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Core&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="coreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="cOrEUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;+cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="PlusCoreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;org.w3c.domts.bogus.feature&quot;" version="nullVersion"/>

                // // unimplemented: // <assertNull actual="featureImpl" id="unrecognizedFeature"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;2.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core20"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;3.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core30"/>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="SVGUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="HTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="EventsUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSAsyncUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XPathUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusHTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusSVGUnspecified"/></if>
            }
            // documentrenamenode03.xml
            #[test]
            fn test_documentrenamenode03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#renamed_node; // type: Node // <var name="renamedNode" type="Node"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#attr = r#doc.create_attribute_ns(None, "test".as_ref()).unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="nullNSURI" qualifiedName="&quot;test&quot;"/>
                r#renamed_node = r#doc
                    .rename_node(
                        r#attr.into(),
                        Some("http://www.w3.org/DOM/Test"),
                        "pre0:fix1",
                    )
                    .unwrap(); // <renameNode var="renamedNode" obj="doc" n="attr" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;pre0:fix1&quot;"/>
                r#node_name = r#renamed_node.node_name().to_string(); // <nodeName var="nodeName" obj="renamedNode"/>
                r#namespace_uri = r#renamed_node.namespace_uri().unwrap().to_string(); // <namespaceURI var="namespaceURI" obj="renamedNode" interface="Node"/>
                assert_eq!(r#node_name, "pre0:fix1"); // <assertEquals expected="&quot;pre0:fix1&quot;" actual="nodeName" id="documentrenamenode03_nodeName" ignoreCase="false"/>
                assert_eq!(r#namespace_uri, "http://www.w3.org/DOM/Test"); // <assertEquals expected="&quot;http://www.w3.org/DOM/Test&quot;" actual="namespaceURI" id="documentrenamenode02_namespaceURI" ignoreCase="false"/>
            }
            // normalizecharacters07.xml
            #[test]
            fn test_normalizecharacters07() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // let mut r#text_value; // type: DOMString // <var name="textValue" type="DOMString"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;normalize-characters&quot;" value="false"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" index="0" interface="NodeList"/>
                // r#text = r#doc.create_text_node("sucon"); // <createTextNode var="text" obj="doc" data="&quot;sucon&quot;"/>
                // r#retval = r#p_elem.append_child(text.into()).unwrap(); // <appendChild var="retval" obj="pElem" newChild="text"/>
                // r#retval.normalize(); // <normalize obj="retval"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" index="0" interface="NodeList"/>
                // r#text = r#p_elem.last_child().unwrap().as_text_node().unwrap(); // <lastChild var="text" obj="pElem" interface="Node"/>
                // r#text_value = r#text.node_value().unwrap().to_string(); // <nodeValue var="textValue" obj="text"/>
                // assert_eq!(r#text_value, "sucon"); // <assertEquals actual="textValue" expected="&quot;sucon&quot;" ignoreCase="false" id="noCharNormalization"/>
            }
            // nodereplacechild39.xml
            #[test]
            fn test_nodereplacechild39() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                let mut r#new_comment; // type: Comment // <var name="newComment" type="Comment"/>
                let mut r#new_element; // type: Element // <var name="newElement" type="Element"/>
                let mut r#ret_node; // type: Node // <var name="retNode" type="Node"/>
                r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>
                r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                r#new_element = r#doc
                    .create_element_ns(Some(r#root_ns.as_ref()), r#root_name.as_ref())
                    .unwrap(); // <createElementNS var="newElement" obj="doc" namespaceURI="rootNS" qualifiedName="rootName"/>
                r#new_comment = r#doc.create_comment("second element goes here"); // <createComment var="newComment" obj="doc" data="&quot;second element goes here&quot;"/>
                r#ret_node = r#doc.append_child(new_comment.into()).unwrap(); // <appendChild var="retNode" obj="doc" newChild="newComment"/>

                // unimplemented: // <try>	<replaceChild var="retNode" obj="doc" newChild="newElement" oldChild="newComment"/>	<fail id="throw_HIERARCHY_REQUEST_OR_NOT_SUPPORTED"/>	<catch>		<DOMException code="HIERARCHY_REQUEST_ERR"/>		<DOMException code="NOT_SUPPORTED_ERR"/>	</catch></try>
            }
            // nodecomparedocumentposition16.xml
            #[test]
            fn test_nodecomparedocumentposition16() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#attr_cloned; // type: Attr // <var name="attrCloned" type="Attr"/>
                // let mut r#doc_frag_position; // type: int // <var name="docFragPosition" type="int"/>
                // let mut r#position1; // type: int // <var name="position1" type="int"/>
                // let mut r#position2; // type: int // <var name="position2" type="int"/>
                // let mut r#position3; // type: int // <var name="position3" type="int"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                // r#attr = r#doc
                //     .create_attribute_ns(
                //         Some("http://www.w3.org/XML/1998/namespace"),
                //         "xml:lang".as_ref(),
                //     )
                //     .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>
                // r#attr_cloned = r#attr.clone_node(true); // <cloneNode var="attrCloned" obj="attr" deep="true"/>
                // r#position1 = r#doc_frag.compare_document_position(&r#attr_cloned.into()); // <compareDocumentPosition var="position1" obj="docFrag" other="attrCloned"/>
                // assert_eq!(u16::from(r#position1), 33); // <assertEquals bitmask="57" actual="position1" expected="33" id="isImplSpecificDisconnected1" ignoreCase="false"/>
                // r#position2 = r#attr_cloned.compare_document_position(&r#doc_frag.into()); // <compareDocumentPosition var="position2" obj="attrCloned" other="docFrag"/>

                // // unimplemented: // <assertNotEquals bitmask="2" actual="position2" expected="position1" id="notBothPreceding" ignoreCase="false"/>

                // // unimplemented: // <assertNotEquals bitmask="4" actual="position2" expected="position1" id="notBothFollowing" ignoreCase="false"/>
                // assert_eq!(u16::from(r#position2), 33); // <assertEquals bitmask="57" actual="position2" expected="33" id="isImplSpecificDisconnected2" ignoreCase="false"/>
                // r#position3 = r#doc_frag.compare_document_position(&r#attr_cloned.into()); // <compareDocumentPosition var="position3" obj="docFrag" other="attrCloned"/>
                // assert_eq!(r#position3, position1); // <assertEquals actual="position3" expected="position1" id="isConsistent" ignoreCase="false"/>
            }
            // nodereplacechild26.xml
            #[test]
            fn test_nodereplacechild26() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#child_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#child_list.item(0).unwrap().clone(); // <item var="elem" obj="childList" index="0" interface="NodeList"/>
                // r#first_child = r#elem.first_child().unwrap(); // <firstChild var="firstChild" obj="elem" interface="Node"/>

                // // unimplemented: // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR"><HIERARCHY_REQUEST_ERR><replaceChild obj="elem" var="replaced" oldChild="firstChild" newChild="docElem"/></HIERARCHY_REQUEST_ERR></assertDOMException>
            }
            // noderemovechild16.xml
            #[test]
            fn test_noderemovechild16() {
                // // unimplemented: // <implementationAttribute name="ignoringElementContentWhitespace" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#parent_list; // type: NodeList // <var name="parentList" type="NodeList"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#parent; // type: Element // <var name="parent" type="Element"/>
                // let mut r#child; // type: Element // <var name="child" type="Element"/>
                // let mut r#removed; // type: Element // <var name="removed" type="Element"/>
                // let mut r#removed_name; // type: DOMString // <var name="removedName" type="DOMString"/>
                // let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#parent_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="parentList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                // r#child = r#parent_list[0].clone(); // <item var="child" obj="parentList" index="0" interface="NodeList"/>
                // r#parent = r#child.parent_node().unwrap(); // <parentNode var="parent" obj="child" interface="Node"/>
                // r#removed = r#parent.remove_child(child.into()).unwrap(); // <removeChild var="removed" obj="parent" oldChild="child"/>
                // r#removed_name = r#removed.node_name().to_string(); // <nodeName obj="removed" var="removedName"/>
                // assert_eq!(r#removed_name, "em"); // <assertEquals actual="removedName" expected="&quot;em&quot;" id="noderemovechild16" ignoreCase="false"/>

                // // unimplemented: // <assertDOMException id="NOT_FOUND_ERR_noderemovechild16"><NOT_FOUND_ERR><removeChild obj="child" var="removedNode" oldChild="parent"/></NOT_FOUND_ERR></assertDOMException>
            }
            // nodegettextcontent14.xml
            #[test]
            fn test_nodegettextcontent14() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#elem = r#elem_list.item(2).unwrap(); // <item var="elem" obj="elemList" index="2" interface="NodeList"/>
                r#text_content = r#elem.text_content().unwrap(); // <textContent var="textContent" obj="elem"/>
                assert_eq!(
                    r#text_content,
                    "\n  EMP0003\n  Roger\n Jones\n  Department Manager\n  100,000\n  Element data\n  PO Box 27 Irving, texas 98553\n "
                );
                // <assertEquals actual="textContent" expected="&quot;\n  EMP0003\n  Roger\n Jones\n  Department Manager\n  100,000\n  Element data\n  PO Box 27 Irving, texas 98553\n &quot;" id="nodegettextcontent13" ignoreCase="false"/>
            }
            // elementsetidattribute11.xml
            #[test]
            fn test_elementsetidattribute11() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#acronym_elem = r#elem_list.item(3).unwrap(); // <item var="acronymElem" obj="elemList" index="3" interface="NodeList"/>
                r#acronym_elem.set_id_attribute("class", true).unwrap(); // <setIdAttribute obj="acronymElem" name="&quot;class&quot;" isId="true"/>
                r#attributes_map = r#acronym_elem.attributes(); // <attributes var="attributesMap" obj="acronymElem"/>
                r#attr = r#attributes_map.get_named_item("class").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;class&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributeIsIdTrue01"/>
                r#elem = r#doc.get_element_by_id("Y".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;Y&quot;"/>

                // unimplemented: // <assertNotNull actual="elem" id="elemByIDNotNull"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "acronym"); // <assertEquals actual="elemName" expected="&quot;acronym&quot;" id="elementsetidattributeGetElementById11" ignoreCase="false"/>
                r#acronym_elem.set_id_attribute("class", false).unwrap(); // <setIdAttribute obj="acronymElem" name="&quot;class&quot;" isId="false"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(!r#id); // <assertFalse actual="id" id="elementsetidattributeIsIdFalse11"/>
            }
            // typeinfoisderivedfrom13.xml
            #[test]
            fn test_typeinfoisderivedfrom13() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>
                // r#attr = r#acronym_elem.get_attribute_node("class").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;class&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "classType"); // <assertEquals actual="typeName" expected="&quot;classType&quot;" ignoreCase="false" id="name"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anyType&quot;" derivationMethod="14"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="derivedFromAnyTypeExceptRestriction"/>
            }
            // domimplementationregistry18.xml
            #[test]
            fn test_domimplementationregistry18() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#dom_impl_list; // type: DOMImplementationList // <var name="domImplList" type="DOMImplementationList"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementationList var="domImplList" obj="domImplRegistry" features="&quot;http://www.example.com/bogus-feature 99.0&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <length var="length" obj="domImplList" interface="DOMImplementationList"/>
                // assert_eq!(r#length, 0); // <assertEquals actual="length" expected="0" ignoreCase="false" id="emptyList"/>
            }
            // nodelookupprefix15.xml
            #[test]
            fn test_nodelookupprefix15() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#body_elem; // type: Element // <var name="bodyElem" type="Element"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                let mut r#cloned_comment; // type: Comment // <var name="clonedComment" type="Comment"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#body_list; // type: NodeList // <var name="bodyList" type="NodeList"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#body_list = r#doc.get_elements_by_tag_name("body"); // <getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/>
                r#body_elem = r#body_list.item(0).unwrap(); // <item var="bodyElem" obj="bodyList" index="0" interface="NodeList"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "dom3:p".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:p&quot;"/>
                r#comment = r#doc.create_comment("Text"); // <createComment var="comment" obj="doc" data="&quot;Text&quot;"/>
                r#cloned_comment = r#comment.clone_node(true); // <cloneNode var="clonedComment" obj="comment" deep="true"/>
                r#appended_child = r#elem.append_child(cloned_comment).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="clonedComment"/>
                r#appended_child = r#body_elem.append_child(elem.into()).unwrap(); // <appendChild obj="bodyElem" var="appendedChild" newChild="elem"/>
                r#prefix = r#cloned_comment
                    .lookup_prefix("http://www.w3.org/1999/xhtml")
                    .unwrap()
                    .to_string(); // <lookupPrefix var="prefix" obj="clonedComment" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>
                assert_eq!(r#prefix, "dom3"); // <assertEquals actual="prefix" expected="&quot;dom3&quot;" id="nodelookupprefix15" ignoreCase="false"/>
            }
            // documentgetxmlstandalone03.xml
            #[test]
            fn test_documentgetxmlstandalone03() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#standalone; // type: boolean // <var name="standalone" type="boolean"/>
                // r#doc = todo!(); // barfoo_standalone_no.xml // <load var="doc" href="barfoo_standalone_no" willBeModified="false"/>
                // r#standalone = r#doc.xml_standalone(); // <xmlStandalone var="standalone" obj="doc"/>
                // assert!(!r#standalone); // <assertFalse actual="standalone" id="documentgetxmlstandalone03"/>
            }
            // nodeisdefaultnamespace09.xml
            #[test]
            fn test_nodeisdefaultnamespace09() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#parent; // type: Element // <var name="parent" type="Element"/>
                let mut r#child; // type: Element // <var name="child" type="Element"/>
                let mut r#is_default; // type: boolean // <var name="isDefault" type="boolean"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#parent = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "xhtml:body".as_ref())
                    .unwrap(); // <createElementNS var="parent" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:body&quot;"/>
                r#child = r#doc.create_element("xhtml:p".to_string()).unwrap(); // <createElement var="child" obj="doc" tagName="&quot;xhtml:p&quot;"/>
                r#appended_child = r#parent.append_child(child.into()).unwrap(); // <appendChild obj="parent" var="appendedChild" newChild="child"/>
                r#is_default = r#parent.is_default_namespace("http://www.w3.org/1999/xhtml"); // <isDefaultNamespace var="isDefault" obj="parent" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>
                assert!(!r#is_default); // <assertFalse actual="isDefault" id="nodeisdefaultnamespace09_1"/>
                r#is_default = r#child.is_default_namespace("http://www.w3.org/1999/xhtml"); // <isDefaultNamespace var="isDefault" obj="child" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>
                assert!(!r#is_default); // <assertFalse actual="isDefault" id="nodeisdefaultnamespace09_2"/>
            }
            // canonicalform12.xml
            #[test]
            fn test_canonicalform12() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#doctype; // type: DocumentType // <var name="doctype" type="DocumentType"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;canonical-form&quot;" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;canonical-form&quot;" value="true"/><setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/><normalizeDocument obj="doc"/><!--  fail test if normalize had any errors or fatal errors   --><assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/><doctype var="doctype" obj="doc"/><assertNull actual="doctype" id="docTypeNull"/></if>
            }
            // nodeinsertbefore03.xml
            #[test]
            fn test_nodeinsertbefore03() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                // let mut r#inserted; // type: Node // <var name="inserted" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                // r#new_attr = r#doc
                //     .create_attribute_ns(
                //         Some("http://www.w3.org/XML/1998/namespace"),
                //         "xml:lang".as_ref(),
                //     )
                //     .unwrap(); // <createAttributeNS var="newAttr" obj="doc" qualifiedName="&quot;xml:lang&quot;" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR"><HIERARCHY_REQUEST_ERR><insertBefore obj="doc" var="inserted" newChild="newAttr" refChild="docType"/></HIERARCHY_REQUEST_ERR></assertDOMException>
            }
            // datatypenormalization12.xml
            #[test]
            fn test_datatypenormalization12() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#str; // type: DOMString // <var name="str" type="DOMString"/>
                // let mut r#can_set_normalization; // type: boolean // <var name="canSetNormalization" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#can_set_xml_schema; // type: boolean // <var name="canSetXMLSchema" type="boolean"/>
                // let mut r#xsd_ns; // type: DOMString // <var name="xsdNS" type="DOMString" value="&quot;http://www.w3.org/2001/XMLSchema&quot;"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // r#doc = todo!(); // datatype_normalization.xml // <load var="doc" href="datatype_normalization" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetNormalization" obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetValidate" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetXMLSchema" obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>

                // // unimplemented: // <if>	<and>		<isTrue value="canSetNormalization"/>		<isTrue value="canSetValidate"/>		<isTrue value="canSetXMLSchema"/>	</and>	<setParameter obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>	<normalizeDocument obj="doc"/>	<!--  fail test if normalize had any errors or fatal errors   -->	<assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>	<getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;http://www.w3.org/2001/DOM-Test-Suite/Level-3/datatype_normalization&quot;" localName="&quot;time&quot;" interface="Document"/>	<item var="element" obj="elemList" interface="NodeList" index="0"/>	<getAttribute var="str" obj="element" name="&quot;default&quot;"/>	<!-- .0 would not be correct, see http://www.w3.org/2001/05/xmlschema-errata#E2-63    -->	<assertEquals actual="str" expected="&quot;20:30:00Z&quot;" ignoreCase="false" id="firstValue"/></if>
            }
            // noderemovechild30.xml
            #[test]
            fn test_noderemovechild30() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#parent_list; // type: NodeList // <var name="parentList" type="NodeList"/>
                // let mut r#attrs_map; // type: NamedNodeMap // <var name="attrsMap" type="NamedNodeMap"/>
                // let mut r#parent; // type: Attr // <var name="parent" type="Attr"/>
                // let mut r#child; // type: Text // <var name="child" type="Text"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#removed; // type: Text // <var name="removed" type="Text"/>
                // let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                // let mut r#removed_name; // type: DOMString // <var name="removedName" type="DOMString"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#parent_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="parentList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#parent_list[3].clone(); // <item var="elem" obj="parentList" index="3" interface="NodeList"/>
                // r#attrs_map = r#elem.attributes(); // <attributes var="attrsMap" obj="elem"/>
                // r#parent = r#attrs_map.get_named_item("dir").unwrap(); // <getNamedItem var="parent" obj="attrsMap" name="&quot;dir&quot;"/>
                // r#child = r#parent.first_child().unwrap(); // <firstChild var="child" obj="parent" interface="Node"/>
                // r#removed = r#parent.remove_child(child.into()).unwrap(); // <removeChild var="removed" obj="parent" oldChild="child"/>
                // r#removed_name = r#removed.node_value().unwrap().to_string(); // <nodeValue obj="removed" var="removedName"/>
                // assert_eq!(r#removed_name, "rtl"); // <assertEquals actual="removedName" expected="&quot;rtl&quot;" id="noderemovechild30" ignoreCase="false"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR"><NOT_FOUND_ERR><removeChild obj="child" var="removedNode" oldChild="parent"/></NOT_FOUND_ERR></assertDOMException>
            }
            // documentnormalizedocument03.xml
            #[test]
            fn test_documentnormalizedocument03() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#new_cdata; // type: CDATASection // <var name="newCdata" type="CDATASection"/>
                // let mut r#cdata; // type: CDATASection // <var name="cdata" type="CDATASection"/>
                // let mut r#text; // type: Node // <var name="text" type="Node"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#p_list.item(0).unwrap(); // <item var="elem" obj="pList" index="0" interface="NodeList"/>
                // r#new_cdata = r#doc.create_cdata_section("CDATA").unwrap(); // <createCDATASection var="newCdata" obj="doc" data="&quot;CDATA&quot;"/>
                // r#appended_child = r#elem.append_child(new_cdata.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="newCdata"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;cdata-sections&quot;" value="true"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" severity="SEVERITY_ERROR" id="normalizationError"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#p_list.item(0).unwrap(); // <item var="elem" obj="pList" index="0" interface="NodeList"/>
                // r#cdata = r#elem.last_child().unwrap(); // <lastChild var="cdata" obj="elem" interface="Node"/>
                // r#node_name = r#cdata.node_name().to_string(); // <nodeName var="nodeName" obj="cdata"/>
                // assert_eq!(r#node_name, "#cdata-section"); // <assertEquals actual="nodeName" expected="&quot;#cdata-section&quot;" id="documentnormalizedocument03_true" ignoreCase="false"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;cdata-sections&quot;" value="false"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" severity="SEVERITY_ERROR" id="normalization2Error"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#p_list.item(0).unwrap(); // <item var="elem" obj="pList" index="0" interface="NodeList"/>
                // r#text = r#elem.last_child().unwrap(); // <lastChild var="text" obj="elem" interface="Node"/>
                // r#node_name = r#text.node_name().to_string(); // <nodeName var="nodeName" obj="text"/>
                // assert_eq!(r#node_name, "#text"); // <assertEquals actual="nodeName" expected="&quot;#text&quot;" id="documentnormalizedocument03_false" ignoreCase="false"/>
                // r#node_value = r#text.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="text"/>
                // assert_eq!(r#node_value, "barCDATA"); // <assertEquals actual="nodeValue" expected="&quot;barCDATA&quot;" id="normalizedValue" ignoreCase="false"/>
            }
            // domconfigdatatypenormalization2.xml
            #[test]
            fn test_domconfigdatatypenormalization2() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // let mut r#parameter; // type: DOMString // <var name="parameter" type="DOMString" value="&quot;datatype-normalization&quot;"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDocType"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;validate&quot;" value="false"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/>  	  <setParameter obj="domConfig" name="parameter" value="true"/>  	  <getParameter var="state" obj="domConfig" name="&quot;validate&quot;"/>  	  <assertTrue actual="state" id="validateSet"/>  </if>
            }
            // documentsetxmlversion02.xml
            #[test]
            fn test_documentsetxmlversion02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#version_value; // type: DOMString // <var name="versionValue" type="DOMString"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#new_doc.set_xml_version("1.0").unwrap(); // <xmlVersion obj="newDoc" value="&quot;1.0&quot;" interface="Document"/>
                // r#version_value = r#new_doc.xml_version().unwrap().to_string(); // <xmlVersion var="versionValue" obj="newDoc" interface="Document"/>
                // assert_eq!(r#version_value, "1.0"); // <assertEquals actual="versionValue" expected="&quot;1.0&quot;" id="documentsetxmlversion02" ignoreCase="false"/>
            }
            // textreplacewholetext02.xml
            #[test]
            fn test_textreplacewholetext02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#item_list; // type: NodeList // <var name="itemList" type="NodeList"/>
                let mut r#element_name; // type: Element // <var name="elementName" type="Element"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#replaced_text; // type: Text // <var name="replacedText" type="Text"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#item_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="itemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#element_name = r#item_list.item(0).unwrap(); // <item var="elementName" obj="itemList" index="0" interface="NodeList"/>
                r#text_node = r#element_name
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild var="textNode" obj="elementName" interface="Node"/>
                r#replaced_text = r#text_node.replace_whole_text("").unwrap().unwrap();
                // <replaceWholeText obj="textNode" var="replacedText" content="&quot;&quot;"/>

                // unimplemented: // <assertNull actual="replacedText" id="textreplacewholetext02"/>
            }
            // nodesettextcontent11.xml
            #[test]
            fn test_nodesettextcontent11() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_child; // type: Element // <var name="elemChild" type="Element"/>
                let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#cdata; // type: CDATASection // <var name="cdata" type="CDATASection"/>
                let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "xhtml:p".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:p&quot;"/>
                r#txt = r#doc.create_text_node("Text "); // <createTextNode var="txt" obj="doc" data="&quot;Text &quot;"/>
                r#comment = r#doc.create_comment("Comment "); // <createComment var="comment" obj="doc" data="&quot;Comment &quot;"/>
                r#ent_ref = r#doc.create_entity_reference("alpha".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;alpha&quot;"/>
                r#pi = r#doc
                    .create_processing_instruction("PIT", Some("PIData "))
                    .unwrap(); // <createProcessingInstruction var="pi" obj="doc" target="&quot;PIT&quot;" data="&quot;PIData &quot;"/>
                r#cdata = r#doc.create_cdata_section("CData").unwrap(); // <createCDATASection var="cdata" obj="doc" data="&quot;CData&quot;"/>
                r#appended_child = r#elem.append_child(txt.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="txt"/>
                r#appended_child = r#elem.append_child(comment.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="comment"/>
                r#appended_child = r#elem.append_child(ent_ref.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="entRef"/>
                r#appended_child = r#elem.append_child(pi.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="pi"/>
                r#appended_child = r#elem.append_child(cdata.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="cdata"/>
                r#appended_child = r#doc_frag.append_child(elem.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="elem"/>
                r#elem.set_text_content("DOCUMENTFRAGMENT").unwrap(); // <textContent obj="elem" value="&quot;DOCUMENTFRAGMENT&quot;"/>
                r#elem_child = r#doc_frag.last_child().unwrap(); // <lastChild var="elemChild" obj="docFrag" interface="Node"/>
                r#text_content = r#elem_child.text_content().unwrap(); // <textContent var="textContent" obj="elemChild"/>
                assert_eq!(r#text_content, "DOCUMENTFRAGMENT"); // <assertEquals actual="textContent" expected="&quot;DOCUMENTFRAGMENT&quot;" id="nodegettextcontent11" ignoreCase="false"/>
            }
            // documentsetdocumenturi03.xml
            #[test]
            fn test_documentsetdocumenturi03() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc_uri; // type: DOMString // <var name="docURI" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#new_doc.set_document_uri("somestring").unwrap(); // <documentURI obj="newDoc" value="&quot;somestring&quot;"/>
                // r#doc_uri = r#new_doc.document_uri().unwrap().to_string(); // <documentURI var="docURI" obj="newDoc"/>
                // assert_eq!(r#doc_uri, "somestring"); // <assertEquals actual="docURI" expected="&quot;somestring&quot;" id="documentsetdocumenturi03" ignoreCase="false"/>
            }
            // elementsetidattribute01.xml
            #[test]
            fn test_elementsetidattribute01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>
                r#acronym_elem.set_id_attribute("class", true).unwrap(); // <setIdAttribute obj="acronymElem" name="&quot;class&quot;" isId="true"/>
                r#attributes_map = r#acronym_elem.attributes(); // <attributes var="attributesMap" obj="acronymElem"/>
                r#attr = r#attributes_map.get_named_item("class").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;class&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributeIsIdTrue01"/>
                r#elem = r#doc.get_element_by_id("No".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;No&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "acronym"); // <assertEquals actual="elemName" expected="&quot;acronym&quot;" id="elementsetidattributeGetElementById01" ignoreCase="false"/>
                r#acronym_elem.set_id_attribute("class", false).unwrap(); // <setIdAttribute obj="acronymElem" name="&quot;class&quot;" isId="false"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(!r#id); // <assertFalse actual="id" id="elementsetidattributeIsIdFalse01"/>
            }
            // documentsetxmlstandalone01.xml
            #[test]
            fn test_documentsetxmlstandalone01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#standalone; // type: boolean // <var name="standalone" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // // <xmlStandalone obj="doc" value="true"/>
                // r#standalone = r#doc.xml_standalone(); // <xmlStandalone var="standalone" obj="doc"/>
                // assert!(r#standalone); // <assertTrue actual="standalone" id="documentsetxmlstandalone01"/>
            }
            // nodecomparedocumentposition14.xml
            #[test]
            fn test_nodecomparedocumentposition14() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#doc_frag_child; // type: Node // <var name="docFragChild" type="Node"/>
                let mut r#doc_frag_position; // type: int // <var name="docFragPosition" type="int"/>
                let mut r#doc_frag_child_position; // type: int // <var name="docFragChildPosition" type="int"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#appended_child = r#doc_frag.append_child(doc_elem.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="docElem"/>
                r#doc_frag_child = r#doc_frag.first_child().unwrap(); // <firstChild var="docFragChild" obj="docFrag" interface="Node"/>
                r#doc_frag_position = r#doc_frag.compare_document_position(&r#doc_frag_child); // <compareDocumentPosition var="docFragPosition" obj="docFrag" other="docFragChild"/>
                assert_eq!(u16::from(r#doc_frag_position), 20); // <assertEquals actual="docFragPosition" expected="20" id="nodecomparedocumentpositionContainsPRECEDING14" ignoreCase="false"/>
                r#doc_frag_child_position =
                    r#doc_frag_child.compare_document_position(&r#doc_frag.into()); // <compareDocumentPosition var="docFragChildPosition" obj="docFragChild" other="docFrag"/>
                assert_eq!(u16::from(r#doc_frag_child_position), 10); // <assertEquals actual="docFragChildPosition" expected="10" id="nodecomparedocumentpositionIsContainedFollowing14" ignoreCase="false"/>
            }
            // nodegetbaseuri11.xml
            #[test]
            fn test_nodegetbaseuri11() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_pi; // type: ProcessingInstruction // <var name="newPI" type="ProcessingInstruction"/>
                // let mut r#imported; // type: ProcessingInstruction // <var name="imported" type="ProcessingInstruction"/>
                // let mut r#base_uri; // type: DOMString // <var name="baseURI" type="DOMString"/>
                // let mut r#doc_uri; // type: DOMString // <var name="docURI" type="DOMString"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // r#doc = todo!(); // barfoo_base.xml // <load var="doc" href="barfoo_base" willBeModified="true"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDocType"/>
                // r#new_pi = r#new_doc
                //     .create_processing_instruction("TARGET", Some("DATA"))
                //     .unwrap(); // <createProcessingInstruction var="newPI" obj="newDoc" target="&quot;TARGET&quot;" data="&quot;DATA&quot;"/>
                // r#imported = r#doc.import_node(r#new_pi.into(), true).unwrap(); // <importNode var="imported" obj="doc" importedNode="newPI" deep="true"/>
                // r#appended_child = r#doc.append_child(imported.into()).unwrap(); // <appendChild obj="doc" var="appendedChild" newChild="imported"/>
                // r#base_uri = r#imported.base_uri().unwrap().to_string(); // <baseURI var="baseURI" obj="imported" interface="Node"/>

                // // unimplemented: // <assertURIEquals actual="baseURI" isAbsolute="true" name="&quot;barfoo_base&quot;" id="equalsBarfooBase"/>
                // r#doc_uri = r#doc.document_uri().unwrap().to_string(); // <documentURI var="docURI" obj="doc"/>
                // assert_eq!(r#base_uri, doc_uri); // <assertEquals actual="baseURI" expected="docURI" ignoreCase="false" id="equalsDocURI"/>
            }
            // hasFeature01.xml
            #[test]
            fn test_has_feature01() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#impl; // type: DOMImplementation // <var name="impl" type="DOMImplementation"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>

                // // unimplemented: // <implementation var="impl"/>

                // // unimplemented: // <hasFeature var="state" obj="impl" feature="&quot;xMl&quot;" version="&quot;3.0&quot;"/>
                // assert!(r#state); // <assertTrue id="hasXML30" actual="state"/>
            }
            // documentrenamenode11.xml
            #[test]
            fn test_documentrenamenode11() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#text_entry; // type: DOMString // <var name="textEntry" type="DOMString" value="&quot;hello&quot;"/>
                // let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                // let mut r#renamed_node; // type: Node // <var name="renamedNode" type="Node"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#null_nsuri; // type: DOMString // <var name="nullNSURI" type="DOMString" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#text_node = r#doc.create_text_node(r#text_entry); // <createTextNode var="textNode" data="textEntry" obj="doc"/>

                // // unimplemented: // <assertDOMException id="documentrenamenode11_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><renameNode var="renamedNode" obj="doc" n="textNode" namespaceURI="nullNSURI" qualifiedName="&quot;pre:fix&quot;"/></NOT_SUPPORTED_ERR></assertDOMException>
            }
            // nodelookupprefix11.xml
            #[test]
            fn test_nodelookupprefix11() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#imported_node; // type: Element // <var name="importedNode" type="Element"/>
                // let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // let mut r#qname; // type: DOMString // <var name="qname" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <plus var="qname" op1="&quot;dom3doc:&quot;" op2="rootName"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="qname" doctype="nullDocType"/>
                // r#elem = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "dom3:br".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:br&quot;"/>
                // r#imported_node = r#new_doc.import_node(r#elem.into(), true).unwrap(); // <importNode var="importedNode" obj="newDoc" importedNode="elem" deep="true"/>
                // r#prefix = r#imported_node
                //     .lookup_prefix("http://www.w3.org/1999/xhtml")
                //     .unwrap()
                //     .to_string(); // <lookupPrefix var="prefix" obj="importedNode" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>
                // assert_eq!(r#prefix, "dom3"); // <assertEquals actual="prefix" expected="&quot;dom3&quot;" id="nodelookupprefix11" ignoreCase="false"/>
            }
            // entitygetxmlversion04.xml
            #[test]
            fn test_entitygetxmlversion04() {
                // // unimplemented: // <implementationAttribute name="validating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#entity_version; // type: DOMString // <var name="entityVersion" type="DOMString"/>
                // r#doc = todo!(); // external_barfoo.xml // <load var="doc" href="external_barfoo" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#entity = r#entities_map.get_named_item("ent1".into()).unwrap(); // <getNamedItem var="entity" obj="entitiesMap" name="&quot;ent1&quot;"/>
                // r#entity_version = r#entity.xml_version().unwrap().to_string(); // <xmlVersion obj="entity" var="entityVersion" interface="Entity"/>
                // assert_eq!(r#entity_version, "1.0"); // <assertEquals expected="&quot;1.0&quot;" actual="entityVersion" id="xmlVersion10" ignoreCase="false"/>
            }
            // infoset09.xml
            #[test]
            fn test_infoset09() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#new_comment; // type: Comment // <var name="newComment" type="Comment"/>
                // let mut r#last_child; // type: Node // <var name="lastChild" type="Node"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#p_list.item(0).unwrap(); // <item var="elem" obj="pList" index="0" interface="NodeList"/>
                // r#new_comment = r#doc.create_comment("COMMENT_NODE"); // <createComment var="newComment" obj="doc" data="&quot;COMMENT_NODE&quot;"/>
                // r#appended_child = r#elem.append_child(new_comment.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="newComment"/>

                // // unimplemented: // <domConfig interface="Document" obj="doc" var="domConfig"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;comments&quot;" value="false"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;infoset&quot;" value="true"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" severity="SEVERITY_ERROR" id="normalizationError"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#p_list.item(0).unwrap(); // <item var="elem" obj="pList" index="0" interface="NodeList"/>
                // r#last_child = r#elem.last_child().unwrap(); // <lastChild var="lastChild" obj="elem" interface="Node"/>
                // r#node_name = r#last_child.node_name().to_string(); // <nodeName var="nodeName" obj="lastChild"/>
                // assert_eq!(r#node_name, "#comment"); // <assertEquals actual="nodeName" expected="&quot;#comment&quot;" id="commentPreserved" ignoreCase="false"/>
            }
            // documentrenamenode15.xml
            #[test]
            fn test_documentrenamenode15() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#renamedclass; // type: Node // <var name="renamedclass" type="Node"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#child_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#element = r#child_list.item(3).unwrap(); // <item var="element" obj="childList" index="3" interface="NodeList"/>
                r#renamedclass = r#doc
                    .rename_node(
                        r#element.into(),
                        Some("http://www.w3.org/DOM/Test"),
                        "qnam:renamedNode",
                    )
                    .unwrap(); // <renameNode var="renamedclass" obj="doc" n="element" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;qnam:renamedNode&quot;"/>
                r#node_name = r#renamedclass.node_name().to_string(); // <nodeName var="nodeName" obj="renamedclass"/>
                r#namespace_uri = r#renamedclass.namespace_uri().unwrap().to_string(); // <namespaceURI var="namespaceURI" obj="renamedclass" interface="Node"/>
                r#node_type = r#renamedclass.node_type(); // <nodeType var="nodeType" obj="renamedclass"/>
                assert_eq!(r#node_name, "qnam:renamedNode"); // <assertEquals expected="&quot;qnam:renamedNode&quot;" actual="nodeName" id="documentrenamenode15_nodeName" ignoreCase="false"/>
                assert_eq!(r#node_type as i32, 1); // <assertEquals expected="1" actual="nodeType" id="documentrenamenode15_nodeType" ignoreCase="false"/>
                assert_eq!(r#namespace_uri, "http://www.w3.org/DOM/Test"); // <assertEquals expected="&quot;http://www.w3.org/DOM/Test&quot;" actual="namespaceURI" id="documentrenamenode15_nodeValue" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom70.xml
            #[test]
            fn test_typeinfoisderivedfrom70() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>

                // // unimplemented: // <implementationAttribute name="validating" value="true"/>

                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_type_info; // type: TypeInfo // <var name="elemTypeInfo" type="TypeInfo"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#ret_value; // type: boolean // <var name="retValue" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("sup"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;sup&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="elemTypeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <isDerivedFrom obj="elemTypeInfo" var="retValue" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;string&quot;" derivationMethod="0"/>
                // assert!(r#ret_value); // <assertTrue actual="retValue" id="isDerived"/>
            }
            // nodelookupnamespaceuri10.xml
            #[test]
            fn test_nodelookupnamespaceuri10() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#parent; // type: Element // <var name="parent" type="Element"/>
                let mut r#child; // type: Element // <var name="child" type="Element"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#parent = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "xhtml:body".as_ref())
                    .unwrap(); // <createElementNS var="parent" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:body&quot;"/>
                r#child = r#doc.create_element("p".to_string()).unwrap(); // <createElement var="child" obj="doc" tagName="&quot;p&quot;"/>
                r#appended_child = r#parent.append_child(child.into()).unwrap(); // <appendChild obj="parent" var="appendedChild" newChild="child"/>
                r#namespace_uri = r#child.lookup_namespace_uri("xhtml").unwrap().to_string(); // <lookupNamespaceURI var="namespaceURI" obj="child" prefix="&quot;xhtml&quot;" interface="Node"/>
                assert_eq!(r#namespace_uri, "http://www.w3.org/1999/xhtml"); // <assertEquals actual="namespaceURI" expected="&quot;http://www.w3.org/1999/xhtml&quot;" id="nodelookupnamespaceuri10" ignoreCase="false"/>
            }
            // nodelookupnamespaceuri19.xml
            #[test]
            fn test_nodelookupnamespaceuri19() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#elem = r#elem_list.item(3).unwrap(); // <item var="elem" obj="elemList" index="3" interface="NodeList"/>
                r#attributes_map = r#elem.attributes(); // <attributes var="attributesMap" obj="elem"/>
                r#attr = r#attributes_map.get_named_item("class").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;class&quot;"/>
                r#namespace_uri = r#attr.lookup_namespace_uri("xsi").unwrap().to_string(); // <lookupNamespaceURI var="namespaceURI" obj="attr" prefix="&quot;xsi&quot;" interface="Node"/>
                assert_eq!(r#namespace_uri, "http://www.w3.org/2001/XMLSchema-instance");
                // <assertEquals actual="namespaceURI" expected="&quot;http://www.w3.org/2001/XMLSchema-instance&quot;" id="nodelookupnamespaceuri19" ignoreCase="false"/>
            }
            // nodegettextcontent13.xml
            #[test]
            fn test_nodegettextcontent13() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#elem = r#elem_list.item(1).unwrap(); // <item var="elem" obj="elemList" index="1" interface="NodeList"/>
                r#text_content = r#elem.text_content().unwrap(); // <textContent var="textContent" obj="elem"/>
                assert_eq!(
                    r#text_content,
                    "Martha Raynolds\nThis is a CDATASection with EntityReference number 2 &ent2;\nThis is an adjacent CDATASection with a reference to a tab &tab;"
                );
                // <assertEquals actual="textContent" expected="&quot;Martha Raynolds\nThis is a CDATASection with EntityReference number 2 &amp;ent2;\nThis is an adjacent CDATASection with a reference to a tab &amp;tab;&quot;" id="nodegettextcontent13" ignoreCase="false"/>
            }
            // nodecomparedocumentposition37.xml
            #[test]
            fn test_nodecomparedocumentposition37() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#attr_position; // type: int // <var name="attrPosition" type="int"/>
                let mut r#txt_position; // type: int // <var name="txtPosition" type="int"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#elem = r#elem_list.item(3).unwrap(); // <item var="elem" obj="elemList" index="3" interface="NodeList"/>
                r#attr = r#elem.get_attribute_node("class").unwrap(); // <getAttributeNode var="attr" obj="elem" name="&quot;class&quot;"/>
                r#txt = r#elem.first_child().unwrap(); // <firstChild var="txt" obj="elem" interface="Node"/>
                r#attr_position = r#attr.compare_document_position(&r#txt); // <compareDocumentPosition var="attrPosition" obj="attr" other="txt"/>
                assert_eq!(u16::from(r#attr_position), 4); // <assertEquals actual="attrPosition" expected="4" id="nodecomparetreepositionFollowing37" ignoreCase="false"/>
                r#txt_position = r#txt.compare_document_position(&r#attr.into()); // <compareDocumentPosition var="txtPosition" obj="txt" other="attr"/>
                assert_eq!(u16::from(r#txt_position), 2); // <assertEquals actual="txtPosition" expected="2" id="nodecomparetreepositionPRECEDING37" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom38.xml
            #[test]
            fn test_typeinfoisderivedfrom38() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anyType&quot;" derivationMethod="13"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="derivedFromAnyTypeNotExtension"/>
            }
            // elementgetschematypeinfo02.xml
            #[test]
            fn test_elementgetschematypeinfo02() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#type_ns; // type: DOMString // <var name="typeNS" type="DOMString"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "emType"); // <assertEquals actual="typeName" expected="&quot;emType&quot;" ignoreCase="false" id="nameIsEmType"/>

                // // unimplemented: // <typeNamespace var="typeNS" obj="typeInfo"/>
                // assert_eq!(r#type_ns, "http://www.w3.org/1999/xhtml"); // <assertEquals actual="typeNS" expected="&quot;http://www.w3.org/1999/xhtml&quot;" ignoreCase="false" id="nsIsXML"/>
            }
            // nodecomparedocumentposition36.xml
            #[test]
            fn test_nodecomparedocumentposition36() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list_follows; // type: NodeList // <var name="elemListFollows" type="NodeList"/>
                let mut r#elem_follows; // type: Element // <var name="elemFollows" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#attr_position; // type: int // <var name="attrPosition" type="int"/>
                let mut r#elem_follows_position; // type: int // <var name="elemFollowsPosition" type="int"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#elem = r#elem_list.item(3).unwrap(); // <item var="elem" obj="elemList" index="3" interface="NodeList"/>
                r#attr = r#elem.get_attribute_node("dir").unwrap(); // <getAttributeNode var="attr" obj="elem" name="&quot;dir&quot;"/>
                r#elem_list_follows = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemListFollows" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#elem_follows = r#elem_list_follows.item(3).unwrap(); // <item var="elemFollows" obj="elemListFollows" index="3" interface="NodeList"/>
                r#attr_position = r#attr.compare_document_position(&r#elem_follows.into()); // <compareDocumentPosition var="attrPosition" obj="attr" other="elemFollows"/>
                assert_eq!(u16::from(r#attr_position), 4); // <assertEquals actual="attrPosition" expected="4" id="nodecomparedocumentpositionFollowing36" ignoreCase="false"/>
                r#elem_follows_position = r#elem_follows.compare_document_position(&r#attr.into()); // <compareDocumentPosition var="elemFollowsPosition" obj="elemFollows" other="attr"/>
                assert_eq!(u16::from(r#elem_follows_position), 2); // <assertEquals actual="elemFollowsPosition" expected="2" id="nodecomparedocumentpositionPRECEEDING36" ignoreCase="false"/>
            }
            // noderemovechild08.xml
            #[test]
            fn test_noderemovechild08() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                let mut r#removed_cmt; // type: Comment // <var name="removedCmt" type="Comment"/>
                let mut r#data; // type: DOMString // <var name="data" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#comment = r#doc.create_comment("Comment"); // <createComment var="comment" obj="doc" data="&quot;Comment&quot;"/>
                r#appended_child = r#doc.append_child(comment.into()).unwrap(); // <appendChild obj="doc" var="appendedChild" newChild="comment"/>
                r#removed_cmt = r#doc
                    .remove_child(comment.into())
                    .unwrap()
                    .as_comment()
                    .unwrap(); // <removeChild var="removedCmt" obj="doc" oldChild="comment"/>
                r#data = r#removed_cmt.data().to_string(); // <data var="data" obj="removedCmt" interface="CharacterData"/>
                assert_eq!(r#data, "Comment"); // <assertEquals actual="data" expected="&quot;Comment&quot;" id="noderemovechild08" ignoreCase="false"/>
            }
            // nodecomparedocumentposition04.xml
            #[test]
            fn test_nodecomparedocumentposition04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#document_position; // type: int // <var name="documentPosition" type="int"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#document_position = r#doc.compare_document_position(&r#doc.into()); // <compareDocumentPosition var="documentPosition" obj="doc" other="doc"/>
                assert_eq!(u16::from(r#document_position), 0); // <assertEquals actual="documentPosition" expected="0" id="nodecomparedocumentpositionNoFlags04" ignoreCase="false"/>
            }
            // nodecomparedocumentposition12.xml
            #[test]
            fn test_nodecomparedocumentposition12() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                let mut r#document_position; // type: int // <var name="documentPosition" type="int"/>
                let mut r#pi_position; // type: int // <var name="piPosition" type="int"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#pi = r#doc
                    .create_processing_instruction("PITarget", Some("PIDATA"))
                    .unwrap(); // <createProcessingInstruction var="pi" obj="doc" data="&quot;PIDATA&quot;" target="&quot;PITarget&quot;"/>
                r#appended_child = r#doc.append_child(pi.into()).unwrap(); // <appendChild obj="doc" var="appendedChild" newChild="pi"/>
                r#document_position = r#doc.compare_document_position(&r#pi.into()); // <compareDocumentPosition var="documentPosition" obj="doc" other="pi"/>
                assert_eq!(u16::from(r#document_position), 20); // <assertEquals actual="documentPosition" expected="20" id="nodecomparedocumentpositionIsContainedFollowing12" ignoreCase="false"/>
                r#pi_position = r#pi.compare_document_position(&r#doc.into()); // <compareDocumentPosition var="piPosition" obj="pi" other="doc"/>
                assert_eq!(u16::from(r#pi_position), 10); // <assertEquals actual="piPosition" expected="10" id="nodecomparedocumentpositionContainsPRECEDING12" ignoreCase="false"/>
            }
            // noderemovechild23.xml
            #[test]
            fn test_noderemovechild23() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#parent; // type: Element // <var name="parent" type="Element"/>
                // let mut r#child; // type: ProcessingInstruction // <var name="child" type="ProcessingInstruction"/>
                // let mut r#removed; // type: ProcessingInstruction // <var name="removed" type="ProcessingInstruction"/>
                // let mut r#removed_name; // type: DOMString // <var name="removedName" type="DOMString"/>
                // let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#parent = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "dom3:p".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="parent" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:p&quot;"/>
                // r#child = r#doc
                //     .create_processing_instruction("TARGET", Some("DATA"))
                //     .unwrap(); // <createProcessingInstruction var="child" obj="doc" data="&quot;DATA&quot;" target="&quot;TARGET&quot;"/>
                // r#appended_child = r#parent.append_child(child.into()).unwrap(); // <appendChild obj="parent" var="appendedChild" newChild="child"/>
                // r#removed = r#parent
                //     .remove_child(child.into())
                //     .unwrap()
                //     .as_processing_instruction()
                //     .unwrap(); // <removeChild var="removed" obj="parent" oldChild="child"/>
                // r#removed_name = r#removed.target().to_string(); // <target obj="removed" var="removedName" interface="ProcessingInstruction"/>
                // assert_eq!(r#removed_name, "TARGET"); // <assertEquals actual="removedName" expected="&quot;TARGET&quot;" id="noderemovechild23" ignoreCase="false"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR">	<NOT_FOUND_ERR>		<removeChild obj="parent" var="removedNode" oldChild="child"/>	</NOT_FOUND_ERR></assertDOMException>
            }
            // documentgetxmlversion02.xml
            #[test]
            fn test_documentgetxmlversion02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#version_value; // type: DOMString // <var name="versionValue" type="DOMString"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#version_value = r#new_doc.xml_version().unwrap().to_string(); // <xmlVersion var="versionValue" obj="newDoc" interface="Document"/>
                // assert_eq!(r#version_value, "1.0"); // <assertEquals actual="versionValue" expected="&quot;1.0&quot;" id="documentgetxmlversion02" ignoreCase="true"/>
            }
            // datatypenormalization16.xml
            #[test]
            fn test_datatypenormalization16() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#str; // type: DOMString // <var name="str" type="DOMString"/>
                // let mut r#can_set_normalization; // type: boolean // <var name="canSetNormalization" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#can_set_xml_schema; // type: boolean // <var name="canSetXMLSchema" type="boolean"/>
                // let mut r#xsd_ns; // type: DOMString // <var name="xsdNS" type="DOMString" value="&quot;http://www.w3.org/2001/XMLSchema&quot;"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#child_node; // type: Node // <var name="childNode" type="Node"/>
                // let mut r#child_value; // type: DOMString // <var name="childValue" type="DOMString"/>
                // r#doc = todo!(); // datatype_normalization2.xml // <load var="doc" href="datatype_normalization2" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetNormalization" obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetValidate" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetXMLSchema" obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>

                // // unimplemented: // <if>	<and>		<isTrue value="canSetNormalization"/>		<isTrue value="canSetValidate"/>		<isTrue value="canSetXMLSchema"/>	</and>	<setParameter obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>	<normalizeDocument obj="doc"/>	<!--  fail test if normalize had any errors or fatal errors   -->	<assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>	<getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" localName="&quot;sup&quot;" interface="Document"/>	<item var="element" obj="elemList" interface="NodeList" index="0"/>	<firstChild var="childNode" obj="element" interface="Node"/>	<nodeValue var="childValue" obj="childNode"/>	<assertEquals actual="childValue" expected="&quot;     EMP  0001 &quot;" ignoreCase="false" id="content1"/>	<item var="element" obj="elemList" interface="NodeList" index="1"/>	<firstChild var="childNode" obj="element" interface="Node"/>	<nodeValue var="childValue" obj="childNode"/>	<assertEquals actual="childValue" expected="&quot;EMP  0001&quot;" ignoreCase="false" id="content2"/>	<item var="element" obj="elemList" interface="NodeList" index="2"/>	<firstChild var="childNode" obj="element" interface="Node"/>	<nodeValue var="childValue" obj="childNode"/>	<assertEquals actual="childValue" expected="&quot;EMP 0001&quot;" ignoreCase="false" id="content3"/>	<item var="element" obj="elemList" interface="NodeList" index="3"/>	<firstChild var="childNode" obj="element" interface="Node"/>	<nodeValue var="childValue" obj="childNode"/>	<assertEquals actual="childValue" expected="&quot;EMP 0001&quot;" ignoreCase="false" id="content4"/></if>
            }
            // attrgetschematypeinfo03.xml
            #[test]
            fn test_attrgetschematypeinfo03() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#type_ns; // type: DOMString // <var name="typeNS" type="DOMString"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(0).unwrap(); // <item var="acronymElem" obj="elemList" index="0" interface="NodeList"/>
                // r#attr = r#acronym_elem.get_attribute_node("title").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;title&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "string"); // <assertEquals actual="typeName" expected="&quot;string&quot;" ignoreCase="false" id="nameIsString"/>

                // // unimplemented: // <typeNamespace var="typeNS" obj="typeInfo"/>
                // assert_eq!(r#type_ns, "http://www.w3.org/2001/XMLSchema"); // <assertEquals actual="typeNS" expected="&quot;http://www.w3.org/2001/XMLSchema&quot;" ignoreCase="false" id="nsIsXML"/>
            }
            // nodereplacechild38.xml
            #[test]
            fn test_nodereplacechild38() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#ent; // type: Entity // <var name="ent" type="Entity"/>
                // let mut r#old_child; // type: Text // <var name="oldChild" type="Text"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                // let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                // let mut r#cdata; // type: CDATASection // <var name="cdata" type="CDATASection"/>
                // let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#ent = r#entities_map.get_named_item("alpha".into()).unwrap(); // <getNamedItem var="ent" obj="entitiesMap" name="&quot;alpha&quot;"/>

                // // unimplemented: // <assertNotNull actual="ent" id="alphaEntity"/>
                // r#old_child = r#ent.first_child().unwrap(); // <firstChild var="oldChild" obj="ent" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="oldChild" id="alphaText"/>
                // r#cdata = r#doc.create_cdata_section("CDATASection").unwrap(); // <createCDATASection var="cdata" obj="doc" data="&quot;CDATASection&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR1">	<NO_MODIFICATION_ALLOWED_ERR>		<replaceChild obj="ent" var="replaced" oldChild="oldChild" newChild="cdata"/>	</NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
                // r#pi = r#doc
                //     .create_processing_instruction("target", Some("data"))
                //     .unwrap(); // <createProcessingInstruction var="pi" obj="doc" target="&quot;target&quot;" data="&quot;data&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR2">	<NO_MODIFICATION_ALLOWED_ERR>		<replaceChild obj="ent" var="replaced" oldChild="oldChild" newChild="pi"/>	</NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
                // r#comment = r#doc.create_comment("Comment"); // <createComment var="comment" obj="doc" data="&quot;Comment&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR3">	<NO_MODIFICATION_ALLOWED_ERR>		<replaceChild obj="ent" var="replaced" oldChild="oldChild" newChild="comment"/>	</NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
                // r#txt = r#doc.create_text_node("Text"); // <createTextNode var="txt" obj="doc" data="&quot;Text&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR4">	<NO_MODIFICATION_ALLOWED_ERR>		<replaceChild obj="ent" var="replaced" oldChild="oldChild" newChild="txt"/>	</NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
                // r#elem = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "xhtml:p".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:p&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR5">	<NO_MODIFICATION_ALLOWED_ERR>		<replaceChild obj="ent" var="replaced" oldChild="oldChild" newChild="elem"/>	</NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
                // r#ent_ref = r#doc.create_entity_reference("delta".to_string()).unwrap();
                // // <createEntityReference var="entRef" obj="doc" name="&quot;delta&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR6">	<NO_MODIFICATION_ALLOWED_ERR>		<replaceChild obj="ent" var="replaced" oldChild="oldChild" newChild="entRef"/>	</NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // nodelookupnamespaceuri08.xml
            #[test]
            fn test_nodelookupnamespaceuri08() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                let mut r#namespace_uri_empty; // type: DOMString // <var name="namespaceURIEmpty" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>
                r#namespace_uri = r#elem.lookup_namespace_uri("dmstc").unwrap().to_string(); // <lookupNamespaceURI var="namespaceURI" obj="elem" prefix="&quot;dmstc&quot;" interface="Node"/>
                assert_eq!(r#namespace_uri, "http://www.usa.com"); // <assertEquals actual="namespaceURI" expected="&quot;http://www.usa.com&quot;" id="nodelookupnamespaceuri08" ignoreCase="false"/>
                r#namespace_uri_empty = r#elem.lookup_namespace_uri("").unwrap().to_string();
                // <lookupNamespaceURI var="namespaceURIEmpty" obj="elem" prefix="&quot;&quot;" interface="Node"/>

                // unimplemented: // <assertNull actual="namespaceURIEmpty" id="nodelookupnamespaceprefixEmpty08"/>
            }
            // nodereplacechild29.xml
            #[test]
            fn test_nodereplacechild29() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#old_child; // type: Element // <var name="oldChild" type="Element"/>
                // let mut r#new_child; // type: Element // <var name="newChild" type="Element"/>
                // let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#child_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#child_list.item(0).unwrap().clone(); // <item var="elem" obj="childList" index="0" interface="NodeList"/>
                // r#old_child = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "dom3:br".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="oldChild" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:br&quot;"/>
                // r#new_child = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "dom3:span".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="newChild" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:span&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR"><NOT_FOUND_ERR><replaceChild obj="elem" var="replaced" oldChild="oldChild" newChild="newChild"/></NOT_FOUND_ERR></assertDOMException>
            }
            // typeinfoisderivedfrom29.xml
            #[test]
            fn test_typeinfoisderivedfrom29() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;pType&quot;" derivationMethod="15"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromPTypeAnyMethod"/>
            }
            // typeinfoisderivedfrom31.xml
            #[test]
            fn test_typeinfoisderivedfrom31() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;pType&quot;" derivationMethod="14"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="derivedFromPTypeNotRestriction"/>
            }
            // typeinfoisderivedfrom47.xml
            #[test]
            fn test_typeinfoisderivedfrom47() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="acronymElem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;string&quot;" derivationMethod="2"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromString"/>
            }
            // datatypenormalization06.xml
            #[test]
            fn test_datatypenormalization06() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#str; // type: DOMString // <var name="str" type="DOMString"/>
                // let mut r#can_set_normalization; // type: boolean // <var name="canSetNormalization" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#can_set_xml_schema; // type: boolean // <var name="canSetXMLSchema" type="boolean"/>
                // let mut r#xsd_ns; // type: DOMString // <var name="xsdNS" type="DOMString" value="&quot;http://www.w3.org/2001/XMLSchema&quot;"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // r#doc = todo!(); // datatype_normalization.xml // <load var="doc" href="datatype_normalization" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetNormalization" obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetValidate" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetXMLSchema" obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>

                // // unimplemented: // <if>	<and>		<isTrue value="canSetNormalization"/>		<isTrue value="canSetValidate"/>		<isTrue value="canSetXMLSchema"/>	</and>	<setParameter obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>		<normalizeDocument obj="doc"/>	<!--  fail test if normalize had any errors or fatal errors   -->	<assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>	<getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;http://www.w3.org/2001/DOM-Test-Suite/Level-3/datatype_normalization&quot;" localName="&quot;time&quot;" interface="Document"/>	<item var="element" obj="elemList" interface="NodeList" index="0"/>	<getAttribute var="str" obj="element" name="&quot;value&quot;"/>	<assertEquals actual="str" expected="&quot;15:30:00-05:00&quot;" ignoreCase="false" id="firstValue"/>	<getAttribute var="str" obj="element" name="&quot;union&quot;"/>	<assertEquals actual="str" expected="&quot;15:30:00-05:00&quot;" ignoreCase="false" id="firstUnion"/>	<textContent var="str" obj="element"/>	<assertEquals actual="str" expected="&quot;15:30:00&quot;" ignoreCase="false" id="firstList"/>		<item var="element" obj="elemList" interface="NodeList" index="1"/>	<getAttribute var="str" obj="element" name="&quot;value&quot;"/>	<assertEquals actual="str" expected="&quot;15:30:00.0000-05:00&quot;" ignoreCase="false" id="secondValue"/>	<getAttribute var="str" obj="element" name="&quot;union&quot;"/>	<assertEquals actual="str" expected="&quot;15:30:00.0000-05:00&quot;" ignoreCase="false" id="secondUnion"/>	<textContent var="str" obj="element"/>	<assertEquals actual="str" expected="&quot;15:30:00.0000&quot;" ignoreCase="false" id="secondList"/>		<item var="element" obj="elemList" interface="NodeList" index="2"/>	<getAttribute var="str" obj="element" name="&quot;value&quot;"/>	<assertEquals actual="str" expected="&quot;15:30:00.0001-05:00&quot;" ignoreCase="false" id="thirdValue"/>	<getAttribute var="str" obj="element" name="&quot;union&quot;"/>	<assertEquals actual="str" expected="&quot;15:30:00.0001-05:00&quot;" ignoreCase="false" id="thirdUnion"/>	<textContent var="str" obj="element"/>	<assertEquals actual="str" expected="&quot;15:30:00.0001&quot;" ignoreCase="false" id="thirdList"/>	</if>
            }
            // textiselementcontentwhitespace02.xml
            #[test]
            fn test_textiselementcontentwhitespace02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#is_elem_content_whitespace; // type: boolean // <var name="isElemContentWhitespace" type="boolean"/>
                r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>
                r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" index="0" interface="NodeList"/>
                r#text_node = r#p_elem.first_child().unwrap().as_text_node().unwrap(); // <firstChild var="textNode" obj="pElem" interface="Node"/>
                r#is_elem_content_whitespace = r#text_node.is_element_content_whitespace(); // <isElementContentWhitespace obj="textNode" var="isElemContentWhitespace"/>
                assert!(!r#is_elem_content_whitespace); // <assertFalse actual="isElemContentWhitespace" id="notElemContentOrWhitespace"/>
            }
            // nodesetuserdata02.xml
            #[test]
            fn test_nodesetuserdata02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#user_data; // type: DOMUserData // <var name="userData" type="DOMUserData"/>
                // let mut r#prev_user_data; // type: DOMUserData // <var name="prevUserData" type="DOMUserData"/>
                // let mut r#test; // type: DOMUserData // <var name="test" type="DOMUserData" isNull="true"/>
                // let mut r#str; // type: DOMString // <var name="str" type="DOMString" value="&quot;Junk&quot;"/>
                // let mut r#null_handler; // type: UserDataHandler // <var name="nullHandler" type="UserDataHandler" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // // unimplemented: // <setUserData var="prevUserData" obj="doc" key="&quot;something&quot;" data="test" handler="nullHandler"/>

                // // unimplemented: // <assertNull actual="prevUserData" id="nodesetuserdata02"/>
            }
            // nodelookupprefix04.xml
            #[test]
            fn test_nodelookupprefix04() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#notations_map; // type: NamedNodeMap // <var name="notationsMap" type="NamedNodeMap"/>
                // let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>

                // // unimplemented: // <notations var="notationsMap" obj="docType"/>
                // r#entity = r#entities_map.get_named_item("alpha".into()).unwrap(); // <getNamedItem var="entity" obj="entitiesMap" name="&quot;alpha&quot;"/>
                // r#notation = r#notations_map.get_named_item("notation1".into()).unwrap(); // <getNamedItem var="notation" obj="notationsMap" name="&quot;notation1&quot;"/>
                // r#prefix = r#entity.lookup_prefix("").unwrap().to_string(); // <lookupPrefix var="prefix" obj="entity" namespaceURI="&quot;&quot;" interface="Node"/>

                // // unimplemented: // <assertNull actual="prefix" id="nodelookupprefixEntity04"/>
                // r#prefix = r#notation.lookup_prefix("").unwrap().to_string(); // <lookupPrefix var="prefix" obj="notation" namespaceURI="&quot;&quot;" interface="Node"/>

                // // unimplemented: // <assertNull actual="prefix" id="nodelookupprefixNotation04"/>
            }
            // nodecomparedocumentposition30.xml
            #[test]
            fn test_nodecomparedocumentposition30() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#name_list; // type: NodeList // <var name="nameList" type="NodeList"/>
                let mut r#position_list; // type: NodeList // <var name="positionList" type="NodeList"/>
                let mut r#strong; // type: Element // <var name="strong" type="Element"/>
                let mut r#code; // type: Element // <var name="code" type="Element"/>
                let mut r#name_position; // type: int // <var name="namePosition" type="int"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#name_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="nameList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#strong = r#name_list.item(0).unwrap(); // <item var="strong" obj="nameList" index="0" interface="NodeList"/>
                r#position_list = r#doc.get_elements_by_tag_name("code"); // <getElementsByTagName var="positionList" obj="doc" tagname="&quot;code&quot;" interface="Document"/>
                r#code = r#position_list.item(0).unwrap(); // <item var="code" obj="positionList" index="0" interface="NodeList"/>
                r#name_position = r#code.compare_document_position(&r#strong.into()); // <compareDocumentPosition var="namePosition" obj="code" other="strong"/>
                assert_eq!(u16::from(r#name_position), 2); // <assertEquals actual="namePosition" expected="2" id="nodecomparedocumentpositionFollowing30" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom39.xml
            #[test]
            fn test_typeinfoisderivedfrom39() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // let mut r#type_ns; // type: DOMString // <var name="typeNS" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>

                // // unimplemented: // <typeNamespace var="typeNS" obj="typeInfo"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="typeNS" typeNameArg="typeName" derivationMethod="15"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="notDerivedFromSelf"/>
            }
            // nodereplacechild24.xml
            #[test]
            fn test_nodereplacechild24() {
                // // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#replaced; // type: Element // <var name="replaced" type="Element"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#child_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#elem = r#child_list.item(1).unwrap().clone(); // <item var="elem" obj="childList" index="1" interface="NodeList"/>
                // r#ent_ref = r#elem.first_child().unwrap(); // <firstChild var="entRef" obj="elem" interface="Node"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR"><NO_MODIFICATION_ALLOWED_ERR><replaceChild var="replaced" obj="entRef" oldChild="elem" newChild="entRef"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // domconfignamespaces1.xml
            #[test]
            fn test_domconfignamespaces1() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // let mut r#parameter; // type: DOMString // <var name="parameter" type="DOMString" value="&quot;nAmEspaces&quot;"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDocType"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(r#state); // <assertTrue actual="state" id="defaultFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="true"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetTrue"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="false"/>

                // // unimplemented: // <if>  	  <isTrue value="canSet"/>  	  <setParameter obj="domConfig" name="parameter" value="false"/>  	  <getParameter var="state" obj="domConfig" name="parameter"/>  	  <assertFalse actual="state" id="setFalseEffective"/>  	  <else>  	  	  <assertDOMException id="throw_NOT_SUPPORTED_ERR">  	  	  	<NOT_SUPPORTED_ERR>  	  			<setParameter obj="domConfig" name="parameter" value="false"/>  	  		</NOT_SUPPORTED_ERR>  	  	  </assertDOMException>  	  	  <!--  should still be true after failed attempt  -->  	  	  <getParameter var="state" obj="domConfig" name="parameter"/>  	      <assertTrue actual="state" id="setFalseNotEffective"/>  	  </else>  </if>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="true"/>
            }
            // attrisid01.xml
            #[test]
            fn test_attrisid01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>
                r#attr = r#acronym_elem.get_attribute_node("class").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;class&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(!r#id); // <assertFalse actual="id" id="AttrIsIDFalse01"/>
            }
            // nodelookupnamespaceuri18.xml
            #[test]
            fn test_nodelookupnamespaceuri18() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#elem = r#elem_list.item(3).unwrap(); // <item var="elem" obj="elemList" index="3" interface="NodeList"/>
                r#attributes_map = r#elem.attributes(); // <attributes var="attributesMap" obj="elem"/>
                r#attr = r#attributes_map.get_named_item("dir").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;dir&quot;"/>
                r#namespace_uri = r#attr.lookup_namespace_uri("nm").unwrap().to_string(); // <lookupNamespaceURI var="namespaceURI" obj="attr" prefix="&quot;nm&quot;" interface="Node"/>
                assert_eq!(r#namespace_uri, "http://www.altavista.com"); // <assertEquals actual="namespaceURI" expected="&quot;http://www.altavista.com&quot;" id="nodelookupnamespaceuri18" ignoreCase="false"/>
            }
            // elementsetidattributenode10.xml
            #[test]
            fn test_elementsetidattributenode10() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "acronym"); // <getElementsByTagNameNS var="elemList" obj="doc" localName="&quot;acronym&quot;" namespaceURI="&quot;*&quot;" interface="Document"/>
                r#acronym_elem = r#elem_list.item(3).unwrap(); // <item var="acronymElem" obj="elemList" index="3" interface="NodeList"/>
                r#attributes_map = r#acronym_elem.attributes(); // <attributes var="attributesMap" obj="acronymElem"/>
                r#attr = r#attributes_map.get_named_item("class").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;class&quot;"/>
                r#acronym_elem.set_id_attribute_node(r#attr, true).unwrap(); // <setIdAttributeNode obj="acronymElem" idAttr="attr" isId="true"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributenodeIsIdTrue10"/>
                r#elem = r#doc.get_element_by_id("Y".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;Y&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "acronym"); // <assertEquals actual="elemName" expected="&quot;acronym&quot;" id="elementsetidattributenodeGetElementById10" ignoreCase="false"/>
                r#acronym_elem.set_id_attribute_node(r#attr, false).unwrap(); // <setIdAttributeNode obj="acronymElem" idAttr="attr" isId="false"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(!r#id); // <assertFalse actual="id" id="elementsetidattributenodeIsIdFalse10"/>
            }
            // typeinfogettypename03.xml
            #[test]
            fn test_typeinfogettypename03() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>

                // // unimplemented: // <implementationAttribute name="validating" value="true"/>

                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#attrid; // type: Attr // <var name="attrid" type="Attr"/>
                // let mut r#ac_elem; // type: Element // <var name="acElem" type="Element"/>
                // let mut r#attr_type_info; // type: TypeInfo // <var name="attrTypeInfo" type="TypeInfo"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#ac_elem = r#elem_list.item(2).unwrap(); // <item var="acElem" obj="elemList" index="2" interface="NodeList"/>
                // r#attrid = r#ac_elem.get_attribute_node("id").unwrap(); // <getAttributeNode var="attrid" obj="acElem" name="&quot;id&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="attrTypeInfo" obj="attrid" interface="Attr"/>

                // // unimplemented: // <typeName var="typeName" obj="attrTypeInfo"/>
                // assert_eq!(r#type_name, "ID"); // <assertEquals expected="&quot;ID&quot;" actual="typeName" id="typeinfogettypename03_1" ignoreCase="false"/>
            }
            // entities03.xml
            #[test]
            fn test_entities03() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#child_type; // type: int // <var name="childType" type="int"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;entities&quot;" value="false"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" interface="NodeList" index="0"/>
                // r#ent_ref = r#doc.create_entity_reference("ent3".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent3&quot;"/>
                // r#child = r#p_elem.append_child(ent_ref.into()).unwrap(); // <appendChild var="child" obj="pElem" newChild="entRef"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" interface="NodeList" index="0"/>
                // r#child = r#p_elem.last_child().unwrap(); // <lastChild var="child" obj="pElem" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="child" id="lastChildNotNull"/>
                // r#child_type = r#child.node_type(); // <nodeType var="childType" obj="child"/>
                // assert_eq!(r#child_type as i32, 5); // <assertEquals actual="childType" expected="5" ignoreCase="false" id="lastChildEntRef"/>
                // r#child_name = r#child.node_name().to_string(); // <nodeName var="childName" obj="child"/>
                // assert_eq!(r#child_name, "ent3"); // <assertEquals actual="childName" expected="&quot;ent3&quot;" ignoreCase="false" id="lastChildName"/>
            }
            // nodelookupnamespaceuri09.xml
            #[test]
            fn test_nodelookupnamespaceuri09() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                let mut r#namespace_uri_empty; // type: DOMString // <var name="namespaceURIEmpty" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>
                r#namespace_uri = r#elem.lookup_namespace_uri("dmstc").unwrap().to_string(); // <lookupNamespaceURI var="namespaceURI" obj="elem" prefix="&quot;dmstc&quot;" interface="Node"/>
                assert_eq!(r#namespace_uri, "http://www.usa.com"); // <assertEquals actual="namespaceURI" expected="&quot;http://www.usa.com&quot;" id="nodelookupnamespaceuri09" ignoreCase="false"/>
                r#namespace_uri_empty = r#elem.lookup_namespace_uri("").unwrap().to_string();
                // <lookupNamespaceURI var="namespaceURIEmpty" obj="elem" prefix="&quot;&quot;" interface="Node"/>

                // unimplemented: // <assertNull actual="namespaceURIEmpty" id="nodelookupnamespaceprefixEmpty09"/>
            }
            // nodecomparedocumentposition07.xml
            #[test]
            fn test_nodecomparedocumentposition07() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#new_elem; // type: Element // <var name="newElem" type="Element"/>
                let mut r#document_position; // type: int // <var name="documentPosition" type="int"/>
                let mut r#document_element_position; // type: int // <var name="documentElementPosition" type="int"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#new_elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "br".as_ref())
                    .unwrap(); // <createElementNS var="newElem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;br&quot;"/>
                r#appended_child = r#doc_elem.append_child(new_elem.into()).unwrap(); // <appendChild obj="docElem" var="appendedChild" newChild="newElem"/>
                r#document_position = r#doc.compare_document_position(&r#new_elem.into()); // <compareDocumentPosition var="documentPosition" obj="doc" other="newElem"/>
                assert_eq!(u16::from(r#document_position), 20); // <assertEquals actual="documentPosition" expected="20" id="nodecomparedocumentpositionIsContainedFollowing07" ignoreCase="false"/>
                r#document_element_position = r#new_elem.compare_document_position(&r#doc.into()); // <compareDocumentPosition var="documentElementPosition" obj="newElem" other="doc"/>
                assert_eq!(u16::from(r#document_element_position), 10); // <assertEquals actual="documentElementPosition" expected="10" id="nodecomparedocumentpositionContainedPRECEDING07" ignoreCase="false"/>
            }
            // nodegetbaseuri07.xml
            #[test]
            fn test_nodegetbaseuri07() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_element; // type: Element // <var name="newElement" type="Element"/>
                let mut r#base_uri; // type: DOMString // <var name="baseURI" type="DOMString"/>
                let mut r#appended; // type: Node // <var name="appended" type="Node"/>
                let mut r#body_list; // type: NodeList // <var name="bodyList" type="NodeList"/>
                let mut r#body_elem; // type: Element // <var name="bodyElem" type="Element"/>
                let mut r#html_ns = "http://www.w3.org/1999/xhtml"; // type: DOMString // <var name="htmlNS" type="DOMString" value="&quot;http://www.w3.org/1999/xhtml&quot;"/>
                r#doc = todo!(); // barfoo_base.xml // <load var="doc" href="barfoo_base" willBeModified="true"/>
                r#body_list = r#doc.get_elements_by_tag_name("body"); // <getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/>
                r#body_elem = r#body_list.item(0).unwrap(); // <item var="bodyElem" obj="bodyList" index="0" interface="NodeList"/>
                r#new_element = r#doc
                    .create_element_ns(Some(r#html_ns), "meta".as_ref())
                    .unwrap(); // <createElementNS var="newElement" obj="doc" namespaceURI="htmlNS" qualifiedName="&quot;meta&quot;"/>
                r#new_element.set_attribute("content", "text/xml").unwrap(); // <setAttribute obj="newElement" name="&quot;content&quot;" value="&quot;text/xml&quot;"/>
                r#appended = r#body_elem.append_child(new_element.into()).unwrap(); // <appendChild obj="bodyElem" var="appended" newChild="newElement"/>
                r#base_uri = r#new_element.base_uri().unwrap().to_string(); // <baseURI var="baseURI" obj="newElement" interface="Node"/>
                assert_eq!(r#base_uri, "http://www.w3.org/DOM/EmployeeID"); // <assertEquals actual="baseURI" expected="&quot;http://www.w3.org/DOM/EmployeeID&quot;" id="nodegetbaseuri07" ignoreCase="false"/>
            }
            // nodegetuserdata01.xml
            #[test]
            fn test_nodegetuserdata01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#user_data; // type: DOMUserData // <var name="userData" type="DOMUserData"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <getUserData var="userData" obj="doc" key="&quot;key1&quot;"/>

                // // unimplemented: // <assertNull actual="userData" id="nodegetuserdata01"/>
            }
            // nodecomparedocumentposition27.xml
            #[test]
            fn test_nodecomparedocumentposition27() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#var_list; // type: NodeList // <var name="varList" type="NodeList"/>
                // let mut r#var_elem; // type: Element // <var name="varElem" type="Element"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#ent_ref_child1; // type: ProcessingInstruction // <var name="entRefChild1" type="ProcessingInstruction"/>
                // let mut r#ent_ref_position; // type: int // <var name="entRefPosition" type="int"/>
                // let mut r#ent_ref_child1_position; // type: int // <var name="entRefChild1Position" type="int"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <if>	<implementationAttribute name="expandEntityReferences" value="false"/>	<getElementsByTagName var="varList" obj="doc" tagname="&quot;var&quot;" interface="Document"/>	<item var="varElem" obj="varList" index="2" interface="NodeList"/>	<assertNotNull actual="varElem" id="varElemNotNull"/>	<firstChild var="entRef" obj="varElem" interface="Node"/>	<assertNotNull actual="entRef" id="entRefNotNull"/>	<else>		<createEntityReference name="&quot;ent4&quot;" obj="doc" var="entRef"/>	</else></if>
                // r#ent_ref_child1 = r#ent_ref.last_child().unwrap(); // <lastChild obj="entRef" var="entRefChild1" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="entRefChild1" id="entRefChild1NotNull"/>
                // r#ent_ref_position = r#ent_ref.compare_document_position(&r#ent_ref_child1.into()); // <compareDocumentPosition var="entRefPosition" obj="entRef" other="entRefChild1"/>
                // assert_eq!(u16::from(r#ent_ref_position), 20); // <assertEquals actual="entRefPosition" expected="20" id="nodecomparedocumentpositionIsContainedFollowing27" ignoreCase="false"/>
                // r#ent_ref_child1_position =
                //     r#ent_ref_child1.compare_document_position(&r#ent_ref.into()); // <compareDocumentPosition var="entRefChild1Position" obj="entRefChild1" other="entRef"/>
                // assert_eq!(u16::from(r#ent_ref_child1_position), 10); // <assertEquals actual="entRefChild1Position" expected="10" id="nodecomparedocumentpositionContainsPRECEDING" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom50.xml
            #[test]
            fn test_typeinfoisderivedfrom50() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // typeinfo.xml // <load var="doc" href="typeinfo" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;double&quot;" derivationMethod="0"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromDoubleAny"/>
            }
            // elementsetidattribute08.xml
            #[test]
            fn test_elementsetidattribute08() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#acronym_elem1; // type: Element // <var name="acronymElem1" type="Element"/>
                let mut r#acronym_elem2; // type: Element // <var name="acronymElem2" type="Element"/>
                let mut r#acronym_elem3; // type: Element // <var name="acronymElem3" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#acronym_elem1 = r#elem_list.item(1).unwrap(); // <item var="acronymElem1" obj="elemList" index="1" interface="NodeList"/>
                r#acronym_elem2 = r#elem_list.item(2).unwrap(); // <item var="acronymElem2" obj="elemList" index="2" interface="NodeList"/>
                r#acronym_elem3 = r#elem_list.item(4).unwrap(); // <item var="acronymElem3" obj="elemList" index="4" interface="NodeList"/>
                r#acronym_elem1.set_id_attribute("class", true).unwrap(); // <setIdAttribute obj="acronymElem1" name="&quot;class&quot;" isId="true"/>
                r#acronym_elem2.set_id_attribute("class", true).unwrap(); // <setIdAttribute obj="acronymElem2" name="&quot;class&quot;" isId="true"/>
                r#acronym_elem3.set_id_attribute("class", true).unwrap(); // <setIdAttribute obj="acronymElem3" name="&quot;class&quot;" isId="true"/>
                r#attributes_map = r#acronym_elem1.attributes(); // <attributes var="attributesMap" obj="acronymElem1"/>
                r#attr = r#attributes_map.get_named_item("class").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;class&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributeIsId1True08"/>
                r#attributes_map = r#acronym_elem2.attributes(); // <attributes var="attributesMap" obj="acronymElem2"/>
                r#attr = r#attributes_map.get_named_item("class").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;class&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributeIsId2True08"/>
                r#attributes_map = r#acronym_elem3.attributes(); // <attributes var="attributesMap" obj="acronymElem3"/>
                r#attr = r#attributes_map.get_named_item("class").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;class&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributeIsId3True08"/>
                r#elem = r#doc.get_element_by_id("No".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;No&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "acronym"); // <assertEquals actual="elemName" expected="&quot;acronym&quot;" id="elementsetidattributeGetElementById08" ignoreCase="false"/>
            }
            // nodeisdefaultnamespace06.xml
            #[test]
            fn test_nodeisdefaultnamespace06() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#is_default; // type: boolean // <var name="isDefault" type="boolean"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>
                r#is_default = r#elem.is_default_namespace("http://www.w3.org/1999/xhtml"); // <isDefaultNamespace var="isDefault" obj="elem" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>
                assert!(r#is_default); // <assertTrue actual="isDefault" id="nodeisdefaultnamespace06_1"/>
                r#is_default = r#elem.is_default_namespace("http://www.usa.com"); // <isDefaultNamespace var="isDefault" obj="elem" namespaceURI="&quot;http://www.usa.com&quot;"/>
                assert!(!r#is_default); // <assertFalse actual="isDefault" id="nodeisdefaultnamespace06_2"/>
            }
            // handleerror02.xml
            #[test]
            fn test_handleerror02() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // let mut r#text_value; // type: DOMString // <var name="textValue" type="DOMString"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#br_elem; // type: Element // <var name="brElem" type="Element"/>
                // let mut r#errors; // type: List // <var name="errors" type="List"/>
                // let mut r#error_handler; // type: DOMErrorHandler // <var name="errorHandler" type="DOMErrorHandler">    <!--   instance scope variables,            value attributes are passed via constructor   -->    <var name="errors" type="List" value="errors"/>    <handleError>        <var name="severity" type="int"/>        <severity var="severity" obj="error"/>        <if><equals actual="severity" expected="2" ignoreCase="false"/>    		<append collection="errors" item="error"/>    	</if>    	<return value="true"/>    </handleError></var>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorHandler"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" index="0" interface="NodeList"/>
                // r#br_elem = r#doc.create_element("br".to_string()).unwrap(); // <createElement var="brElem" obj="doc" tagName="&quot;br&quot;"/>
                // r#retval = r#p_elem.append_child(br_elem.into()).unwrap(); // <appendChild var="retval" obj="pElem" newChild="brElem"/>
                // r#br_elem = r#doc.create_element("br".to_string()).unwrap(); // <createElement var="brElem" obj="doc" tagName="&quot;br&quot;"/>
                // r#retval = r#p_elem.append_child(br_elem.into()).unwrap(); // <appendChild var="retval" obj="pElem" newChild="brElem"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertSize id="twoErrors" size="2" collection="errors"/>
            }
            // nodelookupprefix05.xml
            #[test]
            fn test_nodelookupprefix05() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // let mut r#qname; // type: DOMString // <var name="qname" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <plus var="qname" op1="&quot;dom3:&quot;" op2="rootName"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="qname" doctype="nullDocType"/>
                // r#elem = r#new_doc.document_element().unwrap(); // <documentElement var="elem" obj="newDoc"/>
                // r#prefix = r#elem
                //     .lookup_prefix(r#root_ns.as_ref())
                //     .unwrap()
                //     .to_string(); // <lookupPrefix var="prefix" obj="elem" namespaceURI="rootNS"/>
                // assert_eq!(r#prefix, "dom3"); // <assertEquals actual="prefix" expected="&quot;dom3&quot;" id="nodelookupprefix05" ignoreCase="false"/>
            }
            // nodegetfeature11.xml
            #[test]
            fn test_nodegetfeature11() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // let mut r#feature_impl; // type: Node // <var name="featureImpl" type="Node"/>
                // let mut r#is_supported; // type: boolean // <var name="isSupported" type="boolean"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#node = r#doc.create_cdata_section("some text"); // <createCDATASection var="node" obj="doc" data="&quot;some text&quot;"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Core&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="coreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="cOrEUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;+cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="PlusCoreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;org.w3c.domts.bogus.feature&quot;" version="nullVersion"/>

                // // unimplemented: // <assertNull actual="featureImpl" id="unrecognizedFeature"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;2.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core20"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;3.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core30"/>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="SVGUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="HTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="EventsUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSAsyncUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XPathUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusHTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusSVGUnspecified"/></if>
            }
            // documentadoptnode14.xml
            #[test]
            fn test_documentadoptnode14() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc_fragment; // type: DocumentFragment // <var name="docFragment" type="DocumentFragment"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                // let mut r#acronym_node; // type: Node // <var name="acronymNode" type="Node"/>
                // let mut r#adopted_doc_frag; // type: Node // <var name="adoptedDocFrag" type="Node"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#imported; // type: Node // <var name="imported" type="Node"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#doc_fragment = r#new_doc.create_document_fragment(); // <createDocumentFragment var="docFragment" obj="newDoc"/>
                // r#imported = r#new_doc.import_node(r#doc_elem.into(), true).unwrap(); // <importNode obj="newDoc" var="imported" importedNode="docElem" deep="true"/>
                // r#doc_elem = r#new_doc.document_element().unwrap(); // <documentElement var="docElem" obj="newDoc"/>
                // r#appended_child = r#doc_elem.append_child(imported.into()).unwrap(); // <appendChild obj="docElem" var="appendedChild" newChild="imported"/>
                // r#child_list = r#new_doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="childList" obj="newDoc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_node = r#child_list.item(0).unwrap().clone(); // <item var="acronymNode" obj="childList" index="0" interface="NodeList"/>
                // r#appended_child = r#doc_fragment.append_child(acronym_node.into()).unwrap(); // <appendChild obj="docFragment" var="appendedChild" newChild="acronymNode"/>
                // r#adopted_doc_frag = r#new_doc.adopt_node(r#doc_fragment.into());
                // // <adoptNode var="adoptedDocFrag" obj="newDoc" source="docFragment"/>

                // // unimplemented: // <if><notNull obj="adoptedDocFrag"/><hasChildNodes var="success" obj="adoptedDocFrag"/><assertTrue actual="success" id="documentadoptnode14"/></if>
            }
            // typeinfoisderivedfrom12.xml
            #[test]
            fn test_typeinfoisderivedfrom12() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>
                // r#attr = r#acronym_elem.get_attribute_node("class").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;class&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "classType"); // <assertEquals actual="typeName" expected="&quot;classType&quot;" ignoreCase="false" id="nameIsString"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anyType&quot;" derivationMethod="0"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromAnyType0"/>
            }
            // documentgetxmlstandalone05.xml
            #[test]
            fn test_documentgetxmlstandalone05() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#new_doc_type; // type: DocumentType // <var name="newDocType" type="DocumentType"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#standalone; // type: boolean // <var name="standalone" type="boolean"/>
                // let mut r#null_pub_id; // type: DOMString // <var name="nullPubId" type="DOMString" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#sys_id; // type: DOMString // <var name="sysId" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                // r#sys_id = r#doc_type.system_id().unwrap().to_string(); // <systemId var="sysId" obj="docType" interface="DocumentType"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocumentType var="newDocType" obj="domImpl" qualifiedName="rootName" publicId="nullPubId" systemId="sysId"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="newDocType"/>
                // r#standalone = r#new_doc.xml_standalone(); // <xmlStandalone var="standalone" obj="newDoc"/>
                // assert!(!r#standalone); // <assertFalse actual="standalone" id="documentgetxmlstandalone05"/>
            }
            // elementsetidattributens09.xml
            #[test]
            fn test_elementsetidattributens09() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#var_elem; // type: Element // <var name="varElem" type="Element"/>
                let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "var"); // <getElementsByTagNameNS var="elemList" obj="doc" localName="&quot;var&quot;" namespaceURI="&quot;*&quot;" interface="Document"/>
                r#var_elem = r#elem_list.item(2).unwrap(); // <item interface="NodeList" obj="elemList" var="varElem" index="2"/>
                r#ent_ref = r#var_elem.first_child().unwrap(); // <firstChild interface="Node" var="entRef" obj="varElem"/>
                r#ent_element = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>

                // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR"><NO_MODIFICATION_ALLOWED_ERR><setIdAttributeNS obj="entElement" localName="&quot;xmlns&quot;" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" isId="true"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // elementcontentwhitespace02.xml
            #[test]
            fn test_elementcontentwhitespace02() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#body_list; // type: NodeList // <var name="bodyList" type="NodeList"/>
                // let mut r#body; // type: Element // <var name="body" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;element-content-whitespace&quot;" value="false"/>

                // // unimplemented: // <canSetParameter var="canSetValidate" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <if>	<and>		<isTrue value="canSetValidate"/>		<isTrue value="canSet"/>	</and>	<setParameter obj="domConfig" name="&quot;element-content-whitespace&quot;" value="false"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>	<normalizeDocument obj="doc"/>	<!--  fail test if normalize had any errors or fatal errors   -->	<assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>	<getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/>	<item var="body" obj="bodyList" interface="NodeList" index="0"/>	<firstChild var="child" obj="body" interface="Node"/>	<assertNotNull actual="child" id="firstChildNotNull"/>	<!--   if normalization was successful this should be a "p" element  -->	<nodeName var="childName" obj="child"/>	<assertEquals actual="childName" expected="&quot;p&quot;" ignoreCase="false" id="firstChild"/>	<nextSibling var="child" obj="child" interface="Node"/>	<assertNull actual="child" id="secondChild"/></if>
            }
            // nodeissamenode03.xml
            #[test]
            fn test_nodeissamenode03() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element1; // type: Element // <var name="element1" type="Element"/>
                // let mut r#element2; // type: Element // <var name="element2" type="Element"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#is_same; // type: boolean // <var name="isSame" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#child_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#element1 = r#child_list.item(0).unwrap().clone(); // <item var="element1" obj="childList" index="0" interface="NodeList"/>
                // r#element2 = r#child_list.item(0).unwrap().clone(); // <item var="element2" obj="childList" index="0" interface="NodeList"/>
                // // <isSameNode var="isSame" obj="element2" other="element1"/>
                // assert!(r#is_same); // <assertTrue actual="isSame" id="nodeissamenode03"/>
            }
            // domconfigdatatypenormalization1.xml
            #[test]
            fn test_domconfigdatatypenormalization1() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // let mut r#parameter; // type: DOMString // <var name="parameter" type="DOMString" value="&quot;dAtAtype-normalization&quot;"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDocType"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(!r#state); // <assertFalse actual="state" id="defaultFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="false"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="true"/>

                // // unimplemented: // <if>  	  <isTrue value="canSet"/>  	  <setParameter obj="domConfig" name="parameter" value="true"/>  	  <getParameter var="state" obj="domConfig" name="parameter"/>  	  <assertTrue actual="state" id="setTrueEffective"/>  	  <else>  	  	  <assertDOMException id="throw_NOT_SUPPORTED_ERR">  	  	  	<NOT_SUPPORTED_ERR>  	  			<setParameter obj="domConfig" name="parameter" value="true"/>  	  		</NOT_SUPPORTED_ERR>  	  	  </assertDOMException>  	  	  <!--  should still be false after failed attempt  -->  	  	  <getParameter var="state" obj="domConfig" name="parameter"/>  	      <assertFalse actual="state" id="setTrueNotEffective"/>  	  </else>  </if>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="false"/>
            }
            // nodecomparedocumentposition13.xml
            #[test]
            fn test_nodecomparedocumentposition13() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#document_position; // type: int // <var name="documentPosition" type="int"/>
                let mut r#comment_position; // type: int // <var name="commentPosition" type="int"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#comment = r#doc.create_comment("Another Comment"); // <createComment var="comment" obj="doc" data="&quot;Another Comment&quot;"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#elem = r#elem_list.item(3).unwrap(); // <item var="elem" obj="elemList" index="3" interface="NodeList"/>
                r#appended_child = r#elem.append_child(comment.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="comment"/>
                r#document_position = r#doc.compare_document_position(&r#comment.into()); // <compareDocumentPosition var="documentPosition" obj="doc" other="comment"/>
                assert_eq!(u16::from(r#document_position), 20); // <assertEquals actual="documentPosition" expected="20" id="nodecomparedocumentpositionIsContainedFollowing13" ignoreCase="false"/>
                r#comment_position = r#comment.compare_document_position(&r#doc.into()); // <compareDocumentPosition var="commentPosition" obj="comment" other="doc"/>
                assert_eq!(u16::from(r#comment_position), 10); // <assertEquals actual="commentPosition" expected="10" id="nodecomparedocumentpositionContainsPRECEDING13" ignoreCase="false"/>
            }
            // datatypenormalization17.xml
            #[test]
            fn test_datatypenormalization17() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#str; // type: DOMString // <var name="str" type="DOMString"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#can_set_xml_schema; // type: boolean // <var name="canSetXMLSchema" type="boolean"/>
                // let mut r#xsd_ns; // type: DOMString // <var name="xsdNS" type="DOMString" value="&quot;http://www.w3.org/2001/XMLSchema&quot;"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#child_node; // type: Node // <var name="childNode" type="Node"/>
                // let mut r#child_value; // type: DOMString // <var name="childValue" type="DOMString"/>
                // r#doc = todo!(); // datatype_normalization2.xml // <load var="doc" href="datatype_normalization2" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetValidate" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetXMLSchema" obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>

                // // unimplemented: // <if>	<and>		<isTrue value="canSetValidate"/>		<isTrue value="canSetXMLSchema"/>	</and>	<setParameter obj="domConfig" name="&quot;datatype-normalization&quot;" value="false"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>	<normalizeDocument obj="doc"/>	<!--  fail test if normalize had any errors or fatal errors   -->	<assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>	<getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" localName="&quot;code&quot;" interface="Document"/>	<item var="element" obj="elemList" interface="NodeList" index="1"/>	<firstChild var="childNode" obj="element" interface="Node"/>	<nodeValue var="childValue" obj="childNode"/>	<assertEquals actual="childValue" expected="&quot;EMP  0001&quot;" ignoreCase="false" id="content2"/>	<item var="element" obj="elemList" interface="NodeList" index="2"/>	<firstChild var="childNode" obj="element" interface="Node"/>	<nodeValue var="childValue" obj="childNode"/>	<assertEquals actual="childValue" expected="&quot;EMP 0001&quot;" ignoreCase="false" id="content3"/>	<item var="element" obj="elemList" interface="NodeList" index="0"/>	<firstChild var="childNode" obj="element" interface="Node"/>	<nodeValue var="childValue" obj="childNode"/>	<assertNotEquals actual="childValue" expected="&quot;EMP 0001&quot;" ignoreCase="false" id="content1"/></if>
            }
            // textwholetext01.xml
            #[test]
            fn test_textwholetext01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#item_list; // type: NodeList // <var name="itemList" type="NodeList"/>
                let mut r#element_name; // type: Element // <var name="elementName" type="Element"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#name_whole_text; // type: DOMString // <var name="nameWholeText" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#item_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="itemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#element_name = r#item_list.item(0).unwrap(); // <item var="elementName" obj="itemList" index="0" interface="NodeList"/>
                r#text_node = r#element_name
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild var="textNode" obj="elementName" interface="Node"/>
                r#name_whole_text = r#text_node.whole_text().to_string(); // <wholeText obj="textNode" var="nameWholeText"/>
                assert_eq!(r#name_whole_text, "Margaret Martin"); // <assertEquals expected="&quot;Margaret Martin&quot;" actual="nameWholeText" id="textwholetext01" ignoreCase="false"/>
            }
            // nodeinsertbefore21.xml
            #[test]
            fn test_nodeinsertbefore21() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#ref_node; // type: Node // <var name="refNode" type="Node"/>
                // let mut r#new_node; // type: Element // <var name="newNode" type="Element"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#inserted; // type: Node // <var name="inserted" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#child_list = r#doc.get_elements_by_tag_name("var"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;var&quot;" interface="Document"/>
                // r#element = r#child_list.item(2).unwrap().clone(); // <item var="element" obj="childList" index="2" interface="NodeList"/>
                // r#ref_node = r#element.first_child().unwrap(); // <firstChild var="refNode" obj="element" interface="Node"/>
                // r#new_node = r#element.parent_node().unwrap(); // <parentNode var="newNode" obj="element" interface="Node"/>

                // // unimplemented: // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR"><HIERARCHY_REQUEST_ERR><insertBefore obj="element" var="inserted" refChild="refNode" newChild="newNode"/></HIERARCHY_REQUEST_ERR></assertDOMException>
            }
            // typeinfoisderivedfrom11.xml
            #[test]
            fn test_typeinfoisderivedfrom11() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>
                // r#attr = r#acronym_elem.get_attribute_node("class").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;class&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "classType"); // <assertEquals actual="typeName" expected="&quot;classType&quot;" ignoreCase="false" id="nameIsString"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anyType&quot;" derivationMethod="1"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromAnyTypeRestrictionOnly"/>
            }
            // nodegetuserdata04.xml
            #[test]
            fn test_nodegetuserdata04() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#user_data; // type: DOMUserData // <var name="userData" type="DOMUserData"/>
                // let mut r#ret_user_data; // type: DOMUserData // <var name="retUserData" type="DOMUserData"/>
                // let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                // let mut r#null_handler; // type: UserDataHandler // <var name="nullHandler" type="UserDataHandler" isNull="true"/>
                // let mut r#prev_user_data; // type: DOMUserData // <var name="prevUserData" type="DOMUserData"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <setUserData obj="docType" var="prevUserData" key="&quot;KeyDoc&quot;" data="doc" handler="nullHandler"/>

                // // unimplemented: // <getUserData var="retUserData" obj="docType" key="&quot;KeyDoc&quot;"/>
                // r#success = r#ret_user_data.is_equal_node(&r#doc.into()); // <isEqualNode var="success" obj="retUserData" arg="doc"/>
                // assert!(r#success); // <assertTrue actual="success" id="nodegetuserdata04"/>
            }
            // nodelookupnamespaceuri17.xml
            #[test]
            fn test_nodelookupnamespaceuri17() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#elem = r#elem_list.item(2).unwrap(); // <item var="elem" obj="elemList" index="2" interface="NodeList"/>
                r#attributes_map = r#elem.attributes(); // <attributes var="attributesMap" obj="elem"/>
                r#attr = r#attributes_map
                    .get_named_item("xsi:noNamespaceSchemaLocation")
                    .unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;xsi:noNamespaceSchemaLocation&quot;"/>
                r#namespace_uri = r#attr.lookup_namespace_uri("dmstc").unwrap().to_string(); // <lookupNamespaceURI var="namespaceURI" obj="attr" prefix="&quot;dmstc&quot;" interface="Node"/>
                assert_eq!(r#namespace_uri, "http://www.netzero.com"); // <assertEquals actual="namespaceURI" expected="&quot;http://www.netzero.com&quot;" id="nodelookupnamespaceuri17" ignoreCase="false"/>
            }
            // documentsetstricterrorchecking01.xml
            #[test]
            fn test_documentsetstricterrorchecking01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // // unimplemented: // <strictErrorChecking obj="doc" value="false"/>

                // // unimplemented: // <strictErrorChecking obj="doc" value="true"/>

                // // unimplemented: // <assertDOMException id="INVALID_CHARACTER_ERR_documentsetstricterrorchecking01"><INVALID_CHARACTER_ERR><createAttributeNS obj="doc" var="newAttr" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;@&quot;"/></INVALID_CHARACTER_ERR></assertDOMException>
            }
            // documentadoptnode16.xml
            #[test]
            fn test_documentadoptnode16() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_fragment; // type: DocumentFragment // <var name="docFragment" type="DocumentFragment"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#parent; // type: Element // <var name="parent" type="Element"/>
                // let mut r#child; // type: Element // <var name="child" type="Element"/>
                // let mut r#childs_attr; // type: Attr // <var name="childsAttr" type="Attr"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                // let mut r#adopted; // type: Node // <var name="adopted" type="Node"/>
                // let mut r#parent_imp; // type: Element // <var name="parentImp" type="Element"/>
                // let mut r#child_imp; // type: Element // <var name="childImp" type="Element"/>
                // let mut r#attributes; // type: NamedNodeMap // <var name="attributes" type="NamedNodeMap"/>
                // let mut r#child_attr_imp; // type: Attr // <var name="childAttrImp" type="Attr"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#attr_node; // type: Attr // <var name="attrNode" type="Attr"/>
                // let mut r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                // let mut r#first_child_type; // type: int // <var name="firstChildType" type="int"/>
                // let mut r#first_child_name; // type: DOMString // <var name="firstChildName" type="DOMString"/>
                // let mut r#first_child_value; // type: DOMString // <var name="firstChildValue" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment var="docFragment" obj="doc"/>
                // r#parent = r#doc.create_element("parent".to_string()).unwrap(); // <createElement var="parent" obj="doc" tagName="&quot;parent&quot;"/>
                // r#child = r#doc.create_element("child".to_string()).unwrap(); // <createElement var="child" obj="doc" tagName="&quot;child&quot;"/>
                // r#childs_attr = r#doc.create_attribute("state".to_string()).unwrap(); // <createAttribute var="childsAttr" obj="doc" name="&quot;state&quot;"/>
                // r#ent_ref = r#doc.create_entity_reference("gamma".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;gamma&quot;"/>
                // r#text_node = r#doc.create_text_node("Test"); // <createTextNode var="textNode" obj="doc" data="&quot;Test&quot;"/>
                // r#appended_child = r#childs_attr.append_child(ent_ref.into()).unwrap(); // <appendChild obj="childsAttr" var="appendedChild" newChild="entRef"/>
                // r#attr_node = r#child
                //     .set_attribute_node(r#childs_attr.into())
                //     .unwrap()
                //     .unwrap(); // <setAttributeNode obj="child" var="attrNode" newAttr="childsAttr"/>
                // r#appended_child = r#child.append_child(text_node.into()).unwrap(); // <appendChild obj="child" var="appendedChild" newChild="textNode"/>
                // r#appended_child = r#parent.append_child(child.into()).unwrap(); // <appendChild obj="parent" var="appendedChild" newChild="child"/>
                // r#appended_child = r#doc_fragment.append_child(parent.into()).unwrap(); // <appendChild obj="docFragment" var="appendedChild" newChild="parent"/>
                // r#adopted = r#doc.adopt_node(r#doc_fragment.into()); // <adoptNode var="adopted" obj="doc" source="docFragment"/>

                // // unimplemented: // <if><notNull obj="adopted"/><firstChild var="parentImp" obj="adopted" interface="Node"/><firstChild var="childImp" obj="parentImp" interface="Node"/><attributes var="attributes" obj="childImp"/><getNamedItem var="childAttrImp" obj="attributes" name="&quot;state&quot;"/><firstChild var="firstChild" obj="childAttrImp" interface="Node"/><assertNotNull actual="firstChild" id="firstChildNotNull"/><nodeName var="firstChildName" obj="firstChild"/><nodeValue var="firstChildValue" obj="firstChild"/><nodeType var="firstChildType" obj="firstChild"/><if>	<!--  if first child of the attribute is an	        entity, then it should be for ent3  -->	<equals actual="firstChildType" expected="5"/>	<assertEquals actual="firstChildName" expected="&quot;gamma&quot;" ignoreCase="false" id="firstChildEnt3Ref"/>	<else>		<!--  otherwise the value should be expanded as Texas  -->		<assertEquals expected="&quot;Texas&quot;" actual="firstChildValue" id="documentadoptnode16" ignoreCase="false"/>	</else></if></if>
            }
            // elementsetidattributenode05.xml
            #[test]
            fn test_elementsetidattributenode05() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list1; // type: NodeList // <var name="elemList1" type="NodeList"/>
                let mut r#elem_list2; // type: NodeList // <var name="elemList2" type="NodeList"/>
                let mut r#name_elem; // type: Element // <var name="nameElem" type="Element"/>
                let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list1 = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList1" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#elem_list2 = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList2" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#name_elem = r#elem_list1.item(1).unwrap(); // <item var="nameElem" obj="elemList1" index="1" interface="NodeList"/>
                r#acronym_elem = r#elem_list2.item(1).unwrap(); // <item var="acronymElem" obj="elemList2" index="1" interface="NodeList"/>
                r#attributes_map = r#acronym_elem.attributes(); // <attributes var="attributesMap" obj="acronymElem"/>
                r#attr = r#attributes_map.get_named_item("class").unwrap();
                // <getNamedItem var="attr" obj="attributesMap" name="&quot;class&quot;"/>

                // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR"><NOT_FOUND_ERR><setIdAttributeNode obj="nameElem" idAttr="attr" isId="true"/></NOT_FOUND_ERR></assertDOMException>
            }
            // typeinfoisderivedfrom44.xml
            #[test]
            fn test_typeinfoisderivedfrom44() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="acronymElem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anyType&quot;" derivationMethod="13"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="derivedFromAnyType"/>
            }
            // datatypenormalization02.xml
            #[test]
            fn test_datatypenormalization02() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#str; // type: DOMString // <var name="str" type="DOMString"/>
                // let mut r#can_set_normalization; // type: boolean // <var name="canSetNormalization" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#can_set_xml_schema; // type: boolean // <var name="canSetXMLSchema" type="boolean"/>
                // let mut r#xsd_ns; // type: DOMString // <var name="xsdNS" type="DOMString" value="&quot;http://www.w3.org/2001/XMLSchema&quot;"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // r#doc = todo!(); // datatype_normalization.xml // <load var="doc" href="datatype_normalization" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetNormalization" obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetValidate" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetXMLSchema" obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>

                // // unimplemented: // <if>	<and>		<isTrue value="canSetNormalization"/>		<isTrue value="canSetValidate"/>		<isTrue value="canSetXMLSchema"/>	</and>	<setParameter obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>		<normalizeDocument obj="doc"/>	<!--  fail test if normalize had any errors or fatal errors   -->	<assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>	<getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;http://www.w3.org/2001/DOM-Test-Suite/Level-3/datatype_normalization&quot;" localName="&quot;decimal&quot;" interface="Document"/>	<item var="element" obj="elemList" interface="NodeList" index="0"/>	<getAttribute var="str" obj="element" name="&quot;value&quot;"/>	<assertEquals actual="str" expected="&quot;+0003.141592600&quot;" ignoreCase="false" id="firstValue"/>	<getAttribute var="str" obj="element" name="&quot;union&quot;"/>	<assertEquals actual="str" expected="&quot;+0003.141592600&quot;" ignoreCase="false" id="firstUnion"/>	<textContent var="str" obj="element"/>	<assertEquals actual="str" expected="&quot;+10 .1&quot;" ignoreCase="false" id="firstList"/>		<item var="element" obj="elemList" interface="NodeList" index="1"/>	<getAttribute var="str" obj="element" name="&quot;value&quot;"/>	<assertEquals actual="str" expected="&quot;01&quot;" ignoreCase="false" id="secondValue"/>	<getAttribute var="str" obj="element" name="&quot;union&quot;"/>	<assertEquals actual="str" expected="&quot;01&quot;" ignoreCase="false" id="secondUnion"/>	<textContent var="str" obj="element"/>	<assertEquals actual="str" expected="&quot;-.001&quot;" ignoreCase="false" id="secondList"/>	</if>
            }
            // nodeisequalnode07.xml
            #[test]
            fn test_nodeisequalnode07() {
                let mut r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let mut r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let mut r#elem1; // type: Element // <var name="elem1" type="Element"/>
                let mut r#elem2; // type: Element // <var name="elem2" type="Element"/>
                let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                r#doc1 = todo!(); // hc_staff.xml // <load var="doc1" href="hc_staff" willBeModified="false"/>
                r#doc2 = todo!(); // hc_staff.xml // <load var="doc2" href="hc_staff" willBeModified="false"/>
                r#elem1 = r#doc1
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "xhtml:html".as_ref())
                    .unwrap(); // <createElementNS var="elem1" obj="doc1" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:html&quot;"/>
                r#elem2 = r#doc2
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "xhtml:html".as_ref())
                    .unwrap(); // <createElementNS var="elem2" obj="doc2" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:html&quot;"/>
                r#is_equal = r#elem1.is_equal_node(&r#elem2.into()); // <isEqualNode var="isEqual" obj="elem1" arg="elem2"/>
                assert!(r#is_equal); // <assertTrue actual="isEqual" id="nodeisequalnode07"/>
            }
            // nodereplacechild01.xml
            #[test]
            fn test_nodereplacechild01() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <try>       <replaceChild obj="doc" var="replaced" oldChild="doc" newChild="doc"/>        <catch>                <DOMException code="NOT_FOUND_ERR"/>                <DOMException code="HIERARCHY_REQUEST_ERR"/>        </catch></try>
            }
            // documentadoptnode24.xml
            #[test]
            fn test_documentadoptnode24() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#adopted_node; // type: Node // <var name="adoptedNode" type="Node"/>
                // let mut r#code_elem; // type: Element // <var name="codeElem" type="Element"/>
                // let mut r#code_elem_children; // type: NodeList // <var name="codeElemChildren" type="NodeList"/>
                // let mut r#adopted_children; // type: NodeList // <var name="adoptedChildren" type="NodeList"/>
                // let mut r#code_elem_len; // type: int // <var name="codeElemLen" type="int"/>
                // let mut r#adopted_len; // type: int // <var name="adoptedLen" type="int"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;dom:test&quot;" doctype="nullDocType"/>
                // r#child_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "code"); // <getElementsByTagNameNS var="childList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;code&quot;" interface="Document"/>
                // r#code_elem = r#child_list.item(0).unwrap().clone(); // <item var="codeElem" obj="childList" index="0" interface="NodeList"/>
                // r#adopted_node = r#new_doc.adopt_node(r#code_elem.into()).unwrap(); // <adoptNode var="adoptedNode" obj="newDoc" source="codeElem"/>
                // r#code_elem_children = r#code_elem.child_nodes(); // <childNodes var="codeElemChildren" obj="codeElem"/>
                // r#adopted_children = r#adopted_node.child_nodes(); // <childNodes var="adoptedChildren" obj="adoptedNode"/>
                // r#code_elem_len = r#code_elem_children.len(); // <length var="codeElemLen" obj="codeElemChildren" interface="NodeList"/>
                // r#adopted_len = r#adopted_children.len(); // <length var="adoptedLen" obj="adoptedChildren" interface="NodeList"/>
                // assert_eq!(r#code_elem_len, adopted_len); // <assertEquals actual="codeElemLen" expected="adoptedLen" id="documentadoptnode24" ignoreCase="false"/>
            }
            // documentrenamenode06.xml
            #[test]
            fn test_documentrenamenode06() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#renamedclass; // type: Node // <var name="renamedclass" type="Node"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#child_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#element = r#child_list.item(3).unwrap(); // <item var="element" obj="childList" index="3" interface="NodeList"/>
                r#attr = r#element.get_attribute_node("dir").unwrap(); // <getAttributeNode var="attr" obj="element" name="&quot;dir&quot;"/>
                r#renamedclass = r#doc
                    .rename_node(
                        r#attr.into(),
                        Some("http://www.w3.org/2001/XMLSchema-instance"),
                        "xsi:schemaLocation",
                    )
                    .unwrap(); // <renameNode var="renamedclass" obj="doc" n="attr" namespaceURI="&quot;http://www.w3.org/2001/XMLSchema-instance&quot;" qualifiedName="&quot;xsi:schemaLocation&quot;"/>
                r#node_name = r#renamedclass.node_name().to_string(); // <nodeName var="nodeName" obj="renamedclass"/>
                r#namespace_uri = r#renamedclass.namespace_uri().unwrap().to_string(); // <namespaceURI var="namespaceURI" obj="renamedclass" interface="Node"/>
                r#node_type = r#renamedclass.node_type(); // <nodeType var="nodeType" obj="renamedclass"/>
                assert_eq!(r#node_name, "xsi:schemaLocation"); // <assertEquals expected="&quot;xsi:schemaLocation&quot;" actual="nodeName" id="documentrenameode01_nodeName" ignoreCase="false"/>
                assert_eq!(r#node_type as i32, 2); // <assertEquals expected="2" actual="nodeType" id="documentrenameNode01_nodeType" ignoreCase="false"/>
                assert_eq!(r#namespace_uri, "http://www.w3.org/2001/XMLSchema-instance");
                // <assertEquals expected="&quot;http://www.w3.org/2001/XMLSchema-instance&quot;" actual="namespaceURI" id="documentrenamenode01_nodeValue" ignoreCase="false"/>
            }
            // nodelookupprefix16.xml
            #[test]
            fn test_nodelookupprefix16() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                let mut r#att_node; // type: Attr // <var name="attNode" type="Attr"/>
                r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "dom3:p".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:p&quot;"/>
                r#attr = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/XML/1998/namespace"),
                        "xml:lang".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>
                r#att_node = r#elem.set_attribute_node_ns(r#attr).unwrap().unwrap(); // <setAttributeNodeNS obj="elem" var="attNode" newAttr="attr"/>
                r#prefix = r#attr
                    .lookup_prefix("http://www.w3.org/XML/1998/namespace")
                    .unwrap()
                    .to_string(); // <lookupPrefix var="prefix" obj="attr" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;"/>

                // unimplemented: // <assertNull actual="prefix" id="nodelookupprefix16"/>
            }
            // documentrenamenode25.xml
            #[test]
            fn test_documentrenamenode25() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#renamed_node; // type: Node // <var name="renamedNode" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <assertDOMException id="documentrenamenode25_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><renameNode var="renamedNode" obj="doc" n="docType" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;root&quot;"/></NOT_SUPPORTED_ERR></assertDOMException>
            }
            // typeinfoisderivedfrom51.xml
            #[test]
            fn test_typeinfoisderivedfrom51() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // typeinfo.xml // <load var="doc" href="typeinfo" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;double&quot;" derivationMethod="7"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="derivedFromDoubleNonList"/>
            }
            // nodeissamenode01.xml
            #[test]
            fn test_nodeissamenode01() {
                let mut r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let mut r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let mut r#is_same; // type: boolean // <var name="isSame" type="boolean"/>
                r#doc1 = todo!(); // hc_staff.xml // <load var="doc1" href="hc_staff" willBeModified="false"/>
                r#doc2 = todo!(); // hc_staff.xml // <load var="doc2" href="hc_staff" willBeModified="false"/>
                is_same = doc1.is_same_node(&doc2.into()); // <isSameNode var="isSame" obj="doc1" other="doc2"/>
                assert!(!r#is_same); // <assertFalse actual="isSame" id="nodeissamenode01"/>
            }
            // documentgetxmlstandalone04.xml
            #[test]
            fn test_documentgetxmlstandalone04() {
                // // unimplemented: // <implementationAttribute name="validating" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#standalone; // type: boolean // <var name="standalone" type="boolean"/>
                // r#doc = todo!(); // barfoo_standalone_yes.xml // <load var="doc" href="barfoo_standalone_yes" willBeModified="false"/>
                // r#standalone = r#doc.xml_standalone(); // <xmlStandalone var="standalone" obj="doc"/>
                // assert!(r#standalone); // <assertTrue actual="standalone" id="documentgetxmlstandalone04"/>
            }
            // datatypenormalization07.xml
            #[test]
            fn test_datatypenormalization07() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#str; // type: DOMString // <var name="str" type="DOMString"/>
                // let mut r#can_set_normalization; // type: boolean // <var name="canSetNormalization" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#can_set_xml_schema; // type: boolean // <var name="canSetXMLSchema" type="boolean"/>
                // let mut r#xsd_ns; // type: DOMString // <var name="xsdNS" type="DOMString" value="&quot;http://www.w3.org/2001/XMLSchema&quot;"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // r#doc = todo!(); // datatype_normalization.xml // <load var="doc" href="datatype_normalization" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetNormalization" obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetValidate" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetXMLSchema" obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>

                // // unimplemented: // <if>	<and>		<isTrue value="canSetNormalization"/>		<isTrue value="canSetValidate"/>		<isTrue value="canSetXMLSchema"/>	</and>	<setParameter obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>	<normalizeDocument obj="doc"/>	<!--  fail test if normalize had any errors or fatal errors   -->	<assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>	<getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;http://www.w3.org/2001/DOM-Test-Suite/Level-3/datatype_normalization&quot;" localName="&quot;double&quot;" interface="Document"/>	<item var="element" obj="elemList" interface="NodeList" index="0"/>	<getAttribute var="str" obj="element" name="&quot;default&quot;"/>	<assertEquals actual="str" expected="&quot;3.1415926E0&quot;" ignoreCase="false" id="firstValue"/></if>
            }
            // nodegetfeature07.xml
            #[test]
            fn test_nodegetfeature07() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // let mut r#feature_impl; // type: Node // <var name="featureImpl" type="Node"/>
                // let mut r#is_supported; // type: boolean // <var name="isSupported" type="boolean"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#node = r#doc
                //     .create_attribute_ns(
                //         Some("http://www.w3.org/XML/1998/namespace"),
                //         "xml:lang".as_ref(),
                //     )
                //     .unwrap(); // <createAttributeNS var="node" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Core&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="coreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="cOrEUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;+cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="PlusCoreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;org.w3c.domts.bogus.feature&quot;" version="nullVersion"/>

                // // unimplemented: // <assertNull actual="featureImpl" id="unrecognizedFeature"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;2.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core20"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;3.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core30"/>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="SVGUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="HTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="EventsUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSAsyncUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XPathUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusHTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusSVGUnspecified"/></if>
            }
            // nodesetuserdata10.xml
            #[test]
            fn test_nodesetuserdata10() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                // let mut r#c_data; // type: CDATASection // <var name="cData" type="CDATASection"/>
                // let mut r#var_list; // type: NodeList // <var name="varList" type="NodeList"/>
                // let mut r#var_elem; // type: Element // <var name="varElem" type="Element"/>
                // let mut r#user_data; // type: DOMUserData // <var name="userData" type="DOMUserData"/>
                // let mut r#returned1; // type: DOMUserData // <var name="returned1" type="DOMUserData"/>
                // let mut r#returned2; // type: DOMUserData // <var name="returned2" type="DOMUserData"/>
                // let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                // let mut r#ret_user_data; // type: DOMUserData // <var name="retUserData" type="DOMUserData"/>
                // let mut r#null_handler; // type: UserDataHandler // <var name="nullHandler" type="UserDataHandler" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#var_list = r#doc.get_elements_by_tag_name("var"); // <getElementsByTagName var="varList" obj="doc" tagname="&quot;var&quot;" interface="Document"/>
                // r#var_elem = r#var_list[2].clone(); // <item var="varElem" obj="varList" index="2" interface="NodeList"/>
                // r#ent_ref = r#var_elem.first_child().unwrap(); // <firstChild var="entRef" obj="varElem" interface="Node"/>
                // r#c_data = r#doc.create_cdata_section("CDATASection").unwrap(); // <createCDATASection var="cData" obj="doc" data="&quot;CDATASection&quot;"/>

                // // unimplemented: // <setUserData obj="entRef" var="retUserData" key="&quot;Key1&quot;" data="doc" handler="nullHandler"/>

                // // unimplemented: // <setUserData obj="cData" var="retUserData" key="&quot;Key2&quot;" data="docElem" handler="nullHandler"/>

                // // unimplemented: // <getUserData var="returned1" obj="entRef" key="&quot;Key1&quot;"/>

                // // unimplemented: // <getUserData var="returned2" obj="cData" key="&quot;Key2&quot;"/>
                // r#success = r#returned1.is_equal_node(&r#returned2.into()); // <isEqualNode var="success" obj="returned1" arg="returned2"/>
                // assert!(!r#success); // <assertFalse actual="success" id="nodesetuserdata08"/>
            }
            // nodeisequalnode02.xml
            #[test]
            fn test_nodeisequalnode02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                // let mut r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                // let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="doc1" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>

                // // unimplemented: // <createDocument var="doc2" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#is_equal = r#doc1.is_equal_node(&r#doc2.into()); // <isEqualNode var="isEqual" obj="doc1" arg="doc2"/>
                // assert!(r#is_equal); // <assertTrue actual="isEqual" id="nodeisequalnode02"/>
            }
            // entitygetxmlencoding03.xml
            #[test]
            fn test_entitygetxmlencoding03() {
                // // unimplemented: // <implementationAttribute name="validating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#encoding_name; // type: DOMString // <var name="encodingName" type="DOMString"/>
                // r#doc = todo!(); // external_barfoo.xml // <load var="doc" href="external_barfoo" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#entity = r#entities_map.get_named_item("ent1".into()).unwrap(); // <getNamedItem var="entity" obj="entitiesMap" name="&quot;ent1&quot;"/>
                // r#encoding_name = r#entity.xml_encoding().unwrap().to_string(); // <xmlEncoding obj="entity" var="encodingName" interface="Entity"/>
                // assert_eq!(r#encoding_name, "uTf-16"); // <assertEquals expected="&quot;uTf-16&quot;" actual="encodingName" id="xmlEncoding" ignoreCase="false"/>
            }
            // nodecomparedocumentposition32.xml
            #[test]
            fn test_nodecomparedocumentposition32() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let mut r#name_list; // type: NodeList // <var name="nameList" type="NodeList"/>
                let mut r#position_list; // type: NodeList // <var name="positionList" type="NodeList"/>
                let mut r#strong; // type: Element // <var name="strong" type="Element"/>
                let mut r#code; // type: Element // <var name="code" type="Element"/>
                let mut r#document_position; // type: int // <var name="documentPosition" type="int"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // unimplemented: // <assign var="doc2" value="doc"/>
                r#name_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="nameList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#strong = r#name_list.item(0).unwrap(); // <item var="strong" obj="nameList" index="0" interface="NodeList"/>
                r#position_list = r#doc2.get_elements_by_tag_name("code"); // <getElementsByTagName var="positionList" obj="doc2" tagname="&quot;code&quot;" interface="Document"/>
                r#code = r#position_list.item(0).unwrap(); // <item var="code" obj="positionList" index="0" interface="NodeList"/>
                r#document_position = r#strong.compare_document_position(&r#code.into()); // <compareDocumentPosition var="documentPosition" obj="strong" other="code"/>
                assert_eq!(u16::from(r#document_position), 4); // <assertEquals actual="documentPosition" expected="4" id="nodecomparedocumentpositionFollowing32" ignoreCase="false"/>
            }
            // attrgetschematypeinfo06.xml
            #[test]
            fn test_attrgetschematypeinfo06() {
                // // unimplemented: // <implementationAttribute name="validating" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // let mut r#type_ns; // type: DOMString // <var name="typeNS" type="DOMString"/>
                // r#doc = todo!(); // hc_nodtdstaff.xml // <load var="doc" href="hc_nodtdstaff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(0).unwrap(); // <item var="acronymElem" obj="elemList" index="0" interface="NodeList"/>
                // r#attr = r#acronym_elem.get_attribute_node("title").unwrap();
                // // <getAttributeNode var="attr" obj="acronymElem" name="&quot;title&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>

                // // unimplemented: // <assertNull actual="typeName" id="typeName"/>

                // // unimplemented: // <typeNamespace var="typeNS" obj="typeInfo"/>

                // // unimplemented: // <assertNull actual="typeNS" id="typeNS"/>
            }
            // nodeisequalnode25.xml
            #[test]
            fn test_nodeisequalnode25() {
                // let mut r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                // let mut r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                // let mut r#doc_type1; // type: DocumentType // <var name="docType1" type="DocumentType"/>
                // let mut r#doc_type2; // type: DocumentType // <var name="docType2" type="DocumentType"/>
                // let mut r#entities_map1; // type: NamedNodeMap // <var name="entitiesMap1" type="NamedNodeMap"/>
                // let mut r#entities_map2; // type: NamedNodeMap // <var name="entitiesMap2" type="NamedNodeMap"/>
                // let mut r#alpha; // type: Entity // <var name="alpha" type="Entity"/>
                // let mut r#beta; // type: Entity // <var name="beta" type="Entity"/>
                // let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                // r#doc1 = todo!(); // hc_staff.xml // <load var="doc1" href="hc_staff" willBeModified="false"/>
                // r#doc2 = todo!(); // hc_staff.xml // <load var="doc2" href="hc_staff" willBeModified="false"/>
                // r#doc_type1 = r#doc1.doctype().unwrap(); // <doctype var="docType1" obj="doc1"/>
                // r#doc_type2 = r#doc2.doctype().unwrap(); // <doctype var="docType2" obj="doc2"/>

                // // unimplemented: // <entities var="entitiesMap1" obj="docType1"/>

                // // unimplemented: // <entities var="entitiesMap2" obj="docType2"/>
                // r#alpha = r#entities_map1.get_named_item("delta".into()).unwrap(); // <getNamedItem var="alpha" obj="entitiesMap1" name="&quot;delta&quot;"/>
                // r#beta = r#entities_map2.get_named_item("delta".into()).unwrap(); // <getNamedItem var="beta" obj="entitiesMap2" name="&quot;delta&quot;"/>
                // r#is_equal = r#alpha.is_equal_node(&r#beta.into()); // <isEqualNode var="isEqual" obj="alpha" arg="beta"/>
                // assert!(r#is_equal); // <assertTrue actual="isEqual" id="nodeisequalnode25"/>
            }
            // noderemovechild31.xml
            #[test]
            fn test_noderemovechild31() {
                // // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#parent_list; // type: NodeList // <var name="parentList" type="NodeList"/>
                // let mut r#attrs_map; // type: NamedNodeMap // <var name="attrsMap" type="NamedNodeMap"/>
                // let mut r#parent; // type: Attr // <var name="parent" type="Attr"/>
                // let mut r#child; // type: EntityReference // <var name="child" type="EntityReference"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#removed; // type: EntityReference // <var name="removed" type="EntityReference"/>
                // let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                // let mut r#removed_name; // type: DOMString // <var name="removedName" type="DOMString"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#ent_ref_child; // type: Node // <var name="entRefChild" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#parent_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="parentList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#elem = r#parent_list[3].clone(); // <item var="elem" obj="parentList" index="3" interface="NodeList"/>
                // r#attrs_map = r#elem.attributes(); // <attributes var="attrsMap" obj="elem"/>
                // r#parent = r#attrs_map.get_named_item("class").unwrap(); // <getNamedItem var="parent" obj="attrsMap" name="&quot;class&quot;"/>
                // r#ent_ref = r#doc.create_entity_reference("delta".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;delta&quot;"/>
                // r#appended_child = r#parent.append_child(ent_ref.into()).unwrap(); // <appendChild obj="parent" var="appendedChild" newChild="entRef"/>
                // r#child = r#parent.last_child().unwrap(); // <lastChild var="child" obj="parent" interface="Node"/>
                // r#removed = r#parent.remove_child(child.into()).unwrap(); // <removeChild var="removed" obj="parent" oldChild="child"/>
                // r#removed_name = r#removed.node_name().to_string(); // <nodeName obj="removed" var="removedName"/>
                // assert_eq!(r#removed_name, "delta"); // <assertEquals actual="removedName" expected="&quot;delta&quot;" id="noderemovechild31" ignoreCase="false"/>

                // // unimplemented: // <try>	<removeChild obj="child" var="removedNode" oldChild="parent"/>	<fail id="throw_DOMException"/>	<catch>		<DOMException code="NO_MODIFICATION_ALLOWED_ERR"/>		<DOMException code="NOT_FOUND_ERR"/>	</catch></try>
                // r#ent_ref_child = r#child.first_child().unwrap(); // <firstChild var="entRefChild" obj="child" interface="Node"/>

                // // unimplemented: // <if>    <!-- entity may not be resolved if validating is false  -->	<notNull obj="entRefChild"/>	<assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">		<NO_MODIFICATION_ALLOWED_ERR>			<removeChild obj="child" var="removedNode" oldChild="entRefChild"/>		</NO_MODIFICATION_ALLOWED_ERR>	</assertDOMException></if>
            }
            // domconfigurationcansetparameter06.xml
            #[test]
            fn test_domconfigurationcansetparameter06() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#item_list; // type: NodeList // <var name="itemList" type="NodeList"/>
                // let mut r#element_body; // type: Element // <var name="elementBody" type="Element"/>
                // let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#can_set_false; // type: boolean // <var name="canSetFalse" type="boolean"/>
                // let mut r#param_val; // type: boolean // <var name="paramVal" type="boolean"/>
                // let mut r#has_whitespace; // type: boolean // <var name="hasWhitespace" type="boolean"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter obj="domConfig" var="canSetFalse" name="&quot;element-content-whitespace&quot;" value="false"/>

                // // unimplemented: // <getParameter var="paramVal" obj="domConfig" name="&quot;element-content-whitespace&quot;"/>
                // assert!(r#param_val); // <assertTrue actual="paramVal" id="stillTrue"/>

                // // unimplemented: // <if><isTrue value="canSetFalse"/>   <!--  if it can be set false, actually set it   -->   <setParameter obj="domConfig" name="&quot;element-content-whitespace&quot;" value="false"/></if>

                // // unimplemented: // <canSetParameter obj="domConfig" var="canSet" name="&quot;element-content-whitespace&quot;" value="true"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetTrue"/>

                // // unimplemented: // <if><isTrue value="canSetFalse"/>	<getParameter var="paramVal" obj="domConfig" name="&quot;element-content-whitespace&quot;"/>    <assertFalse actual="paramVal" id="stillFalse"/></if>
            }
            // typeinfoisderivedfrom35.xml
            #[test]
            fn test_typeinfoisderivedfrom35() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anySimpleType&quot;" derivationMethod="15"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="derivedFromAnySimpleType"/>
            }
            // typeinfoisderivedfrom19.xml
            #[test]
            fn test_typeinfoisderivedfrom19() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "emType"); // <assertEquals actual="typeName" expected="&quot;emType&quot;" ignoreCase="false" id="typeName"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anySimpleType&quot;" derivationMethod="1"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromAnySimpleType"/>
            }
            // elementgetschematypeinfo05.xml
            #[test]
            fn test_elementgetschematypeinfo05() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#ac_elem; // type: Element // <var name="acElem" type="Element"/>
                // let mut r#elem_type_info; // type: TypeInfo // <var name="elemTypeInfo" type="TypeInfo"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // let mut r#type_namespace; // type: DOMString // <var name="typeNamespace" type="DOMString"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#doc_elem_node_name; // type: DOMString // <var name="docElemNodeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("span"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;span&quot;" interface="Document"/>
                // r#ac_elem = r#elem_list.item(0).unwrap(); // <item var="acElem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="elemTypeInfo" obj="acElem" interface="Element"/>

                // // unimplemented: // <typeName var="typeName" obj="elemTypeInfo"/>

                // // unimplemented: // <typeNamespace var="typeNamespace" obj="elemTypeInfo"/>
                // assert_eq!(r#type_name, "string"); // <assertEquals expected="&quot;string&quot;" actual="typeName" id="typeNameString" ignoreCase="false"/>
                // assert_eq!(r#type_namespace, "http://www.w3.org/2001/XMLSchema");
                // // <assertEquals expected="&quot;http://www.w3.org/2001/XMLSchema&quot;" actual="typeNamespace" id="typeNsXSD" ignoreCase="false"/>
            }
            // documentrenamenode05.xml
            #[test]
            fn test_documentrenamenode05() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#renamed_node; // type: Node // <var name="renamedNode" type="Node"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#attr = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/XML/1998/namespace"),
                        "xml:lang".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>
                r#renamed_node = r#doc
                    .rename_node(r#attr.into(), None::<&str>, "title")
                    .unwrap(); // <renameNode var="renamedNode" obj="doc" n="attr" namespaceURI="nullNSURI" qualifiedName="&quot;title&quot;"/>
                r#node_name = r#renamed_node.node_name().to_string(); // <nodeName var="nodeName" obj="renamedNode"/>
                r#namespace_uri = r#renamed_node.namespace_uri().unwrap().to_string(); // <namespaceURI var="namespaceURI" obj="renamedNode" interface="Node"/>

                // unimplemented: // <assertNull actual="namespaceURI" id="documentrenamenode05_namespaceURI"/>
                assert_eq!(r#node_name, "title"); // <assertEquals expected="&quot;title&quot;" actual="nodeName" id="documentrenamenode05_nodeName" ignoreCase="false"/>
            }
            // textiselementcontentwhitespace04.xml
            #[test]
            fn test_textiselementcontentwhitespace04() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                // let mut r#blank_node; // type: Text // <var name="blankNode" type="Text"/>
                // let mut r#returned_node; // type: Node // <var name="returnedNode" type="Node"/>
                // let mut r#is_elem_content_whitespace; // type: boolean // <var name="isElemContentWhitespace" type="boolean"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set_validation; // type: boolean // <var name="canSetValidation" type="boolean"/>
                // let mut r#replaced_node; // type: Node // <var name="replacedNode" type="Node"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetValidation" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <if>	<isTrue value="canSetValidation"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>	<item var="pElem" obj="pList" index="0" interface="NodeList"/>	<firstChild var="textNode" obj="pElem" interface="Node"/>	<createTextNode var="blankNode" obj="doc" data="&quot;   &quot;"/>	<replaceChild var="replacedNode" obj="pElem" newChild="blankNode" oldChild="textNode"/>	<normalizeDocument obj="doc"/>	<firstChild var="textNode" obj="pElem" interface="Node"/>	<isElementContentWhitespace obj="textNode" var="isElemContentWhitespace"/>	<assertFalse actual="isElemContentWhitespace" id="notElemContent"/></if>
            }
            // documentrenamenode13.xml
            #[test]
            fn test_documentrenamenode13() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#text_entry; // type: DOMString // <var name="textEntry" type="DOMString" value="&quot;hello&quot;"/>
                // let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                // let mut r#renamed_node; // type: Node // <var name="renamedNode" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#text_node = r#doc.create_text_node(r#text_entry); // <createTextNode var="textNode" data="textEntry" obj="doc"/>

                // // unimplemented: // <assertDOMException id="documentrenamenode13_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><renameNode var="renamedNode" obj="doc" n="textNode" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xmlns:prefix&quot;"/></NOT_SUPPORTED_ERR></assertDOMException>
            }
            // nodeinsertbefore12.xml
            #[test]
            fn test_nodeinsertbefore12() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#doc_frag_new; // type: DocumentFragment // <var name="docFragNew" type="DocumentFragment"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#inserted; // type: Node // <var name="inserted" type="Node"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#last; // type: Node // <var name="last" type="Node"/>
                let mut r#name; // type: DOMString // <var name="name" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#doc_frag_new = r#doc.create_document_fragment(); // <createDocumentFragment var="docFragNew" obj="doc"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test"), "dom3:elem".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" qualifiedName="&quot;dom3:elem&quot;" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;"/>
                r#appended_child = r#doc_frag.append_child(elem.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="elem"/>
                r#inserted = r#doc_frag
                    .insert_before(doc_frag_new.into(), Some(elem.into()))
                    .unwrap(); // <insertBefore obj="docFrag" var="inserted" newChild="docFragNew" refChild="elem"/>
                r#last = r#doc_frag.last_child().unwrap(); // <lastChild obj="docFrag" var="last" interface="Node"/>
                r#name = r#last.node_name().to_string(); // <nodeName obj="last" var="name" interface="Node"/>
                assert_eq!(r#name, "dom3:elem"); // <assertEquals actual="name" expected="&quot;dom3:elem&quot;" id="nodeinsertbefore12" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom07.xml
            #[test]
            fn test_typeinfoisderivedfrom07() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(0).unwrap(); // <item var="acronymElem" obj="elemList" index="0" interface="NodeList"/>
                // r#attr = r#acronym_elem.get_attribute_node("title").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;title&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "string"); // <assertEquals actual="typeName" expected="&quot;string&quot;" ignoreCase="false" id="nameIsString"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anyType&quot;" derivationMethod="0"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromAnyType0"/>
            }
            // nodelookupprefix08.xml
            #[test]
            fn test_nodelookupprefix08() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                let mut r#prefix_empty; // type: DOMString // <var name="prefixEmpty" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>
                r#prefix = r#elem
                    .lookup_prefix("http://www.usa.com")
                    .unwrap()
                    .to_string(); // <lookupPrefix var="prefix" obj="elem" namespaceURI="&quot;http://www.usa.com&quot;"/>
                assert_eq!(r#prefix, "dmstc"); // <assertEquals actual="prefix" expected="&quot;dmstc&quot;" id="nodelookupprefix08" ignoreCase="false"/>
                r#prefix_empty = r#elem
                    .lookup_prefix("http://www.w3.org/1999/xhtml")
                    .unwrap()
                    .to_string(); // <lookupPrefix var="prefixEmpty" obj="elem" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>

                // unimplemented: // <assertNull actual="prefixEmpty" id="nodelookupnamespaceprefixEmpty08"/>
            }
            // domimplementationregistry03.xml
            #[test]
            fn test_domimplementationregistry03() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#has_feature; // type: boolean // <var name="hasFeature" type="boolean"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementation var="domImpl" obj="domImplRegistry" features="&quot;cOrE 3.0&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImpl" id="domImplNotNull"/>

                // // unimplemented: // <hasFeature var="hasFeature" obj="domImpl" feature="&quot;Core&quot;" version="&quot;3.0&quot;"/>
                // assert!(r#has_feature); // <assertTrue actual="hasFeature" id="hasCore"/>
            }
            // typeinfoisderivedfrom57.xml
            #[test]
            fn test_typeinfoisderivedfrom57() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // typeinfo.xml // <load var="doc" href="typeinfo" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anyType&quot;" derivationMethod="8"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromAnyList"/>
            }
            // nodelookupnamespaceuri03.xml
            #[test]
            fn test_nodelookupnamespaceuri03() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                // let mut r#null_prefix; // type: DOMString // <var name="nullPrefix" type="DOMString" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                // r#namespace_uri = r#doc_type
                //     .lookup_namespace_uri(r#null_prefix.as_ref())
                //     .unwrap()
                //     .to_string(); // <lookupNamespaceURI var="namespaceURI" obj="docType" prefix="nullPrefix" interface="Node"/>

                // // unimplemented: // <assertNull actual="namespaceURI" id="nodelookupnamespaceuri03"/>
            }
            // documentadoptnode17.xml
            #[test]
            fn test_documentadoptnode17() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entity_map; // type: NamedNodeMap // <var name="entityMap" type="NamedNodeMap"/>
                // let mut r#ent; // type: Entity // <var name="ent" type="Entity"/>
                // let mut r#adopted_ent; // type: Node // <var name="adoptedEnt" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entityMap" obj="docType"/>
                // r#ent = r#entity_map.get_named_item("alpha".into()).unwrap(); // <getNamedItem var="ent" obj="entityMap" name="&quot;alpha&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR"><NO_MODIFICATION_ALLOWED_ERR><adoptNode var="adoptedEnt" obj="doc" source="ent"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // attrisid07.xml
            #[test]
            fn test_attrisid07() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#attr_imported; // type: Attr // <var name="attrImported" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "acronym"); // <getElementsByTagNameNS var="elemList" obj="doc" localName="&quot;acronym&quot;" namespaceURI="&quot;*&quot;" interface="Document"/>
                r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>
                r#acronym_elem
                    .set_attribute_ns(Some("http://www.w3.org/DOM"), "dom3:newAttr", "null")
                    .unwrap(); // <setAttributeNS obj="acronymElem" namespaceURI="&quot;http://www.w3.org/DOM&quot;" qualifiedName="&quot;dom3:newAttr&quot;" value="&quot;null&quot;"/>
                r#acronym_elem
                    .set_id_attribute_ns(Some("http://www.w3.org/DOM"), "newAttr", true)
                    .unwrap(); // <setIdAttributeNS obj="acronymElem" localName="&quot;newAttr&quot;" namespaceURI="&quot;http://www.w3.org/DOM&quot;" isId="true"/>
                r#attr = r#acronym_elem
                    .get_attribute_node_ns(Some("http://www.w3.org/DOM"), "newAttr")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attr" obj="acronymElem" namespaceURI="&quot;http://www.w3.org/DOM&quot;" localName="&quot;newAttr&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="AttrIsIDTrue07_1"/>
                r#attr_imported = r#doc
                    .import_node(r#attr.into(), false)
                    .unwrap()
                    .as_attribute()
                    .unwrap(); // <importNode var="attrImported" obj="doc" importedNode="attr" deep="false"/>
                r#id = r#attr_imported.is_id(); // <isId var="id" obj="attrImported"/>
                assert!(!r#id); // <assertFalse actual="id" id="AttrIsID07_isFalseforImportedNode"/>
            }
            // textiselementcontentwhitespace05.xml
            #[test]
            fn test_textiselementcontentwhitespace05() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#body_list; // type: NodeList // <var name="bodyList" type="NodeList"/>
                // let mut r#body_elem; // type: Element // <var name="bodyElem" type="Element"/>
                // let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                // let mut r#non_blank_node; // type: Text // <var name="nonBlankNode" type="Text"/>
                // let mut r#returned_node; // type: Node // <var name="returnedNode" type="Node"/>
                // let mut r#is_elem_content_whitespace; // type: boolean // <var name="isElemContentWhitespace" type="boolean"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set_validation; // type: boolean // <var name="canSetValidation" type="boolean"/>
                // let mut r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetValidation" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <if>	<isTrue value="canSetValidation"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>	<getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/>	<item var="bodyElem" obj="bodyList" index="0" interface="NodeList"/>	<!--  newline between body and p or p  -->	<firstChild var="refChild" obj="bodyElem" interface="Node"/>	<!--  replace with non-blank  -->	<createTextNode var="nonBlankNode" obj="doc" data="&quot;not blank&quot;"/>	<insertBefore var="returnedNode" obj="bodyElem" newChild="nonBlankNode" refChild="refChild"/>	<normalizeDocument obj="doc"/>	<assertLowerSeverity obj="errorMonitor" severity="SEVERITY_ERROR" id="noErrors"/>	<getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/>	<item var="bodyElem" obj="bodyList" index="0" interface="NodeList"/>	<!--  non-blank between body and p  -->	<firstChild var="textNode" obj="bodyElem" interface="Node"/>	<isElementContentWhitespace obj="textNode" var="isElemContentWhitespace"/>	<assertFalse actual="isElemContentWhitespace" id="notElemContent"/></if>
            }
            // elementsetidattributenode09.xml
            #[test]
            fn test_elementsetidattributenode09() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#var_elem; // type: Element // <var name="varElem" type="Element"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#ent_element; // type: Element // <var name="entElement" type="Element"/>
                // let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;entities&quot;" value="true" interface="DOMConfiguration"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc" interface="Document"/>
                // r#elem_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "var"); // <getElementsByTagNameNS var="elemList" obj="doc" localName="&quot;var&quot;" namespaceURI="&quot;*&quot;" interface="Document"/>
                // r#var_elem = r#elem_list.item(2).unwrap(); // <item interface="NodeList" obj="elemList" var="varElem" index="2"/>
                // r#ent_ref = r#var_elem.first_child().unwrap(); // <firstChild interface="Node" var="entRef" obj="varElem"/>
                // r#ent_element = r#ent_ref.first_child().unwrap(); // <firstChild interface="Node" var="entElement" obj="entRef"/>
                // r#attributes_map = r#ent_element.attributes().unwrap(); // <attributes var="attributesMap" obj="entElement"/>
                // r#attr = r#attributes_map.get_named_item("xmlns").unwrap();
                // // <getNamedItem var="attr" obj="attributesMap" name="&quot;xmlns&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR"><NO_MODIFICATION_ALLOWED_ERR><setIdAttributeNode obj="entElement" idAttr="attr" isId="true"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // documentadoptnode28.xml
            #[test]
            fn test_documentadoptnode28() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#adopted_node; // type: Node // <var name="adoptedNode" type="Node"/>
                // let mut r#employee_elem; // type: Node // <var name="employeeElem" type="Node"/>
                // let mut r#attr_imp; // type: Attr // <var name="attrImp" type="Attr"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#null_nsuri; // type: DOMString // <var name="nullNSURI" type="DOMString" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#child_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#employee_elem = r#child_list.item(3).unwrap().clone(); // <item var="employeeElem" obj="childList" index="3" interface="NodeList"/>
                // r#adopted_node = r#doc.adopt_node(r#employee_elem.into()); // <adoptNode var="adoptedNode" obj="doc" source="employeeElem"/>

                // // unimplemented: // <if><notNull obj="adoptedNode"/><getAttributeNode var="attrImp" obj="adoptedNode" name="&quot;dir&quot;"/><nodeName var="nodeName" obj="attrImp"/><assertEquals actual="nodeName" expected="&quot;dir&quot;" id="documentadoptnode28" ignoreCase="false"/></if>
            }
            // nodeinsertbefore13.xml
            #[test]
            fn test_nodeinsertbefore13() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_alt: DocumentRef; // <var name="docAlt" type="Document"/>
                // let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                // let mut r#elem_alt; // type: Element // <var name="elemAlt" type="Element"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#inserted; // type: Node // <var name="inserted" type="Node"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_tagname; // type: DOMString // <var name="rootTagname" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_tagname = r#doc_elem.tag_name().to_string(); // <tagName var="rootTagname" obj="docElem"/>
                // r#doc_alt = todo!(); // hc_staff.xml // <load var="docAlt" href="hc_staff" willBeModified="true"/>
                // r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                // r#elem = r#doc
                //     .create_element_ns(Some(r#root_ns.as_ref()), r#root_tagname.as_ref())
                //     .unwrap(); // <createElementNS var="elem" obj="doc" qualifiedName="rootTagname" namespaceURI="rootNS"/>
                // r#elem_alt = r#doc_alt
                //     .create_element_ns(Some(r#root_ns.as_ref()), r#root_tagname.as_ref())
                //     .unwrap(); // <createElementNS var="elemAlt" obj="docAlt" qualifiedName="rootTagname" namespaceURI="rootNS"/>
                // r#appended_child = r#doc_frag.append_child(elem.into()).unwrap();
                // // <appendChild obj="docFrag" var="appendedChild" newChild="elem"/>

                // // unimplemented: // <assertDOMException id="throw_WRONG_DOCUMENT_ERR"><WRONG_DOCUMENT_ERR><insertBefore obj="docFrag" var="inserted" newChild="elemAlt" refChild="elem"/></WRONG_DOCUMENT_ERR></assertDOMException>
            }
            // elementsetidattributens10.xml
            #[test]
            fn test_elementsetidattributens10() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#p_elem1; // type: Element // <var name="pElem1" type="Element"/>
                let mut r#p_elem2; // type: Element // <var name="pElem2" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "p"); // <getElementsByTagNameNS var="elemList" obj="doc" localName="&quot;p&quot;" namespaceURI="&quot;*&quot;" interface="Document"/>
                r#p_elem1 = r#elem_list.item(2).unwrap(); // <item var="pElem1" obj="elemList" index="2" interface="NodeList"/>
                r#p_elem2 = r#elem_list.item(3).unwrap(); // <item var="pElem2" obj="elemList" index="3" interface="NodeList"/>
                r#p_elem1
                    .set_id_attribute_ns(Some("http://www.w3.org/2000/xmlns/"), "dmstc", true)
                    .unwrap(); // <setIdAttributeNS obj="pElem1" localName="&quot;dmstc&quot;" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" isId="true"/>
                r#p_elem2
                    .set_id_attribute_ns(Some("http://www.w3.org/2000/xmlns/"), "nm", true)
                    .unwrap(); // <setIdAttributeNS obj="pElem2" localName="&quot;nm&quot;" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" isId="true"/>
                r#attributes_map = r#p_elem1.attributes(); // <attributes var="attributesMap" obj="pElem1"/>
                r#attr = r#attributes_map.get_named_item("xmlns:dmstc").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;xmlns:dmstc&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributensIsId1True10"/>
                r#attributes_map = r#p_elem2.attributes(); // <attributes var="attributesMap" obj="pElem2"/>
                r#attr = r#attributes_map.get_named_item("xmlns:nm").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;xmlns:nm&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributensIsId2True10"/>
                r#elem = r#doc
                    .get_element_by_id("http://www.netzero.com".as_ref())
                    .unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;http://www.netzero.com&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "p"); // <assertEquals actual="elemName" expected="&quot;p&quot;" id="elementsetidattributens1GetElementById10" ignoreCase="false"/>
                r#elem = r#doc
                    .get_element_by_id("http://www.altavista.com".as_ref())
                    .unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;http://www.altavista.com&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "p"); // <assertEquals actual="elemName" expected="&quot;p&quot;" id="elementsetidattributens2GetElementById10" ignoreCase="false"/>
            }
            // nodereplacechild31.xml
            #[test]
            fn test_nodereplacechild31() {
                // // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#span; // type: Element // <var name="span" type="Element"/>
                // let mut r#ent4_ref; // type: EntityReference // <var name="ent4Ref" type="EntityReference"/>
                // let mut r#span_text; // type: Text // <var name="spanText" type="Text"/>
                // let mut r#new_child; // type: Element // <var name="newChild" type="Element"/>
                // let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#child_list = r#doc.get_elements_by_tag_name("var"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;var&quot;" interface="Document"/>
                // r#elem = r#child_list.item(2).unwrap().clone(); // <item var="elem" obj="childList" index="2" interface="NodeList"/>
                // r#ent4_ref = r#elem.first_child().unwrap(); // <firstChild var="ent4Ref" obj="elem" interface="Node"/>
                // r#span = r#ent4_ref.first_child().unwrap(); // <firstChild var="span" obj="ent4Ref" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="span" id="spanNotNull"/>
                // r#span_text = r#span.first_child().unwrap(); // <firstChild var="spanText" obj="span" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="spanText" id="spanTextNotNull"/>
                // r#new_child = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "xhtml:p".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="newChild" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:p&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR"><NO_MODIFICATION_ALLOWED_ERR><replaceChild obj="span" var="replaced" oldChild="spanText" newChild="newChild"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // documentrenamenode04.xml
            #[test]
            fn test_documentrenamenode04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#renamed_node; // type: Node // <var name="renamedNode" type="Node"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#attr = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/XML/1998/namespace"),
                        "xml:lang".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>
                r#renamed_node = r#doc.rename_node(r#attr.into(), Some(""), "title").unwrap(); // <renameNode var="renamedNode" obj="doc" n="attr" namespaceURI="&quot;&quot;" qualifiedName="&quot;title&quot;"/>
                r#node_name = r#renamed_node.node_name().to_string(); // <nodeName var="nodeName" obj="renamedNode"/>
                r#namespace_uri = r#renamed_node.namespace_uri().unwrap().to_string(); // <namespaceURI var="namespaceURI" obj="renamedNode" interface="Node"/>
                assert_eq!(r#node_name, "title"); // <assertEquals expected="&quot;title&quot;" actual="nodeName" id="documentrenamenode04_nodeName" ignoreCase="false"/>

                // unimplemented: // <assertNull actual="namespaceURI" id="documentrenamenode04_namespaceURI"/>
            }
            // domconfignamespaces2.xml
            #[test]
            fn test_domconfignamespaces2() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="&quot;namespaces&quot;"/>
                // assert!(r#state); // <assertTrue actual="state" id="namespacesTrue"/>
            }
            // canonicalform11.xml
            #[test]
            fn test_canonicalform11() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // // unimplemented: // <implementationAttribute name="validating" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#attr_value; // type: DOMString // <var name="attrValue" type="DOMString"/>
                // let mut r#attr_specified; // type: boolean // <var name="attrSpecified" type="boolean"/>
                // r#doc = todo!(); // canonicalform03.xml // <load var="doc" href="canonicalform03" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;canonical-form&quot;" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/><setParameter obj="domConfig" name="&quot;canonical-form&quot;" value="true"/><normalizeDocument obj="doc"/><!--  fail test if normalize had any errors or fatal errors   --><assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/><getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/><item var="elem" obj="elemList" index="0" interface="NodeList"/><getAttributeNode var="attr" obj="elem" name="&quot;title&quot;"/><assertNotNull actual="attr" id="titlePresent"/><specified var="attrSpecified" obj="attr"/><assertTrue actual="attrSpecified" id="titleSpecified"/><nodeValue var="attrValue" obj="attr"/><assertEquals actual="attrValue" expected="&quot;default&quot;" ignoreCase="false" id="titleValue"/></if>
            }
            // nodesettextcontent06.xml
            #[test]
            fn test_nodesettextcontent06() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#attr_node; // type: Attr // <var name="attrNode" type="Attr"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "p".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;p&quot;"/>
                r#attr = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/XML/1998/namespace"),
                        "xml:lang".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>
                r#attr_node = r#elem.set_attribute_node_ns(r#attr).unwrap().unwrap(); // <setAttributeNodeNS obj="elem" var="attrNode" newAttr="attr"/>
                r#attr.set_text_content("NA").unwrap(); // <textContent obj="attr" value="&quot;NA&quot;"/>
                r#text_content = r#attr.text_content().unwrap(); // <textContent var="textContent" obj="attr"/>
                assert_eq!(r#text_content, "NA"); // <assertEquals actual="textContent" expected="&quot;NA&quot;" id="nodesettextcontent06" ignoreCase="false"/>
            }
            // nodereplacechild18.xml
            #[test]
            fn test_nodereplacechild18() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#cdata; // type: CDATASection // <var name="cdata" type="CDATASection"/>
                let mut r#replaced_c_data; // type: CDATASection // <var name="replacedCData" type="CDATASection"/>
                let mut r#replaced_eref; // type: EntityReference // <var name="replacedEref" type="EntityReference"/>
                let mut r#cdata_name; // type: DOMString // <var name="cdataName" type="DOMString"/>
                let mut r#eref_name; // type: DOMString // <var name="erefName" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#cdata = r#doc.create_cdata_section("CDATASection").unwrap(); // <createCDATASection var="cdata" obj="doc" data="&quot;CDATASection&quot;"/>
                r#ent_ref = r#doc.create_entity_reference("alpha".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;alpha&quot;"/>
                r#appended_child = r#doc_frag.append_child(ent_ref.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="entRef"/>
                r#appended_child = r#doc_frag.append_child(cdata.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="cdata"/>
                r#replaced_c_data = r#doc_frag
                    .replace_child(ent_ref.into(), cdata.into())
                    .unwrap(); // <replaceChild var="replacedCData" obj="docFrag" oldChild="cdata" newChild="entRef"/>
                r#cdata_name = r#replaced_c_data.node_value().unwrap().to_string(); // <nodeValue var="cdataName" obj="replacedCData"/>
                assert_eq!(r#cdata_name, "CDATASection"); // <assertEquals actual="cdataName" expected="&quot;CDATASection&quot;" id="nodereplacechild18_1" ignoreCase="false"/>
                r#replaced_eref = r#doc_frag
                    .replace_child(cdata.into(), ent_ref.into())
                    .unwrap(); // <replaceChild var="replacedEref" obj="docFrag" oldChild="entRef" newChild="cdata"/>
                r#eref_name = r#replaced_eref.node_name().to_string(); // <nodeName var="erefName" obj="replacedEref"/>
                assert_eq!(r#eref_name, "alpha"); // <assertEquals actual="erefName" expected="&quot;alpha&quot;" id="nodereplacechild18_2" ignoreCase="false"/>
            }
            // nodecomparedocumentposition19.xml
            #[test]
            fn test_nodecomparedocumentposition19() {
                // unimplemented: // <implementationAttribute name="coalescing" value="false"/>

                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#elem_strong; // type: Element // <var name="elemStrong" type="Element"/>
                let mut r#cdata1; // type: CDATASection // <var name="cdata1" type="CDATASection"/>
                let mut r#cdata2; // type: CDATASection // <var name="cdata2" type="CDATASection"/>
                let mut r#a_node; // type: Node // <var name="aNode" type="Node"/>
                let mut r#cdata1_position; // type: int // <var name="cdata1Position" type="int"/>
                let mut r#cdata2_position; // type: int // <var name="cdata2Position" type="int"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "strong"); // <getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;strong&quot;" interface="Document"/>
                r#elem_strong = r#elem_list.item(1).unwrap(); // <item var="elemStrong" obj="elemList" index="1" interface="NodeList"/>
                r#cdata2 = r#elem_strong.last_child().unwrap(); // <lastChild var="cdata2" obj="elemStrong" interface="Node"/>
                r#a_node = r#cdata2.previous_sibling().unwrap(); // <previousSibling var="aNode" obj="cdata2" interface="Node"/>
                r#cdata1 = r#a_node.previous_sibling().unwrap(); // <previousSibling var="cdata1" obj="aNode" interface="Node"/>
                r#cdata1_position = r#cdata1.compare_document_position(&r#cdata2); // <compareDocumentPosition var="cdata1Position" obj="cdata1" other="cdata2"/>
                assert_eq!(u16::from(r#cdata1_position), 4); // <assertEquals actual="cdata1Position" expected="4" id="nodecomparedocumentposition19_cdata2Follows" ignoreCase="false"/>
                r#cdata2_position = r#cdata2.compare_document_position(&r#cdata1); // <compareDocumentPosition var="cdata2Position" obj="cdata2" other="cdata1"/>
                assert_eq!(u16::from(r#cdata2_position), 2); // <assertEquals actual="cdata2Position" expected="2" id="nodecomparedocumentposition_cdata1Precedes" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom24.xml
            #[test]
            fn test_typeinfoisderivedfrom24() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "strongType"); // <assertEquals actual="typeName" expected="&quot;strongType&quot;" ignoreCase="false" id="typeName"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;string&quot;" derivationMethod="7"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="derivedFromStringNotList"/>
            }
            // datatypenormalization04.xml
            #[test]
            fn test_datatypenormalization04() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#str; // type: DOMString // <var name="str" type="DOMString"/>
                // let mut r#can_set_normalization; // type: boolean // <var name="canSetNormalization" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#can_set_xml_schema; // type: boolean // <var name="canSetXMLSchema" type="boolean"/>
                // let mut r#xsd_ns; // type: DOMString // <var name="xsdNS" type="DOMString" value="&quot;http://www.w3.org/2001/XMLSchema&quot;"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // r#doc = todo!(); // datatype_normalization.xml // <load var="doc" href="datatype_normalization" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetNormalization" obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetValidate" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetXMLSchema" obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>

                // // unimplemented: // <if>	<and>		<isTrue value="canSetNormalization"/>		<isTrue value="canSetValidate"/>		<isTrue value="canSetXMLSchema"/>	</and>	<setParameter obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>		<normalizeDocument obj="doc"/>	<!--  fail test if normalize had any errors or fatal errors   -->	<assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>	<getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;http://www.w3.org/2001/DOM-Test-Suite/Level-3/datatype_normalization&quot;" localName="&quot;float&quot;" interface="Document"/>	<item var="element" obj="elemList" interface="NodeList" index="0"/>	<getAttribute var="str" obj="element" name="&quot;value&quot;"/>	<assertEquals actual="str" expected="&quot;+0003.141592600E+0000&quot;" ignoreCase="false" id="firstValue"/>	<getAttribute var="str" obj="element" name="&quot;union&quot;"/>	<assertEquals actual="str" expected="&quot;+0003.141592600E+0000&quot;" ignoreCase="false" id="firstUnion"/>	<textContent var="str" obj="element"/>	<assertEquals actual="str" expected="&quot;-31415926.00E-7 2.718&quot;" ignoreCase="false" id="firstList"/>		<item var="element" obj="elemList" interface="NodeList" index="1"/>	<getAttribute var="str" obj="element" name="&quot;value&quot;"/>	<assertEquals actual="str" expected="&quot;NaN&quot;" ignoreCase="false" id="secondValue"/>	<getAttribute var="str" obj="element" name="&quot;union&quot;"/>	<assertEquals actual="str" expected="&quot;NaN&quot;" ignoreCase="false" id="secondUnion"/>	<textContent var="str" obj="element"/>	<assertEquals actual="str" expected="&quot;INF -INF&quot;" ignoreCase="false" id="secondList"/>		<item var="element" obj="elemList" interface="NodeList" index="2"/>	<getAttribute var="str" obj="element" name="&quot;value&quot;"/>	<assertEquals actual="str" expected="&quot;1&quot;" ignoreCase="false" id="thirdValue"/>	<getAttribute var="str" obj="element" name="&quot;union&quot;"/>	<assertEquals actual="str" expected="&quot;1&quot;" ignoreCase="false" id="thirdUnion"/>	<textContent var="str" obj="element"/>	<assertEquals actual="str" expected="&quot;-0&quot;" ignoreCase="false" id="thirdList"/>	</if>
            }
            // entitygetinputencoding01.xml
            #[test]
            fn test_entitygetinputencoding01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#encoding_name; // type: DOMString // <var name="encodingName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#entity = r#entities_map.get_named_item("alpha".into()).unwrap(); // <getNamedItem var="entity" obj="entitiesMap" name="&quot;alpha&quot;"/>
                // r#encoding_name = r#entity.input_encoding().unwrap().to_string();
                // // <inputEncoding obj="entity" var="encodingName" interface="Entity"/>

                // // unimplemented: // <assertNull actual="encodingName" id="entitygetinputencoding01"/>
            }
            // typeinfoisderivedfrom34.xml
            #[test]
            fn test_typeinfoisderivedfrom34() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;part1&quot;" derivationMethod="13"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="derivedFromPart1NotExtension"/>
            }
            // elementsetidattributens06.xml
            #[test]
            fn test_elementsetidattributens06() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#name_elem; // type: Element // <var name="nameElem" type="Element"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#name_elem = r#elem_list.item(2).unwrap(); // <item var="nameElem" obj="elemList" index="2" interface="NodeList"/>

                // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR"><NOT_FOUND_ERR><setIdAttributeNS obj="nameElem" localName="&quot;hasMiddleName&quot;" namespaceURI="&quot;http://www.netzero.com&quot;" isId="true"/></NOT_FOUND_ERR></assertDOMException>
            }
            // nodereplacechild35.xml
            #[test]
            fn test_nodereplacechild35() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#parent; // type: Attr // <var name="parent" type="Attr"/>
                // let mut r#old_child; // type: EntityReference // <var name="oldChild" type="EntityReference"/>
                // let mut r#new_child; // type: Attr // <var name="newChild" type="Attr"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#parent = r#doc
                //     .create_attribute_ns(
                //         Some("http://www.w3.org/XML/1998/namespace"),
                //         "xml:lang".as_ref(),
                //     )
                //     .unwrap(); // <createAttributeNS var="parent" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>
                // r#old_child = r#doc.create_entity_reference("delta".to_string()).unwrap(); // <createEntityReference var="oldChild" obj="doc" name="&quot;delta&quot;"/>
                // r#appended_child = r#parent.append_child(old_child.into()).unwrap(); // <appendChild obj="parent" var="appendedChild" newChild="oldChild"/>
                // r#new_child = r#doc
                //     .create_attribute_ns(
                //         Some("http://www.w3.org/XML/1998/namespace"),
                //         "xml:lang".as_ref(),
                //     )
                //     .unwrap(); // <createAttributeNS var="newChild" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR"><HIERARCHY_REQUEST_ERR><replaceChild obj="parent" var="replaced" oldChild="oldChild" newChild="newChild"/></HIERARCHY_REQUEST_ERR></assertDOMException>
            }
            // nodecomparedocumentposition26.xml
            #[test]
            fn test_nodecomparedocumentposition26() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#var_list; // type: NodeList // <var name="varList" type="NodeList"/>
                // let mut r#var_elem; // type: Element // <var name="varElem" type="Element"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#ent_ref_child1; // type: Element // <var name="entRefChild1" type="Element"/>
                // let mut r#ent_ref_position; // type: int // <var name="entRefPosition" type="int"/>
                // let mut r#ent_ref_child1_position; // type: int // <var name="entRefChild1Position" type="int"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <if>	<implementationAttribute name="expandEntityReferences" value="false"/>	<getElementsByTagName var="varList" obj="doc" tagname="&quot;var&quot;" interface="Document"/>	<item var="varElem" obj="varList" index="2" interface="NodeList"/>	<assertNotNull actual="varElem" id="varElemNotNull"/>	<firstChild var="entRef" obj="varElem" interface="Node"/>	<assertNotNull actual="entRef" id="entRefNotNull"/>	<else>		<createEntityReference name="&quot;ent4&quot;" obj="doc" var="entRef"/>	</else></if>
                // r#ent_ref_child1 = r#ent_ref.first_child().unwrap(); // <firstChild var="entRefChild1" obj="entRef" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="entRefChild1" id="entRefChild1NotNull"/>
                // r#ent_ref_position = r#ent_ref.compare_document_position(&r#ent_ref_child1.into()); // <compareDocumentPosition var="entRefPosition" obj="entRef" other="entRefChild1"/>
                // assert_eq!(u16::from(r#ent_ref_position), 20); // <assertEquals actual="entRefPosition" expected="20" id="nodecomparedocumentpositionIsContainedFollowing26" ignoreCase="false"/>
                // r#ent_ref_child1_position =
                //     r#ent_ref_child1.compare_document_position(&r#ent_ref.into()); // <compareDocumentPosition var="entRefChild1Position" obj="entRefChild1" other="entRef"/>
                // assert_eq!(u16::from(r#ent_ref_child1_position), 10); // <assertEquals actual="entRefChild1Position" expected="10" id="nodecomparedocumentpositionContainsPRECEDING26" ignoreCase="false"/>
            }
            // noderemovechild14.xml
            #[test]
            fn test_noderemovechild14() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#removed; // type: Node // <var name="removed" type="Node"/>
                // let mut r#e_ref; // type: EntityReference // <var name="eRef" type="EntityReference"/>
                // let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                // let mut r#ent_name; // type: DOMString // <var name="entName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#e_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference var="eRef" obj="doc" name="&quot;ent4&quot;"/>
                // r#pi = r#e_ref.last_child().unwrap(); // <lastChild obj="eRef" var="pi" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="pi" id="piNotNull"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">	<NO_MODIFICATION_ALLOWED_ERR>		<removeChild obj="eRef" var="removed" oldChild="pi"/>	</NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // typeinfoisderivedfrom25.xml
            #[test]
            fn test_typeinfoisderivedfrom25() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "strongType"); // <assertEquals actual="typeName" expected="&quot;strongType&quot;" ignoreCase="false" id="typeName"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anySimpleType&quot;" derivationMethod="1"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromAnySimpleType"/>
            }
            // nodegettextcontent11.xml
            #[test]
            fn test_nodegettextcontent11() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#cdata; // type: CDATASection // <var name="cdata" type="CDATASection"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#elem = r#elem_list.item(1).unwrap(); // <item var="elem" obj="elemList" index="1" interface="NodeList"/>
                r#cdata = r#elem.last_child().unwrap(); // <lastChild var="cdata" obj="elem" interface="Node"/>
                r#text_content = r#cdata.text_content().unwrap(); // <textContent var="textContent" obj="cdata"/>
                assert_eq!(
                    r#text_content,
                    "This is an adjacent CDATASection with a reference to a tab &tab;"
                ); // <assertEquals actual="textContent" expected="&quot;This is an adjacent CDATASection with a reference to a tab &amp;tab;&quot;" id="nodegettextcontent11" ignoreCase="false"/>
            }
            // textreplacewholetext01.xml
            #[test]
            fn test_textreplacewholetext01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#item_list; // type: NodeList // <var name="itemList" type="NodeList"/>
                let mut r#element_name; // type: Element // <var name="elementName" type="Element"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#replaced_text; // type: Text // <var name="replacedText" type="Text"/>
                let mut r#whole_text; // type: DOMString // <var name="wholeText" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#item_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="itemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#element_name = r#item_list.item(0).unwrap(); // <item var="elementName" obj="itemList" index="0" interface="NodeList"/>
                r#text_node = r#element_name
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild var="textNode" obj="elementName" interface="Node"/>
                r#replaced_text = r#text_node
                    .replace_whole_text("New Content")
                    .unwrap()
                    .unwrap(); // <replaceWholeText obj="textNode" var="replacedText" content="&quot;New Content&quot;"/>
                r#whole_text = r#replaced_text.whole_text().to_string(); // <wholeText var="wholeText" obj="replacedText"/>
                assert_eq!(r#whole_text, "New Content"); // <assertEquals expected="&quot;New Content&quot;" actual="wholeText" id="textreplacewholetext01_1" ignoreCase="false"/>
            }
            // hasFeature03.xml
            #[test]
            fn test_has_feature03() {
                // let mut r#impl; // type: DOMImplementation // <var name="impl" type="DOMImplementation"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>

                // // unimplemented: // <implementation var="impl"/>

                // // unimplemented: // <hasFeature var="state" obj="impl" feature="&quot;+cOrE&quot;" version="&quot;3.0&quot;"/>
                // assert!(r#state); // <assertTrue id="hasPlusCore30" actual="state"/>
            }
            // documentnormalizedocument01.xml
            #[test]
            fn test_documentnormalizedocument01() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#doc_elem_node_name; // type: DOMString // <var name="docElemNodeName" type="DOMString"/>
                // let mut r#orig_doc_elem_node_name; // type: DOMString // <var name="origDocElemNodeName" type="DOMString"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#orig_doc_elem_node_name = r#doc_elem.node_name().to_string(); // <nodeName var="origDocElemNodeName" obj="docElem"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#doc_elem_node_name = r#doc_elem.node_name().to_string(); // <nodeName var="docElemNodeName" obj="docElem"/>
                // assert_eq!(r#doc_elem_node_name, orig_doc_elem_node_name); // <assertEquals actual="docElemNodeName" expected="origDocElemNodeName" id="documentnormalizedocument01" ignoreCase="false"/>
            }
            // nodecomparedocumentposition18.xml
            #[test]
            fn test_nodecomparedocumentposition18() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#txt1; // type: Text // <var name="txt1" type="Text"/>
                let mut r#txt2; // type: Text // <var name="txt2" type="Text"/>
                let mut r#txt1_position; // type: int // <var name="txt1Position" type="int"/>
                let mut r#txt2_position; // type: int // <var name="txt2Position" type="int"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#txt1 = r#doc.create_text_node("T1"); // <createTextNode var="txt1" obj="doc" data="&quot;T1&quot;"/>
                r#txt2 = r#doc.create_text_node("T2"); // <createTextNode var="txt2" obj="doc" data="&quot;T2&quot;"/>
                r#appended_child = r#doc_elem.append_child(txt1.into()).unwrap(); // <appendChild obj="docElem" var="appendedChild" newChild="txt1"/>
                r#appended_child = r#doc_elem.append_child(txt2.into()).unwrap(); // <appendChild obj="docElem" var="appendedChild" newChild="txt2"/>
                r#txt1_position = r#txt1.compare_document_position(&r#txt2.into()); // <compareDocumentPosition var="txt1Position" obj="txt1" other="txt2"/>
                assert_eq!(u16::from(r#txt1_position), 4); // <assertEquals actual="txt1Position" expected="4" id="nodecomparedocumentpositionFollowing18" ignoreCase="false"/>
                r#txt2_position = r#txt2.compare_document_position(&r#txt1.into()); // <compareDocumentPosition var="txt2Position" obj="txt2" other="txt1"/>
                assert_eq!(u16::from(r#txt2_position), 2); // <assertEquals actual="txt2Position" expected="2" id="nodecomparedocumentpositionPRECEDING18" ignoreCase="false"/>
            }
            // domconfignormalizecharacters1.xml
            #[test]
            fn test_domconfignormalizecharacters1() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // let mut r#parameter; // type: DOMString // <var name="parameter" type="DOMString" value="&quot;nOrMalize-characters&quot;"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDocType"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(!r#state); // <assertFalse actual="state" id="defaultFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="false"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="true"/>

                // // unimplemented: // <if>  	  <isTrue value="canSet"/>  	  <setParameter obj="domConfig" name="parameter" value="true"/>  	  <getParameter var="state" obj="domConfig" name="parameter"/>  	  <assertTrue actual="state" id="setTrueEffective"/>  	  <else>  	  	  <assertDOMException id="throw_NOT_SUPPORTED_ERR">  	  	  	<NOT_SUPPORTED_ERR>  	  			<setParameter obj="domConfig" name="parameter" value="true"/>  	  		</NOT_SUPPORTED_ERR>  	  	  </assertDOMException>  	  	  <!--  should still be false after failed attempt  -->  	  	  <getParameter var="state" obj="domConfig" name="parameter"/>  	      <assertFalse actual="state" id="setTrueNotEffective"/>  	  </else>  </if>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="false"/>
            }
            // typeinfoisderivedfrom33.xml
            #[test]
            fn test_typeinfoisderivedfrom33() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;part1&quot;" derivationMethod="2"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromPart1Extension"/>
            }
            // documentsetstricterrorchecking02.xml
            #[test]
            fn test_documentsetstricterrorchecking02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                // let mut r#null_value; // type: DOMString // <var name="nullValue" type="DOMString" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // // unimplemented: // <strictErrorChecking obj="doc" value="true"/>

                // // unimplemented: // <assertDOMException id="NAMESPACE_ERR_documentsetstricterrorchecking02"><NAMESPACE_ERR><createAttributeNS obj="doc" var="newAttr" namespaceURI="nullValue" qualifiedName="&quot;dom:test&quot;"/></NAMESPACE_ERR></assertDOMException>
            }
            // noderemovechild09.xml
            #[test]
            fn test_noderemovechild09() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                let mut r#removed_pi; // type: ProcessingInstruction // <var name="removedPi" type="ProcessingInstruction"/>
                let mut r#target; // type: DOMString // <var name="target" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#pi = r#doc
                    .create_processing_instruction("PIT", Some("PID"))
                    .unwrap(); // <createProcessingInstruction var="pi" obj="doc" data="&quot;PID&quot;" target="&quot;PIT&quot;"/>
                r#appended_child = r#doc.append_child(pi.into()).unwrap(); // <appendChild obj="doc" var="appendedChild" newChild="pi"/>
                r#removed_pi = r#doc
                    .remove_child(pi.into())
                    .unwrap()
                    .as_processing_instruction()
                    .unwrap(); // <removeChild var="removedPi" obj="doc" oldChild="pi"/>
                r#target = r#removed_pi.target().to_string(); // <target var="target" obj="removedPi" interface="ProcessingInstruction"/>
                assert_eq!(r#target, "PIT"); // <assertEquals actual="target" expected="&quot;PIT&quot;" id="noderemovechild09" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom08.xml
            #[test]
            fn test_typeinfoisderivedfrom08() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>
                // r#attr = r#acronym_elem.get_attribute_node("class").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;class&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "classType"); // <assertEquals actual="typeName" expected="&quot;classType&quot;" ignoreCase="false" id="nameIsString"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;string&quot;" derivationMethod="15"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromString"/>
            }
            // domimplementationregistry12.xml
            #[test]
            fn test_domimplementationregistry12() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#has_core; // type: boolean // <var name="hasCore" type="boolean"/>
                // let mut r#has_xml; // type: boolean // <var name="hasXML" type="boolean"/>
                // let mut r#has_events; // type: boolean // <var name="hasEvents" type="boolean"/>
                // let mut r#has_ls; // type: boolean // <var name="hasLS" type="boolean"/>
                // let mut r#base_impl; // type: DOMImplementation // <var name="baseImpl" type="DOMImplementation"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementation var="domImpl" obj="domImplRegistry" features="&quot;cOrE 3.0 xMl 3.0 eVeNts 2.0 lS&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <if>	<isNull obj="domImpl"/>	<implementation var="baseImpl"/>	<hasFeature var="hasCore" obj="baseImpl" feature="&quot;Core&quot;" version="&quot;3.0&quot;"/>	<hasFeature var="hasXML" obj="baseImpl" feature="&quot;XML&quot;" version="&quot;3.0&quot;"/>	<hasFeature var="hasEvents" obj="baseImpl" feature="&quot;Events&quot;" version="&quot;2.0&quot;"/>	<hasFeature var="hasLS" obj="baseImpl" feature="&quot;LS&quot;" version="nullVersion"/>	<assertFalse id="baseImplFeatures">		<and>			<isTrue value="hasCore"/>			<isTrue value="hasXML"/>			<isTrue value="hasEvents"/>			<isTrue value="hasLS"/>		</and>	</assertFalse>	<else>		<hasFeature var="hasCore" obj="domImpl" feature="&quot;Core&quot;" version="&quot;3.0&quot;"/>		<assertTrue actual="hasCore" id="hasCore"/>		<hasFeature var="hasXML" obj="domImpl" feature="&quot;XML&quot;" version="&quot;3.0&quot;"/>		<assertTrue actual="hasXML" id="hasXML"/>		<hasFeature var="hasEvents" obj="domImpl" feature="&quot;Events&quot;" version="&quot;2.0&quot;"/>		<assertTrue actual="hasEvents" id="hasEvents"/>		<hasFeature var="hasLS" obj="domImpl" feature="&quot;LS&quot;" version="nullVersion"/>		<assertTrue actual="hasLS" id="hasLS"/>	</else></if>
            }
            // documentnormalizedocument11.xml
            #[test]
            fn test_documentnormalizedocument11() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // // unimplemented: // <implementationAttribute name="ignoringElementContentWhitespace" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem_name; // type: Element // <var name="elemName" type="Element"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;namespace-declarations&quot;" value="true"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>
                // r#elem_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "acronym"); // <getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;acronym&quot;" interface="Document"/>
                // r#elem_name = r#elem_list.item(1).unwrap(); // <item var="elemName" obj="elemList" index="1" interface="NodeList"/>

                // // unimplemented: // <assertNotNull actual="elemName" id="documentnormalizedocument11_NotNullElem"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;namespace-declarations&quot;" value="false"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;namespace-declarations&quot;" value="false"/><normalizeDocument obj="doc"/><getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;acronym&quot;" interface="Document"/><item var="elemName" obj="elemList" index="1" interface="NodeList"/><nodeName var="nodeName" obj="elemName"/><assertEquals actual="nodeName" expected="&quot;address&quot;" id="documentnormalizedocument11_namespaceDeclarations" ignoreCase="false"/></if>
            }
            // nodereplacechild34.xml
            #[test]
            fn test_nodereplacechild34() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#parent; // type: Attr // <var name="parent" type="Attr"/>
                let mut r#old_child; // type: EntityReference // <var name="oldChild" type="EntityReference"/>
                let mut r#new_child; // type: Text // <var name="newChild" type="Text"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#parent = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/XML/1998/namespace"),
                        "xml:lang".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="parent" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>
                r#old_child = r#doc.create_entity_reference("delta".to_string()).unwrap(); // <createEntityReference var="oldChild" obj="doc" name="&quot;delta&quot;"/>
                r#appended_child = r#parent.append_child(old_child.into()).unwrap(); // <appendChild obj="parent" var="appendedChild" newChild="oldChild"/>
                r#new_child = r#doc.create_text_node("Text"); // <createTextNode var="newChild" obj="doc" data="&quot;Text&quot;"/>
                r#replaced = r#parent
                    .replace_child(new_child.into(), old_child.into())
                    .unwrap(); // <replaceChild obj="parent" var="replaced" oldChild="oldChild" newChild="newChild"/>
                r#node_value = r#parent.value().to_string(); // <value var="nodeValue" obj="parent"/>
                assert_eq!(r#node_value, "Text"); // <assertEquals actual="nodeValue" expected="&quot;Text&quot;" id="nodereplacechild34" ignoreCase="false"/>
            }
            // nodegetfeature13.xml
            #[test]
            fn test_nodegetfeature13() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // let mut r#feature_impl; // type: Node // <var name="featureImpl" type="Node"/>
                // let mut r#is_supported; // type: boolean // <var name="isSupported" type="boolean"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                // let mut r#doctype; // type: DocumentType // <var name="doctype" type="DocumentType"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#doctype = r#doc.doctype().unwrap(); // <doctype var="doctype" obj="doc"/>

                // // unimplemented: // <notations var="notations" obj="doctype"/>
                // r#node = r#notations.get_named_item("notation1".into()).unwrap();
                // // <getNamedItem var="node" obj="notations" name="&quot;notation1&quot;"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Core&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="coreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="cOrEUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;+cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="PlusCoreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;org.w3c.domts.bogus.feature&quot;" version="nullVersion"/>

                // // unimplemented: // <assertNull actual="featureImpl" id="unrecognizedFeature"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;2.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core20"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;3.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core30"/>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="SVGUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="HTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="EventsUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSAsyncUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XPathUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusHTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusSVGUnspecified"/></if>
            }
            // documentnormalizedocument04.xml
            #[test]
            fn test_documentnormalizedocument04() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#new_comment; // type: Comment // <var name="newComment" type="Comment"/>
                // let mut r#last_child; // type: Node // <var name="lastChild" type="Node"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#p_list.item(0).unwrap(); // <item var="elem" obj="pList" index="0" interface="NodeList"/>
                // r#new_comment = r#doc.create_comment("COMMENT_NODE"); // <createComment var="newComment" obj="doc" data="&quot;COMMENT_NODE&quot;"/>
                // r#appended_child = r#elem.append_child(new_comment.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="newComment"/>

                // // unimplemented: // <domConfig interface="Document" obj="doc" var="domConfig"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;comments&quot;" value="true"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" severity="SEVERITY_ERROR" id="normalizationError"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#p_list.item(0).unwrap(); // <item var="elem" obj="pList" index="0" interface="NodeList"/>
                // r#last_child = r#elem.last_child().unwrap(); // <lastChild var="lastChild" obj="elem" interface="Node"/>
                // r#node_name = r#last_child.node_name().to_string(); // <nodeName var="nodeName" obj="lastChild"/>
                // assert_eq!(r#node_name, "#comment"); // <assertEquals actual="nodeName" expected="&quot;#comment&quot;" id="documentnormalizedocument04_true" ignoreCase="false"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;comments&quot;" value="false"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" severity="SEVERITY_ERROR" id="normalization2Error"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#p_list.item(0).unwrap(); // <item var="elem" obj="pList" index="0" interface="NodeList"/>
                // r#last_child = r#elem.last_child().unwrap(); // <lastChild var="lastChild" obj="elem" interface="Node"/>
                // r#node_name = r#last_child.node_name().to_string(); // <nodeName var="nodeName" obj="lastChild"/>
                // assert_eq!(r#node_name, "#text"); // <assertEquals actual="nodeName" expected="&quot;#text&quot;" id="hasChildText" ignoreCase="false"/>
            }
            // noderemovechild28.xml
            #[test]
            fn test_noderemovechild28() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#parent_list; // type: NodeList // <var name="parentList" type="NodeList"/>
                // let mut r#attrs_map; // type: NamedNodeMap // <var name="attrsMap" type="NamedNodeMap"/>
                // let mut r#parent; // type: Attr // <var name="parent" type="Attr"/>
                // let mut r#child; // type: Text // <var name="child" type="Text"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#removed; // type: Text // <var name="removed" type="Text"/>
                // let mut r#removed_name; // type: DOMString // <var name="removedName" type="DOMString"/>
                // let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#parent_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="parentList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#elem = r#parent_list[0].clone(); // <item var="elem" obj="parentList" index="0" interface="NodeList"/>
                // r#attrs_map = r#elem.attributes(); // <attributes var="attrsMap" obj="elem"/>
                // r#parent = r#attrs_map
                //     .get_named_item("xsi:noNamespaceSchemaLocation")
                //     .unwrap(); // <getNamedItem var="parent" obj="attrsMap" name="&quot;xsi:noNamespaceSchemaLocation&quot;"/>
                // r#child = r#parent.first_child().unwrap(); // <firstChild var="child" obj="parent" interface="Node"/>
                // r#removed = r#parent.remove_child(child.into()).unwrap(); // <removeChild var="removed" obj="parent" oldChild="child"/>
                // r#removed_name = r#removed.node_value().unwrap().to_string(); // <nodeValue obj="removed" var="removedName"/>
                // assert_eq!(r#removed_name, "Yes"); // <assertEquals actual="removedName" expected="&quot;Yes&quot;" id="noderemovechild28" ignoreCase="false"/>

                // // unimplemented: // <assertDOMException id="NOT_FOUND_ERR_noderemovechild28"><NOT_FOUND_ERR><removeChild obj="child" var="removedNode" oldChild="parent"/></NOT_FOUND_ERR></assertDOMException>
            }
            // typeinfoisderivedfrom71.xml
            #[test]
            fn test_typeinfoisderivedfrom71() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>

                // // unimplemented: // <implementationAttribute name="validating" value="true"/>

                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_type_info; // type: TypeInfo // <var name="elemTypeInfo" type="TypeInfo"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#ret_value; // type: boolean // <var name="retValue" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("code"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;code&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="elemTypeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <isDerivedFrom obj="elemTypeInfo" var="retValue" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;field&quot;" derivationMethod="0"/>
                // assert!(r#ret_value); // <assertTrue actual="retValue" id="isDerived"/>
            }
            // documentrenamenode08.xml
            #[test]
            fn test_documentrenamenode08() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#renamed_node; // type: Node // <var name="renamedNode" type="Node"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#doc_elem_ns; // type: DOMString // <var name="docElemNS" type="DOMString"/>
                // let mut r#doc_elem_name; // type: DOMString // <var name="docElemName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#child_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#element = r#child_list.item(3).unwrap().clone(); // <item var="element" obj="childList" index="3" interface="NodeList"/>
                // r#attr = r#element.get_attribute_node("dir").unwrap(); // <getAttributeNode var="attr" obj="element" name="&quot;dir&quot;"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#doc_elem_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="docElemNS" obj="docElem" interface="Node"/>
                // r#doc_elem_name = r#doc_elem.tag_name().to_string(); // <tagName var="docElemName" obj="docElem"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="docElemNS" qualifiedName="docElemName" doctype="nullDocType"/>

                // // unimplemented: // <assertDOMException id="documentrenamenode08_WRONG_DOCUMENT_ERR"><WRONG_DOCUMENT_ERR><renameNode var="renamedNode" obj="newDoc" n="attr" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/></WRONG_DOCUMENT_ERR></assertDOMException>
            }
            // nodereplacechild27.xml
            #[test]
            fn test_nodereplacechild27() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#child_list2; // type: NodeList // <var name="childList2" type="NodeList"/>
                // let mut r#elem2; // type: Element // <var name="elem2" type="Element"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#child_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "p"); // <getElementsByTagNameNS var="childList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;p&quot;" interface="Document"/>
                // r#elem = r#child_list.item(0).unwrap().clone(); // <item var="elem" obj="childList" index="0" interface="NodeList"/>
                // r#first_child = r#elem.first_child().unwrap(); // <firstChild var="firstChild" obj="elem" interface="Node"/>
                // r#doc2 = todo!(); // hc_staff.xml // <load var="doc2" href="hc_staff" willBeModified="false"/>
                // r#child_list2 = r#doc2.get_elements_by_tag_name_ns(Some("*"), "p"); // <getElementsByTagNameNS var="childList2" obj="doc2" namespaceURI="&quot;*&quot;" localName="&quot;p&quot;" interface="Document"/>
                // r#elem2 = r#child_list2[0].clone(); // <item var="elem2" obj="childList2" index="0" interface="NodeList"/>

                // // unimplemented: // <assertDOMException id="WRONG_DOCUMENT_ERR_nodereplacechild27"><WRONG_DOCUMENT_ERR><replaceChild obj="elem" var="replaced" oldChild="firstChild" newChild="elem2"/></WRONG_DOCUMENT_ERR></assertDOMException>
            }
            // nodecomparedocumentposition25.xml
            #[test]
            fn test_nodecomparedocumentposition25() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#elem_name; // type: Element // <var name="elemName" type="Element"/>
                let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                let mut r#element_position; // type: int // <var name="elementPosition" type="int"/>
                let mut r#ent_ref_position; // type: int // <var name="entRefPosition" type="int"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("var"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;var&quot;" interface="Document"/>
                r#elem_name = r#elem_list.item(2).unwrap(); // <item var="elemName" obj="elemList" index="2" interface="NodeList"/>
                r#ent_ref = r#elem_name.first_child().unwrap(); // <firstChild obj="elemName" var="entRef" interface="Node"/>
                r#element_position = r#elem_name.compare_document_position(&r#ent_ref); // <compareDocumentPosition var="elementPosition" obj="elemName" other="entRef"/>
                assert_eq!(u16::from(r#element_position), 20); // <assertEquals actual="elementPosition" expected="20" id="nodecomparedocumentpositionIsContainedFollowing25" ignoreCase="false"/>
                r#ent_ref_position = r#ent_ref.compare_document_position(&r#elem_name.into()); // <compareDocumentPosition var="entRefPosition" obj="entRef" other="elemName"/>
                assert_eq!(u16::from(r#ent_ref_position), 10); // <assertEquals actual="entRefPosition" expected="10" id="nodecomparedocumentpositionContainsPRECEDING25" ignoreCase="false"/>
            }
            // nodereplacechild25.xml
            #[test]
            fn test_nodereplacechild25() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#ent_ref; // type: Node // <var name="entRef" type="Node"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#replaced; // type: Element // <var name="replaced" type="Element"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entities" obj="docType"/>
                // r#entity = r#entities.get_named_item("alpha".into()).unwrap(); // <getNamedItem var="entity" obj="entities" name="&quot;alpha&quot;"/>
                // r#child_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#elem = r#child_list.item(1).unwrap().clone(); // <item var="elem" obj="childList" index="1" interface="NodeList"/>
                // r#ent_ref = r#elem.first_child().unwrap(); // <firstChild var="entRef" obj="elem" interface="Node"/>

                // // unimplemented: // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR_1"><HIERARCHY_REQUEST_ERR><replaceChild var="replaced" obj="elem" oldChild="entRef" newChild="entity"/></HIERARCHY_REQUEST_ERR></assertDOMException>

                // // unimplemented: // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR_2"><HIERARCHY_REQUEST_ERR><replaceChild var="replaced" obj="elem" oldChild="entRef" newChild="elem"/></HIERARCHY_REQUEST_ERR></assertDOMException>
            }
            // nodegetfeature12.xml
            #[test]
            fn test_nodegetfeature12() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // let mut r#feature_impl; // type: Node // <var name="featureImpl" type="Node"/>
                // let mut r#is_supported; // type: boolean // <var name="isSupported" type="boolean"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#doctype; // type: DocumentType // <var name="doctype" type="DocumentType"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#doctype = r#doc.doctype().unwrap(); // <doctype var="doctype" obj="doc"/>

                // // unimplemented: // <entities var="entities" obj="doctype"/>
                // r#node = r#entities.get_named_item("ent1".into()).unwrap(); // <getNamedItem var="node" obj="entities" name="&quot;ent1&quot;"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Core&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="coreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="cOrEUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;+cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="PlusCoreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;org.w3c.domts.bogus.feature&quot;" version="nullVersion"/>

                // // unimplemented: // <assertNull actual="featureImpl" id="unrecognizedFeature"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;2.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core20"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;3.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core30"/>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="SVGUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="HTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="EventsUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSAsyncUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XPathUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusHTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusSVGUnspecified"/></if>
            }
            // datatypenormalization09.xml
            #[test]
            fn test_datatypenormalization09() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#str; // type: DOMString // <var name="str" type="DOMString"/>
                // let mut r#can_set_normalization; // type: boolean // <var name="canSetNormalization" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#can_set_xml_schema; // type: boolean // <var name="canSetXMLSchema" type="boolean"/>
                // let mut r#xsd_ns; // type: DOMString // <var name="xsdNS" type="DOMString" value="&quot;http://www.w3.org/2001/XMLSchema&quot;"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // r#doc = todo!(); // datatype_normalization.xml // <load var="doc" href="datatype_normalization" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetNormalization" obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetValidate" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetXMLSchema" obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>

                // // unimplemented: // <if>	<and>		<isTrue value="canSetNormalization"/>		<isTrue value="canSetValidate"/>		<isTrue value="canSetXMLSchema"/>	</and>	<setParameter obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>	<normalizeDocument obj="doc"/>	<!--  fail test if normalize had any errors or fatal errors   -->	<assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>	<getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;http://www.w3.org/2001/DOM-Test-Suite/Level-3/datatype_normalization&quot;" localName="&quot;boolean&quot;" interface="Document"/>	<item var="element" obj="elemList" interface="NodeList" index="0"/>	<getAttribute var="str" obj="element" name="&quot;default&quot;"/>	<assertEquals actual="str" expected="&quot;true&quot;" ignoreCase="false" id="firstValue"/></if>
            }
            // domimplementationgetfeature03.xml
            #[test]
            fn test_domimplementationgetfeature03() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#dom_impl_returned; // type: DOMImplementation // <var name="domImplReturned" type="DOMImplementation"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <getFeature var="domImplReturned" obj="domImpl" feature="&quot;Core&quot;" version="nullVersion" interface="DOMImplementation"/>

                // // unimplemented: // <assertNotNull actual="domImplReturned" id="domimplementationgetfeature03"/>
            }
            // domimplementationgetfeature01.xml
            #[test]
            fn test_domimplementationgetfeature01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#dom_impl_returned; // type: DOMImplementation // <var name="domImplReturned" type="DOMImplementation"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <getFeature var="domImplReturned" obj="domImpl" feature="&quot;Core&quot;" version="&quot;2.0&quot;" interface="DOMImplementation"/>

                // // unimplemented: // <assertNotNull actual="domImplReturned" id="domimplementationgetfeature01"/>
            }
            // domimplementationregistry15.xml
            #[test]
            fn test_domimplementationregistry15() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#has_feature; // type: boolean // <var name="hasFeature" type="boolean"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // let mut r#dom_impl_list; // type: DOMImplementationList // <var name="domImplList" type="DOMImplementationList"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementationList var="domImplList" obj="domImplRegistry" features="&quot;+cOrE&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <length var="length" obj="domImplList" interface="DOMImplementationList"/>

                // // unimplemented: // <assertTrue id="atLeastOne">	<greater actual="length" expected="0"/></assertTrue>

                // // unimplemented: // <for-each collection="domImplList" member="domImpl">	<hasFeature var="hasFeature" obj="domImpl" feature="&quot;+Core&quot;" version="nullVersion"/>	<assertTrue actual="hasFeature" id="hasCore"/></for-each>
            }
            // documentadoptnode12.xml
            #[test]
            fn test_documentadoptnode12() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#adopted_doc_type; // type: Node // <var name="adoptedDocType" type="Node"/>
                // let mut r#null_pub_id; // type: DOMString // <var name="nullPubID" type="DOMString" isNull="true"/>
                // let mut r#null_sys_id; // type: DOMString // <var name="nullSysID" type="DOMString" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocumentType var="docType" obj="domImpl" qualifiedName="rootName" publicId="nullPubID" systemId="nullSysID"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="docType"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><adoptNode var="adoptedDocType" obj="newDoc" source="docType"/></NOT_SUPPORTED_ERR></assertDOMException>
            }
            // documentadoptnode02.xml
            #[test]
            fn test_documentadoptnode02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#attr_owner_elem; // type: Element // <var name="attrOwnerElem" type="Element"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#adoptedclass; // type: Node // <var name="adoptedclass" type="Node"/>
                // let mut r#attrs_parent; // type: Node // <var name="attrsParent" type="Node"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // let mut r#is_specified; // type: boolean // <var name="isSpecified" type="boolean"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#first_child; // type: Text // <var name="firstChild" type="Text"/>
                // let mut r#first_child_value; // type: DOMString // <var name="firstChildValue" type="DOMString"/>
                // let mut r#second_child; // type: EntityReference // <var name="secondChild" type="EntityReference"/>
                // let mut r#second_child_type; // type: int // <var name="secondChildType" type="int"/>
                // let mut r#second_child_name; // type: DOMString // <var name="secondChildName" type="DOMString"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#child_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#element = r#child_list.item(3).unwrap().clone(); // <item var="element" obj="childList" index="3" interface="NodeList"/>
                // r#attr = r#element.get_attribute_node("class").unwrap(); // <getAttributeNode var="attr" obj="element" name="&quot;class&quot;"/>
                // r#adoptedclass = r#new_doc.adopt_node(r#attr.into()).unwrap(); // <adoptNode var="adoptedclass" obj="newDoc" source="attr"/>

                // // unimplemented: // <if><notNull obj="adoptedclass"/><nodeName var="nodeName" obj="adoptedclass"/><nodeValue var="nodeValue" obj="adoptedclass"/><nodeType var="nodeType" obj="adoptedclass"/><ownerElement var="attrOwnerElem" obj="adoptedclass" interface="Attr"/><specified var="isSpecified" obj="adoptedclass"/><assertEquals expected="&quot;class&quot;" actual="nodeName" id="documentadoptnode02_nodeName" ignoreCase="false"/><assertEquals expected="2" actual="nodeType" id="documentadoptnode02_nodeType" ignoreCase="false"/><assertNull actual="attrOwnerElem" id="documentadoptnode02_ownerDoc"/><assertTrue actual="isSpecified" id="documentadoptnode02_specified"/><!--  The attribute's child list can either be a text node "Yes" or           an text node "Y" and a entity reference to "alpha"  --><firstChild var="firstChild" obj="adoptedclass" interface="Node"/><assertNotNull actual="firstChild" id="firstChildNotNull"/><nodeValue var="firstChildValue" obj="firstChild"/><if>	<equals actual="firstChildValue" expected="&quot;Y&quot;" ignoreCase="false"/>	<nextSibling var="secondChild" obj="firstChild" interface="Node"/>	<assertNotNull actual="secondChild" id="secondChildNotNull"/>	<nodeType var="secondChildType" obj="secondChild"/>	<assertEquals actual="secondChildType" expected="5" id="secondChildIsEntityReference" ignoreCase="false"/>	<nodeName var="secondChildName" obj="secondChild"/>	<assertEquals actual="secondChildName" expected="&quot;alpha&quot;" id="secondChildIsEnt1Reference" ignoreCase="false"/>	<else>		<assertEquals expected="&quot;Y&quot;" actual="nodeValue" id="documentadoptnode02_nodeValue" ignoreCase="false"/>	</else></if></if>
            }
            // documentnormalizedocument10.xml
            #[test]
            fn test_documentnormalizedocument10() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#new_text; // type: Text // <var name="newText" type="Text"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem = r#doc.create_element("newElem".to_string()).unwrap(); // <createElement var="elem" obj="doc" tagName="&quot;newElem&quot;"/>
                // r#new_text = r#doc.create_text_node("Text          Node"); // <createTextNode var="newText" obj="doc" data="&quot;Text          Node&quot;"/>
                // r#appended_child = r#elem.append_child(new_text.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="newText"/>
                // r#appended_child = r#doc.append_child(elem.into()).unwrap(); // <appendChild obj="doc" var="appendedChild" newChild="elem"/>
                // r#text = r#elem.first_child().unwrap(); // <firstChild var="text" obj="elem" interface="Node"/>
                // r#node_value = r#text.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="text"/>
                // assert_eq!(r#node_value, "Text          Node"); // <assertEquals actual="nodeValue" expected="&quot;Text          Node&quot;" id="documentnormalizedocument10" ignoreCase="false"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;element-content-whitespace&quot;" value="true"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetElementContentWhitespaceTrue"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;element-content-whitespace&quot;" value="true"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>
                // r#text = r#elem.first_child().unwrap(); // <firstChild var="text" obj="elem" interface="Node"/>
                // r#node_value = r#text.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="text"/>
                // assert_eq!(r#node_value, "Text          Node"); // <assertEquals actual="nodeValue" expected="&quot;Text          Node&quot;" id="documentnormalizedocument10_true1" ignoreCase="false"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;element-content-whitespace&quot;" value="false"/>

                // // unimplemented: // <if><isTrue value="canSet"/>		     <setParameter obj="domConfig" name="&quot;element-content-whitespace&quot;" value="false"/><normalizeDocument obj="doc"/><firstChild var="text" obj="elem" interface="Node"/><nodeValue var="nodeValue" obj="text"/><assertEquals actual="nodeValue" expected="&quot;Text Node&quot;" id="documentnormalizedocument10_true2" ignoreCase="false"/></if>
            }
            // typeinfoisderivedfrom66.xml
            #[test]
            fn test_typeinfoisderivedfrom66() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>

                // // unimplemented: // <implementationAttribute name="validating" value="true"/>

                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#union_elem; // type: Element // <var name="unionElem" type="Element"/>
                // let mut r#elem_type_info; // type: TypeInfo // <var name="elemTypeInfo" type="TypeInfo"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#ret_value; // type: boolean // <var name="retValue" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                // r#union_elem = r#elem_list.item(0).unwrap(); // <item var="unionElem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="elemTypeInfo" obj="unionElem" interface="Element"/>

                // // unimplemented: // <isDerivedFrom obj="elemTypeInfo" var="retValue" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;emp0004_5Type&quot;" derivationMethod="0"/>
                // assert!(r#ret_value); // <assertTrue actual="retValue" id="typeinfoisderivedfrom66"/>
            }
            // domconfigurationgetparameter02.xml
            #[test]
            fn test_domconfigurationgetparameter02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#param; // type: DOMUserData // <var name="param" type="DOMUserData"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <assertDOMException id="domconfigurationgetparameter02_NOT_FOUND_ERR"><NOT_FOUND_ERR><getParameter obj="domConfig" var="param" name="&quot;not-found-param&quot;"/> </NOT_FOUND_ERR></assertDOMException>
            }
            // nodeisdefaultnamespace03.xml
            #[test]
            fn test_nodeisdefaultnamespace03() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#is_default; // type: boolean // <var name="isDefault" type="boolean"/>
                // let mut r#null_nsuri; // type: DOMString // <var name="nullNSURI" type="DOMString" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                // r#is_default = r#doc_type.is_default_namespace(r#null_nsuri.as_ref()); // <isDefaultNamespace var="isDefault" obj="docType" namespaceURI="nullNSURI"/>
                // assert!(!r#is_default); // <assertFalse actual="isDefault" id="nodeisdefaultnamespace03"/>
            }
            // infoset01.xml
            #[test]
            fn test_infoset01() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#child_value; // type: DOMString // <var name="childValue" type="DOMString"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#ent2; // type: Entity // <var name="ent2" type="Entity"/>
                // let mut r#doctype; // type: DocumentType // <var name="doctype" type="DocumentType"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;infoset&quot;" value="true"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" interface="NodeList" index="0"/>
                // r#ent_ref = r#doc.create_entity_reference("ent1".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent1&quot;"/>
                // r#child = r#p_elem.append_child(ent_ref.into()).unwrap(); // <appendChild var="child" obj="pElem" newChild="entRef"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" interface="NodeList" index="0"/>
                // r#child = r#p_elem.last_child().unwrap(); // <lastChild var="child" obj="pElem" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="child" id="lastChildNotNull"/>
                // r#child_name = r#child.node_name().to_string(); // <nodeName var="childName" obj="child"/>
                // assert_eq!(r#child_name, "#text"); // <assertEquals actual="childName" expected="&quot;#text&quot;" ignoreCase="false" id="firstChildName"/>
                // r#child_value = r#child.node_value().unwrap().to_string(); // <nodeValue var="childValue" obj="child"/>
                // assert_eq!(r#child_value, "barfoo"); // <assertEquals actual="childValue" expected="&quot;barfoo&quot;" ignoreCase="false" id="firstChildValue"/>
                // r#doctype = r#doc.doctype().unwrap(); // <doctype var="doctype" obj="doc"/>

                // // unimplemented: // <entities var="entities" obj="doctype"/>
                // r#ent2 = r#entities.get_named_item("ent2".into()).unwrap(); // <getNamedItem var="ent2" obj="entities" name="&quot;ent2&quot;"/>

                // // unimplemented: // <assertNotNull actual="ent2" id="ent2NotNull"/>
            }
            // domimplementationregistry16.xml
            #[test]
            fn test_domimplementationregistry16() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#has_feature; // type: boolean // <var name="hasFeature" type="boolean"/>
                // let mut r#dom_impl_list; // type: DOMImplementationList // <var name="domImplList" type="DOMImplementationList"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementationList var="domImplList" obj="domImplRegistry" features="&quot;+cOrE 3.0&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <length var="length" obj="domImplList" interface="DOMImplementationList"/>

                // // unimplemented: // <assertTrue id="atLeastOne">	<greater actual="length" expected="0"/></assertTrue>

                // // unimplemented: // <for-each collection="domImplList" member="domImpl">	<hasFeature var="hasFeature" obj="domImpl" feature="&quot;+Core&quot;" version="&quot;3.0&quot;"/>	<assertTrue actual="hasFeature" id="hasCore"/></for-each>
            }
            // domstringlistcontains02.xml
            #[test]
            fn test_domstringlistcontains02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#param_list; // type: DOMStringList // <var name="paramList" type="DOMStringList"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#contain; // type: boolean // <var name="contain" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <parameterNames obj="domConfig" var="paramList"/>

                // // unimplemented: // <contains obj="paramList" var="contain" str="&quot;comments&quot;" interface="DOMStringList"/>
                // assert!(r#contain); // <assertTrue actual="contain" id="domstringlistcontains02_1"/>

                // // unimplemented: // <contains obj="paramList" var="contain" str="&quot;cdata-sections&quot;" interface="DOMStringList"/>
                // assert!(r#contain); // <assertTrue actual="contain" id="domstringlistcontains02_2"/>

                // // unimplemented: // <contains obj="paramList" var="contain" str="&quot;entities&quot;" interface="DOMStringList"/>
                // assert!(r#contain); // <assertTrue actual="contain" id="domstringlistcontains02_3"/>

                // // unimplemented: // <contains obj="paramList" var="contain" str="&quot;error-handler&quot;" interface="DOMStringList"/>
                // assert!(r#contain); // <assertTrue actual="contain" id="domstringlistcontains02_4"/>

                // // unimplemented: // <contains obj="paramList" var="contain" str="&quot;infoset&quot;" interface="DOMStringList"/>
                // assert!(r#contain); // <assertTrue actual="contain" id="domstringlistcontains02_5"/>

                // // unimplemented: // <contains obj="paramList" var="contain" str="&quot;namespace-declarations&quot;" interface="DOMStringList"/>
                // assert!(r#contain); // <assertTrue actual="contain" id="domstringlistcontains02_6"/>

                // // unimplemented: // <contains obj="paramList" var="contain" str="&quot;element-content-whitespace&quot;" interface="DOMStringList"/>
                // assert!(r#contain); // <assertTrue actual="contain" id="domstringlistcontains02_7"/>

                // // unimplemented: // <contains obj="paramList" var="contain" str="&quot;test&quot;" interface="DOMStringList"/>
                // assert!(!r#contain); // <assertFalse actual="contain" id="domstringlistcontains02_8"/>
            }
            // typeinfogettypenamespace01.xml
            #[test]
            fn test_typeinfogettypenamespace01() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>

                // // unimplemented: // <implementationAttribute name="validating" value="true"/>

                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#ac_elem; // type: Element // <var name="acElem" type="Element"/>
                // let mut r#title_attr; // type: Attr // <var name="titleAttr" type="Attr"/>
                // let mut r#attr_type_info; // type: TypeInfo // <var name="attrTypeInfo" type="TypeInfo"/>
                // let mut r#type_namespace; // type: DOMString // <var name="typeNamespace" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#ac_elem = r#elem_list.item(0).unwrap(); // <item var="acElem" obj="elemList" index="0" interface="NodeList"/>
                // r#title_attr = r#ac_elem.get_attribute_node("title").unwrap(); // <getAttributeNode var="titleAttr" obj="acElem" name="&quot;title&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="attrTypeInfo" obj="titleAttr" interface="Attr"/>

                // // unimplemented: // <typeNamespace var="typeNamespace" obj="attrTypeInfo"/>
                // assert_eq!(r#type_namespace, "http://www.w3.org/2001/XMLSchema");
                // // <assertEquals expected="&quot;http://www.w3.org/2001/XMLSchema&quot;" actual="typeNamespace" id="typeinfogettypename01_1" ignoreCase="false"/>
            }
            // nodelookupnamespaceuri04.xml
            #[test]
            fn test_nodelookupnamespaceuri04() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#notations_map; // type: NamedNodeMap // <var name="notationsMap" type="NamedNodeMap"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>

                // // unimplemented: // <notations var="notationsMap" obj="docType"/>
                // r#entity = r#entities_map.get_named_item("alpha".into()).unwrap(); // <getNamedItem var="entity" obj="entitiesMap" name="&quot;alpha&quot;"/>
                // r#notation = r#notations_map.get_named_item("notation1".into()).unwrap(); // <getNamedItem var="notation" obj="notationsMap" name="&quot;notation1&quot;"/>
                // r#namespace_uri = r#entity.lookup_namespace_uri("").unwrap().to_string();
                // // <lookupNamespaceURI var="namespaceURI" obj="entity" prefix="&quot;&quot;" interface="Node"/>

                // // unimplemented: // <assertNull actual="namespaceURI" id="nodelookupnamespaceuri04"/>
            }
            // nodereplacechild14.xml
            #[test]
            fn test_nodereplacechild14() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem2; // type: Element // <var name="elem2" type="Element"/>
                // let mut r#imported; // type: Node // <var name="imported" type="Node"/>
                // let mut r#replaced; // type: Element // <var name="replaced" type="Element"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/DOM/Test"),
                //         "dom3:doc1elem".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;dom3:doc1elem&quot;"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" qualifiedName="&quot;dom3:doc&quot;" namespaceURI="&quot;http://www.w3.org/DOM/test&quot;" doctype="nullDocType"/>
                // r#elem2 = r#new_doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/DOM/Test"),
                //         "dom3:doc2elem".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="elem2" obj="newDoc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;dom3:doc2elem&quot;"/>
                // r#imported = r#new_doc.import_node(r#elem.into(), true).unwrap(); // <importNode var="imported" obj="newDoc" importedNode="elem" deep="true"/>
                // r#doc_elem = r#new_doc.document_element().unwrap(); // <documentElement var="docElem" obj="newDoc" interface="Document"/>
                // r#appended_child = r#doc_elem.append_child(imported.into()).unwrap(); // <appendChild obj="docElem" var="appendedChild" newChild="imported"/>
                // r#appended_child = r#doc_elem.append_child(elem2.into()).unwrap(); // <appendChild obj="docElem" var="appendedChild" newChild="elem2"/>
                // r#replaced = r#doc_elem
                //     .replace_child(imported.into(), elem2.into())
                //     .unwrap(); // <replaceChild var="replaced" obj="docElem" oldChild="elem2" newChild="imported"/>
                // r#node_name = r#replaced.node_name().to_string(); // <nodeName var="nodeName" obj="replaced"/>
                // assert_eq!(r#node_name, "dom3:doc2elem"); // <assertEquals actual="nodeName" expected="&quot;dom3:doc2elem&quot;" id="nodereplacechild14" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom48.xml
            #[test]
            fn test_typeinfoisderivedfrom48() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="acronymElem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;string&quot;" derivationMethod="13"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="derivedFromString"/>
            }
            // domimplementationregistry13.xml
            #[test]
            fn test_domimplementationregistry13() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#has_feature; // type: boolean // <var name="hasFeature" type="boolean"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#dom_impl_list; // type: DOMImplementationList // <var name="domImplList" type="DOMImplementationList"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementationList var="domImplList" obj="domImplRegistry" features="&quot;cOrE&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <length var="length" obj="domImplList" interface="DOMImplementationList"/>
                // r#dom_impl = r#dom_impl_list[length].clone(); // <item var="domImpl" obj="domImplList" index="length" interface="DOMImplementationList"/>

                // // unimplemented: // <assertNull actual="domImpl" id="item_Length_shouldBeNull"/>

                // // unimplemented: // <assertTrue id="atLeastOne">	<greater actual="length" expected="0"/></assertTrue>

                // // unimplemented: // <for-each collection="domImplList" member="domImpl">	<hasFeature var="hasFeature" obj="domImpl" feature="&quot;Core&quot;" version="nullVersion"/>	<assertTrue actual="hasFeature" id="hasCore"/></for-each>
            }
            // nodereplacechild10.xml
            #[test]
            fn test_nodereplacechild10() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#ent; // type: Entity // <var name="ent" type="Entity"/>
                // let mut r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                // let mut r#doc_type1; // type: DocumentType // <var name="docType1" type="DocumentType"/>
                // let mut r#notations_map; // type: NamedNodeMap // <var name="notationsMap" type="NamedNodeMap"/>
                // let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                // let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#ent = r#entities_map.get_named_item("alpha".into()).unwrap(); // <getNamedItem var="ent" obj="entitiesMap" name="&quot;alpha&quot;"/>
                // r#doc1 = todo!(); // hc_staff.xml // <load var="doc1" href="hc_staff" willBeModified="false"/>
                // r#doc_type1 = r#doc1.doctype().unwrap(); // <doctype var="docType1" obj="doc1"/>

                // // unimplemented: // <notations var="notationsMap" obj="docType1"/>
                // r#notation = r#notations_map.get_named_item("notation1".into()).unwrap();
                // // <getNamedItem var="notation" obj="notationsMap" name="&quot;notation1&quot;"/>

                // // unimplemented: // <try>        <replaceChild obj="doc" var="replaced" oldChild="ent" newChild="notation"/>        <catch>                <DOMException code="NOT_FOUND_ERR"/>                <DOMException code="WRONG_DOCUMENT_ERR"/>		<DOMException code="HIERARCHY_REQUEST_ERR"/>        </catch></try>
            }
            // nodeinsertbefore06.xml
            #[test]
            fn test_nodeinsertbefore06() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#new_elem; // type: Element // <var name="newElem" type="Element"/>
                // let mut r#inserted; // type: Node // <var name="inserted" type="Node"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_tagname; // type: DOMString // <var name="rootTagname" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_tagname = r#doc_elem.tag_name().to_string(); // <tagName var="rootTagname" obj="docElem"/>
                // r#new_elem = r#doc
                //     .create_element_ns(Some(r#root_ns.as_ref()), r#root_tagname.as_ref())
                //     .unwrap(); // <createElementNS var="newElem" obj="doc" qualifiedName="rootTagname" namespaceURI="rootNS"/>

                // // unimplemented: // <try>	<insertBefore obj="doc" var="inserted" newChild="newElem" refChild="docElem"/>    <fail id="throw_DOMException"/>	<catch>		<DOMException code="HIERARCHY_REQUEST_ERR"/>		<DOMException code="NOT_SUPPORTED_ERR"/>	</catch></try>
            }
            // typeinfoisderivedfrom68.xml
            #[test]
            fn test_typeinfoisderivedfrom68() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>

                // // unimplemented: // <implementationAttribute name="validating" value="true"/>

                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_type_info; // type: TypeInfo // <var name="elemTypeInfo" type="TypeInfo"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#ret_value; // type: boolean // <var name="retValue" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("sup"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;sup&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="elemTypeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <isDerivedFrom obj="elemTypeInfo" var="retValue" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;emp0004_5Type&quot;" derivationMethod="0"/>
                // assert!(r#ret_value); // <assertTrue actual="retValue" id="isDerived"/>
            }
            // nodereplacechild22.xml
            #[test]
            fn test_nodereplacechild22() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#ent_ref_main; // type: EntityReference // <var name="entRefMain" type="EntityReference"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#replaced_child; // type: Node // <var name="replacedChild" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#elem = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "dom3:p".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:p&quot;"/>
                // r#ent_ref_main = r#doc.create_entity_reference("delta".to_string()).unwrap(); // <createEntityReference var="entRefMain" obj="doc" name="&quot;delta&quot;"/>
                // r#ent_ref = r#doc.create_entity_reference("beta".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;beta&quot;"/>
                // r#appended_child = r#elem.append_child(ent_ref.into()).unwrap();
                // // <appendChild obj="elem" var="appendedChild" newChild="entRef"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR_1"><NO_MODIFICATION_ALLOWED_ERR><replaceChild obj="entRefMain" var="replacedChild" oldChild="entRef" newChild="elem"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR_2"><NO_MODIFICATION_ALLOWED_ERR><replaceChild obj="entRefMain" var="replacedChild" oldChild="elem" newChild="entRef"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR_3"><NO_MODIFICATION_ALLOWED_ERR><replaceChild obj="entRefMain" var="replacedChild" oldChild="entRef" newChild="entRefMain"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // nodeissamenode07.xml
            #[test]
            fn test_nodeissamenode07() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#entity1; // type: Entity // <var name="entity1" type="Entity"/>
                // let mut r#entity2; // type: Entity // <var name="entity2" type="Entity"/>
                // let mut r#is_same; // type: boolean // <var name="isSame" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#entity1 = r#entities_map.get_named_item("delta".into()).unwrap(); // <getNamedItem var="entity1" obj="entitiesMap" name="&quot;delta&quot;"/>
                // r#entity2 = r#entities_map.get_named_item("delta".into()).unwrap(); // <getNamedItem var="entity2" obj="entitiesMap" name="&quot;delta&quot;"/>
                // entity1.is_same_node(&entity2.into()); // <isSameNode var="isSame" obj="entity1" other="entity2"/>
                // assert!(r#is_same); // <assertTrue actual="isSame" id="nodeissamenode07"/>
            }
            // nodeappendchild01.xml
            #[test]
            fn test_nodeappendchild01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#null_pub_id; // type: DOMString // <var name="nullPubId" type="DOMString" isNull="true"/>
                // let mut r#null_sys_id; // type: DOMString // <var name="nullSysId" type="DOMString" isNull="true"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#tag_name; // type: DOMString // <var name="tagName" type="DOMString"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#tag_name = r#doc_elem.tag_name().to_string(); // <tagName var="tagName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocumentType var="docType" obj="domImpl" qualifiedName="tagName" publicId="nullPubId" systemId="nullSysId"/>

                // // unimplemented: // <try>	<appendChild obj="doc" var="appendedChild" newChild="docType"/>	<fail id="throw_HIERARCHY_REQUEST_OR_NOT_SUPPORTED"/>	<catch>		<DOMException code="HIERARCHY_REQUEST_ERR"/>		<DOMException code="NOT_SUPPORTED_ERR"/>	</catch></try>
            }
            // documentrenamenode29.xml
            #[test]
            fn test_documentrenamenode29() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#renamed; // type: Node // <var name="renamed" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>

                // // unimplemented: // <assertDOMException id="documentrenamenode29_ENTITY_NOT_SUPPORTED_ERR"><INVALID_CHARACTER_ERR><renameNode var="renamed" obj="doc" n="docElem" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;@&quot;"/></INVALID_CHARACTER_ERR></assertDOMException>
            }
            // documentadoptnode21.xml
            #[test]
            fn test_documentadoptnode21() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#attr_owner_elem; // type: Element // <var name="attrOwnerElem" type="Element"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#adopted_title; // type: Node // <var name="adoptedTitle" type="Node"/>
                // let mut r#attrs_parent; // type: Node // <var name="attrsParent" type="Node"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#child_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#element = r#child_list.item(0).unwrap().clone(); // <item var="element" obj="childList" index="0" interface="NodeList"/>
                // r#attr = r#element.get_attribute_node("title").unwrap(); // <getAttributeNode var="attr" obj="element" name="&quot;title&quot;"/>
                // r#adopted_title = r#doc
                //     .adopt_node(r#attr.into())
                //     .unwrap()
                //     .as_attribute()
                //     .unwrap(); // <adoptNode var="adoptedTitle" obj="doc" source="attr"/>
                // r#node_name = r#adopted_title.node_name().to_string(); // <nodeName var="nodeName" obj="adoptedTitle"/>
                // r#node_value = r#adopted_title.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="adoptedTitle"/>
                // r#node_type = r#adopted_title.node_type(); // <nodeType var="nodeType" obj="adoptedTitle"/>
                // r#attr_owner_elem = r#adopted_title.owner_element().unwrap(); // <ownerElement var="attrOwnerElem" obj="adoptedTitle" interface="Attr"/>
                // assert_eq!(r#node_name, "title"); // <assertEquals expected="&quot;title&quot;" actual="nodeName" id="documentadoptnode21_nodeName" ignoreCase="false"/>
                // assert_eq!(r#node_type as i32, 2); // <assertEquals expected="2" actual="nodeType" id="documentadoptnode21_nodeType" ignoreCase="false"/>
                // assert_eq!(r#node_value, "Yes"); // <assertEquals expected="&quot;Yes&quot;" actual="nodeValue" id="documentadoptnode21_nodeValue" ignoreCase="false"/>

                // // unimplemented: // <assertNull actual="attrOwnerElem" id="documentadoptnode21_ownerDoc"/>
            }
            // nodeisequalnode29.xml
            #[test]
            fn test_nodeisequalnode29() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#comment1; // type: Comment // <var name="comment1" type="Comment"/>
                let mut r#comment2; // type: Comment // <var name="comment2" type="Comment"/>
                let mut r#comment3; // type: Comment // <var name="comment3" type="Comment"/>
                let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#comment1 = r#doc.create_comment("comment"); // <createComment var="comment1" obj="doc" data="&quot;comment&quot;"/>
                r#comment2 = r#doc.create_comment("comment"); // <createComment var="comment2" obj="doc" data="&quot;comment&quot;"/>
                r#comment3 = r#doc.create_comment("#Comment"); // <createComment var="comment3" obj="doc" data="&quot;#Comment&quot;"/>
                r#is_equal = r#comment1.is_equal_node(&r#comment2.into()); // <isEqualNode var="isEqual" obj="comment1" arg="comment2"/>
                assert!(r#is_equal); // <assertTrue actual="isEqual" id="nodeisequalnodeTrue29"/>
                r#is_equal = r#comment1.is_equal_node(&r#comment3.into()); // <isEqualNode var="isEqual" obj="comment1" arg="comment3"/>
                assert!(!r#is_equal); // <assertFalse actual="isEqual" id="nodeisequalnodeFalse29"/>
            }
            // domstringlistitem01.xml
            #[test]
            fn test_domstringlistitem01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#param_list; // type: DOMStringList // <var name="paramList" type="DOMStringList"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#contains; // type: boolean // <var name="contains" type="boolean"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>
                // let mut r#index; // type: int // <var name="index" type="int"/>
                // let mut r#parameter; // type: DOMString // <var name="parameter" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <parameterNames obj="domConfig" var="paramList"/>

                // // unimplemented: // <length var="length" obj="paramList" interface="DOMStringList"/>
                // r#parameter = r#param_list[0].clone(); // <item var="parameter" obj="paramList" index="0" interface="DOMStringList"/>

                // // unimplemented: // <assertNotNull actual="parameter" id="item0NotNull"/>
                // r#parameter = r#param_list[length].clone(); // <item var="parameter" obj="paramList" index="length" interface="DOMStringList"/>

                // // unimplemented: // <assertNull actual="parameter" id="itemLengthNull"/>
                // r#length -= 1; // <decrement var="length" value="1"/>
                // r#parameter = r#param_list[length].clone(); // <item var="parameter" obj="paramList" index="length" interface="DOMStringList"/>

                // // unimplemented: // <assertNotNull actual="parameter" id="itemLengthMinus1NotNull"/>
            }
            // nodereplacechild16.xml
            #[test]
            fn test_nodereplacechild16() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                let mut r#replaced; // type: Element // <var name="replaced" type="Element"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "dom3:p".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:p&quot;"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#txt = r#doc.create_text_node("Comment"); // <createTextNode var="txt" obj="doc" data="&quot;Comment&quot;"/>
                r#appended_child = r#doc_frag.append_child(txt.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="txt"/>
                r#appended_child = r#doc_frag.append_child(elem.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="elem"/>
                r#replaced = r#doc_frag.replace_child(txt.into(), elem.into()).unwrap(); // <replaceChild var="replaced" obj="docFrag" oldChild="elem" newChild="txt"/>
                r#node_name = r#replaced.node_name().to_string(); // <nodeName var="nodeName" obj="replaced"/>
                assert_eq!(r#node_name, "dom3:p"); // <assertEquals actual="nodeName" expected="&quot;dom3:p&quot;" id="nodereplacechild16" ignoreCase="false"/>
            }
            // nodeisdefaultnamespace10.xml
            #[test]
            fn test_nodeisdefaultnamespace10() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#parent; // type: Element // <var name="parent" type="Element"/>
                let mut r#child; // type: Element // <var name="child" type="Element"/>
                let mut r#is_default; // type: boolean // <var name="isDefault" type="boolean"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#parent = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "xhtml:body".as_ref())
                    .unwrap(); // <createElementNS var="parent" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:body&quot;"/>
                r#child = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "p".as_ref())
                    .unwrap(); // <createElementNS var="child" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;p&quot;"/>
                r#appended_child = r#parent.append_child(child.into()).unwrap(); // <appendChild obj="parent" var="appendedChild" newChild="child"/>
                r#is_default = r#child.is_default_namespace("http://www.w3.org/1999/xhtml"); // <isDefaultNamespace var="isDefault" obj="child" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>
                assert!(r#is_default); // <assertTrue actual="isDefault" id="nodeisdefaultnamespace10_1"/>
                r#is_default = r#parent.is_default_namespace("http://www.w3.org/1999/xhtml"); // <isDefaultNamespace var="isDefault" obj="parent" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>
                assert!(!r#is_default); // <assertFalse actual="isDefault" id="nodeisdefaultnamespace10_2"/>
            }
            // textwholetext03.xml
            #[test]
            fn test_textwholetext03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#text1; // type: Text // <var name="text1" type="Text"/>
                let mut r#text2; // type: Text // <var name="text2" type="Text"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#combined_text; // type: DOMString // <var name="combinedText" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "p".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;p&quot;"/>
                r#text1 = r#doc.create_text_node("Text I"); // <createTextNode var="text1" obj="doc" data="&quot;Text I&quot;"/>
                r#text2 = r#doc.create_text_node(" Text II"); // <createTextNode var="text2" obj="doc" data="&quot; Text II&quot;"/>
                r#appended_child = r#elem.append_child(text1.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="text1"/>
                r#appended_child = r#elem.append_child(text2.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="text2"/>
                r#combined_text = r#text1.whole_text().to_string(); // <wholeText obj="text1" var="combinedText"/>
                assert_eq!(r#combined_text, "Text I Text II"); // <assertEquals expected="&quot;Text I Text II&quot;" actual="combinedText" id="textwholetext03" ignoreCase="false"/>
            }
            // nodeinsertbefore08.xml
            #[test]
            fn test_nodeinsertbefore08() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_alt: DocumentRef; // <var name="docAlt" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#new_comment; // type: Comment // <var name="newComment" type="Comment"/>
                // let mut r#inserted; // type: Node // <var name="inserted" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_alt = todo!(); // hc_staff.xml // <load var="docAlt" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc_alt.document_element().unwrap(); // <documentElement var="docElem" obj="docAlt"/>
                // r#new_comment = r#doc.create_comment("Comment"); // <createComment var="newComment" obj="doc" data="&quot;Comment&quot;"/>

                // // unimplemented: // <assertDOMException id="NOT_FOUND_ERR_nodeinsertbefore08"><NOT_FOUND_ERR><insertBefore obj="doc" var="inserted" newChild="newComment" refChild="docElem"/></NOT_FOUND_ERR></assertDOMException>
            }
            // normalizecharacters03.xml
            #[test]
            fn test_normalizecharacters03() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // let mut r#text_value; // type: DOMString // <var name="textValue" type="DOMString"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;normalize-characters&quot;" value="false"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" index="0" interface="NodeList"/>
                // r#text = r#doc.create_text_node("sucon"); // <createTextNode var="text" obj="doc" data="&quot;sucon&quot;"/>
                // r#retval = r#p_elem.append_child(text.into()).unwrap(); // <appendChild var="retval" obj="pElem" newChild="text"/>
                // r#p_elem.normalize(); // <normalize obj="pElem"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" index="0" interface="NodeList"/>
                // r#text = r#p_elem.first_child().unwrap().as_text_node().unwrap(); // <firstChild var="text" obj="pElem" interface="Node"/>
                // r#text_value = r#text.node_value().unwrap().to_string(); // <nodeValue var="textValue" obj="text"/>
                // assert_eq!(r#text_value, "barsucon"); // <assertEquals actual="textValue" expected="&quot;barsucon&quot;" ignoreCase="false" id="noCharNormalization"/>
            }
            // domconfigsplitcdatasections1.xml
            #[test]
            fn test_domconfigsplitcdatasections1() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // let mut r#parameter; // type: DOMString // <var name="parameter" type="DOMString" value="&quot;sPlIt-cdata-sections&quot;"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDocType"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(r#state); // <assertTrue actual="state" id="defaultFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="false"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="true"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetTrue"/>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="false"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(!r#state); // <assertFalse actual="state" id="setFalseEffective"/>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="true"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(r#state); // <assertTrue actual="state" id="setTrueEffective"/>
            }
            // normalizecharacters02.xml
            #[test]
            fn test_normalizecharacters02() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // let mut r#text_value; // type: DOMString // <var name="textValue" type="DOMString"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;normalize-characters&quot;" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;normalize-characters&quot;" value="true"/><setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/><getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/><item var="pElem" obj="pList" index="0" interface="NodeList"/><!--  character entity is expanded during code generation        code equivalent to "suc\u0327on"    --><createTextNode var="text" obj="doc" data="&quot;sucon&quot;"/><appendChild var="retval" obj="pElem" newChild="text"/><normalizeDocument obj="doc"/><!--  fail test if normalize had any errors or fatal errors   --><assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/><getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/><item var="pElem" obj="pList" index="0" interface="NodeList"/><firstChild var="text" obj="pElem" interface="Node"/><nodeValue var="textValue" obj="text"/><assertEquals actual="textValue" expected="&quot;barsuon&quot;" ignoreCase="false" id="charNormalized"/> </if>
            }
            // documentadoptnode10.xml
            #[test]
            fn test_documentadoptnode10() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#adopted_doc_type; // type: Node // <var name="adoptedDocType" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><adoptNode var="adoptedDocType" obj="doc" source="docType"/></NOT_SUPPORTED_ERR></assertDOMException>
            }
            // domimplementationregistry23.xml
            #[test]
            fn test_domimplementationregistry23() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#has_core; // type: boolean // <var name="hasCore" type="boolean"/>
                // let mut r#has_xml; // type: boolean // <var name="hasXML" type="boolean"/>
                // let mut r#has_events; // type: boolean // <var name="hasEvents" type="boolean"/>
                // let mut r#has_ls; // type: boolean // <var name="hasLS" type="boolean"/>
                // let mut r#base_impl; // type: DOMImplementation // <var name="baseImpl" type="DOMImplementation"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // let mut r#dom_impl_list; // type: DOMImplementationList // <var name="domImplList" type="DOMImplementationList"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementationList var="domImplList" obj="domImplRegistry" features="&quot;cOrE 3.0 xMl 3.0 eVeNts 2.0 lS&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <length var="length" obj="domImplList" interface="DOMImplementationList"/>

                // // unimplemented: // <if>	<equals actual="length" expected="0" ignoreCase="false"/>	<implementation var="baseImpl"/>	<hasFeature var="hasCore" obj="baseImpl" feature="&quot;Core&quot;" version="&quot;3.0&quot;"/>	<hasFeature var="hasXML" obj="baseImpl" feature="&quot;XML&quot;" version="&quot;3.0&quot;"/>	<hasFeature var="hasEvents" obj="baseImpl" feature="&quot;Events&quot;" version="&quot;2.0&quot;"/>	<hasFeature var="hasLS" obj="baseImpl" feature="&quot;LS&quot;" version="nullVersion"/>	<assertFalse id="baseImplFeatures">		<and>			<isTrue value="hasCore"/>			<isTrue value="hasXML"/>			<isTrue value="hasEvents"/>			<isTrue value="hasLS"/>		</and>	</assertFalse>	<else>		<for-each collection="domImplList" member="domImpl">			<hasFeature var="hasCore" obj="domImpl" feature="&quot;Core&quot;" version="&quot;3.0&quot;"/>			<assertTrue actual="hasCore" id="hasCore"/>			<hasFeature var="hasXML" obj="domImpl" feature="&quot;XML&quot;" version="&quot;3.0&quot;"/>			<assertTrue actual="hasXML" id="hasXML"/>			<hasFeature var="hasEvents" obj="domImpl" feature="&quot;Events&quot;" version="&quot;2.0&quot;"/>			<assertTrue actual="hasEvents" id="hasEvents"/>			<hasFeature var="hasLS" obj="domImpl" feature="&quot;LS&quot;" version="nullVersion"/>			<assertTrue actual="hasLS" id="hasLS"/>		</for-each>	</else></if>
            }
            // elementsetidattribute07.xml
            #[test]
            fn test_elementsetidattribute07() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#name_elem1; // type: Element // <var name="nameElem1" type="Element"/>
                let mut r#name_elem2; // type: Element // <var name="nameElem2" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#name_elem1 = r#elem_list.item(2).unwrap(); // <item var="nameElem1" obj="elemList" index="2" interface="NodeList"/>
                r#name_elem2 = r#elem_list.item(3).unwrap(); // <item var="nameElem2" obj="elemList" index="3" interface="NodeList"/>
                r#name_elem1
                    .set_attribute("hasMiddleName", "Antoine")
                    .unwrap(); // <setAttribute obj="nameElem1" name="&quot;hasMiddleName&quot;" value="&quot;Antoine&quot;"/>
                r#name_elem1
                    .set_id_attribute("hasMiddleName", true)
                    .unwrap(); // <setIdAttribute obj="nameElem1" name="&quot;hasMiddleName&quot;" isId="true"/>
                r#name_elem2
                    .set_attribute("hasMiddleName", "Neeya")
                    .unwrap(); // <setAttribute obj="nameElem2" name="&quot;hasMiddleName&quot;" value="&quot;Neeya&quot;"/>
                r#name_elem2
                    .set_id_attribute("hasMiddleName", true)
                    .unwrap(); // <setIdAttribute obj="nameElem2" name="&quot;hasMiddleName&quot;" isId="true"/>
                r#attributes_map = r#name_elem1.attributes(); // <attributes var="attributesMap" obj="nameElem1"/>
                r#attr = r#attributes_map.get_named_item("hasMiddleName").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;hasMiddleName&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributeIsId1True07"/>
                r#attributes_map = r#name_elem2.attributes(); // <attributes var="attributesMap" obj="nameElem2"/>
                r#attr = r#attributes_map.get_named_item("hasMiddleName").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;hasMiddleName&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributeIsId2True07"/>
                r#elem = r#doc.get_element_by_id("Antoine".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;Antoine&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "strong"); // <assertEquals actual="elemName" expected="&quot;strong&quot;" id="elementsetidattribute1GetElementById07" ignoreCase="false"/>
                r#elem = r#doc.get_element_by_id("Neeya".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;Neeya&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "strong"); // <assertEquals actual="elemName" expected="&quot;strong&quot;" id="elementsetidattribute2GetElementById07" ignoreCase="false"/>
            }
            // splitcdatasections01.xml
            #[test]
            fn test_splitcdatasections01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#new_child; // type: CDATASection // <var name="newChild" type="CDATASection"/>
                // let mut r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#errors; // type: List // <var name="errors" type="List"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>
                // r#old_child = r#elem.first_child().unwrap(); // <firstChild var="oldChild" obj="elem" interface="Node"/>
                // r#new_child = r#doc.create_cdata_section("this is not ]]> good").unwrap(); // <createCDATASection var="newChild" obj="doc" data="&quot;this is not ]]&gt; good&quot;"/>
                // r#retval = r#elem
                //     .replace_child(new_child.into(), old_child)
                //     .unwrap(); // <replaceChild var="retval" obj="elem" newChild="newChild" oldChild="oldChild"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;split-cdata-sections&quot;" value="false"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#doc.normalize(); // <normalize obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" severity="SEVERITY_ERROR" id="noErrors"/>
            }
            // documentgetxmlencoding03.xml
            #[test]
            fn test_documentgetxmlencoding03() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#encoding_name; // type: DOMString // <var name="encodingName" type="DOMString"/>
                // r#doc = todo!(); // barfoo_utf16.xml // <load var="doc" href="barfoo_utf16" willBeModified="false"/>
                // r#encoding_name = r#doc.xml_encoding().unwrap().to_string(); // <xmlEncoding obj="doc" var="encodingName" interface="Document"/>
                // assert_eq!(r#encoding_name, "uTf-16"); // <assertEquals expected="&quot;uTf-16&quot;" actual="encodingName" id="documentgetxmlencoding03" ignoreCase="false"/>
            }
            // nodesettextcontent08.xml
            #[test]
            fn test_nodesettextcontent08() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "xhtml:p".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:p&quot;"/>
                r#pi = r#doc
                    .create_processing_instruction("PIT", Some("PID"))
                    .unwrap(); // <createProcessingInstruction var="pi" obj="doc" target="&quot;PIT&quot;" data="&quot;PID&quot;"/>
                r#appended_child = r#elem.append_child(pi.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="pi"/>
                r#pi.set_text_content("PID").unwrap(); // <textContent obj="pi" value="&quot;PID&quot;"/>
                r#text_content = r#pi.text_content().unwrap(); // <textContent var="textContent" obj="pi"/>
                assert_eq!(r#text_content, "PID"); // <assertEquals actual="textContent" expected="&quot;PID&quot;" id="nodesettextcontent08" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom28.xml
            #[test]
            fn test_typeinfoisderivedfrom28() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "strongType"); // <assertEquals actual="typeName" expected="&quot;strongType&quot;" ignoreCase="false" id="typeName"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;strongType&quot;" derivationMethod="1"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="notDerivedFromSelfRestriction"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;strongType&quot;" derivationMethod="14"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="notDerivedFromSelfOther"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;strongType&quot;" derivationMethod="15"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="notDerivedFromSelfAll"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;strongType&quot;" derivationMethod="0"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="notDerivedFromSelfAny"/>
            }
            // domconfigentities1.xml
            #[test]
            fn test_domconfigentities1() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // let mut r#parameter; // type: DOMString // <var name="parameter" type="DOMString" value="&quot;eNtIties&quot;"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDocType"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(r#state); // <assertTrue actual="state" id="defaultFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="false"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="true"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetTrue"/>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="false"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(!r#state); // <assertFalse actual="state" id="setFalseEffective"/>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="true"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(r#state); // <assertTrue actual="state" id="setTrueEffective"/>
            }
            // datatypenormalization13.xml
            #[test]
            fn test_datatypenormalization13() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#str; // type: DOMString // <var name="str" type="DOMString"/>
                // let mut r#can_set_normalization; // type: boolean // <var name="canSetNormalization" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#can_set_xml_schema; // type: boolean // <var name="canSetXMLSchema" type="boolean"/>
                // let mut r#xsd_ns; // type: DOMString // <var name="xsdNS" type="DOMString" value="&quot;http://www.w3.org/2001/XMLSchema&quot;"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#child_node; // type: Node // <var name="childNode" type="Node"/>
                // let mut r#child_value; // type: DOMString // <var name="childValue" type="DOMString"/>
                // r#doc = todo!(); // datatype_normalization2.xml // <load var="doc" href="datatype_normalization2" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetNormalization" obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetValidate" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetXMLSchema" obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>

                // // unimplemented: // <if>	<and>		<isTrue value="canSetNormalization"/>		<isTrue value="canSetValidate"/>		<isTrue value="canSetXMLSchema"/>	</and>	<setParameter obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>	<normalizeDocument obj="doc"/>	<!--  fail test if normalize had any errors or fatal errors   -->	<assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>	<getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" localName="&quot;em&quot;" interface="Document"/>	<item var="element" obj="elemList" interface="NodeList" index="0"/>	<firstChild var="childNode" obj="element" interface="Node"/>	<assertNotNull actual="childNode" id="childNodeNotNull"/>	<nodeValue var="childValue" obj="childNode"/>	<assertEquals actual="childValue" expected="&quot;    EMP  0001   &quot;" ignoreCase="false" id="content"/></if>
            }
            // nodegettextcontent03.xml
            #[test]
            fn test_nodegettextcontent03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                r#text_content = r#doc_type.text_content().unwrap(); // <textContent var="textContent" obj="docType"/>

                // unimplemented: // <assertNull actual="textContent" id="nodegettextcontent03"/>
            }
            // nodegetbaseuri15.xml
            #[test]
            fn test_nodegetbaseuri15() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#base_uri; // type: DOMString // <var name="baseURI" type="DOMString"/>
                let mut r#attr_node; // type: Attr // <var name="attrNode" type="Attr"/>
                let mut r#body_list; // type: NodeList // <var name="bodyList" type="NodeList"/>
                let mut r#body_elem; // type: Element // <var name="bodyElem" type="Element"/>
                r#doc = todo!(); // barfoo_base.xml // <load var="doc" href="barfoo_base" willBeModified="true"/>
                r#body_list = r#doc.get_elements_by_tag_name("body"); // <getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/>
                r#body_elem = r#body_list.item(0).unwrap(); // <item var="bodyElem" obj="bodyList" index="0" interface="NodeList"/>
                r#attr_node = r#body_elem.get_attribute_node("id").unwrap(); // <getAttributeNode var="attrNode" obj="bodyElem" name="&quot;id&quot;"/>
                r#base_uri = r#attr_node.base_uri().unwrap().to_string(); // <baseURI var="baseURI" obj="attrNode" interface="Node"/>

                // unimplemented: // <assertNull actual="baseURI" id="baseURI"/>
            }
            // nodelookupprefix12.xml
            #[test]
            fn test_nodelookupprefix12() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#renamed_node; // type: Element // <var name="renamedNode" type="Element"/>
                // let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#elem = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "dom3:p".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:p&quot;"/>
                // r#renamed_node = r#doc
                //     .rename_node(
                //         r#elem.into(),
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "ren:br",
                //     )
                //     .unwrap(); // <renameNode var="renamedNode" obj="doc" n="elem" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;ren:br&quot;"/>
                // r#prefix = r#renamed_node
                //     .lookup_prefix("http://www.w3.org/1999/xhtml")
                //     .unwrap()
                //     .to_string(); // <lookupPrefix var="prefix" obj="renamedNode" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>
                // assert_eq!(r#prefix, "ren"); // <assertEquals actual="prefix" expected="&quot;ren&quot;" id="nodelookupprefix12" ignoreCase="false"/>
            }
            // elementsetidattributens13.xml
            #[test]
            fn test_elementsetidattributens13() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#name_elem; // type: Element // <var name="nameElem" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#name_elem = r#elem_list.item(2).unwrap(); // <item var="nameElem" obj="elemList" index="2" interface="NodeList"/>
                r#name_elem
                    .set_attribute_ns(
                        Some("http://www.w3.org/2000/xmlns/"),
                        "xmlns:newAttr",
                        "newValue",
                    )
                    .unwrap(); // <setAttributeNS obj="nameElem" qualifiedName="&quot;xmlns:newAttr&quot;" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" value="&quot;newValue&quot;"/>
                r#name_elem
                    .set_id_attribute_ns(Some("http://www.w3.org/2000/xmlns/"), "newAttr", true)
                    .unwrap(); // <setIdAttributeNS obj="nameElem" localName="&quot;newAttr&quot;" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" isId="true"/>
                r#attributes_map = r#name_elem.attributes(); // <attributes var="attributesMap" obj="nameElem"/>
                r#attr = r#attributes_map.get_named_item("xmlns:newAttr").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;xmlns:newAttr&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributensIsIdTrue13"/>
                r#elem = r#doc.get_element_by_id("newValue".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;newValue&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "strong"); // <assertEquals actual="elemName" expected="&quot;strong&quot;" id="elementsetidattributensGetElementById13" ignoreCase="false"/>

                // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR">  	<NOT_FOUND_ERR>  		<setIdAttributeNS obj="nameElem" localName="&quot;lang&quot;" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" isId="false"/>  	</NOT_FOUND_ERR>  </assertDOMException>
            }
            // datatypenormalization11.xml
            #[test]
            fn test_datatypenormalization11() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#str; // type: DOMString // <var name="str" type="DOMString"/>
                // let mut r#can_set_normalization; // type: boolean // <var name="canSetNormalization" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#can_set_xml_schema; // type: boolean // <var name="canSetXMLSchema" type="boolean"/>
                // let mut r#xsd_ns; // type: DOMString // <var name="xsdNS" type="DOMString" value="&quot;http://www.w3.org/2001/XMLSchema&quot;"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // r#doc = todo!(); // datatype_normalization.xml // <load var="doc" href="datatype_normalization" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetNormalization" obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetValidate" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetXMLSchema" obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>

                // // unimplemented: // <if>	<and>		<isTrue value="canSetNormalization"/>		<isTrue value="canSetValidate"/>		<isTrue value="canSetXMLSchema"/>	</and>	<setParameter obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>	<normalizeDocument obj="doc"/>	<!--  fail test if normalize had any errors or fatal errors   -->	<assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>	<getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;http://www.w3.org/2001/DOM-Test-Suite/Level-3/datatype_normalization&quot;" localName="&quot;dateTime&quot;" interface="Document"/>	<item var="element" obj="elemList" interface="NodeList" index="0"/>	<getAttribute var="str" obj="element" name="&quot;default&quot;"/>	<!-- .0 would not be correct, see http://www.w3.org/2001/05/xmlschema-errata#E2-63    -->	<assertEquals actual="str" expected="&quot;2004-01-21T20:30:00Z&quot;" ignoreCase="false" id="firstValue"/></if>
            }
            // elementcontentwhitespace01.xml
            #[test]
            fn test_elementcontentwhitespace01() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#body_list; // type: NodeList // <var name="bodyList" type="NodeList"/>
                // let mut r#body; // type: Node // <var name="body" type="Node"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                // let mut r#child_type; // type: int // <var name="childType" type="int"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;element-content-whitespace&quot;" value="true"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#body_list = r#doc.get_elements_by_tag_name("body"); // <getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/>
                // r#body = r#body_list.item(0).unwrap(); // <item var="body" obj="bodyList" interface="NodeList" index="0"/>
                // r#child = r#body.first_child().unwrap(); // <firstChild var="child" obj="body" interface="Node"/>
                // r#child_type = r#child.node_type(); // <nodeType var="childType" obj="child"/>

                // // unimplemented: // <if><equals actual="childType" expected="1" ignoreCase="false"/>	<createTextNode var="text" obj="doc" data="&quot;    &quot;"/>	<insertBefore var="child" obj="body" newChild="text" refChild="child"/></if>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>
                // r#body_list = r#doc.get_elements_by_tag_name("body"); // <getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/>
                // r#body = r#body_list.item(0).unwrap(); // <item var="body" obj="bodyList" interface="NodeList" index="0"/>
                // r#child = r#body.first_child().unwrap(); // <firstChild var="child" obj="body" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="child" id="firstChildNotNull"/>
                // r#child_name = r#child.node_name().to_string(); // <nodeName var="childName" obj="child"/>
                // assert_eq!(r#child_name, "#text"); // <assertEquals actual="childName" expected="&quot;#text&quot;" ignoreCase="false" id="firstChild"/>
                // r#child = r#child.next_sibling().unwrap(); // <nextSibling var="child" obj="child" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="child" id="secondChildNotNull"/>
                // r#child_name = r#child.node_name().to_string(); // <nodeName var="childName" obj="child"/>
                // assert_eq!(r#child_name, "p"); // <assertEquals actual="childName" expected="&quot;p&quot;" ignoreCase="false" id="secondChild"/>
            }
            // canonicalform03.xml
            #[test]
            fn test_canonicalform03() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // // unimplemented: // <implementationAttribute name="coalescing" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem_name; // type: Element // <var name="elemName" type="Element"/>
                // let mut r#cdata; // type: CDATASection // <var name="cdata" type="CDATASection"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                // r#elem_name = r#elem_list.item(1).unwrap(); // <item var="elemName" obj="elemList" index="1" interface="NodeList"/>
                // r#cdata = r#elem_name.last_child().unwrap(); // <lastChild var="cdata" obj="elemName" interface="Node"/>
                // r#node_name = r#cdata.node_name().to_string(); // <nodeName var="nodeName" obj="cdata"/>
                // assert_eq!(r#node_name, "#cdata-section"); // <assertEquals actual="nodeName" expected="&quot;#cdata-section&quot;" id="documentnormalizedocument02" ignoreCase="false"/>

                // // unimplemented: // <domConfig interface="Document" obj="doc" var="domConfig"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;canonical-form&quot;" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;canonical-form&quot;" value="true"/><normalizeDocument obj="doc"/><assertLowerSeverity obj="errorMonitor" severity="SEVERITY_ERROR" id="normalization2Error"/><getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/><item var="elemName" obj="elemList" index="1" interface="NodeList"/><lastChild var="text" obj="elemName" interface="Node"/><nodeName var="nodeName" obj="text"/><assertEquals actual="nodeName" expected="&quot;#text&quot;" id="documentnormalizedocument02_false" ignoreCase="false"/></if>
            }
            // noderemovechild11.xml
            #[test]
            fn test_noderemovechild11() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                let mut r#removed_txt; // type: Text // <var name="removedTxt" type="Text"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#removed_child; // type: Node // <var name="removedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#txt = r#doc.create_text_node("TEXT"); // <createTextNode var="txt" obj="doc" data="&quot;TEXT&quot;"/>
                r#appended_child = r#doc_frag.append_child(txt.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="txt"/>
                r#removed_child = r#doc_frag.remove_child(txt.into()).unwrap(); // <removeChild obj="docFrag" var="removedChild" oldChild="txt"/>
                r#removed_txt = r#doc_frag.first_child().unwrap(); // <firstChild var="removedTxt" obj="docFrag" interface="Node"/>

                // unimplemented: // <assertNull actual="removedTxt" id="noderemovechild11"/>
            }
            // documentnormalizedocument12.xml
            #[test]
            fn test_documentnormalizedocument12() {
                // // unimplemented: // <implementationAttribute name="validating" value="true"/>

                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>

                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#doc_elem_node_name; // type: DOMString // <var name="docElemNodeName" type="DOMString"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_handler; // type: DOMErrorHandler // <var name="errorHandler" type="DOMErrorHandler"/>
                // let mut r#err_handler; // type: DOMErrorHandler // <var name="errHandler" type="DOMErrorHandler">	<handleError>		<assertFalse actual="true" id="documentnormalizedocument08_Err"/>		<return value="true"/>	</handleError></var>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errHandler"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/><normalizeDocument obj="doc"/><documentElement var="docElem" obj="doc"/><nodeName var="docElemNodeName" obj="docElem"/><assertEquals actual="docElemNodeName" expected="&quot;html&quot;" id="documentnormalizedocument08_True" ignoreCase="false"/></if>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;validate&quot;" value="false"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#doc_elem_node_name = r#doc_elem.node_name().to_string(); // <nodeName var="docElemNodeName" obj="docElem"/>
                // assert_eq!(r#doc_elem_node_name, "html"); // <assertEquals actual="docElemNodeName" expected="&quot;html&quot;" id="documentnormalizedocument08_False" ignoreCase="false"/>
            }
            // elementsetidattributenode07.xml
            #[test]
            fn test_elementsetidattributenode07() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list1; // type: NodeList // <var name="elemList1" type="NodeList"/>
                let mut r#elem_list2; // type: NodeList // <var name="elemList2" type="NodeList"/>
                let mut r#acronym_elem1; // type: Element // <var name="acronymElem1" type="Element"/>
                let mut r#acronym_elem2; // type: Element // <var name="acronymElem2" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list1 = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList1" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#elem_list2 = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList2" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#acronym_elem1 = r#elem_list1.item(1).unwrap(); // <item var="acronymElem1" obj="elemList1" index="1" interface="NodeList"/>
                r#acronym_elem2 = r#elem_list2.item(2).unwrap(); // <item var="acronymElem2" obj="elemList2" index="2" interface="NodeList"/>
                r#attributes_map = r#acronym_elem1.attributes(); // <attributes var="attributesMap" obj="acronymElem1"/>
                r#attr = r#attributes_map.get_named_item("class").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;class&quot;"/>
                r#acronym_elem1.set_id_attribute_node(r#attr, true).unwrap(); // <setIdAttributeNode obj="acronymElem1" idAttr="attr" isId="true"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributenodeIsId1True07"/>
                r#attributes_map = r#acronym_elem2.attributes(); // <attributes var="attributesMap" obj="acronymElem2"/>
                r#attr = r#attributes_map.get_named_item("class").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;class&quot;"/>
                r#acronym_elem2.set_id_attribute_node(r#attr, true).unwrap(); // <setIdAttributeNode obj="acronymElem2" idAttr="attr" isId="true"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributenodeIsId2True07"/>
                r#elem = r#doc.get_element_by_id("No".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;No&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "acronym"); // <assertEquals actual="elemName" expected="&quot;acronym&quot;" id="elementsetidattributenode1GetElementById07" ignoreCase="false"/>
                r#elem = r#doc.get_element_by_id("Yes".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;Yes&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "acronym"); // <assertEquals actual="elemName" expected="&quot;acronym&quot;" id="elementsetidattributenode2GetElementById07" ignoreCase="false"/>
            }
            // nodecomparedocumentposition11.xml
            #[test]
            fn test_nodecomparedocumentposition11() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#attr_position; // type: int // <var name="attrPosition" type="int"/>
                let mut r#replaced_attr; // type: Attr // <var name="replacedAttr" type="Attr"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#elem = r#elem_list.item(3).unwrap(); // <item var="elem" obj="elemList" index="3" interface="NodeList"/>
                r#new_attr = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/XML/1998/namespace"),
                        "xml:lang".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="newAttr" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>
                r#replaced_attr = r#elem.set_attribute_node_ns(r#new_attr).unwrap().unwrap(); // <setAttributeNodeNS obj="elem" var="replacedAttr" newAttr="newAttr"/>
                r#attr_position = r#new_attr.compare_document_position(&r#doc.into()); // <compareDocumentPosition var="attrPosition" obj="newAttr" other="doc"/>
                assert_eq!(u16::from(r#attr_position), 10); // <assertEquals actual="attrPosition" expected="10" id="nodecomparedocumentpositionPRECEDINGContains11" ignoreCase="false"/>
            }
            // documentnormalizedocument05.xml
            #[test]
            fn test_documentnormalizedocument05() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#new_child; // type: Element // <var name="newChild" type="Element"/>
                // let mut r#retval; // type: Element // <var name="retval" type="Element"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#errors; // type: List // <var name="errors" type="List"/>
                // let mut r#error; // type: DOMError // <var name="error" type="DOMError"/>
                // let mut r#error_count; // type: int // <var name="errorCount" type="int" value="0"/>
                // let mut r#severity; // type: int // <var name="severity" type="int"/>
                // let mut r#problem_node; // type: Node // <var name="problemNode" type="Node"/>
                // let mut r#location; // type: DOMLocator // <var name="location" type="DOMLocator"/>
                // let mut r#line_number; // type: int // <var name="lineNumber" type="int"/>
                // let mut r#column_number; // type: int // <var name="columnNumber" type="int"/>
                // let mut r#byte_offset; // type: int // <var name="byteOffset" type="int"/>
                // let mut r#utf16_offset; // type: int // <var name="utf16Offset" type="int"/>
                // let mut r#uri; // type: DOMString // <var name="uri" type="DOMString"/>
                // let mut r#type; // type: DOMString // <var name="type" type="DOMString"/>
                // let mut r#message; // type: DOMString // <var name="message" type="DOMString"/>
                // let mut r#related_exception; // type: DOMObject // <var name="relatedException" type="DOMObject"/>
                // let mut r#related_data; // type: DOMObject // <var name="relatedData" type="DOMObject"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#p_list.item(0).unwrap(); // <item var="elem" obj="pList" index="0" interface="NodeList"/>
                // r#new_child = r#doc.create_element("br".to_string()).unwrap(); // <createElement var="newChild" obj="doc" tagName="&quot;br&quot;"/>
                // r#retval = r#elem.append_child(new_child).unwrap(); // <appendChild var="retval" obj="elem" newChild="newChild"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;namespaces&quot;" value="true"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <allErrors var="errors" obj="errorMonitor"/>

                // // unimplemented: // <for-each member="error" collection="errors">	<severity var="severity" obj="error"/>	<if>		<equals actual="severity" expected="2" ignoreCase="false"/>		<!-- location should have relatedNode, everything else should be -1 or null -->		<location var="location" obj="error"/>		<relatedNode var="problemNode" obj="location" interface="DOMLocator"/>		<assertSame actual="problemNode" expected="newChild" id="relatedNodeIsL1Node"/>		<lineNumber var="lineNumber" obj="location"/>		<assertEquals actual="lineNumber" expected="-1" ignoreCase="false" id="lineNumber"/>		<columnNumber var="columnNumber" obj="location"/>		<assertEquals actual="columnNumber" expected="-1" ignoreCase="false" id="columnNumber"/>		<byteOffset var="byteOffset" obj="location"/>		<assertEquals actual="byteOffset" expected="-1" ignoreCase="false" id="byteOffset"/>		<utf16Offset var="utf16Offset" obj="location"/>		<assertEquals actual="utf16Offset" expected="-1" ignoreCase="false" id="utf16Offset"/>		<uri var="uri" obj="location" interface="DOMLocator"/>		<assertNull actual="uri" id="uri"/>		<!--  message and type should be non-empty  -->		<message var="message" obj="error"/>		<length var="length" obj="message" interface="DOMString"/>		<assertTrue id="messageNotEmpty">			<greater actual="length" expected="0"/>		</assertTrue>		<!--  can't make any assertions about type, relatedData and relatedException		          other than access should not raise exception   -->		<type var="type" obj="error" interface="DOMError"/>		<relatedData var="relatedData" obj="error"/>		<relatedException var="relatedException" obj="error"/>		<increment var="errorCount" value="1"/>		<else>			<assertEquals actual="severity" expected="1" ignoreCase="false" id="anyOthersShouldBeWarnings"/>		</else>	</if></for-each>
                // assert_eq!(r#error_count, 1); // <assertEquals actual="errorCount" expected="1" ignoreCase="false" id="oneError"/>
            }
            // typeinfoisderivedfrom15.xml
            #[test]
            fn test_typeinfoisderivedfrom15() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "emType"); // <assertEquals actual="typeName" expected="&quot;emType&quot;" ignoreCase="false" id="name"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;emp0001_3Type&quot;" derivationMethod="15"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromEmp13AnyMethod"/>
            }
            // nodelookupprefix06.xml
            #[test]
            fn test_nodelookupprefix06() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#elem = r#elem_list.item(2).unwrap(); // <item var="elem" obj="elemList" index="2" interface="NodeList"/>
                r#prefix = r#elem
                    .lookup_prefix("http://www.netzero.com")
                    .unwrap()
                    .to_string(); // <lookupPrefix var="prefix" obj="elem" namespaceURI="&quot;http://www.netzero.com&quot;"/>
                assert_eq!(r#prefix, "dmstc"); // <assertEquals actual="prefix" expected="&quot;dmstc&quot;" id="nodelookupprefix06" ignoreCase="false"/>
            }
            // textiselementcontentwhitespace01.xml
            #[test]
            fn test_textiselementcontentwhitespace01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#new_text; // type: Text // <var name="newText" type="Text"/>
                let mut r#has_whitespace; // type: boolean // <var name="hasWhitespace" type="boolean"/>
                r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                r#new_text = r#doc.create_text_node("   "); // <createTextNode var="newText" obj="doc" data="&quot;   &quot;"/>
                r#has_whitespace = r#new_text.is_element_content_whitespace(); // <isElementContentWhitespace obj="newText" var="hasWhitespace"/>
                assert!(!r#has_whitespace); // <assertFalse actual="hasWhitespace" id="isWhitespace"/>
            }
            // documentadoptnode19.xml
            #[test]
            fn test_documentadoptnode19() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#notation_map; // type: NamedNodeMap // <var name="notationMap" type="NamedNodeMap"/>
                // let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                // let mut r#adopted_notaion; // type: Node // <var name="adoptedNotaion" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <notations var="notationMap" obj="docType"/>
                // r#notation = r#notation_map.get_named_item("notation1".into()).unwrap();
                // // <getNamedItem var="notation" obj="notationMap" name="&quot;notation1&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR"><NO_MODIFICATION_ALLOWED_ERR><adoptNode var="adoptedNotaion" obj="doc" source="notation"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // nodeisequalnode03.xml
            #[test]
            fn test_nodeisequalnode03() {
                let mut r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let mut r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let mut r#doc_elem1; // type: Element // <var name="docElem1" type="Element"/>
                let mut r#doc_elem2; // type: Element // <var name="docElem2" type="Element"/>
                let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                r#doc1 = todo!(); // barfoo_utf8.xml // <load var="doc1" href="barfoo_utf8" willBeModified="false"/>
                r#doc2 = todo!(); // barfoo_utf16.xml // <load var="doc2" href="barfoo_utf16" willBeModified="false"/>
                r#is_equal = r#doc1.is_equal_node(&r#doc2.into()); // <isEqualNode var="isEqual" obj="doc1" arg="doc2"/>
                assert!(r#is_equal); // <assertTrue actual="isEqual" id="docAreNotEquals"/>
                r#doc_elem1 = r#doc1.document_element().unwrap(); // <documentElement var="docElem1" obj="doc1"/>
                r#doc_elem2 = r#doc2.document_element().unwrap(); // <documentElement var="docElem2" obj="doc2"/>
                r#is_equal = r#doc_elem1.is_equal_node(&r#doc_elem2.into()); // <isEqualNode var="isEqual" obj="docElem1" arg="docElem2"/>
                assert!(r#is_equal); // <assertTrue actual="isEqual" id="docElemsAreEquals"/>
            }
            // nodesetuserdata08.xml
            #[test]
            fn test_nodesetuserdata08() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#c_data; // type: CDATASection // <var name="cData" type="CDATASection"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem_name; // type: Element // <var name="elemName" type="Element"/>
                // let mut r#user_data; // type: DOMUserData // <var name="userData" type="DOMUserData"/>
                // let mut r#returned1; // type: DOMUserData // <var name="returned1" type="DOMUserData"/>
                // let mut r#returned2; // type: DOMUserData // <var name="returned2" type="DOMUserData"/>
                // let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                // let mut r#ret_user_data; // type: DOMUserData // <var name="retUserData" type="DOMUserData"/>
                // let mut r#null_handler; // type: UserDataHandler // <var name="nullHandler" type="UserDataHandler" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#ent_ref = r#doc.create_entity_reference("delta".to_string()).unwrap(); // <createEntityReference name="&quot;delta&quot;" obj="doc" var="entRef"/>
                // r#c_data = r#doc.create_cdata_section("CDATASection").unwrap(); // <createCDATASection var="cData" obj="doc" data="&quot;CDATASection&quot;"/>

                // // unimplemented: // <setUserData obj="entRef" var="retUserData" key="&quot;Key1&quot;" data="doc" handler="nullHandler"/>

                // // unimplemented: // <setUserData obj="cData" var="retUserData" key="&quot;Key2&quot;" data="docElem" handler="nullHandler"/>

                // // unimplemented: // <getUserData var="returned1" obj="entRef" key="&quot;Key1&quot;"/>

                // // unimplemented: // <getUserData var="returned2" obj="cData" key="&quot;Key2&quot;"/>
                // r#success = r#returned1.is_equal_node(&r#returned2.into()); // <isEqualNode var="success" obj="returned1" arg="returned2"/>
                // assert!(!r#success); // <assertFalse actual="success" id="nodesetuserdata08"/>
            }
            // nodeisdefaultnamespace15.xml
            #[test]
            fn test_nodeisdefaultnamespace15() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#body_elem; // type: Element // <var name="bodyElem" type="Element"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                let mut r#cloned_comment; // type: Comment // <var name="clonedComment" type="Comment"/>
                let mut r#is_default; // type: boolean // <var name="isDefault" type="boolean"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#body_list; // type: NodeList // <var name="bodyList" type="NodeList"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#body_list = r#doc.get_elements_by_tag_name("body"); // <getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/>
                r#body_elem = r#body_list.item(0).unwrap(); // <item var="bodyElem" obj="bodyList" index="0" interface="NodeList"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "p".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;p&quot;"/>
                r#comment = r#doc.create_comment("Text"); // <createComment var="comment" obj="doc" data="&quot;Text&quot;"/>
                r#cloned_comment = r#comment.clone_node(true); // <cloneNode var="clonedComment" obj="comment" deep="true"/>
                r#appended_child = r#elem.append_child(cloned_comment).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="clonedComment"/>
                r#appended_child = r#body_elem.append_child(elem.into()).unwrap(); // <appendChild obj="bodyElem" var="appendedChild" newChild="elem"/>
                r#is_default =
                    r#cloned_comment.is_default_namespace("http://www.w3.org/1999/xhtml"); // <isDefaultNamespace var="isDefault" obj="clonedComment" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>
                assert!(r#is_default); // <assertTrue actual="isDefault" id="nodeisdefaultnamespace15"/>
            }
            // elementgetschematypeinfo03.xml
            #[test]
            fn test_elementgetschematypeinfo03() {
                // // unimplemented: // <implementationAttribute name="validating" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // let mut r#type_ns; // type: DOMString // <var name="typeNS" type="DOMString"/>
                // r#doc = todo!(); // hc_nodtdstaff.xml // <load var="doc" href="hc_nodtdstaff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>

                // // unimplemented: // <assertNull actual="typeName" id="typeName"/>

                // // unimplemented: // <typeNamespace var="typeNS" obj="typeInfo"/>

                // // unimplemented: // <assertNull actual="typeNS" id="typeNS"/>
            }
            // attrgetschematypeinfo07.xml
            #[test]
            fn test_attrgetschematypeinfo07() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#ac_elem; // type: Element // <var name="acElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#attr_type_info; // type: TypeInfo // <var name="attrTypeInfo" type="TypeInfo"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // let mut r#type_namespace; // type: DOMString // <var name="typeNamespace" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#ac_elem = r#elem_list.item(3).unwrap(); // <item var="acElem" obj="elemList" index="3" interface="NodeList"/>
                // r#attr = r#ac_elem.get_attribute_node("id").unwrap(); // <getAttributeNode var="attr" obj="acElem" name="&quot;id&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="attrTypeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <assertNotNull actual="attrTypeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="attrTypeInfo"/>

                // // unimplemented: // <typeNamespace var="typeNamespace" obj="attrTypeInfo"/>
                // assert_eq!(r#type_name, "ID"); // <assertEquals expected="&quot;ID&quot;" actual="typeName" id="attrgetschematypeinfo07_typeName" ignoreCase="false"/>
                // assert_eq!(r#type_namespace, "http://www.w3.org/2001/XMLSchema");
                // // <assertEquals expected="&quot;http://www.w3.org/2001/XMLSchema&quot;" actual="typeNamespace" id="attrgetschematypeinfo07_typeNamespace" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom52.xml
            #[test]
            fn test_typeinfoisderivedfrom52() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // typeinfo.xml // <load var="doc" href="typeinfo" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anySimpleType&quot;" derivationMethod="1"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="derivedFromAnySimpleRestriction"/>
            }
            // documentadoptnode31.xml
            #[test]
            fn test_documentadoptnode31() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#new_text; // type: Text // <var name="newText" type="Text"/>
                // let mut r#adopted_text; // type: Text // <var name="adoptedText" type="Text"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#new_text =
                //     r#new_doc.create_text_node("new Document.adoptNode test for a TEXT_NODE"); // <createTextNode var="newText" obj="newDoc" data="&quot;new Document.adoptNode test for a TEXT_NODE&quot;"/>
                // r#adopted_text = r#doc.adopt_node(r#new_text.into()); // <adoptNode var="adoptedText" obj="doc" source="newText"/>

                // // unimplemented: // <if><notNull obj="adoptedText"/><nodeValue var="nodeValue" obj="adoptedText"/><assertEquals actual="nodeValue" expected="&quot;new Document.adoptNode test for a TEXT_NODE&quot;" id="documentadoptnode31" ignoreCase="false"/></if>
            }
            // nodeinsertbefore24.xml
            #[test]
            fn test_nodeinsertbefore24() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#ref_node; // type: CDATASection // <var name="refNode" type="CDATASection"/>
                // let mut r#new_node; // type: Comment // <var name="newNode" type="Comment"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#inserted; // type: Node // <var name="inserted" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#element = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "xhtml:p".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:p&quot;"/>
                // r#ref_node = r#doc.create_cdata_section("CDATASection").unwrap(); // <createCDATASection var="refNode" obj="doc" data="&quot;CDATASection&quot;"/>
                // r#new_node = r#doc.create_comment("Comment"); // <createComment var="newNode" obj="doc" data="&quot;Comment&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR"><NOT_FOUND_ERR><insertBefore obj="element" var="inserted" refChild="refNode" newChild="newNode"/></NOT_FOUND_ERR></assertDOMException>
            }
            // typeinfoisderivedfrom01.xml
            #[test]
            fn test_typeinfoisderivedfrom01() {
                // // unimplemented: // <implementationAttribute name="validating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(0).unwrap(); // <item var="acronymElem" obj="elemList" index="0" interface="NodeList"/>
                // r#attr = r#acronym_elem.get_attribute_node("title").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;title&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/TR/REC-xml&quot;" typeNameArg="&quot;CDATA&quot;" derivationMethod="0"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="isDerived0"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/TR/REC-xml&quot;" typeNameArg="&quot;CDATA&quot;" derivationMethod="15"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="isDerived15"/>
            }
            // typeinfoisderivedfrom20.xml
            #[test]
            fn test_typeinfoisderivedfrom20() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anyType&quot;" derivationMethod="1"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromAnyType"/>
            }
            // nodegettextcontent07.xml
            #[test]
            fn test_nodegettextcontent07() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#elem = r#elem_list.item(3).unwrap(); // <item var="elem" obj="elemList" index="3" interface="NodeList"/>
                r#elem
                    .set_attribute_ns(
                        Some("http://www.w3.org/XML/1998/namespace"),
                        "xml:lang",
                        "en-US",
                    )
                    .unwrap(); // <setAttributeNS obj="elem" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;" value="&quot;en-US&quot;"/>
                r#attr = r#elem
                    .get_attribute_node_ns(Some("http://www.w3.org/XML/1998/namespace"), "lang")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attr" obj="elem" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" localName="&quot;lang&quot;"/>
                r#text_content = r#attr.text_content().unwrap(); // <textContent var="textContent" obj="attr"/>
                assert_eq!(r#text_content, "en-US"); // <assertEquals actual="textContent" expected="&quot;en-US&quot;" id="nodegettextcontent07" ignoreCase="false"/>
            }
            // documentadoptnode08.xml
            #[test]
            fn test_documentadoptnode08() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#adopted_doc; // type: Node // <var name="adoptedDoc" type="Node"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><adoptNode var="adoptedDoc" obj="doc" source="newDoc"/></NOT_SUPPORTED_ERR></assertDOMException>
            }
            // userdatahandler01.xml
            #[test]
            fn test_userdatahandler01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#user_data_monitor; // type: UserDataMonitor // <var name="userDataMonitor" type="UserDataMonitor"/>
                // let mut r#old_user_data; // type: DOMUserData // <var name="oldUserData" type="DOMUserData"/>
                // let mut r#element_ns; // type: DOMString // <var name="elementNS" type="DOMString"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // let mut r#notifications; // type: List // <var name="notifications" type="List"/>
                // let mut r#notification; // type: UserDataNotification // <var name="notification" type="UserDataNotification"/>
                // let mut r#operation; // type: short // <var name="operation" type="short"/>
                // let mut r#key; // type: DOMString // <var name="key" type="DOMString"/>
                // let mut r#data; // type: DOMString // <var name="data" type="DOMString"/>
                // let mut r#src; // type: Node // <var name="src" type="Node"/>
                // let mut r#dst; // type: Node // <var name="dst" type="Node"/>
                // let mut r#greeting_count; // type: int // <var name="greetingCount" type="int" value="0"/>
                // let mut r#salutation_count; // type: int // <var name="salutationCount" type="int" value="0"/>
                // let mut r#hello; // type: DOMString // <var name="hello" type="DOMString" value="&quot;Hello&quot;"/>
                // let mut r#mister; // type: DOMString // <var name="mister" type="DOMString" value="&quot;Mr.&quot;"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#node = r#p_list.item(0).unwrap(); // <item var="node" obj="pList" index="0" interface="NodeList"/>

                // // unimplemented: // <setUserData var="oldUserData" obj="node" key="&quot;greeting&quot;" data="hello" handler="userDataMonitor"/>

                // // unimplemented: // <setUserData var="oldUserData" obj="node" key="&quot;salutation&quot;" data="mister" handler="userDataMonitor"/>
                // r#element_ns = r#node.namespace_uri().unwrap().to_string(); // <namespaceURI var="elementNS" obj="node" interface="Node"/>
                // r#new_node = r#doc
                //     .rename_node(r#node.into(), Some(r#element_ns), "div")
                //     .unwrap(); // <renameNode var="newNode" obj="doc" n="node" namespaceURI="elementNS" qualifiedName="&quot;div&quot;"/>

                // // unimplemented: // <allNotifications var="notifications" obj="userDataMonitor"/>

                // // unimplemented: // <assertSize size="2" collection="notifications" id="twoNotifications"/>

                // // unimplemented: // <for-each member="notification" collection="notifications">	<operation var="operation" obj="notification"/>	<assertEquals actual="operation" expected="4" ignoreCase="false" id="operationIsRename"/>	<key var="key" obj="notification"/>	<data var="data" obj="notification" interface="UserDataNotification"/>	<if>		<equals actual="key" expected="&quot;greeting&quot;" ignoreCase="false"/>		<assertEquals actual="data" expected="hello" ignoreCase="false" id="greetingDataHello"/>		<increment var="greetingCount" value="1"/>		<else>			<assertEquals actual="key" expected="&quot;salutation&quot;" ignoreCase="false" id="saluationKey"/>			<assertEquals actual="data" expected="mister" ignoreCase="false" id="salutationDataMr"/>			<increment var="salutationCount" value="1"/>		</else>	</if>	<src interface="UserDataNotification" var="src" obj="notification"/>	<assertSame actual="src" expected="node" id="srcIsNode"/>	<dst var="dst" obj="notification"/>	<if>		<!-- will be null if no node needs to be newly created  -->		<isNull obj="dst"/>		<assertSame actual="newNode" expected="node" id="ifDstNullRenameMustReuseNode"/>		<else>			<!-- otherwise will be same as newNode   -->			<assertSame actual="dst" expected="newNode" id="dstIsNewNode"/>		</else>	</if></for-each>
                // assert_eq!(r#greeting_count, 1); // <assertEquals actual="greetingCount" expected="1" ignoreCase="false" id="greetingCountIs1"/>
                // assert_eq!(r#salutation_count, 1); // <assertEquals actual="salutationCount" expected="1" ignoreCase="false" id="salutationCountIs1"/>
            }
            // documentgetdocumenturi03.xml
            #[test]
            fn test_documentgetdocumenturi03() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#imported_owner: DocumentRef; // <var name="importedOwner" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#doc_elem_imported; // type: Node // <var name="docElemImported" type="Node"/>
                // let mut r#doc_uri; // type: DOMString // <var name="docURI" type="DOMString"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#doc_elem_imported = r#new_doc.import_node(r#doc_elem.into(), false).unwrap(); // <importNode var="docElemImported" obj="newDoc" importedNode="docElem" deep="false"/>
                // r#imported_owner = r#doc_elem_imported.owner_document().unwrap(); // <ownerDocument var="importedOwner" obj="docElemImported"/>
                // r#doc_uri = r#imported_owner.document_uri().unwrap().to_string();
                // // <documentURI var="docURI" obj="importedOwner"/>

                // // unimplemented: // <assertNull actual="docURI" id="documentgetdocumenturi03"/>
            }
            // nodegetbaseuri03.xml
            #[test]
            fn test_nodegetbaseuri03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#base_uri; // type: DOMString // <var name="baseURI" type="DOMString"/>
                r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                r#base_uri = r#doc_type.base_uri().unwrap().to_string(); // <baseURI var="baseURI" obj="docType" interface="Node"/>

                // unimplemented: // <assertNull actual="baseURI" id="nodegetbaseuri03"/>
            }
            // typeinfoisderivedfrom45.xml
            #[test]
            fn test_typeinfoisderivedfrom45() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="acronymElem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anySimpleType&quot;" derivationMethod="2"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromAnySimpleType"/>
            }
            // normalizecharacters06.xml
            #[test]
            fn test_normalizecharacters06() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // let mut r#text_value; // type: DOMString // <var name="textValue" type="DOMString"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;normalize-characters&quot;" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;normalize-characters&quot;" value="true"/><setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/><getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/><item var="pElem" obj="pList" index="0" interface="NodeList"/><!--  character entity is expanded during code generation        code equivalent to "suc\u0327on"    --><createTextNode var="text" obj="doc" data="&quot;sucon&quot;"/><appendChild var="retval" obj="pElem" newChild="text"/><normalize obj="doc"/><!--  fail test if normalize had any errors or fatal errors   --><assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/><getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/><item var="pElem" obj="pList" index="0" interface="NodeList"/><firstChild var="text" obj="pElem" interface="Node"/><nodeValue var="textValue" obj="text"/><assertEquals actual="textValue" expected="&quot;barsuon&quot;" ignoreCase="false" id="noCharNormalization"/> </if>
            }
            // nodeinsertbefore04.xml
            #[test]
            fn test_nodeinsertbefore04() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#inserted; // type: Node // <var name="inserted" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR"><HIERARCHY_REQUEST_ERR><insertBefore obj="doc" var="inserted" newChild="doc" refChild="docType"/></HIERARCHY_REQUEST_ERR></assertDOMException>
            }
            // nodereplacechild40.xml
            #[test]
            fn test_nodereplacechild40() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // let mut r#public_id; // type: DOMString // <var name="publicId" type="DOMString" isNull="true"/>
                // let mut r#system_id; // type: DOMString // <var name="systemId" type="DOMString" isNull="true"/>
                // let mut r#new_comment; // type: Comment // <var name="newComment" type="Comment"/>
                // let mut r#new_doc_type; // type: DocumentType // <var name="newDocType" type="DocumentType"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#ret_node; // type: Node // <var name="retNode" type="Node"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocumentType var="newDocType" obj="domImpl" qualifiedName="rootName" publicId="publicId" systemId="systemId"/>
                // r#new_comment = r#doc.create_comment("second element goes here"); // <createComment var="newComment" obj="doc" data="&quot;second element goes here&quot;"/>
                // r#ret_node = r#doc
                //     .insert_before(new_comment.into(), Some(doc_elem.into()))
                //     .unwrap(); // <insertBefore var="retNode" obj="doc" newChild="newComment" refChild="docElem"/>

                // // unimplemented: // <try>	<replaceChild var="retNode" obj="doc" newChild="newDocType" oldChild="newComment"/>	<fail id="throw_HIERARCHY_REQUEST_OR_NOT_SUPPORTED"/>	<catch>		<DOMException code="HIERARCHY_REQUEST_ERR"/>		<DOMException code="NOT_SUPPORTED_ERR"/>	</catch></try>
            }
            // nodeissamenode05.xml
            #[test]
            fn test_nodeissamenode05() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element1; // type: Element // <var name="element1" type="Element"/>
                let mut r#element2; // type: Element // <var name="element2" type="Element"/>
                let mut r#is_same; // type: boolean // <var name="isSame" type="boolean"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#element1 = r#doc.document_element().unwrap(); // <documentElement var="element1" obj="doc"/>
                r#element2 = r#doc.document_element().unwrap(); // <documentElement var="element2" obj="doc"/>
                is_same = element2.is_same_node(&element1.into()); // <isSameNode var="isSame" obj="element2" other="element1"/>
                assert!(r#is_same); // <assertTrue actual="isSame" id="nodeissamenode05"/>
            }
            // nodelookupprefix14.xml
            #[test]
            fn test_nodelookupprefix14() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#body_elem; // type: Element // <var name="bodyElem" type="Element"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#cdata; // type: CDATASection // <var name="cdata" type="CDATASection"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#body_list; // type: NodeList // <var name="bodyList" type="NodeList"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#body_list = r#doc.get_elements_by_tag_name("body"); // <getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/>
                r#body_elem = r#body_list.item(0).unwrap(); // <item var="bodyElem" obj="bodyList" index="0" interface="NodeList"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "dom3:p".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:p&quot;"/>
                r#cdata = r#doc.create_cdata_section("Text").unwrap(); // <createCDATASection var="cdata" obj="doc" data="&quot;Text&quot;"/>
                r#appended_child = r#elem.append_child(cdata.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="cdata"/>
                r#appended_child = r#body_elem.append_child(elem.into()).unwrap(); // <appendChild obj="bodyElem" var="appendedChild" newChild="elem"/>
                r#prefix = r#cdata
                    .lookup_prefix("http://www.w3.org/1999/xhtml")
                    .unwrap()
                    .to_string(); // <lookupPrefix var="prefix" obj="cdata" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>
                assert_eq!(r#prefix, "dom3"); // <assertEquals actual="prefix" expected="&quot;dom3&quot;" id="nodelookupprefix14" ignoreCase="false"/>
            }
            // infoset04.xml
            #[test]
            fn test_infoset04() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#new_cdata; // type: CDATASection // <var name="newCdata" type="CDATASection"/>
                // let mut r#cdata; // type: CDATASection // <var name="cdata" type="CDATASection"/>
                // let mut r#text; // type: Node // <var name="text" type="Node"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#p_list.item(0).unwrap(); // <item var="elem" obj="pList" index="0" interface="NodeList"/>
                // r#new_cdata = r#doc.create_cdata_section("CDATA").unwrap(); // <createCDATASection var="newCdata" obj="doc" data="&quot;CDATA&quot;"/>
                // r#appended_child = r#elem.append_child(new_cdata.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="newCdata"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;infoset&quot;" value="true"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" severity="SEVERITY_ERROR" id="normalization2Error"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#p_list.item(0).unwrap(); // <item var="elem" obj="pList" index="0" interface="NodeList"/>
                // r#text = r#elem.last_child().unwrap(); // <lastChild var="text" obj="elem" interface="Node"/>
                // r#node_name = r#text.node_name().to_string(); // <nodeName var="nodeName" obj="text"/>
                // assert_eq!(r#node_name, "#text"); // <assertEquals actual="nodeName" expected="&quot;#text&quot;" id="documentnormalizedocument03_false" ignoreCase="false"/>
                // r#node_value = r#text.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="text"/>
                // assert_eq!(r#node_value, "barCDATA"); // <assertEquals actual="nodeValue" expected="&quot;barCDATA&quot;" id="normalizedValue" ignoreCase="false"/>
            }
            // elementgetschematypeinfo07.xml
            #[test]
            fn test_elementgetschematypeinfo07() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#sup_elem; // type: Element // <var name="supElem" type="Element"/>
                // let mut r#elem_type_info; // type: TypeInfo // <var name="elemTypeInfo" type="TypeInfo"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // let mut r#type_namespace; // type: DOMString // <var name="typeNamespace" type="DOMString"/>
                // let mut r#doc_elem_node_name; // type: DOMString // <var name="docElemNodeName" type="DOMString"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("sup"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;sup&quot;" interface="Document"/>
                // r#sup_elem = r#elem_list.item(0).unwrap(); // <item var="supElem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="elemTypeInfo" obj="supElem" interface="Element"/>

                // // unimplemented: // <typeName var="typeName" obj="elemTypeInfo"/>

                // // unimplemented: // <typeNamespace var="typeNamespace" obj="elemTypeInfo"/>
                // assert_eq!(r#type_name, "sup"); // <assertEquals expected="&quot;sup&quot;" actual="typeName" id="elementgetschematypeinfo07_typeName" ignoreCase="false"/>
                // assert_eq!(r#type_namespace, "http://www.w3.org/1999/xhtml"); // <assertEquals expected="&quot;http://www.w3.org/1999/xhtml&quot;" actual="typeNamespace" id="elementgetschematypeinfo07_typeNamespace" ignoreCase="false"/>
            }
            // nodelookupnamespaceuri01.xml
            #[test]
            fn test_nodelookupnamespaceuri01() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                // let mut r#null_prefix; // type: DOMString // <var name="nullPrefix" type="DOMString" isNull="true"/>
                // r#doc = todo!(); // barfoo_nodefaultns.xml // <load var="doc" href="barfoo_nodefaultns" willBeModified="false"/>
                // r#namespace_uri = r#doc
                //     .lookup_namespace_uri(r#null_prefix.as_ref())
                //     .unwrap()
                //     .to_string(); // <lookupNamespaceURI var="namespaceURI" obj="doc" prefix="nullPrefix" interface="Node"/>

                // // unimplemented: // <assertNull actual="namespaceURI" id="nodelookupnamespaceuri01"/>
            }
            // documentgetxmlencoding05.xml
            #[test]
            fn test_documentgetxmlencoding05() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#cloned: DocumentRef; // <var name="cloned" type="Document"/>
                // let mut r#encoding_name; // type: DOMString // <var name="encodingName" type="DOMString"/>
                // r#doc = todo!(); // barfoo_utf8.xml // <load var="doc" href="barfoo_utf8" willBeModified="false"/>
                // r#cloned = r#doc.clone_node(true).as_document().unwrap(); // <cloneNode var="cloned" obj="doc" deep="true"/>
                // r#encoding_name = r#cloned.xml_encoding().unwrap().to_string(); // <xmlEncoding obj="cloned" var="encodingName" interface="Document"/>

                // // unimplemented: // <assertTrue id="documentgetxmlencoding05"><or><equals expected="&quot;uTf-8&quot;" actual="encodingName" ignoreCase="false"/><isNull obj="encodingName"/></or></assertTrue>
            }
            // namespacedeclarations01.xml
            #[test]
            fn test_namespacedeclarations01() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#xmlns_attr; // type: Attr // <var name="xmlnsAttr" type="Attr"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;namespace-declarations&quot;" value="true"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#xmlns_attr = r#doc_elem.get_attribute_node("xmlns").unwrap();
                // // <getAttributeNode var="xmlnsAttr" obj="docElem" name="&quot;xmlns&quot;"/>

                // // unimplemented: // <assertNotNull actual="xmlnsAttr" id="xmlnsAttrNotNull"/>
            }
            // elementsetidattributens11.xml
            #[test]
            fn test_elementsetidattributens11() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#p_elem1; // type: Element // <var name="pElem1" type="Element"/>
                let mut r#p_elem2; // type: Element // <var name="pElem2" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "p"); // <getElementsByTagNameNS var="elemList" obj="doc" localName="&quot;p&quot;" namespaceURI="&quot;*&quot;" interface="Document"/>
                r#p_elem1 = r#elem_list.item(1).unwrap(); // <item var="pElem1" obj="elemList" index="1" interface="NodeList"/>
                r#p_elem2 = r#elem_list.item(2).unwrap(); // <item var="pElem2" obj="elemList" index="2" interface="NodeList"/>
                r#p_elem1
                    .set_id_attribute_ns(Some("http://www.w3.org/2000/xmlns/"), "dmstc", true)
                    .unwrap(); // <setIdAttributeNS obj="pElem1" localName="&quot;dmstc&quot;" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" isId="true"/>
                r#p_elem2
                    .set_id_attribute_ns(Some("http://www.w3.org/2000/xmlns/"), "dmstc", true)
                    .unwrap(); // <setIdAttributeNS obj="pElem2" localName="&quot;dmstc&quot;" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" isId="true"/>
                r#attributes_map = r#p_elem1.attributes(); // <attributes var="attributesMap" obj="pElem1"/>
                r#attr = r#attributes_map.get_named_item("xmlns:dmstc").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;xmlns:dmstc&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributensIsId1True11"/>
                r#attributes_map = r#p_elem2.attributes(); // <attributes var="attributesMap" obj="pElem2"/>
                r#attr = r#attributes_map.get_named_item("xmlns:dmstc").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;xmlns:dmstc&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributensIsId2True11"/>
                r#elem = r#doc
                    .get_element_by_id("http://www.netzero.com".as_ref())
                    .unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;http://www.netzero.com&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "p"); // <assertEquals actual="elemName" expected="&quot;p&quot;" id="elementsetidattributens1GetElementById11" ignoreCase="false"/>
                r#elem = r#doc
                    .get_element_by_id("http://www.usa.com".as_ref())
                    .unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;http://www.usa.com&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "p"); // <assertEquals actual="elemName" expected="&quot;p&quot;" id="elementsetidattributens2GetElementById11" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom41.xml
            #[test]
            fn test_typeinfoisderivedfrom41() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "emType"); // <assertEquals actual="typeName" expected="&quot;emType&quot;" ignoreCase="false" id="typeName"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;ID&quot;" derivationMethod="10"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="derivedFromID"/>
            }
            // domimplementationgetfeature06.xml
            #[test]
            fn test_domimplementationgetfeature06() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#dom_impl_returned; // type: DOMImplementation // <var name="domImplReturned" type="DOMImplementation"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <getFeature var="domImplReturned" obj="domImpl" feature="&quot;1-1&quot;" version="&quot;*&quot;" interface="DOMImplementation"/>

                // // unimplemented: // <assertNull actual="domImplReturned" id="domimplementationgetfeature06"/>
            }
            // nodegetuserdata02.xml
            #[test]
            fn test_nodegetuserdata02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#user_data; // type: DOMUserData // <var name="userData" type="DOMUserData"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <getUserData var="userData" obj="doc" key="&quot;key1&quot;"/>

                // // unimplemented: // <assertNull actual="userData" id="nodegetuserdata02"/>
            }
            // infoset08.xml
            #[test]
            fn test_infoset08() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#body_list; // type: NodeList // <var name="bodyList" type="NodeList"/>
                // let mut r#body; // type: Element // <var name="body" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;infoset&quot;" value="true"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>

                // // unimplemented: // <if><implementationAttribute name="ignoringElementContentWhitespace" value="true"/>	<getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/>	<item var="body" obj="bodyList" interface="NodeList" index="0"/>	<firstChild var="child" obj="body" interface="Node"/>	<createTextNode var="text" obj="doc" data="&quot;    &quot;"/>	<insertBefore var="child" obj="body" newChild="text" refChild="child"/></if>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>
                // r#body_list = r#doc.get_elements_by_tag_name("body"); // <getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/>
                // r#body = r#body_list.item(0).unwrap(); // <item var="body" obj="bodyList" interface="NodeList" index="0"/>
                // r#child = r#body.first_child().unwrap(); // <firstChild var="child" obj="body" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="child" id="firstChildNotNull"/>
                // r#child_name = r#child.node_name().to_string(); // <nodeName var="childName" obj="child"/>
                // assert_eq!(r#child_name, "#text"); // <assertEquals actual="childName" expected="&quot;#text&quot;" ignoreCase="false" id="firstChild"/>
                // r#child = r#child.next_sibling().unwrap(); // <nextSibling var="child" obj="child" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="child" id="secondChildNotNull"/>
                // r#child_name = r#child.node_name().to_string(); // <nodeName var="childName" obj="child"/>
                // assert_eq!(r#child_name, "p"); // <assertEquals actual="childName" expected="&quot;p&quot;" ignoreCase="false" id="secondChild"/>
            }
            // nodecomparedocumentposition35.xml
            #[test]
            fn test_nodecomparedocumentposition35() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#element_position; // type: int // <var name="elementPosition" type="int"/>
                let mut r#attr_position; // type: int // <var name="attrPosition" type="int"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#elem = r#elem_list.item(3).unwrap(); // <item var="elem" obj="elemList" index="3" interface="NodeList"/>
                r#attr = r#elem.get_attribute_node("dir").unwrap(); // <getAttributeNode var="attr" obj="elem" name="&quot;dir&quot;"/>
                r#element_position = r#elem.compare_document_position(&r#attr.into()); // <compareDocumentPosition var="elementPosition" obj="elem" other="attr"/>
                assert_eq!(u16::from(r#element_position), 20); // <assertEquals actual="elementPosition" expected="20" id="nodecomparedocumentpositionIsContainedFollowing35" ignoreCase="false"/>
                r#attr_position = r#attr.compare_document_position(&r#elem.into()); // <compareDocumentPosition var="attrPosition" obj="attr" other="elem"/>
                assert_eq!(u16::from(r#attr_position), 10); // <assertEquals actual="attrPosition" expected="10" id="nodecomparedocumentpositionPRECEDINGContains35" ignoreCase="false"/>
            }
            // attrgetschematypeinfo08.xml
            #[test]
            fn test_attrgetschematypeinfo08() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#ac_elem; // type: Element // <var name="acElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#attr_type_info; // type: TypeInfo // <var name="attrTypeInfo" type="TypeInfo"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // let mut r#type_namespace; // type: DOMString // <var name="typeNamespace" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#ac_elem = r#elem_list.item(0).unwrap(); // <item var="acElem" obj="elemList" index="0" interface="NodeList"/>
                // r#attr = r#ac_elem.get_attribute_node("title").unwrap(); // <getAttributeNode var="attr" obj="acElem" name="&quot;title&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="attrTypeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <typeName var="typeName" obj="attrTypeInfo"/>

                // // unimplemented: // <typeNamespace var="typeNamespace" obj="attrTypeInfo"/>
                // assert_eq!(r#type_name, "string"); // <assertEquals expected="&quot;string&quot;" actual="typeName" id="attrgetschematypeinfo08_typeName" ignoreCase="false"/>
                // assert_eq!(r#type_namespace, "http://www.w3.org/2001/XMLSchema");
                // // <assertEquals actual="typeNamespace" expected="&quot;http://www.w3.org/2001/XMLSchema&quot;" id="attrgetschematypeinfo08_typeNamespace" ignoreCase="false"/>
            }
            // documentadoptnode06.xml
            #[test]
            fn test_documentadoptnode06() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                // let mut r#new_text; // type: Text // <var name="newText" type="Text"/>
                // let mut r#new_ent_ref; // type: EntityReference // <var name="newEntRef" type="EntityReference"/>
                // let mut r#adopted_attr; // type: Attr // <var name="adoptedAttr" type="Attr"/>
                // let mut r#adopt_text; // type: Text // <var name="adoptText" type="Text"/>
                // let mut r#adopt_ent_ref; // type: EntityReference // <var name="adoptEntRef" type="EntityReference"/>
                // let mut r#node_list; // type: NodeList // <var name="nodeList" type="NodeList"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#node_namespace_uri; // type: DOMString // <var name="nodeNamespaceURI" type="DOMString"/>
                // let mut r#node_prefix; // type: DOMString // <var name="nodePrefix" type="DOMString"/>
                // let mut r#attr_owner_elem; // type: Element // <var name="attrOwnerElem" type="Element"/>
                // let mut r#is_specified; // type: boolean // <var name="isSpecified" type="boolean"/>
                // let mut r#adopted_text_node_value; // type: DOMString // <var name="adoptedTextNodeValue" type="DOMString"/>
                // let mut r#adopted_ent_ref_node_value; // type: DOMString // <var name="adoptedEntRefNodeValue" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // let mut r#xml_ns = "http://www.w3.org/XML/1998/namespace"; // type: DOMString // <var name="xmlNS" type="DOMString" value="&quot;http://www.w3.org/XML/1998/namespace&quot;"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#new_attr = r#doc
                //     .create_attribute_ns(Some(r#xml_ns.as_ref()), "xml:lang".as_ref())
                //     .unwrap(); // <createAttributeNS var="newAttr" obj="doc" namespaceURI="xmlNS" qualifiedName="&quot;xml:lang&quot;"/>
                // r#new_text = r#doc.create_text_node("Text Node"); // <createTextNode var="newText" obj="doc" data="&quot;Text Node&quot;"/>
                // r#new_ent_ref = r#doc.create_entity_reference("alpha".to_string()).unwrap(); // <createEntityReference var="newEntRef" obj="doc" name="&quot;alpha&quot;"/>
                // r#appended_child = r#new_attr.append_child(new_text.into()).unwrap(); // <appendChild obj="newAttr" var="appendedChild" newChild="newText"/>
                // r#appended_child = r#new_attr.append_child(new_ent_ref.into()).unwrap(); // <appendChild obj="newAttr" var="appendedChild" newChild="newEntRef"/>
                // r#adopted_attr = r#new_doc.adopt_node(r#new_attr.into()); // <adoptNode var="adoptedAttr" obj="newDoc" source="newAttr"/>

                // // unimplemented: // <if><notNull obj="adoptedAttr"/><nodeName var="nodeName" obj="adoptedAttr"/><namespaceURI var="nodeNamespaceURI" obj="adoptedAttr" interface="Node"/><prefix var="nodePrefix" obj="adoptedAttr"/><ownerElement var="attrOwnerElem" obj="adoptedAttr" interface="Attr"/><specified var="isSpecified" obj="adoptedAttr"/><assertEquals expected="&quot;xml:lang&quot;" actual="nodeName" id="documentadoptnode06_nodeName" ignoreCase="false"/><assertEquals expected="xmlNS" actual="nodeNamespaceURI" id="documentadoptnode06_namespaceURI" ignoreCase="false"/><assertEquals expected="&quot;xml&quot;" actual="nodePrefix" id="documentadoptnode06_prefix" ignoreCase="false"/><assertNull actual="attrOwnerElem" id="documentadoptnode06_ownerDoc"/><assertTrue actual="isSpecified" id="documentadoptnode06_specified"/><childNodes var="nodeList" obj="adoptedAttr"/><item var="adoptText" obj="nodeList" index="0" interface="NodeList"/><item var="adoptEntRef" obj="nodeList" index="1" interface="NodeList"/><nodeValue var="adoptedTextNodeValue" obj="adoptText"/><nodeName var="adoptedEntRefNodeValue" obj="adoptEntRef"/><assertEquals expected="&quot;Text Node&quot;" actual="adoptedTextNodeValue" id="documentadoptnode06_TextNodeValue" ignoreCase="false"/><assertEquals expected="&quot;alpha&quot;" actual="adoptedEntRefNodeValue" id="documentadoptnode06_EntRefNodeValue" ignoreCase="false"/></if>
            }
            // typeinfoisderivedfrom09.xml
            #[test]
            fn test_typeinfoisderivedfrom09() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>
                // r#attr = r#acronym_elem.get_attribute_node("class").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;class&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "classType"); // <assertEquals actual="typeName" expected="&quot;classType&quot;" ignoreCase="false" id="nameIsString"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anySimpleType&quot;" derivationMethod="15"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromAnySimpleType"/>
            }
            // entitygetxmlversion03.xml
            #[test]
            fn test_entitygetxmlversion03() {
                // // unimplemented: // <implementationAttribute name="validating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#entity_version; // type: DOMString // <var name="entityVersion" type="DOMString"/>
                // r#doc = todo!(); // external_barfoo.xml // <load var="doc" href="external_barfoo" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#entity = r#entities_map.get_named_item("ent2".into()).unwrap(); // <getNamedItem var="entity" obj="entitiesMap" name="&quot;ent2&quot;"/>
                // r#entity_version = r#entity.xml_version().unwrap().to_string(); // <xmlVersion obj="entity" var="entityVersion" interface="Entity"/>

                // // unimplemented: // <assertNull actual="entityVersion" id="xmlVersionNull"/>
            }
            // documentrenamenode17.xml
            #[test]
            fn test_documentrenamenode17() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#renamed_node; // type: Node // <var name="renamedNode" type="Node"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_tagname; // type: DOMString // <var name="rootTagname" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_tagname = r#doc_elem.tag_name().to_string(); // <tagName var="rootTagname" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootTagname" doctype="nullDocType"/>
                // r#element = r#new_doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "body".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="element" obj="newDoc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;body&quot;"/>
                // r#renamed_node = r#new_doc
                //     .rename_node(
                //         r#element.into(),
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "xhtml:head",
                //     )
                //     .unwrap(); // <renameNode var="renamedNode" obj="newDoc" n="element" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:head&quot;"/>
                // r#node_name = r#renamed_node.node_name().to_string(); // <nodeName var="nodeName" obj="renamedNode"/>
                // r#namespace_uri = r#renamed_node.namespace_uri().unwrap().to_string(); // <namespaceURI var="namespaceURI" obj="renamedNode" interface="Node"/>
                // r#node_type = r#renamed_node.node_type(); // <nodeType var="nodeType" obj="renamedNode"/>
                // assert_eq!(r#node_name, "xhtml:head"); // <assertEquals expected="&quot;xhtml:head&quot;" actual="nodeName" id="documentrenamenode16_nodeName" ignoreCase="false"/>
                // assert_eq!(r#node_type as i32, 1); // <assertEquals expected="1" actual="nodeType" id="documentrenamenode16_nodeType" ignoreCase="false"/>
                // assert_eq!(r#namespace_uri, "http://www.w3.org/1999/xhtml"); // <assertEquals expected="&quot;http://www.w3.org/1999/xhtml&quot;" actual="namespaceURI" id="documentrenamenode16_nodeValue" ignoreCase="false"/>
            }
            // datatypenormalization18.xml
            #[test]
            fn test_datatypenormalization18() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#str; // type: DOMString // <var name="str" type="DOMString"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#can_set_xml_schema; // type: boolean // <var name="canSetXMLSchema" type="boolean"/>
                // let mut r#can_set_data_norm; // type: boolean // <var name="canSetDataNorm" type="boolean"/>
                // let mut r#xsd_ns; // type: DOMString // <var name="xsdNS" type="DOMString" value="&quot;http://www.w3.org/2001/XMLSchema&quot;"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#child_node; // type: Node // <var name="childNode" type="Node"/>
                // let mut r#child_value; // type: DOMString // <var name="childValue" type="DOMString"/>
                // r#doc = todo!(); // datatype_normalization2.xml // <load var="doc" href="datatype_normalization2" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetValidate" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetXMLSchema" obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>

                // // unimplemented: // <canSetParameter var="canSetDataNorm" obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>

                // // unimplemented: // <if>	<and>		<isTrue value="canSetValidate"/>		<isTrue value="canSetXMLSchema"/>		<isTrue value="canSetDataNorm"/>			</and>	<setParameter obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>	<normalize obj="doc"/>	<!--  fail test if normalize had any errors or fatal errors   -->	<assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>	<getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" localName="&quot;code&quot;" interface="Document"/>	<item var="element" obj="elemList" interface="NodeList" index="1"/>	<firstChild var="childNode" obj="element" interface="Node"/>	<nodeValue var="childValue" obj="childNode"/>	<assertEquals actual="childValue" expected="&quot;EMP  0001&quot;" ignoreCase="false" id="content2"/>	<item var="element" obj="elemList" interface="NodeList" index="2"/>	<firstChild var="childNode" obj="element" interface="Node"/>	<nodeValue var="childValue" obj="childNode"/>	<assertEquals actual="childValue" expected="&quot;EMP 0001&quot;" ignoreCase="false" id="content3"/>	<item var="element" obj="elemList" interface="NodeList" index="0"/>	<firstChild var="childNode" obj="element" interface="Node"/>	<nodeValue var="childValue" obj="childNode"/>	<assertNotEquals actual="childValue" expected="&quot;EMP 0001&quot;" ignoreCase="false" id="content1"/></if>
            }
            // elementsetidattributens14.xml
            #[test]
            fn test_elementsetidattributens14() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "p"); // <getElementsByTagNameNS var="elemList" obj="doc" localName="&quot;p&quot;" namespaceURI="&quot;*&quot;" interface="Document"/>
                r#p_elem = r#elem_list.item(1).unwrap(); // <item var="pElem" obj="elemList" index="1" interface="NodeList"/>
                r#elem_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "acronym"); // <getElementsByTagNameNS var="elemList" obj="doc" localName="&quot;acronym&quot;" namespaceURI="&quot;*&quot;" interface="Document"/>
                r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>
                r#p_elem
                    .set_id_attribute_ns(Some("http://www.w3.org/2000/xmlns/"), "dmstc", true)
                    .unwrap(); // <setIdAttributeNS obj="pElem" localName="&quot;dmstc&quot;" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" isId="true"/>
                r#acronym_elem
                    .set_id_attribute_ns(
                        Some("http://www.w3.org/2001/XMLSchema-instance"),
                        "noNamespaceSchemaLocation",
                        true,
                    )
                    .unwrap(); // <setIdAttributeNS obj="acronymElem" localName="&quot;noNamespaceSchemaLocation&quot;" namespaceURI="&quot;http://www.w3.org/2001/XMLSchema-instance&quot;" isId="true"/>
                r#attributes_map = r#p_elem.attributes(); // <attributes var="attributesMap" obj="pElem"/>
                r#attr = r#attributes_map.get_named_item("xmlns:dmstc").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;xmlns:dmstc&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributensIsId1True14"/>
                r#attributes_map = r#acronym_elem.attributes(); // <attributes var="attributesMap" obj="acronymElem"/>
                r#attr = r#attributes_map
                    .get_named_item("xsi:noNamespaceSchemaLocation")
                    .unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;xsi:noNamespaceSchemaLocation&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributensIsId2True14"/>
                r#elem = r#doc.get_element_by_id("Yes".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;Yes&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "acronym"); // <assertEquals actual="elemName" expected="&quot;acronym&quot;" id="elementsetidattributens1GetElementById14" ignoreCase="false"/>
                r#elem = r#doc
                    .get_element_by_id("http://www.usa.com".as_ref())
                    .unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;http://www.usa.com&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "p"); // <assertEquals actual="elemName" expected="&quot;p&quot;" id="elementsetidattributens2GetElementById14" ignoreCase="false"/>
            }
            // domconfigcomments1.xml
            #[test]
            fn test_domconfigcomments1() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // let mut r#parameter; // type: DOMString // <var name="parameter" type="DOMString" value="&quot;cOmments&quot;"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDocType"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(r#state); // <assertTrue actual="state" id="defaultFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="false"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="true"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetTrue"/>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="false"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(!r#state); // <assertFalse actual="state" id="setFalseEffective"/>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="true"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(r#state); // <assertTrue actual="state" id="setTrueEffective"/>
            }
            // nodegetuserdata05.xml
            #[test]
            fn test_nodegetuserdata05() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#user_data; // type: DOMUserData // <var name="userData" type="DOMUserData"/>
                // let mut r#ret_user_data; // type: DOMUserData // <var name="retUserData" type="DOMUserData"/>
                // let mut r#null_handler; // type: UserDataHandler // <var name="nullHandler" type="UserDataHandler" isNull="true"/>
                // let mut r#prev_user_data; // type: DOMUserData // <var name="prevUserData" type="DOMUserData"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entities" obj="docType"/>
                // r#entity = r#entities.get_named_item("delta".into()).unwrap(); // <getNamedItem var="entity" obj="entities" name="&quot;delta&quot;"/>
                // r#attr = r#doc
                //     .create_attribute_ns(
                //         Some("http://www.w3.org/XML/1998/namespace"),
                //         "lang".as_ref(),
                //     )
                //     .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;lang&quot;"/>

                // // unimplemented: // <setUserData obj="entity" var="prevUserData" key="&quot;key&quot;" data="attr" handler="nullHandler"/>

                // // unimplemented: // <getUserData var="retUserData" obj="entity" key="&quot;Key&quot;"/>

                // // unimplemented: // <assertNull actual="retUserData" id="nodegetuserdata05"/>
            }
            // documentadoptnode32.xml
            #[test]
            fn test_documentadoptnode32() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_adopter: DocumentRef; // <var name="docAdopter" type="Document"/>
                // let mut r#new_cdata; // type: Node // <var name="newCDATA" type="Node"/>
                // let mut r#adopted_cdata; // type: Node // <var name="adoptedCDATA" type="Node"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_adopter = todo!(); // hc_staff.xml // <load var="docAdopter" href="hc_staff" willBeModified="true"/>
                // r#new_cdata = r#doc
                //     .create_cdata_section("Document.adoptNode test for a CDATASECTION_NODE")
                //     .unwrap(); // <createCDATASection var="newCDATA" obj="doc" data="&quot;Document.adoptNode test for a CDATASECTION_NODE&quot;"/>
                // r#adopted_cdata = r#doc_adopter.adopt_node(r#new_cdata.into()); // <adoptNode var="adoptedCDATA" obj="docAdopter" source="newCDATA"/>

                // // unimplemented: // <if><notNull obj="adoptedCDATA"/><nodeValue var="nodeValue" obj="adoptedCDATA"/><assertEquals actual="nodeValue" expected="&quot;Document.adoptNode test for a CDATASECTION_NODE&quot;" id="documentadoptnode32" ignoreCase="false"/></if>
            }
            // wellformed03.xml
            #[test]
            fn test_wellformed03() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#null_doctype; // type: DocumentType // <var name="nullDoctype" type="DocumentType" isNull="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#errors; // type: List // <var name="errors" type="List"/>
                // let mut r#error; // type: DOMError // <var name="error" type="DOMError"/>
                // let mut r#severity; // type: int // <var name="severity" type="int"/>
                // let mut r#type; // type: DOMString // <var name="type" type="DOMString"/>
                // let mut r#locator; // type: DOMLocator // <var name="locator" type="DOMLocator"/>
                // let mut r#related_node; // type: Node // <var name="relatedNode" type="Node"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDoctype"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>

                // // unimplemented: // <assertDOMException id="xml10InvalidName">	<INVALID_CHARACTER_ERR>		<createAttribute var="attr" obj="doc" name="&quot;LegalName&quot;"/>	</INVALID_CHARACTER_ERR></assertDOMException>

                // // unimplemented: // <try>	<xmlVersion obj="doc" value="&quot;1.1&quot;" interface="Document"/>	<catch>		<DOMException code="NOT_SUPPORTED_ERR">			<return/>		</DOMException>	</catch></try>
                // r#doc_elem
                //     .set_attribute("LegalName".into(), "foo".into())
                //     .unwrap(); // <setAttribute obj="docElem" name="&quot;LegalName&quot;" value="&quot;foo&quot;"/>
                // r#attr = r#doc_elem.get_attribute_node("LegalName".into()).unwrap(); // <getAttributeNode var="attr" obj="docElem" name="&quot;LegalName&quot;"/>
                // r#doc.set_xml_version("1.0").unwrap(); // <xmlVersion obj="doc" value="&quot;1.0&quot;" interface="Document"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;well-formed&quot;" value="true"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <allErrors var="errors" obj="errorMonitor"/>

                // // unimplemented: // <for-each member="error" collection="errors">	<severity var="severity" obj="error"/>	<assertEquals actual="severity" expected="2" ignoreCase="false" id="severity"/>	<type var="type" obj="error" interface="DOMError"/>	<assertEquals actual="type" expected="&quot;wf-invalid-character-in-node-name&quot;" ignoreCase="false" id="type"/>	<location var="locator" obj="error" interface="DOMError"/>	<relatedNode var="relatedNode" obj="locator" interface="DOMLocator"/>	<assertSame actual="relatedNode" expected="attr" id="relatedNode"/></for-each>

                // // unimplemented: // <assertSize size="1" collection="errors" id="oneError"/>
            }
            // domimplementationregistry04.xml
            #[test]
            fn test_domimplementationregistry04() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#has_feature; // type: boolean // <var name="hasFeature" type="boolean"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementation var="domImpl" obj="domImplRegistry" features="&quot;+cOrE&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImpl" id="domImplNotNull"/>

                // // unimplemented: // <hasFeature var="hasFeature" obj="domImpl" feature="&quot;+Core&quot;" version="nullVersion"/>
                // assert!(r#has_feature); // <assertTrue actual="hasFeature" id="hasCore"/>
            }
            // nodecomparedocumentposition05.xml
            #[test]
            fn test_nodecomparedocumentposition05() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#document_position1; // type: int // <var name="documentPosition1" type="int"/>
                // let mut r#document_position2; // type: int // <var name="documentPosition2" type="int"/>
                // let mut r#document_position3; // type: int // <var name="documentPosition3" type="int"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" qualifiedName="rootName" namespaceURI="rootNS" doctype="nullDocType"/>
                // r#document_position1 = r#doc.compare_document_position(&r#new_doc.into()); // <compareDocumentPosition var="documentPosition1" obj="doc" other="newDoc"/>
                // assert_eq!(u16::from(r#document_position1), 33); // <assertEquals bitmask="57" actual="documentPosition1" expected="33" id="isImplSpecificDisconnected1" ignoreCase="false"/>
                // r#document_position2 = r#new_doc.compare_document_position(&r#doc.into()); // <compareDocumentPosition var="documentPosition2" obj="newDoc" other="doc"/>
                // assert_eq!(u16::from(r#document_position2), 33); // <assertEquals bitmask="57" actual="documentPosition2" expected="33" id="isImplSpecificDisconnected2" ignoreCase="false"/>

                // // unimplemented: // <assertNotEquals bitmask="2" actual="documentPosition2" expected="documentPosition1" id="notBothPreceding" ignoreCase="false"/>

                // // unimplemented: // <assertNotEquals bitmask="4" actual="documentPosition2" expected="documentPosition1" id="notBothFollowing" ignoreCase="false"/>
                // r#document_position3 = r#doc.compare_document_position(&r#new_doc.into()); // <compareDocumentPosition var="documentPosition3" obj="doc" other="newDoc"/>
                // assert_eq!(r#document_position3, document_position1); // <assertEquals actual="documentPosition3" expected="documentPosition1" id="isConsistent" ignoreCase="false"/>
            }
            // nodelookupnamespaceuri16.xml
            #[test]
            fn test_nodelookupnamespaceuri16() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#att_node; // type: Attr // <var name="attNode" type="Attr"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "dom3:p".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:p&quot;"/>
                r#attr = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/XML/1998/namespace"),
                        "xml:lang".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>
                r#att_node = r#elem.set_attribute_node_ns(r#attr).unwrap().unwrap(); // <setAttributeNodeNS obj="elem" var="attNode" newAttr="attr"/>
                r#namespace_uri = r#attr.lookup_namespace_uri("xml").unwrap().to_string();
                // <lookupNamespaceURI var="namespaceURI" obj="attr" prefix="&quot;xml&quot;" interface="Node"/>

                // unimplemented: // <assertNull actual="namespaceURI" id="nodelookupnamespaceuri16"/>
            }
            // nodereplacechild15.xml
            #[test]
            fn test_nodereplacechild15() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem2; // type: Element // <var name="elem2" type="Element"/>
                // let mut r#replaced; // type: Element // <var name="replaced" type="Element"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#title; // type: DOMString // <var name="title" type="DOMString"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#elem = r#doc
                //     .create_element_ns(Some(r#root_ns.as_ref()), r#root_name.as_ref())
                //     .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="rootNS" qualifiedName="rootName"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                // r#elem2 = r#doc
                //     .create_element_ns(Some(r#root_ns.as_ref()), r#root_name.as_ref())
                //     .unwrap(); // <createElementNS var="elem2" obj="doc" namespaceURI="rootNS" qualifiedName="rootName"/>
                // r#elem2.set_attribute("title", "new element").unwrap(); // <setAttribute obj="elem2" name="&quot;title&quot;" value="&quot;new element&quot;"/>
                // r#appended_child = r#doc_frag.append_child(elem2.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="elem2"/>
                // r#replaced = r#doc_frag
                //     .replace_child(elem.into(), elem2.into())
                //     .unwrap()
                //     .as_element()
                //     .unwrap(); // <replaceChild var="replaced" obj="docFrag" oldChild="elem2" newChild="elem"/>
                // r#title = r#replaced.get_attribute("title".into()).unwrap(); // <getAttribute var="title" obj="replaced" name="&quot;title&quot;"/>
                // assert_eq!(r#title, "new element"); // <assertEquals actual="title" expected="&quot;new element&quot;" id="nodereplacechild15" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom49.xml
            #[test]
            fn test_typeinfoisderivedfrom49() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // typeinfo.xml // <load var="doc" href="typeinfo" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;double&quot;" derivationMethod="8"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromDoubleList"/>
            }
            // hasFeature02.xml
            #[test]
            fn test_has_feature02() {
                // let mut r#impl; // type: DOMImplementation // <var name="impl" type="DOMImplementation"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>

                // // unimplemented: // <implementation var="impl"/>

                // // unimplemented: // <hasFeature var="state" obj="impl" feature="&quot;cOrE&quot;" version="&quot;3.0&quot;"/>
                // assert!(r#state); // <assertTrue id="hasCore30" actual="state"/>
            }
            // typeinfoisderivedfrom23.xml
            #[test]
            fn test_typeinfoisderivedfrom23() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "strongType"); // <assertEquals actual="typeName" expected="&quot;strongType&quot;" ignoreCase="false" id="typeName"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;string&quot;" derivationMethod="8"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromStringList"/>
            }
            // documentgetstricterrorchecking02.xml
            #[test]
            fn test_documentgetstricterrorchecking02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#strict_error_checking_value; // type: boolean // <var name="strictErrorCheckingValue" type="boolean"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>

                // // unimplemented: // <strictErrorChecking var="strictErrorCheckingValue" obj="newDoc"/>
                // assert!(r#strict_error_checking_value); // <assertTrue actual="strictErrorCheckingValue" id="documentgetstricterrorchecking02"/>
            }
            // documentsetxmlversion03.xml
            #[test]
            fn test_documentsetxmlversion03() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#version_value; // type: DOMString // <var name="versionValue" type="DOMString"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#new_doc.set_xml_version("1.1").unwrap(); // <xmlVersion obj="newDoc" value="&quot;1.1&quot;" interface="Document"/>
                // r#version_value = r#new_doc.xml_version().unwrap().to_string(); // <xmlVersion var="versionValue" obj="newDoc" interface="Document"/>
                // assert_eq!(r#version_value, "1.1"); // <assertEquals actual="versionValue" expected="&quot;1.1&quot;" id="documentsetxmlversion03" ignoreCase="false"/>
            }
            // domconfigcheckcharacternormalization1.xml
            #[test]
            fn test_domconfigcheckcharacternormalization1() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // let mut r#parameter; // type: DOMString // <var name="parameter" type="DOMString" value="&quot;cHeCk-character-normalization&quot;"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDocType"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(!r#state); // <assertFalse actual="state" id="defaultFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="false"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="true"/>

                // // unimplemented: // <if>  	  <isTrue value="canSet"/>  	  <setParameter obj="domConfig" name="parameter" value="true"/>  	  <getParameter var="state" obj="domConfig" name="parameter"/>  	  <assertTrue actual="state" id="setTrueEffective"/>  	  <else>  	  	  <assertDOMException id="throw_NOT_SUPPORTED_ERR">  	  	  	<NOT_SUPPORTED_ERR>  	  			<setParameter obj="domConfig" name="parameter" value="true"/>  	  		</NOT_SUPPORTED_ERR>  	  	  </assertDOMException>  	  	  <!--  should still be false after failed attempt  -->  	  	  <getParameter var="state" obj="domConfig" name="parameter"/>  	      <assertFalse actual="state" id="setTrueNotEffective"/>  	  </else>  </if>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="false"/>
            }
            // documentadoptnode13.xml
            #[test]
            fn test_documentadoptnode13() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_fragment; // type: DocumentFragment // <var name="docFragment" type="DocumentFragment"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                // let mut r#acronym_node; // type: Node // <var name="acronymNode" type="Node"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#adopted_doc_frag; // type: Node // <var name="adoptedDocFrag" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_fragment = r#doc.create_document_fragment(); // <createDocumentFragment var="docFragment" obj="doc"/>
                // r#child_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_node = r#child_list.item(0).unwrap().clone(); // <item var="acronymNode" obj="childList" index="0" interface="NodeList"/>
                // r#appended_child = r#doc_fragment.append_child(acronym_node.into()).unwrap(); // <appendChild obj="docFragment" var="appendedChild" newChild="acronymNode"/>
                // r#adopted_doc_frag = r#doc.adopt_node(r#doc_fragment.into()); // <adoptNode var="adoptedDocFrag" obj="doc" source="docFragment"/>

                // // unimplemented: // <if><notNull obj="adoptedDocFrag"/><hasChildNodes var="success" obj="adoptedDocFrag"/><assertTrue actual="success" id="documentadoptnode13"/></if>
            }
            // typeinfoisderivedfrom26.xml
            #[test]
            fn test_typeinfoisderivedfrom26() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "strongType"); // <assertEquals actual="typeName" expected="&quot;strongType&quot;" ignoreCase="false" id="typeName"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anyType&quot;" derivationMethod="1"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromAnyType"/>
            }
            // nodelookupprefix10.xml
            #[test]
            fn test_nodelookupprefix10() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#parent; // type: Element // <var name="parent" type="Element"/>
                let mut r#child; // type: Element // <var name="child" type="Element"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#parent = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "dom3:p".as_ref())
                    .unwrap(); // <createElementNS var="parent" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:p&quot;"/>
                r#child = r#doc.create_element("br".to_string()).unwrap(); // <createElement var="child" obj="doc" tagName="&quot;br&quot;"/>
                r#appended_child = r#parent.append_child(child.into()).unwrap(); // <appendChild obj="parent" var="appendedChild" newChild="child"/>
                r#prefix = r#child
                    .lookup_prefix("http://www.w3.org/1999/xhtml")
                    .unwrap()
                    .to_string(); // <lookupPrefix var="prefix" obj="child" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>
                assert_eq!(r#prefix, "dom3"); // <assertEquals actual="prefix" expected="&quot;dom3&quot;" id="nodelookupprefix10" ignoreCase="false"/>
            }
            // documentadoptnode07.xml
            #[test]
            fn test_documentadoptnode07() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#adopted_doc; // type: Node // <var name="adoptedDoc" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><adoptNode var="adoptedDoc" obj="doc" source="doc"/></NOT_SUPPORTED_ERR></assertDOMException>
            }
            // nodegettextcontent04.xml
            #[test]
            fn test_nodegettextcontent04() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                // let mut r#null_pub_id; // type: DOMString // <var name="nullPubId" type="DOMString" isNull="true"/>
                // let mut r#null_sys_id; // type: DOMString // <var name="nullSysId" type="DOMString" isNull="true"/>
                // let mut r#old_doc_type; // type: DocumentType // <var name="oldDocType" type="DocumentType"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#old_doc_type = r#doc.doctype().unwrap(); // <doctype var="oldDocType" obj="doc"/>
                // r#root_name = r#old_doc_type.name().to_string(); // <name var="rootName" obj="oldDocType" interface="DocumentType"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocumentType var="docType" obj="domImpl" qualifiedName="rootName" publicId="nullPubId" systemId="nullSysId"/>
                // r#text_content = r#doc_type.text_content().unwrap(); // <textContent var="textContent" obj="docType"/>

                // // unimplemented: // <assertNull actual="textContent" id="nodegettextcontent04"/>
            }
            // noderemovechild13.xml
            #[test]
            fn test_noderemovechild13() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                // let mut r#e_ref; // type: EntityReference // <var name="eRef" type="EntityReference"/>
                // let mut r#removed; // type: Node // <var name="removed" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#e_ref = r#doc.create_entity_reference("alpha".to_string()).unwrap(); // <createEntityReference var="eRef" obj="doc" name="&quot;alpha&quot;"/>
                // r#txt = r#e_ref.first_child().unwrap(); // <firstChild obj="eRef" var="txt" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="txt" id="txtNotNull"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">	<NO_MODIFICATION_ALLOWED_ERR>		<removeChild obj="eRef" var="removed" oldChild="txt"/>	</NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // nodegettextcontent09.xml
            #[test]
            fn test_nodegettextcontent09() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "p".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;p&quot;"/>
                r#txt = r#doc.create_text_node("Replacement Text"); // <createTextNode var="txt" obj="doc" data="&quot;Replacement Text&quot;"/>
                r#appended_child = r#elem.append_child(txt.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="txt"/>
                r#text_content = r#txt.text_content().unwrap(); // <textContent var="textContent" obj="txt"/>
                assert_eq!(r#text_content, "Replacement Text"); // <assertEquals actual="textContent" expected="&quot;Replacement Text&quot;" id="nodegettextcontent09" ignoreCase="false"/>
            }
            // nodecomparedocumentposition02.xml
            #[test]
            fn test_nodecomparedocumentposition02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc_type; // type: DocumentType // <var name="newDocType" type="DocumentType"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#document_position_doc; // type: int // <var name="documentPositionDoc" type="int"/>
                // let mut r#document_position_doc_type; // type: int // <var name="documentPositionDocType" type="int"/>
                // let mut r#null_pub_id; // type: DOMString // <var name="nullPubId" type="DOMString" isNull="true"/>
                // let mut r#null_sys_id; // type: DOMString // <var name="nullSysId" type="DOMString" isNull="true"/>
                // let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                // r#root_name = r#doc_type.name().to_string(); // <name var="rootName" obj="docType" interface="DocumentType"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocumentType var="newDocType" obj="domImpl" qualifiedName="rootName" publicId="nullPubId" systemId="nullSysId"/>
                // r#replaced = r#doc
                //     .replace_child(new_doc_type.into(), doc_type.into())
                //     .unwrap(); // <replaceChild obj="doc" var="replaced" newChild="newDocType" oldChild="docType"/>
                // r#document_position_doc = r#doc.compare_document_position(&r#new_doc_type.into()); // <compareDocumentPosition var="documentPositionDoc" obj="doc" other="newDocType"/>
                // assert_eq!(u16::from(r#document_position_doc), 20); // <assertEquals actual="documentPositionDoc" expected="20" id="nodecomparedocumentpositionIsContainedFollowing02" ignoreCase="false"/>
                // r#document_position_doc_type =
                //     r#new_doc_type.compare_document_position(&r#doc.into()); // <compareDocumentPosition var="documentPositionDocType" obj="newDocType" other="doc"/>
                // assert_eq!(u16::from(r#document_position_doc_type), 10); // <assertEquals actual="documentPositionDocType" expected="10" id="nodecomparedocumentpositionContainsPRECEDING02" ignoreCase="false"/>
            }
            // canonicalform08.xml
            #[test]
            fn test_canonicalform08() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // // unimplemented: // <implementationAttribute name="validating" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#body_list; // type: NodeList // <var name="bodyList" type="NodeList"/>
                // let mut r#body; // type: Element // <var name="body" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // r#doc = todo!(); // canonicalform01.xml // <load var="doc" href="canonicalform01" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;canonical-form&quot;" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;canonical-form&quot;" value="true"/><setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/><normalizeDocument obj="doc"/><!--  fail test if normalize had any errors or fatal errors   --><assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/><firstChild var="node" obj="doc" interface="Node"/><nodeType var="nodeType" obj="node" interface="Node"/><assertEquals expected="7" actual="nodeType" ignoreCase="false" id="PIisFirstChild"/><data var="nodeValue" obj="node" interface="ProcessingInstruction"/><length var="length" obj="nodeValue" interface="DOMString"/><assertEquals actual="length" expected="36" ignoreCase="false" id="piDataLength"/><!--  next sibling is a #0A line feed  --><nextSibling interface="Node" var="node" obj="node"/><nodeType var="nodeType" obj="node"/><assertEquals expected="3" actual="nodeType" ignoreCase="false" id="TextisSecondChild"/><nodeValue var="nodeValue" obj="node"/><length var="length" obj="nodeValue" interface="DOMString"/><assertEquals actual="length" expected="1" ignoreCase="false" id="secondChildLength"/><!--  next sibling is document element  --><nextSibling interface="Node" var="node" obj="node"/><nodeType var="nodeType" obj="node"/><assertEquals expected="1" actual="nodeType" ignoreCase="false" id="ElementisThirdChild"/><!--  next sibling is a #0A line feed  --><nextSibling interface="Node" var="node" obj="node"/><nodeType var="nodeType" obj="node"/><assertEquals expected="3" actual="nodeType" ignoreCase="false" id="TextisFourthChild"/><nodeValue var="nodeValue" obj="node"/><length var="length" obj="nodeValue" interface="DOMString"/><assertEquals actual="length" expected="1" ignoreCase="false" id="fourthChildLength"/><!--  next sibling is a processing instruction  --><nextSibling interface="Node" var="node" obj="node"/><nodeType var="nodeType" obj="node"/><assertEquals expected="7" actual="nodeType" ignoreCase="false" id="PIisFifthChild"/><data var="nodeValue" obj="node" interface="ProcessingInstruction"/><assertEquals actual="nodeValue" expected="&quot;&quot;" ignoreCase="false" id="trailingPIData"/><!--  next sibling is a #0A line feed  --><nextSibling interface="Node" var="node" obj="node"/><nodeType var="nodeType" obj="node"/><assertEquals expected="3" actual="nodeType" ignoreCase="false" id="TextisSixthChild"/><nodeValue var="nodeValue" obj="node"/><length var="length" obj="nodeValue" interface="DOMString"/><assertEquals actual="length" expected="1" ignoreCase="false" id="sixthChildLength"/><!--  next sibling is a comment  --><nextSibling interface="Node" var="node" obj="node"/><nodeType var="nodeType" obj="node"/><assertEquals expected="8" actual="nodeType" ignoreCase="false" id="CommentisSeventhChild"/><!--  next sibling is a #0A line feed  --><nextSibling interface="Node" var="node" obj="node"/><nodeType var="nodeType" obj="node"/><assertEquals expected="3" actual="nodeType" ignoreCase="false" id="TextisEighthChild"/><nodeValue var="nodeValue" obj="node"/><length var="length" obj="nodeValue" interface="DOMString"/><assertEquals actual="length" expected="1" ignoreCase="false" id="eighthChildLength"/><!--  next sibling is a comment  --><nextSibling interface="Node" var="node" obj="node"/><nodeType var="nodeType" obj="node"/><assertEquals expected="8" actual="nodeType" ignoreCase="false" id="CommentisNinthChild"/><!--  next sibling is a null  --><nextSibling interface="Node" var="node" obj="node"/><assertNull actual="node" id="TenthIsNull"/></if>
            }
            // namespacedeclarations02.xml
            #[test]
            fn test_namespacedeclarations02() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#xmlns_attr; // type: Attr // <var name="xmlnsAttr" type="Attr"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;namespace-declarations&quot;" value="false"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#xmlns_attr = r#doc_elem.get_attribute_node("xmlns").unwrap();
                // // <getAttributeNode var="xmlnsAttr" obj="docElem" name="&quot;xmlns&quot;"/>

                // // unimplemented: // <assertNull actual="xmlnsAttr" id="xmlnsAttrNull"/>
            }
            // infoset03.xml
            #[test]
            fn test_infoset03() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#str; // type: DOMString // <var name="str" type="DOMString"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#can_set_xml_schema; // type: boolean // <var name="canSetXMLSchema" type="boolean"/>
                // let mut r#xsd_ns; // type: DOMString // <var name="xsdNS" type="DOMString" value="&quot;http://www.w3.org/2001/XMLSchema&quot;"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#child_node; // type: Node // <var name="childNode" type="Node"/>
                // let mut r#child_value; // type: DOMString // <var name="childValue" type="DOMString"/>
                // let mut r#child_length; // type: int // <var name="childLength" type="int"/>
                // r#doc = todo!(); // datatype_normalization2.xml // <load var="doc" href="datatype_normalization2" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetValidate" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetXMLSchema" obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>

                // // unimplemented: // <if>	<and>		<isTrue value="canSetValidate"/>		<isTrue value="canSetXMLSchema"/>	</and>	<setParameter obj="domConfig" name="&quot;infoset&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>	<normalizeDocument obj="doc"/>	<!--  fail test if normalize had any errors or fatal errors   -->	<assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>	<getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" localName="&quot;code&quot;" interface="Document"/>	<item var="element" obj="elemList" interface="NodeList" index="0"/>	<firstChild var="childNode" obj="element" interface="Node"/>	<nodeValue var="childValue" obj="childNode"/>	<length var="childLength" obj="childValue" interface="DOMString"/>	<assertEquals actual="childLength" expected="18" ignoreCase="false" id="content1"/>	<item var="element" obj="elemList" interface="NodeList" index="1"/>	<firstChild var="childNode" obj="element" interface="Node"/>	<nodeValue var="childValue" obj="childNode"/>	<assertEquals actual="childValue" expected="&quot;EMP  0001&quot;" ignoreCase="false" id="content2"/>	<item var="element" obj="elemList" interface="NodeList" index="2"/>	<firstChild var="childNode" obj="element" interface="Node"/>	<nodeValue var="childValue" obj="childNode"/>	<assertEquals actual="childValue" expected="&quot;EMP 0001&quot;" ignoreCase="false" id="content3"/></if>
            }
            // documentnormalizedocument13.xml
            #[test]
            fn test_documentnormalizedocument13() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                // let mut r#retval; // type: Element // <var name="retval" type="Element"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#errors; // type: List // <var name="errors" type="List"/>
                // let mut r#error; // type: DOMError // <var name="error" type="DOMError"/>
                // let mut r#error_count; // type: int // <var name="errorCount" type="int" value="0"/>
                // let mut r#severity; // type: int // <var name="severity" type="int"/>
                // let mut r#problem_node; // type: Node // <var name="problemNode" type="Node"/>
                // let mut r#location; // type: DOMLocator // <var name="location" type="DOMLocator"/>
                // let mut r#line_number; // type: int // <var name="lineNumber" type="int"/>
                // let mut r#column_number; // type: int // <var name="columnNumber" type="int"/>
                // let mut r#byte_offset; // type: int // <var name="byteOffset" type="int"/>
                // let mut r#utf16_offset; // type: int // <var name="utf16Offset" type="int"/>
                // let mut r#uri; // type: DOMString // <var name="uri" type="DOMString"/>
                // let mut r#type; // type: DOMString // <var name="type" type="DOMString"/>
                // let mut r#message; // type: DOMString // <var name="message" type="DOMString"/>
                // let mut r#related_exception; // type: DOMObject // <var name="relatedException" type="DOMObject"/>
                // let mut r#related_data; // type: DOMObject // <var name="relatedData" type="DOMObject"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#p_list.item(0).unwrap(); // <item var="elem" obj="pList" index="0" interface="NodeList"/>
                // r#elem
                //     .set_attribute("title", "DOM L1 Attribute".into())
                //     .unwrap(); // <setAttribute obj="elem" name="&quot;title&quot;" value="&quot;DOM L1 Attribute&quot;"/>
                // r#new_attr = r#elem.get_attribute_node("title").unwrap(); // <getAttributeNode var="newAttr" obj="elem" name="&quot;title&quot;"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;namespaces&quot;" value="true"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <allErrors var="errors" obj="errorMonitor"/>

                // // unimplemented: // <for-each member="error" collection="errors">	<severity var="severity" obj="error"/>	<if>		<equals actual="severity" expected="2" ignoreCase="false"/>		<!-- location should have relatedNode, everything else should be -1 or null -->		<location var="location" obj="error"/>		<relatedNode var="problemNode" obj="location" interface="DOMLocator"/>		<assertSame actual="problemNode" expected="newAttr" id="relatedNodeIsL1Node"/>		<lineNumber var="lineNumber" obj="location"/>		<assertEquals actual="lineNumber" expected="-1" ignoreCase="false" id="lineNumber"/>		<columnNumber var="columnNumber" obj="location"/>		<assertEquals actual="columnNumber" expected="-1" ignoreCase="false" id="columnNumber"/>		<byteOffset var="byteOffset" obj="location"/>		<assertEquals actual="byteOffset" expected="-1" ignoreCase="false" id="byteOffset"/>		<utf16Offset var="utf16Offset" obj="location"/>		<assertEquals actual="utf16Offset" expected="-1" ignoreCase="false" id="utf16Offset"/>		<uri var="uri" obj="location" interface="DOMLocator"/>		<assertNull actual="uri" id="uri"/>		<!--  message and type should be non-empty  -->		<message var="message" obj="error"/>		<length var="length" obj="message" interface="DOMString"/>		<assertTrue id="messageNotEmpty">			<greater actual="length" expected="0"/>		</assertTrue>		<!--  can't make any assertions about type, relatedData and relatedException		          other than access should not raise exception   -->		<type var="type" obj="error" interface="DOMError"/>		<relatedData var="relatedData" obj="error"/>		<relatedException var="relatedException" obj="error"/>		<increment var="errorCount" value="1"/>		<else>			<assertEquals actual="severity" expected="1" ignoreCase="false" id="anyOthersShouldBeWarnings"/>		</else>	</if></for-each>
                // assert_eq!(r#error_count, 1); // <assertEquals actual="errorCount" expected="1" ignoreCase="false" id="oneError"/>
            }
            // typeinfoisderivedfrom55.xml
            #[test]
            fn test_typeinfoisderivedfrom55() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // typeinfo.xml // <load var="doc" href="typeinfo" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anyType&quot;" derivationMethod="2"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromAnyRestriction"/>
            }
            // nodelookupprefix01.xml
            #[test]
            fn test_nodelookupprefix01() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                // let mut r#null_nsuri; // type: DOMString // <var name="nullNSURI" type="DOMString" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#prefix = r#doc
                //     .lookup_prefix(r#null_nsuri.as_ref())
                //     .unwrap()
                //     .to_string(); // <lookupPrefix var="prefix" obj="doc" namespaceURI="nullNSURI"/>

                // // unimplemented: // <assertNull actual="prefix" id="nodelookupprefix01"/>
            }
            // nodereplacechild23.xml
            #[test]
            fn test_nodereplacechild23() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                // let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                // let mut r#cdata; // type: CDATASection // <var name="cdata" type="CDATASection"/>
                // let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#elem = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "dom3:p".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:p&quot;"/>
                // r#ent_ref = r#doc.create_entity_reference("delta".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;delta&quot;"/>
                // r#txt = r#doc.create_text_node("Text"); // <createTextNode var="txt" obj="doc" data="&quot;Text&quot;"/>
                // r#comment = r#doc.create_comment("Comment"); // <createComment var="comment" obj="doc" data="&quot;Comment&quot;"/>
                // r#cdata = r#doc.create_cdata_section("CDATASection").unwrap(); // <createCDATASection var="cdata" obj="doc" data="&quot;CDATASection&quot;"/>
                // r#pi = r#doc
                //     .create_processing_instruction("target", Some("data"))
                //     .unwrap(); // <createProcessingInstruction var="pi" obj="doc" target="&quot;target&quot;" data="&quot;data&quot;"/>
                // r#appended_child = r#elem.append_child(ent_ref.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="entRef"/>
                // r#appended_child = r#elem.append_child(txt.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="txt"/>
                // r#appended_child = r#elem.append_child(comment.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="comment"/>
                // r#appended_child = r#elem.append_child(pi.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="pi"/>
                // r#appended_child = r#elem.append_child(cdata.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="cdata"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR_1"><NO_MODIFICATION_ALLOWED_ERR><replaceChild obj="entRef" var="replaced" oldChild="elem" newChild="cdata"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR_2"><NO_MODIFICATION_ALLOWED_ERR><replaceChild obj="entRef" var="replaced" oldChild="cdata" newChild="pi"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR_3"><NO_MODIFICATION_ALLOWED_ERR><replaceChild obj="entRef" var="replaced" oldChild="pi" newChild="comment"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR_4"><NO_MODIFICATION_ALLOWED_ERR><replaceChild obj="entRef" var="replaced" oldChild="comment" newChild="txt"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR_5"><NO_MODIFICATION_ALLOWED_ERR><replaceChild obj="entRef" var="replaced" oldChild="txt" newChild="elem"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // documentadoptnode35.xml
            #[test]
            fn test_documentadoptnode35() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#new_pi; // type: ProcessingInstruction // <var name="newPI" type="ProcessingInstruction"/>
                // let mut r#adopted_pi; // type: ProcessingInstruction // <var name="adoptedPI" type="ProcessingInstruction"/>
                // let mut r#pi_target; // type: DOMString // <var name="piTarget" type="DOMString"/>
                // let mut r#pi_data; // type: DOMString // <var name="piData" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#new_pi = r#new_doc
                //     .create_processing_instruction("PITarget", Some("PIData"))
                //     .unwrap(); // <createProcessingInstruction var="newPI" obj="newDoc" target="&quot;PITarget&quot;" data="&quot;PIData&quot;"/>
                // r#adopted_pi = r#doc.adopt_node(r#new_pi.into()); // <adoptNode var="adoptedPI" obj="doc" source="newPI"/>

                // // unimplemented: // <if><notNull obj="adoptedPI"/>	<target var="piTarget" obj="adoptedPI" interface="ProcessingInstruction"/>	<data var="piData" obj="adoptedPI" interface="ProcessingInstruction"/>	<assertEquals actual="piTarget" expected="&quot;PITarget&quot;" id="documentadoptnode35_Target" ignoreCase="false"/>	<assertEquals actual="piData" expected="&quot;PIData&quot;" id="documentadoptnode35_Data" ignoreCase="false"/></if>
            }
            // documentadoptnode34.xml
            #[test]
            fn test_documentadoptnode34() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#new_comment; // type: Node // <var name="newComment" type="Node"/>
                // let mut r#adopted_comment; // type: Node // <var name="adoptedComment" type="Node"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#new_comment =
                //     r#new_doc.create_comment("Document.adoptNode test for a COMMENT_NODE"); // <createComment var="newComment" obj="newDoc" data="&quot;Document.adoptNode test for a COMMENT_NODE&quot;"/>
                // r#adopted_comment = r#new_doc.adopt_node(r#new_comment.into()); // <adoptNode var="adoptedComment" obj="newDoc" source="newComment"/>

                // // unimplemented: // <if><notNull obj="adoptedComment"/><nodeValue var="nodeValue" obj="adoptedComment"/><assertEquals actual="nodeValue" expected="&quot;Document.adoptNode test for a COMMENT_NODE&quot;" id="documentadoptnode34" ignoreCase="false"/></if>
            }
            // documentsetxmlstandalone02.xml
            #[test]
            fn test_documentsetxmlstandalone02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#standalone; // type: boolean // <var name="standalone" type="boolean"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // // <xmlStandalone obj="newDoc" value="false"/>
                // r#standalone = r#new_doc.xml_standalone(); // <xmlStandalone var="standalone" obj="newDoc"/>
                // assert!(!r#standalone); // <assertFalse actual="standalone" id="documentsetxmlstandalone02_false"/>
                // // <xmlStandalone obj="newDoc" value="true"/>
                // r#standalone = r#new_doc.xml_standalone(); // <xmlStandalone var="standalone" obj="newDoc"/>
                // assert!(r#standalone); // <assertTrue actual="standalone" id="documentsetxmlstandalone02_true"/>
            }
            // nodegettextcontent18.xml
            #[test]
            fn test_nodegettextcontent18() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#entitymap; // type: NamedNodeMap // <var name="entitymap" type="NamedNodeMap"/>
                // let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitymap" obj="docType"/>
                // r#entity = r#entitymap.get_named_item("delta".into()).unwrap(); // <getNamedItem var="entity" obj="entitymap" name="&quot;delta&quot;"/>
                // r#text_content = r#entity.text_content().unwrap(); // <textContent var="textContent" obj="entity"/>
                // assert_eq!(r#text_content, ""); // <assertEquals actual="textContent" expected="&quot;&quot;" id="nodegettextcontent18" ignoreCase="false"/>
            }
            // nodereplacechild30.xml
            #[test]
            fn test_nodereplacechild30() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#parent; // type: Element // <var name="parent" type="Element"/>
                let mut r#old_child; // type: Element // <var name="oldChild" type="Element"/>
                let mut r#new_element; // type: Element // <var name="newElement" type="Element"/>
                let mut r#new_text; // type: Text // <var name="newText" type="Text"/>
                let mut r#new_comment; // type: Comment // <var name="newComment" type="Comment"/>
                let mut r#new_pi; // type: ProcessingInstruction // <var name="newPI" type="ProcessingInstruction"/>
                let mut r#new_cdata; // type: CDATASection // <var name="newCdata" type="CDATASection"/>
                let mut r#new_e_ref; // type: EntityReference // <var name="newERef" type="EntityReference"/>
                let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#parent = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "xhtml:html".as_ref())
                    .unwrap(); // <createElementNS var="parent" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:html&quot;"/>
                r#old_child = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "xhtml:head".as_ref())
                    .unwrap(); // <createElementNS var="oldChild" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:head&quot;"/>
                r#new_element = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "xhtml:body".as_ref())
                    .unwrap(); // <createElementNS var="newElement" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:body&quot;"/>
                r#appended_child = r#parent.append_child(old_child.into()).unwrap(); // <appendChild obj="parent" var="appendedChild" newChild="oldChild"/>
                r#appended_child = r#parent.append_child(new_element.into()).unwrap(); // <appendChild obj="parent" var="appendedChild" newChild="newElement"/>
                r#new_text = r#doc.create_text_node("Text"); // <createTextNode var="newText" obj="doc" data="&quot;Text&quot;"/>
                r#appended_child = r#parent.append_child(new_text.into()).unwrap(); // <appendChild obj="parent" var="appendedChild" newChild="newText"/>
                r#new_comment = r#doc.create_comment("Comment"); // <createComment var="newComment" obj="doc" data="&quot;Comment&quot;"/>
                r#appended_child = r#parent.append_child(new_comment.into()).unwrap(); // <appendChild obj="parent" var="appendedChild" newChild="newComment"/>
                r#new_pi = r#doc
                    .create_processing_instruction("target", Some("data"))
                    .unwrap(); // <createProcessingInstruction var="newPI" obj="doc" target="&quot;target&quot;" data="&quot;data&quot;"/>
                r#appended_child = r#parent.append_child(new_pi.into()).unwrap(); // <appendChild obj="parent" var="appendedChild" newChild="newPI"/>
                r#new_cdata = r#doc.create_cdata_section("Cdata").unwrap(); // <createCDATASection var="newCdata" obj="doc" data="&quot;Cdata&quot;"/>
                r#appended_child = r#parent.append_child(new_cdata.into()).unwrap(); // <appendChild obj="parent" var="appendedChild" newChild="newCdata"/>
                r#new_e_ref = r#doc.create_entity_reference("delta".to_string()).unwrap(); // <createEntityReference var="newERef" obj="doc" name="&quot;delta&quot;"/>
                r#appended_child = r#parent.append_child(new_e_ref.into()).unwrap(); // <appendChild obj="parent" var="appendedChild" newChild="newERef"/>
                r#replaced = r#parent
                    .replace_child(new_element.into(), old_child.into())
                    .unwrap(); // <replaceChild var="replaced" obj="parent" oldChild="oldChild" newChild="newElement"/>
                r#node_name = r#replaced.node_name().to_string(); // <nodeName var="nodeName" obj="replaced"/>
                assert_eq!(r#node_name, "xhtml:head"); // <assertEquals actual="nodeName" expected="&quot;xhtml:head&quot;" id="nodereplacechild30_1" ignoreCase="false"/>
                r#replaced = r#parent
                    .replace_child(old_child.into(), new_element.into())
                    .unwrap(); // <replaceChild var="replaced" obj="parent" oldChild="newElement" newChild="oldChild"/>
                r#node_name = r#replaced.node_name().to_string(); // <nodeName var="nodeName" obj="replaced"/>
                assert_eq!(r#node_name, "xhtml:body"); // <assertEquals actual="nodeName" expected="&quot;xhtml:body&quot;" id="nodereplacechild30_2" ignoreCase="false"/>
                r#replaced = r#parent
                    .replace_child(new_text.into(), old_child.into())
                    .unwrap(); // <replaceChild var="replaced" obj="parent" oldChild="oldChild" newChild="newText"/>
                r#node_name = r#replaced.node_name().to_string(); // <nodeName var="nodeName" obj="replaced"/>
                assert_eq!(r#node_name, "xhtml:head"); // <assertEquals actual="nodeName" expected="&quot;xhtml:head&quot;" id="nodereplacechild30_3" ignoreCase="false"/>
                r#replaced = r#parent
                    .replace_child(old_child.into(), new_text.into())
                    .unwrap(); // <replaceChild var="replaced" obj="parent" oldChild="newText" newChild="oldChild"/>
                r#node_name = r#replaced.node_name().to_string(); // <nodeName var="nodeName" obj="replaced"/>
                assert_eq!(r#node_name, "#text"); // <assertEquals actual="nodeName" expected="&quot;#text&quot;" id="nodereplacechild30_4" ignoreCase="false"/>
                r#replaced = r#parent
                    .replace_child(new_comment.into(), old_child.into())
                    .unwrap(); // <replaceChild var="replaced" obj="parent" oldChild="oldChild" newChild="newComment"/>
                r#node_name = r#replaced.node_name().to_string(); // <nodeName var="nodeName" obj="replaced"/>
                assert_eq!(r#node_name, "xhtml:head"); // <assertEquals actual="nodeName" expected="&quot;xhtml:head&quot;" id="nodereplacechild30_5" ignoreCase="false"/>
                r#replaced = r#parent
                    .replace_child(old_child.into(), new_comment.into())
                    .unwrap(); // <replaceChild var="replaced" obj="parent" oldChild="newComment" newChild="oldChild"/>
                r#node_name = r#replaced.node_name().to_string(); // <nodeName var="nodeName" obj="replaced"/>
                assert_eq!(r#node_name, "#comment"); // <assertEquals actual="nodeName" expected="&quot;#comment&quot;" id="nodereplacechild30_6" ignoreCase="false"/>
                r#replaced = r#parent
                    .replace_child(old_child.into(), new_pi.into())
                    .unwrap(); // <replaceChild var="replaced" obj="parent" oldChild="newPI" newChild="oldChild"/>
                r#node_name = r#replaced.node_name().to_string(); // <nodeName var="nodeName" obj="replaced"/>
                assert_eq!(r#node_name, "target"); // <assertEquals actual="nodeName" expected="&quot;target&quot;" id="nodereplacechild30_7" ignoreCase="false"/>
                r#replaced = r#parent
                    .replace_child(old_child.into(), new_cdata.into())
                    .unwrap(); // <replaceChild var="replaced" obj="parent" oldChild="newCdata" newChild="oldChild"/>
                r#node_name = r#replaced.node_name().to_string(); // <nodeName var="nodeName" obj="replaced"/>
                assert_eq!(r#node_name, "#cdata-section"); // <assertEquals actual="nodeName" expected="&quot;#cdata-section&quot;" id="nodereplacechild30_8" ignoreCase="false"/>
                r#replaced = r#parent
                    .replace_child(old_child.into(), new_e_ref.into())
                    .unwrap(); // <replaceChild var="replaced" obj="parent" oldChild="newERef" newChild="oldChild"/>
                r#node_name = r#replaced.node_name().to_string(); // <nodeName var="nodeName" obj="replaced"/>
                assert_eq!(r#node_name, "delta"); // <assertEquals actual="nodeName" expected="&quot;delta&quot;" id="nodereplacechild30_9" ignoreCase="false"/>
            }
            // wellformed02.xml
            #[test]
            fn test_wellformed02() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#null_string; // type: DOMString // <var name="nullString" type="DOMString" isNull="true"/>
                // let mut r#null_doctype; // type: DocumentType // <var name="nullDoctype" type="DocumentType" isNull="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#errors; // type: List // <var name="errors" type="List"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="nullString" qualifiedName="nullString" doctype="nullDoctype"/>

                // // unimplemented: // <assertDOMException id="xml10InvalidName">	<INVALID_CHARACTER_ERR>		<createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.example.org/domts/wellformed02&quot;" qualifiedName="&quot;LegalName&quot;"/>	</INVALID_CHARACTER_ERR></assertDOMException>

                // // unimplemented: // <try>	<xmlVersion obj="doc" value="&quot;1.1&quot;" interface="Document"/>	<catch>		<DOMException code="NOT_SUPPORTED_ERR">			<return/>		</DOMException>	</catch></try>
                // r#elem = r#doc
                //     .create_element_ns(
                //         Some("http://www.example.org/domts/wellformed02".as_ref()),
                //         "LegalName".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.example.org/domts/wellformed02&quot;" qualifiedName="&quot;LegalName&quot;"/>
                // r#retval = r#doc.append_child(elem.into()).unwrap(); // <appendChild var="retval" obj="doc" newChild="elem"/>
                // r#doc.set_xml_version("1.0").unwrap(); // <xmlVersion obj="doc" value="&quot;1.0&quot;" interface="Document"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;well-formed&quot;" value="false"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;well-formed&quot;" value="false"/><setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/><normalizeDocument obj="doc"/><allErrors var="errors" obj="errorMonitor"/><assertSize size="0" collection="errors" id="noError"/></if>
            }
            // domconfigurationcansetparameter01.xml
            #[test]
            fn test_domconfigurationcansetparameter01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#new_comment_node; // type: Comment // <var name="newCommentNode" type="Comment"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#last_child; // type: Node // <var name="lastChild" type="Node"/>
                // let mut r#comment_value; // type: DOMString // <var name="commentValue" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#new_comment_node = r#doc.create_comment("This is a new Comment node"); // <createComment obj="doc" var="newCommentNode" data="&quot;This is a new Comment node&quot;"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement obj="doc" var="docElem" interface="Document"/>
                // r#appended_child = r#doc_elem.append_child(new_comment_node.into()).unwrap(); // <appendChild obj="docElem" var="appendedChild" newChild="newCommentNode" interface="Node"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter obj="domConfig" var="canSet" name="&quot;comments&quot;" value="false"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="domconfigurationcansetparameter01"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>
                // r#last_child = r#doc_elem.last_child().unwrap(); // <lastChild obj="docElem" var="lastChild" interface="Node"/>
                // r#comment_value = r#last_child.node_value().unwrap().to_string(); // <nodeValue obj="lastChild" var="commentValue" interface="Node"/>
                // assert_eq!(r#comment_value, "This is a new Comment node"); // <assertEquals actual="commentValue" expected="&quot;This is a new Comment node&quot;" id="domconfigurationsetparameter02_2" ignoreCase="false"/>
            }
            // documentnormalizedocument08.xml
            #[test]
            fn test_documentnormalizedocument08() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#new_child; // type: CDATASection // <var name="newChild" type="CDATASection"/>
                // let mut r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#errors; // type: List // <var name="errors" type="List"/>
                // let mut r#error; // type: DOMError // <var name="error" type="DOMError"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>
                // let mut r#child_nodes; // type: NodeList // <var name="childNodes" type="NodeList"/>
                // let mut r#type; // type: DOMString // <var name="type" type="DOMString"/>
                // let mut r#splitted_count; // type: int // <var name="splittedCount" type="int" value="0"/>
                // let mut r#severity; // type: int // <var name="severity" type="int"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>
                // r#new_child = r#doc.create_cdata_section("this is not ]]> good").unwrap(); // <createCDATASection var="newChild" obj="doc" data="&quot;this is not ]]&gt; good&quot;"/>
                // r#old_child = r#elem.first_child().unwrap(); // <firstChild var="oldChild" obj="elem" interface="Node"/>
                // r#retval = r#elem
                //     .replace_child(new_child.into(), old_child)
                //     .unwrap(); // <replaceChild var="retval" obj="elem" newChild="newChild" oldChild="oldChild"/>
                // r#new_child = r#doc.create_cdata_section("this is not ]]> good").unwrap(); // <createCDATASection var="newChild" obj="doc" data="&quot;this is not ]]&gt; good&quot;"/>
                // r#retval = r#elem.append_child(new_child).unwrap(); // <appendChild var="retval" obj="elem" newChild="newChild"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;split-cdata-sections&quot;" value="true"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <allErrors var="errors" obj="errorMonitor"/>

                // // unimplemented: // <for-each member="error" collection="errors">	<type var="type" obj="error" interface="DOMError"/>	<severity var="severity" obj="error"/>	<if>		<equals actual="type" expected="&quot;cdata-sections-splitted&quot;" ignoreCase="false"/>		<increment var="splittedCount" value="1"/>		<else>			<assertEquals actual="severity" expected="1" ignoreCase="false" id="anyOthersShouldBeWarnings"/>		</else>	</if></for-each>
                // assert_eq!(r#splitted_count, 2); // <assertEquals actual="splittedCount" expected="2" ignoreCase="false" id="twoSplittedWarning"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>
                // r#child_nodes = r#elem.child_nodes(); // <childNodes var="childNodes" obj="elem"/>
                // r#length = r#child_nodes.len(); // <length var="length" obj="childNodes" interface="NodeList"/>

                // // unimplemented: // <assertTrue id="atLeast4ChildNodes"><greater actual="length" expected="3"/></assertTrue>
            }
            // nodecomparedocumentposition10.xml
            #[test]
            fn test_nodecomparedocumentposition10() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#dir; // type: Attr // <var name="dir" type="Attr"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#attr_position; // type: int // <var name="attrPosition" type="int"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#elem = r#elem_list.item(3).unwrap(); // <item var="elem" obj="elemList" index="3" interface="NodeList"/>
                r#dir = r#elem.get_attribute_node("dir").unwrap(); // <getAttributeNode var="dir" obj="elem" name="&quot;dir&quot;"/>
                r#attr_position = r#dir.compare_document_position(&r#doc.into()); // <compareDocumentPosition var="attrPosition" obj="dir" other="doc"/>
                assert_eq!(u16::from(r#attr_position), 10); // <assertEquals actual="attrPosition" expected="10" id="nodecomparedocumentpositionPRECEDINGContains10" ignoreCase="false"/>
            }
            // documentgetstricterrorchecking01.xml
            #[test]
            fn test_documentgetstricterrorchecking01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#strict_error_checking_value; // type: boolean // <var name="strictErrorCheckingValue" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <strictErrorChecking var="strictErrorCheckingValue" obj="doc"/>
                // assert!(r#strict_error_checking_value); // <assertTrue actual="strictErrorCheckingValue" id="documentgetstricterrorchecking01"/>
            }
            // noderemovechild15.xml
            #[test]
            fn test_noderemovechild15() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#e_ref; // type: EntityReference // <var name="eRef" type="EntityReference"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#ent_name; // type: DOMString // <var name="entName" type="DOMString"/>
                // let mut r#removed; // type: Node // <var name="removed" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#e_ref = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference var="eRef" obj="doc" name="&quot;ent4&quot;"/>
                // r#elem = r#e_ref.first_child().unwrap(); // <firstChild obj="eRef" var="elem" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="elem" id="elemNotNull"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">	<NO_MODIFICATION_ALLOWED_ERR>		<removeChild obj="eRef" var="removed" oldChild="elem"/>	</NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // nodegetuserdata06.xml
            #[test]
            fn test_nodegetuserdata06() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                // let mut r#ret_user_data; // type: DOMUserData // <var name="retUserData" type="DOMUserData"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#txt = r#doc.create_text_node("TEXT"); // <createTextNode var="txt" obj="doc" data="&quot;TEXT&quot;"/>

                // // unimplemented: // <getUserData var="retUserData" obj="txt" key="&quot;&quot;"/>

                // // unimplemented: // <assertNull actual="retUserData" id="nodegetuserdata06"/>
            }
            // documentgetinputencoding03.xml
            #[test]
            fn test_documentgetinputencoding03() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#encoding_name; // type: DOMString // <var name="encodingName" type="DOMString"/>
                // r#doc = todo!(); // barfoo_utf16.xml // <load var="doc" href="barfoo_utf16" willBeModified="false"/>
                // r#encoding_name = r#doc.input_encoding().unwrap().to_string(); // <inputEncoding obj="doc" var="encodingName" interface="Document"/>
                // assert_eq!(r#encoding_name, "UTF-16BE"); // <assertEquals expected="&quot;UTF-16BE&quot;" actual="encodingName" id="documentgetinputencoding03" ignoreCase="true"/>
            }
            // domimplementationregistry08.xml
            #[test]
            fn test_domimplementationregistry08() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#base_impl; // type: DOMImplementation // <var name="baseImpl" type="DOMImplementation"/>
                // let mut r#has_feature; // type: boolean // <var name="hasFeature" type="boolean"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementation var="domImpl" obj="domImplRegistry" features="&quot;SVG&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <if>	<isNull obj="domImpl"/>	<implementation var="baseImpl"/>	<hasFeature var="hasFeature" feature="&quot;SVG&quot;"/>	<assertFalse actual="hasFeature" id="baseImplSupportsSVG"/>	<else>		<hasFeature var="hasFeature" obj="domImpl" feature="&quot;SVG&quot;" version="nullVersion"/>		<assertTrue actual="hasFeature" id="hasCore"/>	</else></if>
            }
            // textiselementcontentwhitespace03.xml
            #[test]
            fn test_textiselementcontentwhitespace03() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>

                // unimplemented: // <implementationAttribute name="ignoringElementContentWhitespace" value="false"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#is_elem_content_whitespace; // type: boolean // <var name="isElemContentWhitespace" type="boolean"/>
                r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>
                r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" index="0" interface="NodeList"/>
                r#text_node = r#p_elem.previous_sibling().unwrap().as_text_node().unwrap(); // <previousSibling var="textNode" obj="pElem" interface="Node"/>
                r#is_elem_content_whitespace = r#text_node.is_element_content_whitespace(); // <isElementContentWhitespace obj="textNode" var="isElemContentWhitespace"/>
                assert!(r#is_elem_content_whitespace); // <assertTrue actual="isElemContentWhitespace" id="isElementContentWhitespace"/>
            }
            // nodereplacechild12.xml
            #[test]
            fn test_nodereplacechild12() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                // let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                // let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                // let mut r#last_child; // type: Node // <var name="lastChild" type="Node"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#replaced_node; // type: Node // <var name="replacedNode" type="Node"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#comment = r#doc.create_comment("dom3:doc"); // <createComment var="comment" obj="doc" data="&quot;dom3:doc&quot;"/>
                // r#pi = r#doc
                //     .create_processing_instruction("PITarget", Some("PIData"))
                //     .unwrap(); // <createProcessingInstruction var="pi" obj="doc" target="&quot;PITarget&quot;" data="&quot;PIData&quot;"/>
                // r#appended_child = r#doc.append_child(comment.into()).unwrap(); // <appendChild obj="doc" var="appendedChild" newChild="comment"/>
                // r#appended_child = r#doc.append_child(pi.into()).unwrap(); // <appendChild obj="doc" var="appendedChild" newChild="pi"/>
                // r#replaced_node = r#doc.replace_child(comment.into(), pi.into()).unwrap(); // <replaceChild obj="doc" var="replacedNode" oldChild="pi" newChild="comment"/>

                // // unimplemented: // <assertNotNull actual="replacedNode" id="returnValueNotNull"/>
                // r#node_name = r#replaced_node.node_name().to_string(); // <nodeName var="nodeName" obj="replacedNode"/>
                // assert_eq!(r#node_name, "PITarget"); // <assertEquals actual="nodeName" expected="&quot;PITarget&quot;" id="returnValueIsPI" ignoreCase="false"/>
                // r#last_child = r#doc.last_child().unwrap(); // <lastChild var="lastChild" obj="doc" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="lastChild" id="lastChildNotNull"/>
                // r#node_name = r#last_child.node_name().to_string(); // <nodeName var="nodeName" obj="lastChild"/>
                // assert_eq!(r#node_name, "#comment"); // <assertEquals actual="nodeName" expected="&quot;#comment&quot;" id="lastChildIsComment" ignoreCase="false"/>
            }
            // typeinfogettypenamespace04.xml
            #[test]
            fn test_typeinfogettypenamespace04() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>

                // // unimplemented: // <implementationAttribute name="validating" value="true"/>

                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#em_elem; // type: Element // <var name="emElem" type="Element"/>
                // let mut r#elem_type_info; // type: TypeInfo // <var name="elemTypeInfo" type="TypeInfo"/>
                // let mut r#type_namespace; // type: DOMString // <var name="typeNamespace" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                // r#em_elem = r#elem_list.item(0).unwrap(); // <item var="emElem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="elemTypeInfo" obj="emElem" interface="Element"/>

                // // unimplemented: // <typeNamespace var="typeNamespace" obj="elemTypeInfo"/>
                // assert_eq!(r#type_namespace, "http://www.w3.org/1999/xhtml"); // <assertEquals expected="&quot;http://www.w3.org/1999/xhtml&quot;" actual="typeNamespace" id="typeinfogettypenamespace04_1" ignoreCase="false"/>
            }
            // textreplacewholetext04.xml
            #[test]
            fn test_textreplacewholetext04() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                // let mut r#replaced_text; // type: Text // <var name="replacedText" type="Text"/>
                // let mut r#whole_text; // type: DOMString // <var name="wholeText" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#text_node = r#doc.create_text_node("New Text"); // <createTextNode var="textNode" obj="doc" data="&quot;New Text&quot;"/>
                // r#replaced_text = r#text_node.replace_whole_text("").unwrap().unwrap();
                // // <replaceWholeText obj="textNode" var="replacedText" content="&quot;&quot;"/>

                // // unimplemented: // <assertNull actual="replacedText" id="retvalIsNull"/>
            }
            // nodegettextcontent01.xml
            #[test]
            fn test_nodegettextcontent01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#text_content = r#doc.text_content().unwrap(); // <textContent var="textContent" obj="doc"/>

                // unimplemented: // <assertNull actual="textContent" id="nodegettextcontent01"/>
            }
            // nodelookupprefix02.xml
            #[test]
            fn test_nodelookupprefix02() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // let mut r#qname; // type: DOMString // <var name="qname" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <plus var="qname" op1="&quot;dom3:&quot;" op2="rootName"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="qname" doctype="nullDocType"/>
                // r#prefix = r#new_doc
                //     .lookup_prefix(r#root_ns.as_ref())
                //     .unwrap()
                //     .to_string(); // <lookupPrefix var="prefix" obj="newDoc" namespaceURI="rootNS"/>
                // assert_eq!(r#prefix, "dom3"); // <assertEquals actual="prefix" expected="&quot;dom3&quot;" id="nodelookupprefix02" ignoreCase="false"/>
            }
            // nodecomparedocumentposition20.xml
            #[test]
            fn test_nodecomparedocumentposition20() {
                // unimplemented: // <implementationAttribute name="coalescing" value="false"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#elem_name; // type: Element // <var name="elemName" type="Element"/>
                let mut r#cdata; // type: CDATASection // <var name="cdata" type="CDATASection"/>
                let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                let mut r#txt_position; // type: int // <var name="txtPosition" type="int"/>
                let mut r#cdata_position; // type: int // <var name="cdataPosition" type="int"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#elem_name = r#elem_list.item(1).unwrap(); // <item var="elemName" obj="elemList" index="1" interface="NodeList"/>
                r#txt = r#elem_name.first_child().unwrap(); // <firstChild var="txt" obj="elemName" interface="Node"/>
                r#cdata = r#elem_name.last_child().unwrap(); // <lastChild var="cdata" obj="elemName" interface="Node"/>
                r#txt_position = r#txt.compare_document_position(&r#cdata); // <compareDocumentPosition var="txtPosition" obj="txt" other="cdata"/>
                assert_eq!(u16::from(r#txt_position), 4); // <assertEquals actual="txtPosition" expected="4" id="nodecomparedocumentpositionFollowingg20" ignoreCase="false"/>
                r#cdata_position = r#cdata.compare_document_position(&r#txt); // <compareDocumentPosition var="cdataPosition" obj="cdata" other="txt"/>
                assert_eq!(u16::from(r#cdata_position), 2); // <assertEquals actual="cdataPosition" expected="2" id="nodecomparedocumentpositionPRECEDING20" ignoreCase="false"/>
            }
            // documentgetinputencoding01.xml
            #[test]
            fn test_documentgetinputencoding01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#encoding_name; // type: DOMString // <var name="encodingName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#encoding_name = r#doc.input_encoding().unwrap().to_string(); // <inputEncoding obj="doc" var="encodingName" interface="Document"/>
                // assert_eq!(r#encoding_name, "UTF-8"); // <assertEquals expected="&quot;UTF-8&quot;" actual="encodingName" id="documentgetinputencoding01" ignoreCase="true"/>
            }
            // domimplementationregistry24.xml
            #[test]
            fn test_domimplementationregistry24() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementation var="domImpl" obj="domImplRegistry" features="&quot;&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImpl" id="domImplNotNull"/>
            }
            // entitygetinputencoding03.xml
            #[test]
            fn test_entitygetinputencoding03() {
                // // unimplemented: // <implementationAttribute name="validating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#encoding_name; // type: DOMString // <var name="encodingName" type="DOMString"/>
                // r#doc = todo!(); // external_barfoo.xml // <load var="doc" href="external_barfoo" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#entity = r#entities_map.get_named_item("ent1".into()).unwrap(); // <getNamedItem var="entity" obj="entitiesMap" name="&quot;ent1&quot;"/>
                // r#encoding_name = r#entity.input_encoding().unwrap().to_string(); // <inputEncoding obj="entity" var="encodingName" interface="Entity"/>

                // // unimplemented: // <if>	<notEquals actual="encodingName" expected="&quot;UTF-16LE&quot;" ignoreCase="true"/>	<assertEquals id="entityIsUTF16orUTF16LE" actual="encodingName" expected="&quot;UTF-16&quot;" ignoreCase="true"/></if>
                // r#encoding_name = r#doc.input_encoding().unwrap().to_string(); // <inputEncoding obj="doc" var="encodingName" interface="Document"/>
                // assert_eq!(r#encoding_name, "UTF-8"); // <assertEquals id="documentIsUTF8" actual="encodingName" expected="&quot;UTF-8&quot;" ignoreCase="true"/>
            }
            // domconfigcdatasections1.xml
            #[test]
            fn test_domconfigcdatasections1() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // let mut r#parameter; // type: DOMString // <var name="parameter" type="DOMString" value="&quot;cDaTa-sections&quot;"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDocType"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(r#state); // <assertTrue actual="state" id="defaultFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="false"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="true"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetTrue"/>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="false"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(!r#state); // <assertFalse actual="state" id="setFalseEffective"/>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="true"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(r#state); // <assertTrue actual="state" id="setTrueEffective"/>
            }
            // nodecomparedocumentposition22.xml
            #[test]
            fn test_nodecomparedocumentposition22() {
                // // unimplemented: // <implementationAttribute name="coalescing" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#notations_map; // type: NamedNodeMap // <var name="notationsMap" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                // let mut r#entity_position; // type: int // <var name="entityPosition" type="int"/>
                // let mut r#notation_position; // type: int // <var name="notationPosition" type="int"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>

                // // unimplemented: // <notations var="notationsMap" obj="docType"/>
                // r#entity = r#entities_map.get_named_item("alpha".into()).unwrap(); // <getNamedItem var="entity" obj="entitiesMap" name="&quot;alpha&quot;"/>
                // r#notation = r#notations_map.get_named_item("notation1".into()).unwrap(); // <getNamedItem var="notation" obj="notationsMap" name="&quot;notation1&quot;"/>
                // r#entity_position = r#entity.compare_document_position(&r#notation.into()); // <compareDocumentPosition var="entityPosition" obj="entity" other="notation"/>
                // assert_eq!(r#entity_position, 4); // <assertEquals actual="entityPosition" expected="4" id="nodecomparedocumentpositionFollowing22" ignoreCase="false"/>
                // r#notation_position = r#notation.compare_document_position(&r#entity.into()); // <compareDocumentPosition var="notationPosition" obj="notation" other="entity"/>
                // assert_eq!(r#notation_position, 2); // <assertEquals actual="notationPosition" expected="2" id="nodecomparedocumentpositionPRECEDING22" ignoreCase="false"/>
            }
            // documentgetxmlversion01.xml
            #[test]
            fn test_documentgetxmlversion01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#version_value; // type: DOMString // <var name="versionValue" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#version_value = r#doc.xml_version().unwrap().to_string(); // <xmlVersion var="versionValue" obj="doc" interface="Document"/>
                // assert_eq!(r#version_value, "1.0"); // <assertEquals actual="versionValue" expected="&quot;1.0&quot;" id="documentgetxmlversion01" ignoreCase="false"/>
            }
            // nodeinsertbefore16.xml
            #[test]
            fn test_nodeinsertbefore16() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#new_elem; // type: Element // <var name="newElem" type="Element"/>
                let mut r#ref_elem; // type: Element // <var name="refElem" type="Element"/>
                let mut r#first_child; // type: Node // <var name="firstChild" type="Node"/>
                let mut r#inserted_elem; // type: Element // <var name="insertedElem" type="Element"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#inserted; // type: Node // <var name="inserted" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#child_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#element = r#child_list.item(0).unwrap(); // <item var="element" obj="childList" index="0" interface="NodeList"/>
                r#first_child = r#element.first_child().unwrap(); // <firstChild var="firstChild" obj="element" interface="Node"/>
                r#ref_elem = r#first_child.next_sibling().unwrap(); // <nextSibling var="refElem" obj="firstChild" interface="Node"/>
                r#new_elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "xhtml:br".as_ref())
                    .unwrap(); // <createElementNS var="newElem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:br&quot;"/>
                r#inserted = r#element
                    .insert_before(new_elem.into(), ref_elem.into())
                    .unwrap(); // <insertBefore obj="element" var="inserted" refChild="refElem" newChild="newElem"/>
                r#child_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#element = r#child_list.item(0).unwrap(); // <item var="element" obj="childList" index="0" interface="NodeList"/>
                r#first_child = r#element.first_child().unwrap(); // <firstChild var="firstChild" obj="element" interface="Node"/>
                r#inserted_elem = r#first_child.next_sibling().unwrap(); // <nextSibling var="insertedElem" obj="firstChild" interface="Node"/>
                r#node_name = r#inserted_elem.node_name().to_string(); // <nodeName var="nodeName" obj="insertedElem"/>
                assert_eq!(r#node_name, "xhtml:br"); // <assertEquals actual="nodeName" expected="&quot;xhtml:br&quot;" id="nodeinsertbefore16" ignoreCase="false"/>
            }
            // infoset06.xml
            #[test]
            fn test_infoset06() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#null_string; // type: DOMString // <var name="nullString" type="DOMString" isNull="true"/>
                // let mut r#null_doctype; // type: DocumentType // <var name="nullDoctype" type="DocumentType" isNull="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#errors; // type: List // <var name="errors" type="List"/>
                // let mut r#error; // type: DOMError // <var name="error" type="DOMError"/>
                // let mut r#severity; // type: int // <var name="severity" type="int"/>
                // let mut r#type; // type: DOMString // <var name="type" type="DOMString"/>
                // let mut r#locator; // type: DOMLocator // <var name="locator" type="DOMLocator"/>
                // let mut r#related_node; // type: Node // <var name="relatedNode" type="Node"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="nullString" qualifiedName="nullString" doctype="nullDoctype"/>

                // // unimplemented: // <assertDOMException id="xml10InvalidName">	<INVALID_CHARACTER_ERR>		<createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.example.org/domts/wellformed01&quot;" qualifiedName="&quot;LegalName&quot;"/>	</INVALID_CHARACTER_ERR></assertDOMException>

                // // unimplemented: // <try>	<xmlVersion obj="doc" value="&quot;1.1&quot;" interface="Document"/>	<catch>		<DOMException code="NOT_SUPPORTED_ERR">			<return/>		</DOMException>	</catch></try>
                // r#elem = r#doc
                //     .create_element_ns(
                //         Some("http://www.example.org/domts/wellformed01".as_ref()),
                //         "LegalName".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.example.org/domts/wellformed01&quot;" qualifiedName="&quot;LegalName&quot;"/>
                // r#retval = r#doc.append_child(elem.into()).unwrap(); // <appendChild var="retval" obj="doc" newChild="elem"/>
                // r#doc.set_xml_version("1.0").unwrap(); // <xmlVersion obj="doc" value="&quot;1.0&quot;" interface="Document"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;infoset&quot;" value="true"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <allErrors var="errors" obj="errorMonitor"/>

                // // unimplemented: // <for-each member="error" collection="errors">	<severity var="severity" obj="error"/>	<assertEquals actual="severity" expected="2" ignoreCase="false" id="severity"/>	<type var="type" obj="error" interface="DOMError"/>	<assertEquals actual="type" expected="&quot;wf-invalid-character-in-node-name&quot;" ignoreCase="false" id="type"/>	<location var="locator" obj="error" interface="DOMError"/>	<relatedNode var="relatedNode" obj="locator" interface="DOMLocator"/>	<assertSame actual="relatedNode" expected="elem" id="relatedNode"/></for-each>

                // // unimplemented: // <assertSize size="1" collection="errors" id="oneError"/>
            }
            // nodecomparedocumentposition33.xml
            #[test]
            fn test_nodecomparedocumentposition33() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#position1; // type: int // <var name="position1" type="int"/>
                let mut r#position2; // type: int // <var name="position2" type="int"/>
                let mut r#position3; // type: int // <var name="position3" type="int"/>
                let mut r#position4; // type: int // <var name="position4" type="int"/>
                let mut r#position5; // type: int // <var name="position5" type="int"/>
                let mut r#replaced_attr; // type: Attr // <var name="replacedAttr" type="Attr"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "br".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;br&quot;"/>
                r#attr = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/XML/1998/namespace"),
                        "xml:lang".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>
                r#replaced_attr = r#elem.set_attribute_node_ns(r#attr).unwrap().unwrap(); // <setAttributeNodeNS obj="elem" var="replacedAttr" newAttr="attr"/>
                r#position4 = r#elem.compare_document_position(&r#attr.into()); // <compareDocumentPosition var="position4" obj="elem" other="attr"/>
                assert_eq!(u16::from(r#position4), 20); // <assertEquals actual="position4" expected="20" id="nodecomparedocumentposition3FollowingisContained33" ignoreCase="false"/>
                r#position5 = r#attr.compare_document_position(&r#elem.into()); // <compareDocumentPosition var="position5" obj="attr" other="elem"/>
                assert_eq!(u16::from(r#position5), 10); // <assertEquals actual="position5" expected="10" id="nodecomparedocumentposition4ContainsPRECEDING33" ignoreCase="false"/>
                r#position1 = r#doc.compare_document_position(&r#elem.into()); // <compareDocumentPosition var="position1" obj="doc" other="elem"/>
                assert_eq!(u16::from(r#position1), 33); // <assertEquals bitmask="57" actual="position1" expected="33" id="isImplSpecificDisconnected1" ignoreCase="false"/>
                r#position2 = r#elem.compare_document_position(&r#doc.into()); // <compareDocumentPosition var="position2" obj="elem" other="doc"/>

                // unimplemented: // <assertNotEquals bitmask="2" actual="position2" expected="position1" id="notBothPreceding" ignoreCase="false"/>

                // unimplemented: // <assertNotEquals bitmask="4" actual="position2" expected="position1" id="notBothFollowing" ignoreCase="false"/>
                assert_eq!(u16::from(r#position2), 33); // <assertEquals bitmask="57" actual="position2" expected="33" id="isImplSpecificDisconnected2" ignoreCase="false"/>
                r#position3 = r#doc.compare_document_position(&r#elem.into()); // <compareDocumentPosition var="position3" obj="doc" other="elem"/>
                assert_eq!(r#position3, position1); // <assertEquals actual="position3" expected="position1" id="isConsistent" ignoreCase="false"/>
            }
            // nodeissamenode10.xml
            #[test]
            fn test_nodeissamenode10() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#is_same; // type: boolean // <var name="isSame" type="boolean"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#element = r#new_doc
                //     .create_element_ns(Some(r#root_ns.as_ref()), r#root_name.as_ref())
                //     .unwrap(); // <createElementNS var="element" obj="newDoc" namespaceURI="rootNS" qualifiedName="rootName"/>
                // is_same = new_doc.is_same_node(&element.into()); // <isSameNode var="isSame" obj="newDoc" other="element"/>
                // assert!(!r#is_same); // <assertFalse actual="isSame" id="nodeissamenode10"/>
            }
            // documentrenamenode24.xml
            #[test]
            fn test_documentrenamenode24() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#renamed_node; // type: Node // <var name="renamedNode" type="Node"/>
                // let mut r#null_nsuri; // type: DOMString // <var name="nullNSURI" type="DOMString" isNull="true"/>
                // let mut r#docowner: DocumentRef; // <var name="docowner" type="Document"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <assertDOMException id="documentrenamenode24_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><renameNode var="renamedNode" obj="doc" n="doc" namespaceURI="nullNSURI" qualifiedName="&quot;doc:root&quot;"/></NOT_SUPPORTED_ERR></assertDOMException>
            }
            // documentnormalizedocument02.xml
            #[test]
            fn test_documentnormalizedocument02() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // // unimplemented: // <implementationAttribute name="coalescing" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem_name; // type: Element // <var name="elemName" type="Element"/>
                // let mut r#cdata; // type: CDATASection // <var name="cdata" type="CDATASection"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                // r#elem_name = r#elem_list.item(1).unwrap(); // <item var="elemName" obj="elemList" index="1" interface="NodeList"/>
                // r#cdata = r#elem_name.last_child().unwrap(); // <lastChild var="cdata" obj="elemName" interface="Node"/>
                // r#node_name = r#cdata.node_name().to_string(); // <nodeName var="nodeName" obj="cdata"/>
                // assert_eq!(r#node_name, "#cdata-section"); // <assertEquals actual="nodeName" expected="&quot;#cdata-section&quot;" id="documentnormalizedocument02" ignoreCase="false"/>

                // // unimplemented: // <domConfig interface="Document" obj="doc" var="domConfig"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;cdata-sections&quot;" value="true"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" severity="SEVERITY_ERROR" id="normalizationError"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                // r#elem_name = r#elem_list.item(1).unwrap(); // <item var="elemName" obj="elemList" index="1" interface="NodeList"/>
                // r#cdata = r#elem_name.last_child().unwrap(); // <lastChild var="cdata" obj="elemName" interface="Node"/>
                // r#node_name = r#cdata.node_name().to_string(); // <nodeName var="nodeName" obj="cdata"/>
                // assert_eq!(r#node_name, "#cdata-section"); // <assertEquals actual="nodeName" expected="&quot;#cdata-section&quot;" id="documentnormalizedocument02_true" ignoreCase="false"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;cdata-sections&quot;" value="false"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" severity="SEVERITY_ERROR" id="normalization2Error"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                // r#elem_name = r#elem_list.item(1).unwrap(); // <item var="elemName" obj="elemList" index="1" interface="NodeList"/>
                // r#text = r#elem_name.last_child().unwrap(); // <lastChild var="text" obj="elemName" interface="Node"/>
                // r#node_name = r#text.node_name().to_string(); // <nodeName var="nodeName" obj="text"/>
                // assert_eq!(r#node_name, "#text"); // <assertEquals actual="nodeName" expected="&quot;#text&quot;" id="documentnormalizedocument02_false" ignoreCase="false"/>
            }
            // nodegetbaseuri16.xml
            #[test]
            fn test_nodegetbaseuri16() {
                // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#base_uri; // type: DOMString // <var name="baseURI" type="DOMString"/>
                let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                r#doc = todo!(); // external_barfoo.xml // <load var="doc" href="external_barfoo" willBeModified="false"/>
                r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" index="0" interface="NodeList"/>
                r#ent_ref = r#p_elem.last_child().unwrap(); // <lastChild var="entRef" obj="pElem" interface="Node"/>
                r#base_uri = r#ent_ref.base_uri().unwrap().to_string(); // <baseURI var="baseURI" obj="entRef" interface="Node"/>

                // unimplemented: // <assertURIEquals actual="baseURI" isAbsolute="true" name="&quot;external_barfoo&quot;" id="baseURI"/>
            }
            // documentnormalizedocument06.xml
            #[test]
            fn test_documentnormalizedocument06() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#new_child; // type: CDATASection // <var name="newChild" type="CDATASection"/>
                // let mut r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#errors; // type: List // <var name="errors" type="List"/>
                // let mut r#error; // type: DOMError // <var name="error" type="DOMError"/>
                // let mut r#splitted_count; // type: int // <var name="splittedCount" type="int" value="0"/>
                // let mut r#severity; // type: int // <var name="severity" type="int"/>
                // let mut r#problem_node; // type: Node // <var name="problemNode" type="Node"/>
                // let mut r#location; // type: DOMLocator // <var name="location" type="DOMLocator"/>
                // let mut r#line_number; // type: int // <var name="lineNumber" type="int"/>
                // let mut r#column_number; // type: int // <var name="columnNumber" type="int"/>
                // let mut r#byte_offset; // type: int // <var name="byteOffset" type="int"/>
                // let mut r#utf16_offset; // type: int // <var name="utf16Offset" type="int"/>
                // let mut r#uri; // type: DOMString // <var name="uri" type="DOMString"/>
                // let mut r#type; // type: DOMString // <var name="type" type="DOMString"/>
                // let mut r#message; // type: DOMString // <var name="message" type="DOMString"/>
                // let mut r#related_exception; // type: DOMObject // <var name="relatedException" type="DOMObject"/>
                // let mut r#related_data; // type: DOMObject // <var name="relatedData" type="DOMObject"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>
                // let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>
                // r#new_child = r#doc.create_cdata_section("this is not ]]> good").unwrap(); // <createCDATASection var="newChild" obj="doc" data="&quot;this is not ]]&gt; good&quot;"/>
                // r#old_child = r#elem.first_child().unwrap(); // <firstChild var="oldChild" obj="elem" interface="Node"/>
                // r#retval = r#elem
                //     .replace_child(new_child.into(), old_child)
                //     .unwrap(); // <replaceChild var="retval" obj="elem" newChild="newChild" oldChild="oldChild"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;split-cdata-sections&quot;" value="true"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>
                // r#new_child = r#elem.first_child().unwrap().as_cdata_section().unwrap(); // <firstChild var="newChild" obj="elem" interface="Node"/>
                // r#node_value = r#new_child.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="newChild"/>
                // r#node_type = r#new_child.node_type(); // <nodeType var="nodeType" obj="newChild"/>

                // // unimplemented: // <assertFalse id="wasSplit">	<and>		<equals actual="nodeType" expected="4" ignoreCase="false"/>				<contains obj="nodeValue" str="&quot;]]&gt;&quot;" interface="DOMString"/>	</and></assertFalse>

                // // unimplemented: // <allErrors var="errors" obj="errorMonitor"/>

                // // unimplemented: // <for-each member="error" collection="errors">	<type var="type" obj="error" interface="DOMError"/>	<severity var="severity" obj="error"/>	<if>		<equals actual="type" expected="&quot;cdata-sections-splitted&quot;" ignoreCase="false"/>		<!--  related data is first split node  -->		<relatedData var="relatedData" obj="error"/>		<assertSame actual="relatedData" expected="newChild" id="relatedData"/>		<!--  severity is warning   -->		<assertEquals actual="severity" expected="1" ignoreCase="false" id="severity"/>			<!--  message should be non-empty  -->		<message var="message" obj="error"/>		<length var="length" obj="message" interface="DOMString"/>		<assertTrue id="messageNotEmpty">			<greater actual="length" expected="0"/>		</assertTrue>		<!--  can't make any assertions about relatedException		          other than access should not raise exception   -->		<relatedException var="relatedException" obj="error"/>		<!-- location should have relatedNode-->		<location var="location" obj="error"/>		<relatedNode var="problemNode" obj="location" interface="DOMLocator"/>		<assertSame actual="problemNode" expected="newChild" id="relatedNode"/>		<!--  			can't make assertions about these values   		-->		<lineNumber var="lineNumber" obj="location"/>		<columnNumber var="columnNumber" obj="location"/>		<byteOffset var="byteOffset" obj="location"/>		<utf16Offset var="utf16Offset" obj="location"/>		<uri var="uri" obj="location" interface="DOMLocator"/>		<increment var="splittedCount" value="1"/>		<else>			<assertEquals actual="severity" expected="1" ignoreCase="false" id="anyOthersShouldBeWarnings"/>		</else>	</if></for-each>
                // assert_eq!(r#splitted_count, 1); // <assertEquals actual="splittedCount" expected="1" ignoreCase="false" id="oneSplittedWarning"/>
            }
            // nodeisequalnode01.xml
            #[test]
            fn test_nodeisequalnode01() {
                let mut r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                let mut r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                r#doc1 = todo!(); // hc_staff.xml // <load var="doc1" href="hc_staff" willBeModified="false"/>
                r#doc2 = todo!(); // hc_staff.xml // <load var="doc2" href="hc_staff" willBeModified="false"/>
                r#is_equal = r#doc1.is_equal_node(&r#doc2.into()); // <isEqualNode var="isEqual" obj="doc1" arg="doc2"/>
                assert!(r#is_equal); // <assertTrue actual="isEqual" id="nodeisequalnode01"/>
            }
            // datatypenormalization15.xml
            #[test]
            fn test_datatypenormalization15() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#str; // type: DOMString // <var name="str" type="DOMString"/>
                // let mut r#can_set_normalization; // type: boolean // <var name="canSetNormalization" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#can_set_xml_schema; // type: boolean // <var name="canSetXMLSchema" type="boolean"/>
                // let mut r#xsd_ns; // type: DOMString // <var name="xsdNS" type="DOMString" value="&quot;http://www.w3.org/2001/XMLSchema&quot;"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#child_node; // type: Node // <var name="childNode" type="Node"/>
                // let mut r#child_value; // type: DOMString // <var name="childValue" type="DOMString"/>
                // r#doc = todo!(); // datatype_normalization2.xml // <load var="doc" href="datatype_normalization2" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetNormalization" obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetValidate" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetXMLSchema" obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>

                // // unimplemented: // <if>	<and>		<isTrue value="canSetNormalization"/>		<isTrue value="canSetValidate"/>		<isTrue value="canSetXMLSchema"/>	</and>	<setParameter obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>	<normalizeDocument obj="doc"/>	<!--  fail test if normalize had any errors or fatal errors   -->	<assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>	<getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" localName="&quot;code&quot;" interface="Document"/>	<item var="element" obj="elemList" interface="NodeList" index="0"/>	<firstChild var="childNode" obj="element" interface="Node"/>	<nodeValue var="childValue" obj="childNode"/>	<assertEquals actual="childValue" expected="&quot;EMP 0001&quot;" ignoreCase="false" id="content1"/>	<item var="element" obj="elemList" interface="NodeList" index="1"/>	<firstChild var="childNode" obj="element" interface="Node"/>	<nodeValue var="childValue" obj="childNode"/>	<assertEquals actual="childValue" expected="&quot;EMP 0001&quot;" ignoreCase="false" id="content2"/>	<item var="element" obj="elemList" interface="NodeList" index="2"/>	<firstChild var="childNode" obj="element" interface="Node"/>	<nodeValue var="childValue" obj="childNode"/>	<assertEquals actual="childValue" expected="&quot;EMP 0001&quot;" ignoreCase="false" id="content3"/></if>
            }
            // noderemovechild25.xml
            #[test]
            fn test_noderemovechild25() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#ent4; // type: Entity // <var name="ent4" type="Entity"/>
                // let mut r#span; // type: Element // <var name="span" type="Element"/>
                // let mut r#removed; // type: Node // <var name="removed" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#ent4 = r#entities_map.get_named_item("ent4".into()).unwrap(); // <getNamedItem var="ent4" interface="NamedNodeMap" obj="entitiesMap" name="&quot;ent4&quot;"/>

                // // unimplemented: // <assertNotNull actual="ent4" id="ent4NotNull"/>
                // r#span = r#ent4.first_child().unwrap(); // <firstChild var="span" obj="ent4" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="span" id="spanNotNull"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">	<NO_MODIFICATION_ALLOWED_ERR>		<removeChild obj="ent4" var="removed" oldChild="span"/>	</NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // nodegettextcontent05.xml
            #[test]
            fn test_nodegettextcontent05() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#notations_map; // type: NamedNodeMap // <var name="notationsMap" type="NamedNodeMap"/>
                // let mut r#notation1; // type: Notation // <var name="notation1" type="Notation"/>
                // let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <notations var="notationsMap" obj="docType"/>
                // r#notation1 = r#notations_map.get_named_item("notation1".into()).unwrap(); // <getNamedItem var="notation1" obj="notationsMap" name="&quot;notation1&quot;"/>
                // r#text_content = r#doc_type.text_content().unwrap(); // <textContent var="textContent" obj="docType"/>

                // // unimplemented: // <assertNull actual="textContent" id="nodegettextcontent05"/>
            }
            // nodereplacechild32.xml
            #[test]
            fn test_nodereplacechild32() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#parent; // type: Attr // <var name="parent" type="Attr"/>
                // let mut r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                // let mut r#new_child; // type: Text // <var name="newChild" type="Text"/>
                // let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                // let mut r#en_ref; // type: EntityReference // <var name="enRef" type="EntityReference"/>
                // let mut r#en_ref_child; // type: EntityReference // <var name="enRefChild" type="EntityReference"/>
                // let mut r#reference; // type: DOMString // <var name="reference" type="DOMString" value="&quot;entity1&quot;"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#new_child = r#doc.create_text_node("Text"); // <createTextNode var="newChild" obj="doc" data="&quot;Text&quot;"/>
                // r#child_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "acronym"); // <getElementsByTagNameNS var="childList" obj="doc" namespaceURI="&quot;*&quot;" localName="&quot;acronym&quot;" interface="Document"/>
                // r#elem = r#child_list.item(3).unwrap().clone(); // <item var="elem" obj="childList" index="3" interface="NodeList"/>
                // r#parent = r#elem.get_attribute_node("class").unwrap(); // <getAttributeNode var="parent" obj="elem" name="&quot;class&quot;"/>
                // r#en_ref = r#doc
                //     .create_entity_reference(reference.to_string())
                //     .unwrap(); // <createEntityReference var="enRef" obj="doc" name="reference"/>
                // r#en_ref_child = r#parent.append_child(en_ref.into()).unwrap(); // <appendChild var="enRefChild" obj="parent" newChild="enRef"/>
                // r#replaced = r#parent
                //     .replace_child(new_child.into(), en_ref_child.into())
                //     .unwrap(); // <replaceChild var="replaced" obj="parent" oldChild="enRefChild" newChild="newChild"/>
                // r#node_name = r#replaced.node_name().to_string(); // <nodeName var="nodeName" obj="replaced"/>
                // assert_eq!(r#node_name, "entity1"); // <assertEquals actual="nodeName" expected="&quot;entity1&quot;" id="nodereplacechild32" ignoreCase="false"/>
            }
            // nodesetuserdata09.xml
            #[test]
            fn test_nodesetuserdata09() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#returned; // type: DOMUserData // <var name="returned" type="DOMUserData"/>
                // let mut r#null_handler; // type: UserDataHandler // <var name="nullHandler" type="UserDataHandler" isNull="true"/>
                // let mut r#ret_user_data; // type: DOMUserData // <var name="retUserData" type="DOMUserData"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>

                // // unimplemented: // <setUserData obj="docElem" var="retUserData" key="&quot;Key1&quot;" data="doc" handler="nullHandler"/>

                // // unimplemented: // <getUserData var="returned" obj="doc" key="&quot;Key1&quot;"/>

                // // unimplemented: // <assertNull actual="returned" id="nodesetuserdata09"/>
            }
            // noderemovechild05.xml
            #[test]
            fn test_noderemovechild05() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#removed_doc_type; // type: DocumentType // <var name="removedDocType" type="DocumentType"/>
                // let mut r#null_pub_id; // type: DOMString // <var name="nullPubId" type="DOMString" isNull="true"/>
                // let mut r#null_sys_id; // type: DOMString // <var name="nullSysId" type="DOMString" isNull="true"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#removed_child; // type: Node // <var name="removedChild" type="Node"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <try>	<removeChild obj="doc" var="removedChild" oldChild="docType"/>	<catch>		<DOMException code="NOT_SUPPORTED_ERR">			<return/>		</DOMException>	</catch></try>

                // // unimplemented: // <assertNotNull actual="removedChild" id="removedChildNotNull"/>
                // r#removed_doc_type = r#doc.doctype().unwrap(); // <doctype var="removedDocType" obj="doc"/>

                // // unimplemented: // <assertNull actual="removedDocType" id="noderemovechild05"/>

                // // unimplemented: // <assertDOMException id="NOT_FOUND_ERR_noderemovechild05"><NOT_FOUND_ERR><removeChild obj="docType" var="removedChild" oldChild="doc"/></NOT_FOUND_ERR></assertDOMException>
            }
            // typeinfoisderivedfrom06.xml
            #[test]
            fn test_typeinfoisderivedfrom06() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(0).unwrap(); // <item var="acronymElem" obj="elemList" index="0" interface="NodeList"/>
                // r#attr = r#acronym_elem.get_attribute_node("title").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;title&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "string"); // <assertEquals actual="typeName" expected="&quot;string&quot;" ignoreCase="false" id="nameIsString"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anyType&quot;" derivationMethod="14"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="derivedFromAnyTypeExceptRestriction"/>
            }
            // nodesettextcontent12.xml
            #[test]
            fn test_nodesettextcontent12() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#elem = r#doc.document_element().unwrap(); // <documentElement var="elem" obj="doc"/>
                // r#ent_ref = r#doc.create_entity_reference("beta".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;beta&quot;"/>
                // r#appended_child = r#elem.append_child(ent_ref.into()).unwrap();
                // // <appendChild obj="elem" var="appendedChild" newChild="entRef"/>

                // // unimplemented: // <assertDOMException id="nodesettextcontent12"><NO_MODIFICATION_ALLOWED_ERR><textContent obj="entRef" value="&quot;NA&quot;"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // textwholetext02.xml
            #[test]
            fn test_textwholetext02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#item_list; // type: NodeList // <var name="itemList" type="NodeList"/>
                let mut r#element_name; // type: Element // <var name="elementName" type="Element"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#new_text_node; // type: Text // <var name="newTextNode" type="Text"/>
                let mut r#whole_text; // type: DOMString // <var name="wholeText" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#item_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="itemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#element_name = r#item_list.item(0).unwrap(); // <item var="elementName" obj="itemList" index="0" interface="NodeList"/>
                r#new_text_node = r#doc.create_text_node("New Text"); // <createTextNode var="newTextNode" obj="doc" data="&quot;New Text&quot;"/>
                r#appended_child = r#element_name.append_child(new_text_node.into()).unwrap(); // <appendChild obj="elementName" var="appendedChild" newChild="newTextNode"/>
                r#text_node = r#element_name
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild var="textNode" obj="elementName" interface="Node"/>
                r#whole_text = r#text_node.whole_text().to_string(); // <wholeText obj="textNode" var="wholeText"/>
                assert_eq!(r#whole_text, "Margaret MartinNew Text"); // <assertEquals expected="&quot;Margaret MartinNew Text&quot;" actual="wholeText" id="textwholetext02" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom37.xml
            #[test]
            fn test_typeinfoisderivedfrom37() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anyType&quot;" derivationMethod="1"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="derivedFromAnyTypeRestriction"/>
            }
            // documentgetdoctype01.xml
            #[test]
            fn test_documentgetdoctype01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#new_doc_type; // type: DocumentType // <var name="newDocType" type="DocumentType"/>
                // let mut r#replaced_doc_type; // type: DocumentType // <var name="replacedDocType" type="DocumentType"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_sys_id; // type: DOMString // <var name="newSysID" type="DOMString"/>
                // let mut r#null_pub_id; // type: DOMString // <var name="nullPubID" type="DOMString" isNull="true"/>
                // let mut r#null_sys_id; // type: DOMString // <var name="nullSysID" type="DOMString" isNull="true"/>
                // let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                // r#root_name = r#doc_type.name().to_string(); // <name var="rootName" obj="docType" interface="DocumentType"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <createDocumentType obj="domImpl" var="newDocType" qualifiedName="rootName" publicId="nullPubID" systemId="nullSysID"/>

                // // unimplemented: // <try>	<replaceChild obj="doc" var="replaced" newChild="newDocType" oldChild="docType"/>	<catch>		<DOMException code="NOT_SUPPORTED_ERR">			<return/>		</DOMException>	</catch></try>
                // r#replaced_doc_type = r#doc.doctype().unwrap(); // <doctype var="replacedDocType" obj="doc"/>
                // r#new_sys_id = r#replaced_doc_type.system_id().unwrap().to_string(); // <systemId var="newSysID" obj="replacedDocType" interface="DocumentType"/>

                // // unimplemented: // <assertNull actual="newSysID" id="newSysIdNull"/>
            }
            // userdatahandler03.xml
            #[test]
            fn test_userdatahandler03() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#user_data_monitor; // type: UserDataMonitor // <var name="userDataMonitor" type="UserDataMonitor"/>
                // let mut r#old_user_data; // type: DOMUserData // <var name="oldUserData" type="DOMUserData"/>
                // let mut r#element_ns; // type: DOMString // <var name="elementNS" type="DOMString"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // let mut r#notifications; // type: List // <var name="notifications" type="List"/>
                // let mut r#notification; // type: UserDataNotification // <var name="notification" type="UserDataNotification"/>
                // let mut r#operation; // type: short // <var name="operation" type="short"/>
                // let mut r#key; // type: DOMString // <var name="key" type="DOMString"/>
                // let mut r#data; // type: DOMString // <var name="data" type="DOMString"/>
                // let mut r#src; // type: Node // <var name="src" type="Node"/>
                // let mut r#dst; // type: Node // <var name="dst" type="Node"/>
                // let mut r#greeting_count; // type: int // <var name="greetingCount" type="int" value="0"/>
                // let mut r#salutation_count; // type: int // <var name="salutationCount" type="int" value="0"/>
                // let mut r#hello; // type: DOMString // <var name="hello" type="DOMString" value="&quot;Hello&quot;"/>
                // let mut r#mister; // type: DOMString // <var name="mister" type="DOMString" value="&quot;Mr.&quot;"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" qualifiedName="rootName" namespaceURI="rootNS" doctype="docType"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#node = r#p_list.item(0).unwrap(); // <item var="node" obj="pList" index="0" interface="NodeList"/>

                // // unimplemented: // <setUserData var="oldUserData" obj="node" key="&quot;greeting&quot;" data="hello" handler="userDataMonitor"/>

                // // unimplemented: // <setUserData var="oldUserData" obj="node" key="&quot;salutation&quot;" data="mister" handler="userDataMonitor"/>
                // r#element_ns = r#node.namespace_uri().unwrap().to_string(); // <namespaceURI var="elementNS" obj="node" interface="Node"/>
                // r#new_node = r#doc.import_node(r#node.into(), true); // <importNode var="newNode" obj="doc" importedNode="node" deep="true"/>

                // // unimplemented: // <allNotifications var="notifications" obj="userDataMonitor"/>

                // // unimplemented: // <assertSize size="2" collection="notifications" id="twoNotifications"/>

                // // unimplemented: // <for-each member="notification" collection="notifications">	<operation var="operation" obj="notification"/>	<assertEquals actual="operation" expected="2" ignoreCase="false" id="operationIsImport"/>	<key var="key" obj="notification"/>	<data var="data" obj="notification" interface="UserDataNotification"/>	<if>		<equals actual="key" expected="&quot;greeting&quot;" ignoreCase="false"/>		<assertEquals actual="data" expected="hello" ignoreCase="false" id="greetingDataHello"/>		<increment var="greetingCount" value="1"/>		<else>			<assertEquals actual="key" expected="&quot;salutation&quot;" ignoreCase="false" id="saluationKey"/>			<assertEquals actual="data" expected="mister" ignoreCase="false" id="salutationDataMr"/>			<increment var="salutationCount" value="1"/>		</else>	</if>	<src interface="UserDataNotification" var="src" obj="notification"/>	<assertSame actual="src" expected="node" id="srcIsNode"/>	<dst var="dst" obj="notification"/>	<assertSame actual="dst" expected="newNode" id="dstIsNewNode"/></for-each>
                // assert_eq!(r#greeting_count, 1); // <assertEquals actual="greetingCount" expected="1" ignoreCase="false" id="greetingCountIs1"/>
                // assert_eq!(r#salutation_count, 1); // <assertEquals actual="salutationCount" expected="1" ignoreCase="false" id="salutationCountIs1"/>
            }
            // entitygetxmlencoding01.xml
            #[test]
            fn test_entitygetxmlencoding01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#encoding_name; // type: DOMString // <var name="encodingName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#entity = r#entities_map.get_named_item("alpha".into()).unwrap(); // <getNamedItem var="entity" obj="entitiesMap" name="&quot;alpha&quot;"/>
                // r#encoding_name = r#entity.xml_encoding().unwrap().to_string(); // <xmlEncoding obj="entity" var="encodingName" interface="Entity"/>

                // // unimplemented: // <assertNull actual="encodingName" id="entitygetxmlencoding01"/>
            }
            // typeinfogettypename04.xml
            #[test]
            fn test_typeinfogettypename04() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>

                // // unimplemented: // <implementationAttribute name="validating" value="true"/>

                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#em_elem; // type: Element // <var name="emElem" type="Element"/>
                // let mut r#elem_type_info; // type: TypeInfo // <var name="elemTypeInfo" type="TypeInfo"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                // r#em_elem = r#elem_list.item(0).unwrap(); // <item var="emElem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="elemTypeInfo" obj="emElem" interface="Element"/>

                // // unimplemented: // <typeName var="typeName" obj="elemTypeInfo"/>
                // assert_eq!(r#type_name, "emType"); // <assertEquals expected="&quot;emType&quot;" actual="typeName" id="typeinfogettypename04_1" ignoreCase="false"/>
            }
            // documentadoptnode03.xml
            #[test]
            fn test_documentadoptnode03() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                // let mut r#adopted_attr; // type: Attr // <var name="adoptedAttr" type="Attr"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#node_namespace_uri; // type: DOMString // <var name="nodeNamespaceURI" type="DOMString"/>
                // let mut r#node_prefix; // type: DOMString // <var name="nodePrefix" type="DOMString"/>
                // let mut r#attr_owner_elem; // type: Element // <var name="attrOwnerElem" type="Element"/>
                // let mut r#is_specified; // type: boolean // <var name="isSpecified" type="boolean"/>
                // let mut r#xml_ns = "http://www.w3.org/XML/1998/namespace"; // type: DOMString // <var name="xmlNS" type="DOMString" value="&quot;http://www.w3.org/XML/1998/namespace&quot;"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#new_attr = r#doc
                //     .create_attribute_ns(Some(r#xml_ns.as_ref()), "xml:lang".as_ref())
                //     .unwrap(); // <createAttributeNS var="newAttr" obj="doc" namespaceURI="xmlNS" qualifiedName="&quot;xml:lang&quot;"/>
                // r#adopted_attr = r#doc.adopt_node(r#new_attr.into()); // <adoptNode var="adoptedAttr" obj="doc" source="newAttr"/>

                // // unimplemented: // <if><notNull obj="adoptedAttr"/><nodeName var="nodeName" obj="adoptedAttr"/><namespaceURI var="nodeNamespaceURI" obj="adoptedAttr" interface="Node"/><prefix var="nodePrefix" obj="adoptedAttr"/><ownerElement var="attrOwnerElem" obj="adoptedAttr" interface="Attr"/><specified var="isSpecified" obj="adoptedAttr"/><assertEquals expected="&quot;xml:lang&quot;" actual="nodeName" id="documentadoptode03_nodeName" ignoreCase="false"/><assertEquals expected="xmlNS" actual="nodeNamespaceURI" id="documentadoptNode03_namespaceURI" ignoreCase="false"/><assertEquals expected="&quot;xml&quot;" actual="nodePrefix" id="documentadoptnode03_prefix" ignoreCase="false"/><assertNull actual="attrOwnerElem" id="documentadoptnode03_ownerDoc"/><assertTrue actual="isSpecified" id="documentadoptnode03_specified"/></if>
            }
            // nodeisdefaultnamespace11.xml
            #[test]
            fn test_nodeisdefaultnamespace11() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#imported_node; // type: Element // <var name="importedNode" type="Element"/>
                // let mut r#is_default; // type: boolean // <var name="isDefault" type="boolean"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#elem = r#doc
                //     .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "p".as_ref())
                //     .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;p&quot;"/>
                // r#imported_node = r#new_doc.import_node(r#elem.into(), true).unwrap(); // <importNode var="importedNode" obj="newDoc" importedNode="elem" deep="true"/>
                // r#is_default = r#imported_node.is_default_namespace("http://www.w3.org/1999/xhtml"); // <isDefaultNamespace var="isDefault" obj="importedNode" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>
                // assert!(r#is_default); // <assertTrue actual="isDefault" id="nodeisdefaultnamespace11"/>
            }
            // documentrenamenode09.xml
            #[test]
            fn test_documentrenamenode09() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#renamed_node; // type: Node // <var name="renamedNode" type="Node"/>
                // let mut r#adopted; // type: Node // <var name="adopted" type="Node"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#attr_node_name; // type: DOMString // <var name="attrNodeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;dom:newD&quot;" doctype="nullDocType"/>
                // r#attr = r#doc
                //     .create_attribute_ns(
                //         Some("http://www.w3.org/DOM/Test"),
                //         "test".as_ref(),
                //     )
                //     .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;test&quot;"/>
                // r#adopted = r#new_doc.adopt_node(r#attr.into()).unwrap(); // <adoptNode obj="newDoc" var="adopted" source="attr"/>
                // r#renamed_node = r#new_doc
                //     .rename_node(
                //         r#attr.into(),
                //         Some("http://www.w3.org/2000/xmlns/"),
                //         "xmlns:xmlns",
                //     )
                //     .unwrap(); // <renameNode var="renamedNode" obj="newDoc" n="attr" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" qualifiedName="&quot;xmlns:xmlns&quot;"/>
                // r#attr_node_name = r#renamed_node.node_name().to_string(); // <nodeName var="attrNodeName" obj="renamedNode"/>
                // assert_eq!(r#attr_node_name, "xmlns:xmlns"); // <assertEquals actual="attrNodeName" expected="&quot;xmlns:xmlns&quot;" id="documentrenamenode09_1" ignoreCase="false"/>
            }
            // documentadoptnode11.xml
            #[test]
            fn test_documentadoptnode11() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#adopted_doc_type; // type: Node // <var name="adoptedDocType" type="Node"/>
                // let mut r#null_pub_id; // type: DOMString // <var name="nullPubID" type="DOMString" isNull="true"/>
                // let mut r#null_sys_id; // type: DOMString // <var name="nullSysID" type="DOMString" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocumentType var="docType" obj="domImpl" qualifiedName="rootName" publicId="nullPubID" systemId="nullSysID"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><adoptNode var="adoptedDocType" obj="doc" source="docType"/></NOT_SUPPORTED_ERR></assertDOMException>
            }
            // nodegettextcontent16.xml
            #[test]
            fn test_nodegettextcontent16() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // unimplemented: // <implementationAttribute name="expandEntityReferences" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#cdata; // type: CDATASection // <var name="cdata" type="CDATASection"/>
                let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM/Test"), "dom3:elem".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;dom3:elem&quot;"/>
                r#txt = r#doc.create_text_node("Text "); // <createTextNode var="txt" obj="doc" data="&quot;Text &quot;"/>
                r#comment = r#doc.create_comment("Comment "); // <createComment var="comment" obj="doc" data="&quot;Comment &quot;"/>
                r#ent_ref = r#doc.create_entity_reference("beta".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;beta&quot;"/>
                r#pi = r#doc
                    .create_processing_instruction("PIT", Some("PIData "))
                    .unwrap(); // <createProcessingInstruction var="pi" obj="doc" target="&quot;PIT&quot;" data="&quot;PIData &quot;"/>
                r#cdata = r#doc.create_cdata_section("CData").unwrap(); // <createCDATASection var="cdata" obj="doc" data="&quot;CData&quot;"/>
                r#appended_child = r#elem.append_child(txt.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="txt"/>
                r#appended_child = r#elem.append_child(comment.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="comment"/>
                r#appended_child = r#elem.append_child(ent_ref.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="entRef"/>
                r#appended_child = r#elem.append_child(pi.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="pi"/>
                r#appended_child = r#elem.append_child(cdata.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="cdata"/>
                r#appended_child = r#doc_frag.append_child(elem.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="elem"/>
                r#doc.normalize_document(); // <normalizeDocument obj="doc"/>
                r#text_content = r#doc_frag.text_content().unwrap(); // <textContent var="textContent" obj="docFrag"/>
                assert_eq!(r#text_content, "Text CData"); // <assertEquals actual="textContent" expected="&quot;Text CData&quot;" id="nodegettextcontent16" ignoreCase="false"/>
            }
            // nodeisequalnode19.xml
            #[test]
            fn test_nodeisequalnode19() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attr1; // type: Attr // <var name="attr1" type="Attr"/>
                let mut r#attr2; // type: Attr // <var name="attr2" type="Attr"/>
                let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#attr1 = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/XML/1998/namespace"),
                        "lang".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="attr1" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;lang&quot;"/>
                r#attr2 = r#doc.create_attribute_ns(None, "lang".as_ref()).unwrap(); // <createAttributeNS var="attr2" obj="doc" namespaceURI="nullNSURI" qualifiedName="&quot;lang&quot;"/>
                r#is_equal = r#attr1.is_equal_node(&r#attr2.into()); // <isEqualNode var="isEqual" obj="attr1" arg="attr2"/>
                assert!(!r#is_equal); // <assertFalse actual="isEqual" id="nodeisequalnode19"/>
            }
            // nodegetbaseuri04.xml
            #[test]
            fn test_nodegetbaseuri04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#base_uri; // type: DOMString // <var name="baseURI" type="DOMString"/>
                let mut r#document_uri; // type: DOMString // <var name="documentURI" type="DOMString"/>
                r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#base_uri = r#doc_elem.base_uri().unwrap().to_string(); // <baseURI var="baseURI" obj="docElem" interface="Node"/>

                // unimplemented: // <assertURIEquals actual="baseURI" isAbsolute="true" name="&quot;barfoo&quot;" id="baseURI"/>
                r#document_uri = r#doc.document_uri().unwrap().to_string(); // <documentURI var="documentURI" obj="doc"/>
                assert_eq!(r#base_uri, document_uri); // <assertEquals actual="baseURI" expected="documentURI" ignoreCase="false" id="baseURIEqualsDocURI"/>
            }
            // checkcharacternormalization03.xml
            #[test]
            fn test_checkcharacternormalization03() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // let mut r#text_value; // type: DOMString // <var name="textValue" type="DOMString"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;check-character-normalization&quot;" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;check-character-normalization&quot;" value="true"/><setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/><getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/><item var="pElem" obj="pList" index="0" interface="NodeList"/><!--  character entity is expanded during code generation        code equivalent to "suc\u0327on"    --><createTextNode var="text" obj="doc" data="&quot;sucon&quot;"/><appendChild var="retval" obj="pElem" newChild="text"/><normalize obj="doc"/><!--  fail test if normalize had any errors or fatal errors   --><assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/><getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/><item var="pElem" obj="pList" index="0" interface="NodeList"/><firstChild var="text" obj="pElem" interface="Node"/><nodeValue var="textValue" obj="text"/><assertEquals actual="textValue" expected="&quot;barsucon&quot;" ignoreCase="false" id="noCharNormalization"/> </if>
            }
            // typeinfoisderivedfrom64.xml
            #[test]
            fn test_typeinfoisderivedfrom64() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#ac_elem; // type: Element // <var name="acElem" type="Element"/>
                // let mut r#class_attr; // type: Attr // <var name="classAttr" type="Attr"/>
                // let mut r#attr_type_info; // type: TypeInfo // <var name="attrTypeInfo" type="TypeInfo"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // let mut r#ret_value; // type: boolean // <var name="retValue" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#ac_elem = r#elem_list.item(1).unwrap(); // <item var="acElem" obj="elemList" index="1" interface="NodeList"/>
                // r#class_attr = r#ac_elem.get_attribute_node("class").unwrap(); // <getAttributeNode var="classAttr" obj="acElem" name="&quot;class&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="attrTypeInfo" obj="classAttr" interface="Attr"/>

                // // unimplemented: // <isDerivedFrom obj="attrTypeInfo" var="retValue" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;classType&quot;" derivationMethod="1"/>
                // assert!(r#ret_value); // <assertTrue actual="retValue" id="derivedFromClassType"/>

                // // unimplemented: // <isDerivedFrom obj="attrTypeInfo" var="retValue" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;string&quot;" derivationMethod="1"/>
                // assert!(r#ret_value); // <assertTrue actual="retValue" id="derivedFromString"/>
            }
            // entitygetxmlversion01.xml
            #[test]
            fn test_entitygetxmlversion01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#entity_version; // type: DOMString // <var name="entityVersion" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#entity = r#entities_map.get_named_item("epsilon".into()).unwrap(); // <getNamedItem var="entity" obj="entitiesMap" name="&quot;epsilon&quot;"/>
                // r#entity_version = r#entity.xml_version().unwrap().to_string(); // <xmlVersion obj="entity" var="entityVersion" interface="Entity"/>

                // // unimplemented: // <assertNull actual="entityVersion" id="entitygetxmlversion01"/>
            }
            // canonicalform02.xml
            #[test]
            fn test_canonicalform02() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // let mut r#text_value; // type: DOMString // <var name="textValue" type="DOMString"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;canonical-form&quot;" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;canonical-form&quot;" value="true"/><setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/><getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/><item var="pElem" obj="pList" index="0" interface="NodeList"/><!--  character entity is expanded during code generation        code equivalent to "suc\u0327on"    --><createTextNode var="text" obj="doc" data="&quot;sucon&quot;"/><appendChild var="retval" obj="pElem" newChild="text"/><normalizeDocument obj="doc"/><!--  fail test if normalize had any errors or fatal errors   --><assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/><getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/><item var="pElem" obj="pList" index="0" interface="NodeList"/><firstChild var="text" obj="pElem" interface="Node"/><nodeValue var="textValue" obj="text"/><assertEquals actual="textValue" expected="&quot;barsucon&quot;" ignoreCase="false" id="noCharNormalization"/> </if>
            }
            // typeinfoisderivedfrom18.xml
            #[test]
            fn test_typeinfoisderivedfrom18() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "emType"); // <assertEquals actual="typeName" expected="&quot;emType&quot;" ignoreCase="false" id="typeName"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;ID&quot;" derivationMethod="1"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="derivedFromID"/>
            }
            // typeinfoisderivedfrom58.xml
            #[test]
            fn test_typeinfoisderivedfrom58() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#code_elem; // type: Element // <var name="codeElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // typeinfo.xml // <load var="doc" href="typeinfo" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("code"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;code&quot;" interface="Document"/>
                // r#code_elem = r#elem_list.item(0).unwrap(); // <item var="codeElem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="codeElem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;unbounded&quot;" derivationMethod="4"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="isDerived"/>
            }
            // nodelookupprefix07.xml
            #[test]
            fn test_nodelookupprefix07() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                r#elem = r#elem_list.item(2).unwrap(); // <item var="elem" obj="elemList" index="2" interface="NodeList"/>
                r#prefix = r#elem
                    .lookup_prefix("http://www.netzero.com")
                    .unwrap()
                    .to_string(); // <lookupPrefix var="prefix" obj="elem" namespaceURI="&quot;http://www.netzero.com&quot;"/>
                assert_eq!(r#prefix, "dmstc"); // <assertEquals actual="prefix" expected="&quot;dmstc&quot;" id="nodelookupprefix07" ignoreCase="false"/>
            }
            // documentadoptnode36.xml
            #[test]
            fn test_documentadoptnode36() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#new_p_i1; // type: ProcessingInstruction // <var name="newPI1" type="ProcessingInstruction"/>
                // let mut r#new_p_i2; // type: ProcessingInstruction // <var name="newPI2" type="ProcessingInstruction"/>
                // let mut r#adopted_p_i1; // type: ProcessingInstruction // <var name="adoptedPI1" type="ProcessingInstruction"/>
                // let mut r#adopted_p_i2; // type: ProcessingInstruction // <var name="adoptedPI2" type="ProcessingInstruction"/>
                // let mut r#pi_target; // type: DOMString // <var name="piTarget" type="DOMString"/>
                // let mut r#pi_data; // type: DOMString // <var name="piData" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#new_p_i1 = r#new_doc
                //     .create_processing_instruction("PITarget", Some("PIData"))
                //     .unwrap(); // <createProcessingInstruction var="newPI1" obj="newDoc" target="&quot;PITarget&quot;" data="&quot;PIData&quot;"/>
                // r#new_p_i2 = r#doc
                //     .create_processing_instruction("PITarget", Some("PIData"))
                //     .unwrap(); // <createProcessingInstruction var="newPI2" obj="doc" target="&quot;PITarget&quot;" data="&quot;PIData&quot;"/>
                // r#adopted_p_i1 = r#new_doc.adopt_node(r#new_p_i1.into()); // <adoptNode var="adoptedPI1" obj="newDoc" source="newPI1"/>

                // // unimplemented: // <if><notNull obj="adoptedPI1"/><adoptNode var="adoptedPI2" obj="newDoc" source="newPI2"/><if><notNull obj="adoptedPI2"/><target var="piTarget" obj="adoptedPI1" interface="ProcessingInstruction"/><data var="piData" obj="adoptedPI1" interface="ProcessingInstruction"/><assertEquals actual="piTarget" expected="&quot;PITarget&quot;" id="documentadoptnode36_Target1" ignoreCase="false"/><assertEquals actual="piData" expected="&quot;PIData&quot;" id="documentadoptnode36_Data1" ignoreCase="false"/><target var="piTarget" obj="adoptedPI2" interface="ProcessingInstruction"/><data var="piData" obj="adoptedPI2" interface="ProcessingInstruction"/><assertEquals actual="piTarget" expected="&quot;PITarget&quot;" id="documentadoptnode36_Target2" ignoreCase="false"/><assertEquals actual="piData" expected="&quot;PIData&quot;" id="documentadoptnode36_Data2" ignoreCase="false"/></if></if>
            }
            // nodesettextcontent04.xml
            #[test]
            fn test_nodesettextcontent04() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#notations_map; // type: NamedNodeMap // <var name="notationsMap" type="NamedNodeMap"/>
                // let mut r#notation1; // type: Notation // <var name="notation1" type="Notation"/>
                // let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <notations var="notationsMap" obj="docType"/>
                // r#notation1 = r#notations_map.get_named_item("notation1".into()).unwrap(); // <getNamedItem var="notation1" obj="notationsMap" name="&quot;notation1&quot;"/>
                // r#notation1.set_text_content("textContent").unwrap(); // <textContent value="&quot;textContent&quot;" obj="notation1"/>
                // r#text_content = r#notation1.text_content().unwrap(); // <textContent var="textContent" obj="notation1"/>

                // // unimplemented: // <assertNull actual="textContent" id="nodesettextcontent04"/>
            }
            // typeinfogettypenamespace03.xml
            #[test]
            fn test_typeinfogettypenamespace03() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>

                // // unimplemented: // <implementationAttribute name="validating" value="true"/>

                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#class_attr; // type: Attr // <var name="classAttr" type="Attr"/>
                // let mut r#attr_type_info; // type: TypeInfo // <var name="attrTypeInfo" type="TypeInfo"/>
                // let mut r#type_namespace; // type: DOMString // <var name="typeNamespace" type="DOMString"/>
                // let mut r#ac_elem; // type: Element // <var name="acElem" type="Element"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#ac_elem = r#elem_list.item(1).unwrap(); // <item var="acElem" obj="elemList" index="1" interface="NodeList"/>
                // r#class_attr = r#ac_elem.get_attribute_node("class").unwrap(); // <getAttributeNode var="classAttr" obj="acElem" name="&quot;class&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="attrTypeInfo" obj="classAttr" interface="Attr"/>

                // // unimplemented: // <typeNamespace var="typeNamespace" obj="attrTypeInfo"/>
                // assert_eq!(r#type_namespace, "http://www.w3.org/1999/xhtml"); // <assertEquals expected="&quot;http://www.w3.org/1999/xhtml&quot;" actual="typeNamespace" id="typeinfogettypename03_1" ignoreCase="false"/>
            }
            // nodereplacechild07.xml
            #[test]
            fn test_nodereplacechild07() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#replaced; // type: Element // <var name="replaced" type="Element"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#replaced_node; // type: Node // <var name="replacedNode" type="Node"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#elem = r#doc
                //     .create_element_ns(Some(r#root_ns.as_ref()), r#root_name.as_ref())
                //     .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="rootNS" qualifiedName="rootName"/>

                // // unimplemented: // <try>	<replaceChild obj="doc" var="replacedNode" oldChild="docElem" newChild="elem"/>	<catch>		<DOMException code="NOT_SUPPORTED_ERR">			<return/>		</DOMException>	</catch></try>
                // r#replaced = r#doc.document_element().unwrap(); // <documentElement var="replaced" obj="doc"/>
                // r#node_name = r#replaced.node_name().to_string(); // <nodeName obj="replaced" var="nodeName"/>
                // assert_eq!(r#node_name, root_name); // <assertEquals actual="nodeName" expected="rootName" id="nodereplacechild07" ignoreCase="false"/>
            }
            // documentrenamenode23.xml
            #[test]
            fn test_documentrenamenode23() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#renamed_node; // type: Node // <var name="renamedNode" type="Node"/>
                // let mut r#docowner: DocumentRef; // <var name="docowner" type="Document"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <assertDOMException id="documentrenamenode23_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><renameNode var="renamedNode" obj="doc" n="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;root&quot;"/></NOT_SUPPORTED_ERR></assertDOMException>
            }
            // nodeinsertbefore11.xml
            #[test]
            fn test_nodeinsertbefore11() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                let mut r#cdata; // type: CDATASection // <var name="cdata" type="CDATASection"/>
                let mut r#e_ref; // type: EntityReference // <var name="eRef" type="EntityReference"/>
                let mut r#inserted; // type: Node // <var name="inserted" type="Node"/>
                let mut r#inserted_val; // type: DOMString // <var name="insertedVal" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "body".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" qualifiedName="&quot;body&quot;" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>
                r#pi = r#doc
                    .create_processing_instruction("PITarget", Some("PIData"))
                    .unwrap(); // <createProcessingInstruction var="pi" obj="doc" target="&quot;PITarget&quot;" data="&quot;PIData&quot;"/>
                r#comment = r#doc.create_comment("Comment"); // <createComment var="comment" obj="doc" data="&quot;Comment&quot;"/>
                r#txt = r#doc.create_text_node("Text"); // <createTextNode var="txt" obj="doc" data="&quot;Text&quot;"/>
                r#cdata = r#doc.create_cdata_section("CDATA").unwrap(); // <createCDATASection var="cdata" obj="doc" data="&quot;CDATA&quot;"/>
                r#e_ref = r#doc.create_entity_reference("alpha".to_string()).unwrap(); // <createEntityReference var="eRef" obj="doc" name="&quot;alpha&quot;"/>
                r#appended_child = r#doc_frag.append_child(elem.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="elem"/>
                r#appended_child = r#doc_frag.append_child(pi.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="pi"/>
                r#appended_child = r#doc_frag.append_child(comment.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="comment"/>
                r#appended_child = r#doc_frag.append_child(txt.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="txt"/>
                r#appended_child = r#doc_frag.append_child(cdata.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="cdata"/>
                r#appended_child = r#doc_frag.append_child(e_ref.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="eRef"/>
                r#inserted = r#doc_frag
                    .insert_before(comment.into(), Some(pi.into()))
                    .unwrap()
                    .as_comment()
                    .unwrap(); // <insertBefore var="inserted" obj="docFrag" newChild="comment" refChild="pi"/>
                r#inserted_val = r#inserted.data().to_string(); // <data var="insertedVal" obj="inserted" interface="CharacterData"/>
                assert_eq!(r#inserted_val, "Comment"); // <assertEquals actual="insertedVal" expected="&quot;Comment&quot;" id="nodeinsertbefore11_Comment" ignoreCase="false"/>
                let r#inserted = r#doc_frag
                    .insert_before(txt.into(), Some(comment.into()))
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <insertBefore var="inserted" obj="docFrag" newChild="txt" refChild="comment"/>
                r#inserted_val = r#inserted.data().to_string(); // <data var="insertedVal" obj="inserted" interface="CharacterData"/>
                assert_eq!(r#inserted_val, "Text"); // <assertEquals actual="insertedVal" expected="&quot;Text&quot;" id="nodeinsertbefore11_Text" ignoreCase="false"/>
                let r#inserted = r#doc_frag
                    .insert_before(cdata.into(), Some(txt.into()))
                    .unwrap()
                    .as_cdata_section()
                    .unwrap(); // <insertBefore var="inserted" obj="docFrag" newChild="cdata" refChild="txt"/>
                r#inserted_val = r#inserted.data().to_string(); // <data var="insertedVal" obj="inserted" interface="CharacterData"/>
                assert_eq!(r#inserted_val, "CDATA"); // <assertEquals actual="insertedVal" expected="&quot;CDATA&quot;" id="nodeinsertbefore11_CDATA" ignoreCase="false"/>
                let r#inserted = r#doc_frag
                    .insert_before(e_ref.into(), Some(cdata.into()))
                    .unwrap()
                    .as_entity_reference()
                    .unwrap(); // <insertBefore var="inserted" obj="docFrag" newChild="eRef" refChild="cdata"/>
                r#inserted_val = r#inserted.node_name().to_string(); // <nodeName var="insertedVal" obj="inserted"/>
                assert_eq!(r#inserted_val, "alpha"); // <assertEquals actual="insertedVal" expected="&quot;alpha&quot;" id="nodeinsertbefore11_Ent1" ignoreCase="false"/>
            }
            // nodelookupnamespaceuri11.xml
            #[test]
            fn test_nodelookupnamespaceuri11() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#imported_node; // type: Element // <var name="importedNode" type="Element"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#elem = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "dom3:p".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:p&quot;"/>
                // r#imported_node = r#new_doc.import_node(r#elem.into(), true).unwrap(); // <importNode var="importedNode" obj="newDoc" importedNode="elem" deep="true"/>
                // r#namespace_uri = r#imported_node
                //     .lookup_namespace_uri("dom3")
                //     .unwrap()
                //     .to_string(); // <lookupNamespaceURI var="namespaceURI" obj="importedNode" prefix="&quot;dom3&quot;" interface="Node"/>
                // assert_eq!(r#namespace_uri, "http://www.w3.org/1999/xhtml"); // <assertEquals actual="namespaceURI" expected="&quot;http://www.w3.org/1999/xhtml&quot;" id="nodelookupnamespaceuri11" ignoreCase="false"/>
            }
            // entitygetxmlencoding02.xml
            #[test]
            fn test_entitygetxmlencoding02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#encoding_name; // type: DOMString // <var name="encodingName" type="DOMString"/>
                // r#doc = todo!(); // external_barfoo.xml // <load var="doc" href="external_barfoo" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#entity = r#entities_map.get_named_item("ent5".into()).unwrap(); // <getNamedItem var="entity" obj="entitiesMap" name="&quot;ent5&quot;"/>
                // r#encoding_name = r#entity.xml_encoding().unwrap().to_string(); // <xmlEncoding obj="entity" var="encodingName" interface="Entity"/>

                // // unimplemented: // <assertNull actual="encodingName" id="entitygetxmlencoding02"/>
            }
            // nodegettextcontent06.xml
            #[test]
            fn test_nodegettextcontent06() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#elem = r#elem_list.item(3).unwrap(); // <item var="elem" obj="elemList" index="3" interface="NodeList"/>
                r#attr = r#elem.get_attribute_node("dir").unwrap(); // <getAttributeNode var="attr" obj="elem" name="&quot;dir&quot;"/>
                r#text_content = r#attr.text_content().unwrap(); // <textContent var="textContent" obj="attr"/>
                assert_eq!(r#text_content, "rtl"); // <assertEquals actual="textContent" expected="&quot;rtl&quot;" id="nodegettextcontent06" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom69.xml
            #[test]
            fn test_typeinfoisderivedfrom69() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>

                // // unimplemented: // <implementationAttribute name="validating" value="true"/>

                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_type_info; // type: TypeInfo // <var name="elemTypeInfo" type="TypeInfo"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#ret_value; // type: boolean // <var name="retValue" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("sup"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;sup&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="elemTypeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <isDerivedFrom obj="elemTypeInfo" var="retValue" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;integer&quot;" derivationMethod="12"/>
                // assert!(!r#ret_value); // <assertFalse actual="retValue" id="isDerived"/>
            }
            // nodesetuserdata01.xml
            #[test]
            fn test_nodesetuserdata01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#user_data; // type: DOMUserData // <var name="userData" type="DOMUserData"/>
                // let mut r#prev_user_data; // type: DOMUserData // <var name="prevUserData" type="DOMUserData"/>
                // let mut r#null_handler; // type: UserDataHandler // <var name="nullHandler" type="UserDataHandler" isNull="true"/>
                // let mut r#null_data; // type: DOMUserData // <var name="nullData" type="DOMUserData" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // // unimplemented: // <setUserData var="prevUserData" obj="doc" key="&quot;something&quot;" data="nullData" handler="nullHandler"/>

                // // unimplemented: // <assertNull actual="prevUserData" id="nodesetuserdata01"/>
            }
            // canonicalform09.xml
            #[test]
            fn test_canonicalform09() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // // unimplemented: // <implementationAttribute name="validating" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#body_list; // type: NodeList // <var name="bodyList" type="NodeList"/>
                // let mut r#body; // type: Element // <var name="body" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // r#doc = todo!(); // canonicalform01.xml // <load var="doc" href="canonicalform01" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;canonical-form&quot;" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/><setParameter obj="domConfig" name="&quot;canonical-form&quot;" value="true"/><setParameter obj="domConfig" name="&quot;comments&quot;" value="false"/><normalizeDocument obj="doc"/><!--  fail test if normalize had any errors or fatal errors   --><assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/><firstChild var="node" obj="doc" interface="Node"/><nodeType var="nodeType" obj="node" interface="Node"/><assertEquals expected="7" actual="nodeType" ignoreCase="false" id="PIisFirstChild"/><data var="nodeValue" obj="node" interface="ProcessingInstruction"/><length var="length" obj="nodeValue" interface="DOMString"/><assertEquals actual="length" expected="36" ignoreCase="false" id="piDataLength"/><!--  next sibling is a #0A line feed  --><nextSibling interface="Node" var="node" obj="node"/><nodeType var="nodeType" obj="node"/><assertEquals expected="3" actual="nodeType" ignoreCase="false" id="TextisSecondChild"/><nodeValue var="nodeValue" obj="node"/><length var="length" obj="nodeValue" interface="DOMString"/><assertEquals actual="length" expected="1" ignoreCase="false" id="secondChildLength"/><!--  next sibling is document element  --><nextSibling interface="Node" var="node" obj="node"/><nodeType var="nodeType" obj="node"/><assertEquals expected="1" actual="nodeType" ignoreCase="false" id="ElementisThirdChild"/><!--  next sibling is a #0A line feed  --><nextSibling interface="Node" var="node" obj="node"/><nodeType var="nodeType" obj="node"/><assertEquals expected="3" actual="nodeType" ignoreCase="false" id="TextisFourthChild"/><nodeValue var="nodeValue" obj="node"/><length var="length" obj="nodeValue" interface="DOMString"/><assertEquals actual="length" expected="1" ignoreCase="false" id="fourthChildLength"/><!--  next sibling is a processing instruction  --><nextSibling interface="Node" var="node" obj="node"/><nodeType var="nodeType" obj="node"/><assertEquals expected="7" actual="nodeType" ignoreCase="false" id="PIisFifthChild"/><data var="nodeValue" obj="node" interface="ProcessingInstruction"/><assertEquals actual="nodeValue" expected="&quot;&quot;" ignoreCase="false" id="trailingPIData"/><!--  next sibling is a null  --><nextSibling interface="Node" var="node" obj="node"/><assertNull actual="node" id="SixthIsNull"/></if>
            }
            // nodereplacechild04.xml
            #[test]
            fn test_nodereplacechild04() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>

                // // unimplemented: // <try>        <replaceChild obj="doc" var="replaced" oldChild="docElem" newChild="doc"/>        <catch>                <DOMException code="NOT_FOUND_ERR"/>                <DOMException code="HIERARCHY_REQUEST_ERR"/>        </catch></try>
            }
            // typeinfoisderivedfrom54.xml
            #[test]
            fn test_typeinfoisderivedfrom54() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // typeinfo.xml // <load var="doc" href="typeinfo" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anySimpleType&quot;" derivationMethod="8"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromAnySimpleList"/>
            }
            // nodegetbaseuri14.xml
            #[test]
            fn test_nodegetbaseuri14() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#doc_elem_ns; // type: DOMString // <var name="docElemNS" type="DOMString"/>
                // let mut r#doc_elem_name; // type: DOMString // <var name="docElemName" type="DOMString"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#notations_map; // type: NamedNodeMap // <var name="notationsMap" type="NamedNodeMap"/>
                // let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                // let mut r#notation_imported; // type: Notation // <var name="notationImported" type="Notation"/>
                // let mut r#base_uri; // type: DOMString // <var name="baseURI" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#doc_elem_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="docElemNS" obj="docElem" interface="Node"/>
                // r#doc_elem_name = r#doc_elem.local_name().unwrap().to_string(); // <localName var="docElemName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="docElemNS" qualifiedName="docElemName" doctype="nullDocType"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <notations var="notationsMap" obj="docType"/>
                // r#notation = r#notations_map.get_named_item("notation2".into()).unwrap(); // <getNamedItem var="notation" obj="notationsMap" name="&quot;notation2&quot;"/>
                // r#notation_imported = r#new_doc.import_node(r#notation.into(), true); // <importNode var="notationImported" obj="newDoc" importedNode="notation" deep="true"/>
                // r#base_uri = r#notation_imported.base_uri().unwrap().to_string();
                // // <baseURI var="baseURI" obj="notationImported" interface="Node"/>

                // // unimplemented: // <assertNull actual="baseURI" id="nodegetbaseuri14"/>
            }
            // normalizecharacters04.xml
            #[test]
            fn test_normalizecharacters04() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // let mut r#text_value; // type: DOMString // <var name="textValue" type="DOMString"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;normalize-characters&quot;" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;normalize-characters&quot;" value="true"/><setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/><getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/><item var="pElem" obj="pList" index="0" interface="NodeList"/><!--  character entity is expanded during code generation        code equivalent to "suc\u0327on"    --><createTextNode var="text" obj="doc" data="&quot;sucon&quot;"/><appendChild var="retval" obj="pElem" newChild="text"/><normalize obj="pElem"/><!--  fail test if normalize had any errors or fatal errors   --><assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/><getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/><item var="pElem" obj="pList" index="0" interface="NodeList"/><firstChild var="text" obj="pElem" interface="Node"/><nodeValue var="textValue" obj="text"/><assertEquals actual="textValue" expected="&quot;barsuon&quot;" ignoreCase="false" id="noCharNormalization"/> </if>
            }
            // noderemovechild29.xml
            #[test]
            fn test_noderemovechild29() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#parent_list; // type: NodeList // <var name="parentList" type="NodeList"/>
                // let mut r#attrs_map; // type: NamedNodeMap // <var name="attrsMap" type="NamedNodeMap"/>
                // let mut r#parent; // type: Attr // <var name="parent" type="Attr"/>
                // let mut r#child; // type: Text // <var name="child" type="Text"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#removed; // type: Text // <var name="removed" type="Text"/>
                // let mut r#removed_name; // type: DOMString // <var name="removedName" type="DOMString"/>
                // let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#parent_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="parentList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#parent_list[0].clone(); // <item var="elem" obj="parentList" index="0" interface="NodeList"/>
                // r#attrs_map = r#elem.attributes(); // <attributes var="attrsMap" obj="elem"/>
                // r#parent = r#attrs_map.get_named_item("xmlns:dmstc").unwrap(); // <getNamedItem var="parent" obj="attrsMap" name="&quot;xmlns:dmstc&quot;"/>
                // r#child = r#parent.first_child().unwrap(); // <firstChild var="child" obj="parent" interface="Node"/>
                // r#removed = r#parent.remove_child(child.into()).unwrap(); // <removeChild var="removed" obj="parent" oldChild="child"/>
                // r#removed_name = r#removed.node_value().unwrap().to_string(); // <nodeValue obj="removed" var="removedName"/>
                // assert_eq!(r#removed_name, "http://www.usa.com"); // <assertEquals actual="removedName" expected="&quot;http://www.usa.com&quot;" id="noderemovechild29" ignoreCase="false"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR"><NOT_FOUND_ERR><removeChild obj="child" var="removedNode" oldChild="parent"/></NOT_FOUND_ERR></assertDOMException>
            }
            // domconfigurationgetparameter01.xml
            #[test]
            fn test_domconfigurationgetparameter01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#param; // type: DOMUserData // <var name="param" type="DOMUserData"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <getParameter obj="domConfig" var="param" name="&quot;comments&quot;"/>
                // assert!(r#param); // <assertTrue actual="param" id="domconfigurationgetparameter01_1"/>

                // // unimplemented: // <getParameter obj="domConfig" var="param" name="&quot;cdata-sections&quot;"/>
                // assert!(r#param); // <assertTrue actual="param" id="domconfigurationgetparameter01_2"/>

                // // unimplemented: // <getParameter obj="domConfig" var="param" name="&quot;entities&quot;"/>
                // assert!(r#param); // <assertTrue actual="param" id="domconfigurationgetparameter01_3"/>

                // // unimplemented: // <getParameter obj="domConfig" var="param" name="&quot;namespace-declarations&quot;"/>
                // assert!(r#param); // <assertTrue actual="param" id="domconfigurationgetparameter01_4"/>

                // // unimplemented: // <getParameter obj="domConfig" var="param" name="&quot;infoset&quot;"/>
                // assert!(!r#param); // <assertFalse actual="param" id="domconfigurationgetparameter01_5"/>
            }
            // nodeissamenode08.xml
            #[test]
            fn test_nodeissamenode08() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#notation1; // type: Notation // <var name="notation1" type="Notation"/>
                // let mut r#notation2; // type: Notation // <var name="notation2" type="Notation"/>
                // let mut r#is_same; // type: boolean // <var name="isSame" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <notations var="entitiesMap" obj="docType"/>
                // r#notation1 = r#entities_map.get_named_item("notation1".into()).unwrap(); // <getNamedItem var="notation1" obj="entitiesMap" name="&quot;notation1&quot;"/>
                // r#notation2 = r#entities_map.get_named_item("notation1".into()).unwrap(); // <getNamedItem var="notation2" obj="entitiesMap" name="&quot;notation1&quot;"/>
                // // <isSameNode var="isSame" obj="notation1" other="notation2"/>
                // assert!(r#is_same); // <assertTrue actual="isSame" id="nodeissamenode08"/>
            }
            // nodeisequalnode22.xml
            #[test]
            fn test_nodeisequalnode22() {
                // let mut r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                // let mut r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                // let mut r#dom_impl1; // type: DOMImplementation // <var name="domImpl1" type="DOMImplementation"/>
                // let mut r#dom_impl2; // type: DOMImplementation // <var name="domImpl2" type="DOMImplementation"/>
                // let mut r#doc_type1; // type: DocumentType // <var name="docType1" type="DocumentType"/>
                // let mut r#doc_type2; // type: DocumentType // <var name="docType2" type="DocumentType"/>
                // let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                // let mut r#null_pub_id; // type: DOMString // <var name="nullPubId" type="DOMString" isNull="true"/>
                // let mut r#null_sys_id; // type: DOMString // <var name="nullSysId" type="DOMString" isNull="true"/>
                // let mut r#old_doc_type; // type: DocumentType // <var name="oldDocType" type="DocumentType"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc1 = todo!(); // barfoo.xml // <load var="doc1" href="barfoo" willBeModified="false"/>
                // r#old_doc_type = r#doc1.doctype().unwrap(); // <doctype var="oldDocType" obj="doc1"/>
                // r#root_name = r#old_doc_type.name().to_string(); // <name var="rootName" obj="oldDocType" interface="DocumentType"/>
                // r#doc2 = todo!(); // barfoo.xml // <load var="doc2" href="barfoo" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl1" obj="doc1"/>

                // // unimplemented: // <implementation var="domImpl2" obj="doc2"/>

                // // unimplemented: // <createDocumentType var="docType1" obj="domImpl1" qualifiedName="rootName" publicId="nullPubId" systemId="nullSysId"/>

                // // unimplemented: // <createDocumentType var="docType2" obj="domImpl2" qualifiedName="rootName" publicId="nullPubId" systemId="nullSysId"/>
                // r#is_equal = r#doc_type1.is_equal_node(&r#doc_type2.into()); // <isEqualNode var="isEqual" obj="docType1" arg="docType2"/>
                // assert!(r#is_equal); // <assertTrue actual="isEqual" id="nodeisequalnode22"/>
            }
            // domimplementationregistry19.xml
            #[test]
            fn test_domimplementationregistry19() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#base_impl; // type: DOMImplementation // <var name="baseImpl" type="DOMImplementation"/>
                // let mut r#has_feature; // type: boolean // <var name="hasFeature" type="boolean"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // let mut r#dom_impl_list; // type: DOMImplementationList // <var name="domImplList" type="DOMImplementationList"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementationList var="domImplList" obj="domImplRegistry" features="&quot;SVG&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <length var="length" obj="domImplList" interface="DOMImplementationList"/>

                // // unimplemented: // <if>	<equals actual="length" expected="0" ignoreCase="false"/>	<implementation var="baseImpl"/>	<hasFeature var="hasFeature" feature="&quot;SVG&quot;"/>	<assertFalse actual="hasFeature" id="baseImplSupportsSVG"/>	<else>		<for-each collection="domImplList" member="domImpl">			<hasFeature var="hasFeature" obj="domImpl" feature="&quot;SVG&quot;" version="nullVersion"/>			<assertTrue actual="hasFeature" id="hasCore"/>		</for-each>	</else></if>
            }
            // nodereplacechild19.xml
            #[test]
            fn test_nodereplacechild19() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#replaced; // type: Element // <var name="replaced" type="Element"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "dom3:p".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:p&quot;"/>
                r#ent_ref = r#doc.create_entity_reference("alpha".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;alpha&quot;"/>
                r#appended_child = r#elem.append_child(ent_ref.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="entRef"/>
                r#appended_child = r#doc_frag.append_child(elem.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="elem"/>
                r#replaced = r#doc_frag
                    .replace_child(ent_ref.into(), elem.into())
                    .unwrap(); // <replaceChild var="replaced" obj="docFrag" oldChild="elem" newChild="entRef"/>
                r#node_name = r#replaced.node_name().to_string(); // <nodeName var="nodeName" obj="replaced"/>
                assert_eq!(r#node_name, "dom3:p"); // <assertEquals actual="nodeName" expected="&quot;dom3:p&quot;" id="nodereplacechild19" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom63.xml
            #[test]
            fn test_typeinfoisderivedfrom63() {
                // // unimplemented: // <implementationAttribute name="validating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#ret_value; // type: boolean // <var name="retValue" type="boolean"/>
                // let mut r#type_namespace; // type: DOMString // <var name="typeNamespace" type="DOMString"/>
                // let mut r#null_name; // type: DOMString // <var name="nullName" type="DOMString" isNull="true"/>
                // let mut r#elem_type_info; // type: TypeInfo // <var name="elemTypeInfo" type="TypeInfo"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(0).unwrap(); // <item var="acronymElem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="elemTypeInfo" obj="acronymElem" interface="Element"/>

                // // unimplemented: // <isDerivedFrom obj="elemTypeInfo" var="retValue" typeNamespaceArg="&quot;http://www.w3.org/TR/REC-xml&quot;" typeNameArg="nullName" derivationMethod="0"/>
                // assert!(!r#ret_value); // <assertFalse actual="retValue" id="typeinfoisderivedfrom63"/>
            }
            // elementsetidattribute09.xml
            #[test]
            fn test_elementsetidattribute09() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list1; // type: NodeList // <var name="elemList1" type="NodeList"/>
                let mut r#elem_list2; // type: NodeList // <var name="elemList2" type="NodeList"/>
                let mut r#name_elem; // type: Element // <var name="nameElem" type="Element"/>
                let mut r#salary_elem; // type: Element // <var name="salaryElem" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list1 = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList1" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#elem_list2 = r#doc.get_elements_by_tag_name("sup"); // <getElementsByTagName var="elemList2" obj="doc" tagname="&quot;sup&quot;" interface="Document"/>
                r#name_elem = r#elem_list1.item(2).unwrap(); // <item var="nameElem" obj="elemList1" index="2" interface="NodeList"/>
                r#salary_elem = r#elem_list2.item(2).unwrap(); // <item var="salaryElem" obj="elemList2" index="2" interface="NodeList"/>
                r#name_elem
                    .set_attribute("hasMiddleName", "Antoine")
                    .unwrap(); // <setAttribute obj="nameElem" name="&quot;hasMiddleName&quot;" value="&quot;Antoine&quot;"/>
                r#salary_elem.set_attribute("annual", "2002").unwrap(); // <setAttribute obj="salaryElem" name="&quot;annual&quot;" value="&quot;2002&quot;"/>
                r#name_elem.set_id_attribute("hasMiddleName", true).unwrap(); // <setIdAttribute obj="nameElem" name="&quot;hasMiddleName&quot;" isId="true"/>
                r#salary_elem.set_id_attribute("annual", true).unwrap(); // <setIdAttribute obj="salaryElem" name="&quot;annual&quot;" isId="true"/>
                r#attributes_map = r#name_elem.attributes(); // <attributes var="attributesMap" obj="nameElem"/>
                r#attr = r#attributes_map.get_named_item("hasMiddleName").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;hasMiddleName&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributeIsId1True09"/>
                r#attributes_map = r#salary_elem.attributes(); // <attributes var="attributesMap" obj="salaryElem"/>
                r#attr = r#attributes_map.get_named_item("annual").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;annual&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributeIsId2True09"/>
                r#elem = r#doc.get_element_by_id("Antoine".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;Antoine&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "strong"); // <assertEquals actual="elemName" expected="&quot;strong&quot;" id="elementsetidattribute1GetElementById09" ignoreCase="false"/>
                r#elem = r#doc.get_element_by_id("2002".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;2002&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "sup"); // <assertEquals actual="elemName" expected="&quot;sup&quot;" id="elementsetidattribute2GetElementById09" ignoreCase="false"/>
            }
            // nodelookupnamespaceuri20.xml
            #[test]
            fn test_nodelookupnamespaceuri20() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#elem = r#elem_list.item(3).unwrap(); // <item var="elem" obj="elemList" index="3" interface="NodeList"/>
                r#attributes_map = r#elem.attributes(); // <attributes var="attributesMap" obj="elem"/>
                r#attr = r#attributes_map.get_named_item("xmlns:nm").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;xmlns:nm&quot;"/>
                r#namespace_uri = r#attr.lookup_namespace_uri("nm").unwrap().to_string(); // <lookupNamespaceURI var="namespaceURI" obj="attr" prefix="&quot;nm&quot;" interface="Node"/>
                assert_eq!(r#namespace_uri, "http://www.altavista.com"); // <assertEquals actual="namespaceURI" expected="&quot;http://www.altavista.com&quot;" id="nodelookupnamespaceuri20" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom22.xml
            #[test]
            fn test_typeinfoisderivedfrom22() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "strongType"); // <assertEquals actual="typeName" expected="&quot;strongType&quot;" ignoreCase="false" id="typeName"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;string&quot;" derivationMethod="15"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromStringAnyMethod"/>
            }
            // nodegetfeature10.xml
            #[test]
            fn test_nodegetfeature10() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // let mut r#feature_impl; // type: Node // <var name="featureImpl" type="Node"/>
                // let mut r#is_supported; // type: boolean // <var name="isSupported" type="boolean"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#node_list; // type: NodeList // <var name="nodeList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#node_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="nodeList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#node_list[0].clone(); // <item var="elem" obj="nodeList" index="0" interface="NodeList"/>
                // r#node = r#elem.first_child().unwrap(); // <firstChild var="node" obj="elem" interface="Node"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Core&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="coreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="cOrEUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;+cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="PlusCoreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;org.w3c.domts.bogus.feature&quot;" version="nullVersion"/>

                // // unimplemented: // <assertNull actual="featureImpl" id="unrecognizedFeature"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;2.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core20"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;3.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core30"/>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="SVGUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="HTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="EventsUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSAsyncUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XPathUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusHTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusSVGUnspecified"/></if>
            }
            // userdatahandler02.xml
            #[test]
            fn test_userdatahandler02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#user_data_monitor; // type: UserDataMonitor // <var name="userDataMonitor" type="UserDataMonitor"/>
                // let mut r#old_user_data; // type: DOMUserData // <var name="oldUserData" type="DOMUserData"/>
                // let mut r#element_ns; // type: DOMString // <var name="elementNS" type="DOMString"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // let mut r#notifications; // type: List // <var name="notifications" type="List"/>
                // let mut r#notification; // type: UserDataNotification // <var name="notification" type="UserDataNotification"/>
                // let mut r#operation; // type: short // <var name="operation" type="short"/>
                // let mut r#key; // type: DOMString // <var name="key" type="DOMString"/>
                // let mut r#data; // type: DOMString // <var name="data" type="DOMString"/>
                // let mut r#src; // type: Node // <var name="src" type="Node"/>
                // let mut r#dst; // type: Node // <var name="dst" type="Node"/>
                // let mut r#greeting_count; // type: int // <var name="greetingCount" type="int" value="0"/>
                // let mut r#salutation_count; // type: int // <var name="salutationCount" type="int" value="0"/>
                // let mut r#hello; // type: DOMString // <var name="hello" type="DOMString" value="&quot;Hello&quot;"/>
                // let mut r#mister; // type: DOMString // <var name="mister" type="DOMString" value="&quot;Mr.&quot;"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#node = r#p_list.item(0).unwrap(); // <item var="node" obj="pList" index="0" interface="NodeList"/>

                // // unimplemented: // <setUserData var="oldUserData" obj="node" key="&quot;greeting&quot;" data="hello" handler="userDataMonitor"/>

                // // unimplemented: // <setUserData var="oldUserData" obj="node" key="&quot;salutation&quot;" data="mister" handler="userDataMonitor"/>
                // r#element_ns = r#node.namespace_uri().unwrap().to_string(); // <namespaceURI var="elementNS" obj="node" interface="Node"/>
                // r#new_node = r#node.clone_node(true); // <cloneNode var="newNode" obj="node" deep="true"/>

                // // unimplemented: // <allNotifications var="notifications" obj="userDataMonitor"/>

                // // unimplemented: // <assertSize size="2" collection="notifications" id="twoNotifications"/>

                // // unimplemented: // <for-each member="notification" collection="notifications">	<operation var="operation" obj="notification"/>	<assertEquals actual="operation" expected="1" ignoreCase="false" id="operationIsClone"/>	<key var="key" obj="notification"/>	<data var="data" obj="notification" interface="UserDataNotification"/>	<if>		<equals actual="key" expected="&quot;greeting&quot;" ignoreCase="false"/>		<assertEquals actual="data" expected="hello" ignoreCase="false" id="greetingDataHello"/>		<increment var="greetingCount" value="1"/>		<else>			<assertEquals actual="key" expected="&quot;salutation&quot;" ignoreCase="false" id="saluationKey"/>			<assertEquals actual="data" expected="mister" ignoreCase="false" id="salutationDataMr"/>			<increment var="salutationCount" value="1"/>		</else>	</if>	<src interface="UserDataNotification" var="src" obj="notification"/>	<assertSame actual="src" expected="node" id="srcIsNode"/>	<dst var="dst" obj="notification"/>	<assertSame actual="dst" expected="newNode" id="dstIsNewNode"/></for-each>
                // assert_eq!(r#greeting_count, 1); // <assertEquals actual="greetingCount" expected="1" ignoreCase="false" id="greetingCountIs1"/>
                // assert_eq!(r#salutation_count, 1); // <assertEquals actual="salutationCount" expected="1" ignoreCase="false" id="salutationCountIs1"/>
            }
            // wellformed01.xml
            #[test]
            fn test_wellformed01() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#null_string; // type: DOMString // <var name="nullString" type="DOMString" isNull="true"/>
                // let mut r#null_doctype; // type: DocumentType // <var name="nullDoctype" type="DocumentType" isNull="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#errors; // type: List // <var name="errors" type="List"/>
                // let mut r#error; // type: DOMError // <var name="error" type="DOMError"/>
                // let mut r#severity; // type: int // <var name="severity" type="int"/>
                // let mut r#type; // type: DOMString // <var name="type" type="DOMString"/>
                // let mut r#locator; // type: DOMLocator // <var name="locator" type="DOMLocator"/>
                // let mut r#related_node; // type: Node // <var name="relatedNode" type="Node"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="nullString" qualifiedName="nullString" doctype="nullDoctype"/>

                // // unimplemented: // <assertDOMException id="xml10InvalidName">	<INVALID_CHARACTER_ERR>		<createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.example.org/domts/wellformed01&quot;" qualifiedName="&quot;LegalName&quot;"/>	</INVALID_CHARACTER_ERR></assertDOMException>

                // // unimplemented: // <try>	<xmlVersion obj="doc" value="&quot;1.1&quot;" interface="Document"/>	<catch>		<DOMException code="NOT_SUPPORTED_ERR">			<return/>		</DOMException>	</catch></try>
                // r#elem = r#doc
                //     .create_element_ns(
                //         Some("http://www.example.org/domts/wellformed01".as_ref()),
                //         "LegalName".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.example.org/domts/wellformed01&quot;" qualifiedName="&quot;LegalName&quot;"/>
                // r#retval = r#doc.append_child(elem.into()).unwrap(); // <appendChild var="retval" obj="doc" newChild="elem"/>
                // r#doc.set_xml_version("1.0").unwrap(); // <xmlVersion obj="doc" value="&quot;1.0&quot;" interface="Document"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;well-formed&quot;" value="true"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <allErrors var="errors" obj="errorMonitor"/>

                // // unimplemented: // <for-each member="error" collection="errors">	<severity var="severity" obj="error"/>	<assertEquals actual="severity" expected="2" ignoreCase="false" id="severity"/>	<type var="type" obj="error" interface="DOMError"/>	<assertEquals actual="type" expected="&quot;wf-invalid-character-in-node-name&quot;" ignoreCase="false" id="type"/>	<location var="locator" obj="error" interface="DOMError"/>	<relatedNode var="relatedNode" obj="locator" interface="DOMLocator"/>	<assertSame actual="relatedNode" expected="elem" id="relatedNode"/></for-each>

                // // unimplemented: // <assertSize size="1" collection="errors" id="oneError"/>
            }
            // nodeisequalnode06.xml
            #[test]
            fn test_nodeisequalnode06() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem1; // type: Element // <var name="elem1" type="Element"/>
                let mut r#elem2; // type: Element // <var name="elem2" type="Element"/>
                let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem1 = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "xhtml:html".as_ref())
                    .unwrap(); // <createElementNS var="elem1" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:html&quot;"/>
                r#elem2 = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "xhtml:html".as_ref())
                    .unwrap(); // <createElementNS var="elem2" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:html&quot;"/>
                r#is_equal = r#elem1.is_equal_node(&r#elem2.into()); // <isEqualNode var="isEqual" obj="elem1" arg="elem2"/>
                assert!(r#is_equal); // <assertTrue actual="isEqual" id="nodeisequalnode06"/>
            }
            // nodecomparedocumentposition40.xml
            #[test]
            fn test_nodecomparedocumentposition40() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#attr1; // type: Attr // <var name="attr1" type="Attr"/>
                let mut r#attr2; // type: Attr // <var name="attr2" type="Attr"/>
                let mut r#attr_position; // type: int // <var name="attrPosition" type="int"/>
                let mut r#swapped_position; // type: int // <var name="swappedPosition" type="int"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#elem = r#elem_list.item(3).unwrap(); // <item var="elem" obj="elemList" index="3" interface="NodeList"/>
                r#attr1 = r#elem.get_attribute_node("class").unwrap(); // <getAttributeNode var="attr1" obj="elem" name="&quot;class&quot;"/>
                r#elem
                    .set_attribute_ns(
                        Some("http://www.w3.org/XML/1998/namespace"),
                        "xml:lang",
                        "FR-fr",
                    )
                    .unwrap(); // <setAttributeNS obj="elem" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;" value="&quot;FR-fr&quot;"/>
                r#attr2 = r#elem.get_attribute_node("xml:lang").unwrap(); // <getAttributeNode var="attr2" obj="elem" name="&quot;xml:lang&quot;"/>
                r#attr_position = r#attr1.compare_document_position(&r#attr2.into()); // <compareDocumentPosition var="attrPosition" obj="attr1" other="attr2"/>
                assert_eq!(u16::from(r#attr_position), 32); // <assertEquals actual="attrPosition" expected="32" bitmask="32" id="isImplementationSpecific" ignoreCase="false"/>
                assert_eq!(u16::from(r#attr_position), 0); // <assertEquals actual="attrPosition" expected="0" bitmask="25" id="otherBitsZero" ignoreCase="false"/>

                // unimplemented: // <assertNotEquals actual="attrPosition" expected="0" bitmask="6" id="eitherFollowingOrPreceding" ignoreCase="false"/>
                r#swapped_position = r#attr2.compare_document_position(&r#attr1.into());
                // <compareDocumentPosition var="swappedPosition" obj="attr2" other="attr1"/>

                // unimplemented: // <assertNotEquals actual="attrPosition" expected="swappedPosition" bitmask="2" id="onlyOnePreceding" ignoreCase="false"/>

                // unimplemented: // <assertNotEquals actual="attrPosition" expected="swappedPosition" bitmask="4" id="onlyOneFollowing" ignoreCase="false"/>
            }
            // datatypenormalization14.xml
            #[test]
            fn test_datatypenormalization14() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#str; // type: DOMString // <var name="str" type="DOMString"/>
                // let mut r#can_set_normalization; // type: boolean // <var name="canSetNormalization" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#can_set_xml_schema; // type: boolean // <var name="canSetXMLSchema" type="boolean"/>
                // let mut r#xsd_ns; // type: DOMString // <var name="xsdNS" type="DOMString" value="&quot;http://www.w3.org/2001/XMLSchema&quot;"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#child_node; // type: Node // <var name="childNode" type="Node"/>
                // let mut r#child_value; // type: DOMString // <var name="childValue" type="DOMString"/>
                // r#doc = todo!(); // datatype_normalization2.xml // <load var="doc" href="datatype_normalization2" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetNormalization" obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetValidate" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetXMLSchema" obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>

                // // unimplemented: // <if>	<and>		<isTrue value="canSetNormalization"/>		<isTrue value="canSetValidate"/>		<isTrue value="canSetXMLSchema"/>	</and>	<setParameter obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>	<normalizeDocument obj="doc"/>	<!--  fail test if normalize had any errors or fatal errors   -->	<assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>	<getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" localName="&quot;acronym&quot;" interface="Document"/>	<item var="element" obj="elemList" interface="NodeList" index="0"/>	<firstChild var="childNode" obj="element" interface="Node"/>	<assertNotNull actual="childNode" id="childNodeNotNull"/>	<nodeValue var="childValue" obj="childNode"/>	<assertEquals actual="childValue" expected="&quot;    EMP  0001   &quot;" ignoreCase="false" id="content"/></if>
            }
            // documentrenamenode28.xml
            #[test]
            fn test_documentrenamenode28() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entity_node_map; // type: NamedNodeMap // <var name="entityNodeMap" type="NamedNodeMap"/>
                // let mut r#notation_node_map; // type: NamedNodeMap // <var name="notationNodeMap" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                // let mut r#renamed_entity_node; // type: Node // <var name="renamedEntityNode" type="Node"/>
                // let mut r#renamed_notation_node; // type: Node // <var name="renamedNotationNode" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entityNodeMap" obj="docType"/>

                // // unimplemented: // <notations var="notationNodeMap" obj="docType"/>
                // r#entity = r#entity_node_map.get_named_item("alpha".into()).unwrap(); // <getNamedItem var="entity" obj="entityNodeMap" name="&quot;alpha&quot;"/>
                // r#notation = r#notation_node_map
                //     .get_named_item("notation1".into())
                //     .unwrap(); // <getNamedItem var="notation" obj="notationNodeMap" name="&quot;notation1&quot;"/>

                // // unimplemented: // <assertDOMException id="documentrenamenode28_ENTITY_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><renameNode var="renamedEntityNode" obj="doc" n="entity" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;beta&quot;"/></NOT_SUPPORTED_ERR></assertDOMException>

                // // unimplemented: // <assertDOMException id="documentrenamenode28_NOTATION_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><renameNode var="renamedNotationNode" obj="doc" n="notation" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;notation2&quot;"/></NOT_SUPPORTED_ERR></assertDOMException>
            }
            // nodeisequalnode12.xml
            #[test]
            fn test_nodeisequalnode12() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem1; // type: Element // <var name="elem1" type="Element"/>
                let mut r#elem2; // type: Element // <var name="elem2" type="Element"/>
                let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem1 = r#doc.document_element().unwrap(); // <documentElement var="elem1" obj="doc"/>
                r#elem2 = r#doc.document_element().unwrap(); // <documentElement var="elem2" obj="doc"/>
                r#is_equal = r#elem1.is_equal_node(&r#elem2.into()); // <isEqualNode var="isEqual" obj="elem1" arg="elem2"/>
                assert!(r#is_equal); // <assertTrue actual="isEqual" id="nodeisequalnode12"/>
            }
            // elementsetidattributens07.xml
            #[test]
            fn test_elementsetidattributens07() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#employee_elem; // type: Element // <var name="employeeElem" type="Element"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#employee_elem = r#elem_list.item(1).unwrap(); // <item var="employeeElem" obj="elemList" index="1" interface="NodeList"/>

                // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR"><NOT_FOUND_ERR><setIdAttributeNS obj="employeeElem" localName="&quot;xsi&quot;" namespaceURI="&quot;http://www.netzero.com&quot;" isId="true"/></NOT_FOUND_ERR></assertDOMException>
            }
            // nodesetuserdata03.xml
            #[test]
            fn test_nodesetuserdata03() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#user_data; // type: DOMUserData // <var name="userData" type="DOMUserData"/>
                // let mut r#ret_user_data; // type: DOMUserData // <var name="retUserData" type="DOMUserData"/>
                // let mut r#returned_user_data; // type: DOMUserData // <var name="returnedUserData" type="DOMUserData"/>
                // let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                // let mut r#null_handler; // type: UserDataHandler // <var name="nullHandler" type="UserDataHandler" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#elem = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "xhtml:p".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:p&quot;"/>
                // r#txt = r#doc.create_text_node("TEXT"); // <createTextNode var="txt" obj="doc" data="&quot;TEXT&quot;"/>

                // // unimplemented: // <setUserData obj="doc" var="returnedUserData" key="&quot;Key1&quot;" data="elem" handler="nullHandler"/>

                // // unimplemented: // <setUserData var="retUserData" obj="doc" key="&quot;Key1&quot;" data="txt" handler="nullHandler"/>
                // r#success = r#ret_user_data.is_equal_node(&r#elem.into()); // <isEqualNode var="success" obj="retUserData" arg="elem"/>
                // assert!(r#success); // <assertTrue actual="success" id="nodesetuserdata03"/>
            }
            // nodecomparedocumentposition23.xml
            #[test]
            fn test_nodecomparedocumentposition23() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#entity2; // type: Entity // <var name="entity2" type="Entity"/>
                // let mut r#position1; // type: int // <var name="position1" type="int"/>
                // let mut r#position2; // type: int // <var name="position2" type="int"/>
                // let mut r#position3; // type: int // <var name="position3" type="int"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#entity = r#entities_map.get_named_item("alpha".into()).unwrap(); // <getNamedItem var="entity" obj="entitiesMap" name="&quot;alpha&quot;"/>
                // r#entity2 = r#entities_map.get_named_item("delta".into()).unwrap(); // <getNamedItem var="entity2" obj="entitiesMap" name="&quot;delta&quot;"/>
                // r#position1 = r#entity.compare_document_position(&r#entity2.into()); // <compareDocumentPosition var="position1" obj="entity" other="entity2"/>
                // assert_eq!(u16::from(r#position1), 32); // <assertEquals bitmask="57" actual="position1" expected="32" id="isImplSpecificDisconnected1" ignoreCase="false"/>
                // r#position2 = r#entity2.compare_document_position(&r#entity.into()); // <compareDocumentPosition var="position2" obj="entity2" other="entity"/>

                // // unimplemented: // <assertNotEquals bitmask="2" actual="position2" expected="position1" id="notBothPreceding" ignoreCase="false"/>

                // // unimplemented: // <assertNotEquals bitmask="4" actual="position2" expected="position1" id="notBothFollowing" ignoreCase="false"/>
                // assert_eq!(u16::from(r#position2), 32); // <assertEquals bitmask="57" actual="position2" expected="32" id="isImplSpecificDisconnected2" ignoreCase="false"/>
                // r#position3 = r#entity.compare_document_position(&r#entity2.into()); // <compareDocumentPosition var="position3" obj="entity" other="entity2"/>
                // assert_eq!(r#position3, position1); // <assertEquals actual="position3" expected="position1" id="isConsistent" ignoreCase="false"/>
            }
            // nodelookupnamespaceuri02.xml
            #[test]
            fn test_nodelookupnamespaceuri02() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // let mut r#qname; // type: DOMString // <var name="qname" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <plus var="qname" op1="&quot;dom3:&quot;" op2="rootName"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="qname" doctype="nullDocType"/>
                // r#namespace_uri = r#new_doc.lookup_namespace_uri("dom3").unwrap().to_string(); // <lookupNamespaceURI var="namespaceURI" obj="newDoc" prefix="&quot;dom3&quot;" interface="Node"/>
                // assert_eq!(r#namespace_uri, root_ns); // <assertEquals actual="namespaceURI" expected="rootNS" id="nodelookupnamespaceuri02" ignoreCase="false"/>
            }
            // documentrenamenode14.xml
            #[test]
            fn test_documentrenamenode14() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#renamed_node; // type: Node // <var name="renamedNode" type="Node"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#text_entry; // type: DOMString // <var name="textEntry" type="DOMString" value="&quot;hello&quot;"/>
                // let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#text_node = r#doc.create_text_node(r#text_entry); // <createTextNode var="textNode" data="textEntry" obj="doc"/>

                // // unimplemented: // <assertDOMException id="documentrenamenode14_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><renameNode var="renamedNode" obj="doc" n="textNode" namespaceURI="&quot;http://www.w3.org/2000/xmlns&quot;" qualifiedName="&quot;xmlns&quot;"/></NOT_SUPPORTED_ERR></assertDOMException>
            }
            // documentrenamenode16.xml
            #[test]
            fn test_documentrenamenode16() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#renamedclass; // type: Node // <var name="renamedclass" type="Node"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#child_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#element = r#child_list.item(3).unwrap(); // <item var="element" obj="childList" index="3" interface="NodeList"/>
                r#renamedclass = r#doc
                    .rename_node(r#element.into(), None::<&str>, "renamedNode")
                    .unwrap(); // <renameNode var="renamedclass" obj="doc" n="element" namespaceURI="nullNSURI" qualifiedName="&quot;renamedNode&quot;"/>
                r#node_name = r#renamedclass.node_name().to_string(); // <nodeName var="nodeName" obj="renamedclass"/>
                r#namespace_uri = r#renamedclass.namespace_uri().unwrap().to_string(); // <namespaceURI var="namespaceURI" obj="renamedclass" interface="Node"/>
                r#node_type = r#renamedclass.node_type(); // <nodeType var="nodeType" obj="renamedclass"/>
                assert_eq!(r#node_name, "renamedNode"); // <assertEquals expected="&quot;renamedNode&quot;" actual="nodeName" id="documentrenamenode16_nodeName" ignoreCase="false"/>
                assert_eq!(r#node_type as i32, 1); // <assertEquals expected="1" actual="nodeType" id="documentrenamenode16_nodeType" ignoreCase="false"/>

                // unimplemented: // <assertNull actual="namespaceURI" id="documentrenamenode16_nodeValue"/>
            }
            // nodesettextcontent13.xml
            #[test]
            fn test_nodesettextcontent13() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#entitymap; // type: NamedNodeMap // <var name="entitymap" type="NamedNodeMap"/>
                // let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitymap" obj="docType"/>
                // r#entity = r#entitymap.get_named_item("delta".into()).unwrap(); // <getNamedItem var="entity" obj="entitymap" name="&quot;delta&quot;"/>

                // // unimplemented: // <assertDOMException id="nodesettextcontent13"><NO_MODIFICATION_ALLOWED_ERR><textContent value="&quot;NA&quot;" obj="entity"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // nodeinsertbefore15.xml
            #[test]
            fn test_nodeinsertbefore15() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#elem_child; // type: Node // <var name="elemChild" type="Node"/>
                // let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                // let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                // let mut r#cdata; // type: CDATASection // <var name="cdata" type="CDATASection"/>
                // let mut r#inserted; // type: Node // <var name="inserted" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#ent_ref = r#doc.create_entity_reference("delta".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;delta&quot;"/>
                // r#elem_child = r#ent_ref.first_child().unwrap(); // <firstChild obj="entRef" var="elemChild" interface="Node"/>
                // r#cdata = r#doc.create_cdata_section("CDATASection").unwrap(); // <createCDATASection var="cdata" obj="doc" data="&quot;CDATASection&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR_1"><NO_MODIFICATION_ALLOWED_ERR><insertBefore obj="entRef" var="inserted" refChild="elemChild" newChild="cdata"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
                // r#pi = r#doc
                //     .create_processing_instruction("target", Some("data"))
                //     .unwrap(); // <createProcessingInstruction var="pi" obj="doc" target="&quot;target&quot;" data="&quot;data&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR_2"><NO_MODIFICATION_ALLOWED_ERR><insertBefore obj="entRef" var="inserted" refChild="elemChild" newChild="pi"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
                // r#comment = r#doc.create_comment("Comment"); // <createComment var="comment" obj="doc" data="&quot;Comment&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR_3"><NO_MODIFICATION_ALLOWED_ERR><insertBefore obj="entRef" var="inserted" refChild="elemChild" newChild="comment"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
                // r#txt = r#doc.create_text_node("Text"); // <createTextNode var="txt" obj="doc" data="&quot;Text&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR_4"><NO_MODIFICATION_ALLOWED_ERR><insertBefore obj="entRef" var="inserted" refChild="elemChild" newChild="txt"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
                // r#elem = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "body".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;body&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR_5"><NO_MODIFICATION_ALLOWED_ERR><insertBefore obj="entRef" var="inserted" refChild="elemChild" newChild="elem"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // nodeisdefaultnamespace16.xml
            #[test]
            fn test_nodeisdefaultnamespace16() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#is_default; // type: boolean // <var name="isDefault" type="boolean"/>
                r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>
                r#attr = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/XML/1998/namespace"),
                        "lang".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;lang&quot;"/>
                r#is_default = r#attr.is_default_namespace("http://www.w3.org/XML/1998/namespace"); // <isDefaultNamespace var="isDefault" obj="attr" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;"/>
                assert!(!r#is_default); // <assertFalse actual="isDefault" id="nodeisdefaultnamespace16"/>
            }
            // nodeisequalnode27.xml
            #[test]
            fn test_nodeisequalnode27() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#notations_map; // type: NamedNodeMap // <var name="notationsMap" type="NamedNodeMap"/>
                // let mut r#alpha; // type: Entity // <var name="alpha" type="Entity"/>
                // let mut r#notation1; // type: Notation // <var name="notation1" type="Notation"/>
                // let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>

                // // unimplemented: // <notations var="notationsMap" obj="docType"/>
                // r#alpha = r#entities_map.get_named_item("alpha".into()).unwrap(); // <getNamedItem var="alpha" obj="entitiesMap" name="&quot;alpha&quot;"/>
                // r#notation1 = r#notations_map.get_named_item("notation1".into()).unwrap(); // <getNamedItem var="notation1" obj="notationsMap" name="&quot;notation1&quot;"/>
                // r#is_equal = r#notation1.is_equal_node(&r#alpha.into()); // <isEqualNode var="isEqual" obj="notation1" arg="alpha"/>
                // assert!(!r#is_equal); // <assertFalse actual="isEqual" id="nodeisequalnode27"/>
            }
            // nodegettextcontent08.xml
            #[test]
            fn test_nodegettextcontent08() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#att; // type: Attr // <var name="att" type="Attr"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#replaced_attr; // type: Attr // <var name="replacedAttr" type="Attr"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "p".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;p&quot;"/>
                r#att = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/XML/1998/namespace"),
                        "xml:lang".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="att" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>
                r#replaced_attr = r#elem.set_attribute_node_ns(r#att).unwrap().unwrap(); // <setAttributeNodeNS obj="elem" var="replacedAttr" newAttr="att"/>
                r#attr = r#elem
                    .get_attribute_node_ns(Some("http://www.w3.org/XML/1998/namespace"), "lang")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attr" obj="elem" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" localName="&quot;lang&quot;"/>
                r#text_content = r#attr.text_content().unwrap(); // <textContent var="textContent" obj="attr"/>
                assert_eq!(r#text_content, ""); // <assertEquals actual="textContent" expected="&quot;&quot;" id="nodegettextcontent08" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom10.xml
            #[test]
            fn test_typeinfoisderivedfrom10() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>
                // r#attr = r#acronym_elem.get_attribute_node("class").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;class&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "classType"); // <assertEquals actual="typeName" expected="&quot;classType&quot;" ignoreCase="false" id="nameIsString"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anyType&quot;" derivationMethod="15"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromAnyType"/>
            }
            // normalizecharacters08.xml
            #[test]
            fn test_normalizecharacters08() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // let mut r#text_value; // type: DOMString // <var name="textValue" type="DOMString"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;normalize-characters&quot;" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;normalize-characters&quot;" value="true"/><setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/><getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/><item var="pElem" obj="pList" index="0" interface="NodeList"/><!--  character entity is expanded during code generation        code equivalent to "suc\u0327on"    --><createTextNode var="text" obj="doc" data="&quot;sucon&quot;"/><appendChild var="retval" obj="pElem" newChild="text"/><normalize obj="retval"/><!--  fail test if normalize had any errors or fatal errors   --><assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/><getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/><item var="pElem" obj="pList" index="0" interface="NodeList"/><lastChild var="text" obj="pElem" interface="Node"/><nodeValue var="textValue" obj="text"/><assertEquals actual="textValue" expected="&quot;suon&quot;" ignoreCase="false" id="noCharNormalization"/> </if>
            }
            // nodeisequalnode13.xml
            #[test]
            fn test_nodeisequalnode13() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#employee_list; // type: NodeList // <var name="employeeList" type="NodeList"/>
                // let mut r#elem1; // type: Element // <var name="elem1" type="Element"/>
                // let mut r#elem2; // type: Element // <var name="elem2" type="Element"/>
                // let mut r#elem3; // type: Element // <var name="elem3" type="Element"/>
                // let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#employee_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="employeeList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem1 = r#employee_list.item(0).unwrap(); // <item var="elem1" obj="employeeList" index="0" interface="NodeList"/>
                // r#elem2 = r#elem1.clone_node(false); // <cloneNode var="elem2" obj="elem1" deep="false"/>
                // r#is_equal = r#elem1.is_equal_node(&r#elem2.into()); // <isEqualNode var="isEqual" obj="elem1" arg="elem2"/>
                // assert!(!r#is_equal); // <assertFalse actual="isEqual" id="nodeisequalnodeFalse13"/>
                // r#elem3 = r#elem1.clone_node(true); // <cloneNode var="elem3" obj="elem1" deep="true"/>
                // r#is_equal = r#elem1.is_equal_node(&r#elem3.into()); // <isEqualNode var="isEqual" obj="elem1" arg="elem3"/>
                // assert!(r#is_equal); // <assertTrue actual="isEqual" id="nodeisequalnodeTrue13"/>
            }
            // nodesetuserdata06.xml
            #[test]
            fn test_nodesetuserdata06() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                // let mut r#user_data; // type: DOMUserData // <var name="userData" type="DOMUserData"/>
                // let mut r#returned; // type: DOMUserData // <var name="returned" type="DOMUserData"/>
                // let mut r#ret_user_data; // type: DOMUserData // <var name="retUserData" type="DOMUserData"/>
                // let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                // let mut r#null_handler; // type: UserDataHandler // <var name="nullHandler" type="UserDataHandler" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entities" obj="docType"/>
                // r#entity = r#entities.get_named_item("delta".into()).unwrap(); // <getNamedItem var="entity" obj="entities" name="&quot;delta&quot;"/>
                // r#comment = r#doc.create_comment("COMMENT_NODE"); // <createComment var="comment" obj="doc" data="&quot;COMMENT_NODE&quot;"/>

                // // unimplemented: // <setUserData obj="comment" var="retUserData" key="&quot;Key1&quot;" data="entity" handler="nullHandler"/>

                // // unimplemented: // <setUserData var="returned" obj="comment" key="&quot;Key1&quot;" data="entity" handler="nullHandler"/>
                // r#success = r#returned.is_equal_node(&r#entity.into()); // <isEqualNode var="success" obj="returned" arg="entity"/>
                // assert!(r#success); // <assertTrue actual="success" id="nodesetuserdata06"/>
            }
            // typeinfoisderivedfrom43.xml
            #[test]
            fn test_typeinfoisderivedfrom43() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="acronymElem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anyType&quot;" derivationMethod="1"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="derivedFromAnyType"/>
            }
            // nodeisdefaultnamespace14.xml
            #[test]
            fn test_nodeisdefaultnamespace14() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#cdata; // type: CDATASection // <var name="cdata" type="CDATASection"/>
                let mut r#is_default; // type: boolean // <var name="isDefault" type="boolean"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#body_list; // type: NodeList // <var name="bodyList" type="NodeList"/>
                let mut r#body_elem; // type: Element // <var name="bodyElem" type="Element"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#body_list = r#doc.get_elements_by_tag_name("body"); // <getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/>
                r#body_elem = r#body_list.item(0).unwrap(); // <item var="bodyElem" obj="bodyList" index="0" interface="NodeList"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "p".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;p&quot;"/>
                r#cdata = r#doc.create_cdata_section("CDATASection").unwrap(); // <createCDATASection var="cdata" obj="doc" data="&quot;CDATASection&quot;"/>
                r#appended_child = r#elem.append_child(cdata.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="cdata"/>
                r#appended_child = r#body_elem.append_child(elem.into()).unwrap(); // <appendChild obj="bodyElem" var="appendedChild" newChild="elem"/>
                r#is_default = r#cdata.is_default_namespace("http://www.w3.org/1999/xhtml"); // <isDefaultNamespace var="isDefault" obj="cdata" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>
                assert!(r#is_default); // <assertTrue actual="isDefault" id="nodeisdefaultnamespace14"/>
            }
            // typeinfoisderivedfrom46.xml
            #[test]
            fn test_typeinfoisderivedfrom46() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="acronymElem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anySimpleType&quot;" derivationMethod="13"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="derivedFromAnySimpleType"/>
            }
            // documentadoptnode22.xml
            #[test]
            fn test_documentadoptnode22() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_element; // type: Element // <var name="docElement" type="Element"/>
                // let mut r#adopted_node; // type: Node // <var name="adoptedNode" type="Node"/>
                // let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                // let mut r#node_name_orig; // type: DOMString // <var name="nodeNameOrig" type="DOMString"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_element = r#doc.document_element().unwrap(); // <documentElement var="docElement" obj="doc"/>
                // r#adopted_node = r#doc.adopt_node(r#doc_element.into()); // <adoptNode var="adoptedNode" obj="doc" source="docElement"/>

                // // unimplemented: // <if><notNull obj="adoptedNode"/><hasChildNodes var="success" obj="adoptedNode"/><assertTrue actual="success" id="documentadoptnode22_1"/><nodeName var="nodeName" obj="adoptedNode"/><nodeName var="nodeNameOrig" obj="docElement"/><assertEquals actual="nodeNameOrig" expected="nodeName" id="documentadoptnode22_2" ignoreCase="false"/></if>
            }
            // nodecomparedocumentposition08.xml
            #[test]
            fn test_nodecomparedocumentposition08() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#document_position; // type: int // <var name="documentPosition" type="int"/>
                let mut r#element_position; // type: int // <var name="elementPosition" type="int"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#elem = r#elem_list.item(3).unwrap(); // <item var="elem" obj="elemList" index="3" interface="NodeList"/>
                r#document_position = r#doc.compare_document_position(&r#elem.into()); // <compareDocumentPosition var="documentPosition" obj="doc" other="elem"/>
                assert_eq!(u16::from(r#document_position), 20); // <assertEquals actual="documentPosition" expected="20" id="nodecomparedocumentpositionIsContainedFollowing08" ignoreCase="false"/>
                r#element_position = r#elem.compare_document_position(&r#doc.into()); // <compareDocumentPosition var="elementPosition" obj="elem" other="doc"/>
                assert_eq!(u16::from(r#element_position), 10); // <assertEquals actual="elementPosition" expected="10" id="nodecomparedocumentpositionContainsPRECEDING08" ignoreCase="false"/>
            }
            // checkcharacternormalization01.xml
            #[test]
            fn test_checkcharacternormalization01() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // let mut r#text_value; // type: DOMString // <var name="textValue" type="DOMString"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;check-character-normalization&quot;" value="false"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" index="0" interface="NodeList"/>
                // r#text = r#doc.create_text_node("sucon"); // <createTextNode var="text" obj="doc" data="&quot;sucon&quot;"/>
                // r#retval = r#p_elem.append_child(text.into()).unwrap(); // <appendChild var="retval" obj="pElem" newChild="text"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" index="0" interface="NodeList"/>
                // r#text = r#p_elem.first_child().unwrap().as_text_node().unwrap(); // <firstChild var="text" obj="pElem" interface="Node"/>
                // r#text_value = r#text.node_value().unwrap().to_string(); // <nodeValue var="textValue" obj="text"/>
                // assert_eq!(r#text_value, "barsucon"); // <assertEquals actual="textValue" expected="&quot;barsucon&quot;" ignoreCase="false" id="noCharNormalization"/>
            }
            // domimplementationregistry20.xml
            #[test]
            fn test_domimplementationregistry20() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#has_feature; // type: boolean // <var name="hasFeature" type="boolean"/>
                // let mut r#base_impl; // type: DOMImplementation // <var name="baseImpl" type="DOMImplementation"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // let mut r#dom_impl_list; // type: DOMImplementationList // <var name="domImplList" type="DOMImplementationList"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementationList var="domImplList" obj="domImplRegistry" features="&quot;HTML&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <length var="length" obj="domImplList" interface="DOMImplementationList"/>

                // // unimplemented: // <if>	<equals actual="length" expected="0" ignoreCase="false"/>	<implementation var="baseImpl"/>	<hasFeature var="hasFeature" feature="&quot;HTML&quot;" version="nullVersion"/>	<assertFalse actual="hasFeature" id="baseImplSupportsHTML"/>	<else>		<for-each collection="domImplList" member="domImpl">			<hasFeature var="hasFeature" obj="domImpl" feature="&quot;HTML&quot;" version="nullVersion"/>			<assertTrue actual="hasFeature" id="hasCore"/>		</for-each>	</else></if>
            }
            // documentrenamenode19.xml
            #[test]
            fn test_documentrenamenode19() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#renamed_node; // type: Node // <var name="renamedNode" type="Node"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#qualified_names; // type: List // <var name="qualifiedNames" type="List"><member>"a_:"</member><member>"_:"</member><member>":"</member><member>"::0;"</member><member>"a:-:c"</member></var>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;newD&quot;" doctype="nullDocType"/>
                // r#element = r#doc
                //     .create_element_ns(Some("http://www.w3.org/DOM/Test"), "test".as_ref())
                //     .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;test&quot;"/>

                // // unimplemented: // <for-each collection="qualifiedNames" member="qualifiedName"><assertDOMException id="documentrenamenode19_NAMESPACE_ERR"><NAMESPACE_ERR><renameNode var="renamedNode" obj="doc" n="element" namespaceURI="&quot;http://www.w3.org/2000/XMLNS&quot;" qualifiedName="qualifiedName"/></NAMESPACE_ERR></assertDOMException></for-each>
            }
            // nodeinsertbefore22.xml
            #[test]
            fn test_nodeinsertbefore22() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#ref_node; // type: Element // <var name="refNode" type="Element"/>
                // let mut r#ancestor; // type: Element // <var name="ancestor" type="Element"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#inserted; // type: Node // <var name="inserted" type="Node"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#element = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "xhtml:body".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:body&quot;"/>
                // r#ref_node = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "xhtml:a".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="refNode" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:a&quot;"/>
                // r#ancestor = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "xhtml:p".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="ancestor" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:p&quot;"/>
                // r#appended_child = r#element.append_child(ref_node.into()).unwrap(); // <appendChild obj="element" var="appendedChild" newChild="refNode"/>
                // r#appended_child = r#ancestor.append_child(element.into()).unwrap();
                // // <appendChild obj="ancestor" var="appendedChild" newChild="element"/>

                // // unimplemented: // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR"><HIERARCHY_REQUEST_ERR><insertBefore obj="element" var="inserted" refChild="refNode" newChild="ancestor"/></HIERARCHY_REQUEST_ERR></assertDOMException>
            }
            // noderemovechild18.xml
            #[test]
            fn test_noderemovechild18() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#parent_list; // type: NodeList // <var name="parentList" type="NodeList"/>
                // let mut r#parent; // type: Element // <var name="parent" type="Element"/>
                // let mut r#child; // type: CDATASection // <var name="child" type="CDATASection"/>
                // let mut r#removed; // type: CDATASection // <var name="removed" type="CDATASection"/>
                // let mut r#removed_value; // type: DOMString // <var name="removedValue" type="DOMString"/>
                // let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#parent_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="parentList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                // r#parent = r#parent_list[1].clone(); // <item var="parent" obj="parentList" index="1" interface="NodeList"/>
                // r#child = r#parent.last_child().unwrap(); // <lastChild var="child" obj="parent" interface="Node"/>
                // r#removed = r#parent.remove_child(child.into()).unwrap(); // <removeChild var="removed" obj="parent" oldChild="child"/>
                // r#removed_value = r#removed.node_value().unwrap().to_string(); // <nodeValue obj="removed" var="removedValue"/>
                // assert_eq!(
                //     r#removed_value,
                //     "This is an adjacent CDATASection with a reference to a tab &tab;"
                // ); // <assertEquals actual="removedValue" expected="&quot;This is an adjacent CDATASection with a reference to a tab &amp;tab;&quot;" id="noderemovechild18" ignoreCase="false"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR"><NOT_FOUND_ERR><removeChild obj="child" var="removedNode" oldChild="parent"/></NOT_FOUND_ERR></assertDOMException>
            }
            // noderemovechild22.xml
            #[test]
            fn test_noderemovechild22() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#parent; // type: Element // <var name="parent" type="Element"/>
                // let mut r#child; // type: Comment // <var name="child" type="Comment"/>
                // let mut r#removed; // type: Comment // <var name="removed" type="Comment"/>
                // let mut r#removed_name; // type: DOMString // <var name="removedName" type="DOMString"/>
                // let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#parent = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "dom3:p".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="parent" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:p&quot;"/>
                // r#child = r#doc.create_comment("DATA"); // <createComment var="child" obj="doc" data="&quot;DATA&quot;"/>
                // r#appended_child = r#parent.append_child(child.into()).unwrap(); // <appendChild obj="parent" var="appendedChild" newChild="child"/>
                // r#removed = r#parent.remove_child(child.into()).unwrap(); // <removeChild var="removed" obj="parent" oldChild="child"/>
                // r#removed_name = r#removed.node_value().unwrap().to_string(); // <nodeValue obj="removed" var="removedName"/>
                // assert_eq!(r#removed_name, "DATA"); // <assertEquals actual="removedName" expected="&quot;DATA&quot;" id="noderemovechild22" ignoreCase="false"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR">	<NOT_FOUND_ERR>		<removeChild obj="parent" var="removedNode" oldChild="child"/>	</NOT_FOUND_ERR></assertDOMException>
            }
            // textiselementcontentwhitespace06.xml
            #[test]
            fn test_textiselementcontentwhitespace06() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#body_list; // type: NodeList // <var name="bodyList" type="NodeList"/>
                // let mut r#body_elem; // type: Element // <var name="bodyElem" type="Element"/>
                // let mut r#ref_child; // type: Node // <var name="refChild" type="Node"/>
                // let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                // let mut r#blank_node; // type: Text // <var name="blankNode" type="Text"/>
                // let mut r#returned_node; // type: Node // <var name="returnedNode" type="Node"/>
                // let mut r#is_elem_content_whitespace; // type: boolean // <var name="isElemContentWhitespace" type="boolean"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set_validation; // type: boolean // <var name="canSetValidation" type="boolean"/>
                // let mut r#replaced_node; // type: Node // <var name="replacedNode" type="Node"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetValidation" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <if>	<isTrue value="canSetValidation"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>	<getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/>	<item var="bodyElem" obj="bodyList" index="0" interface="NodeList"/>	<!--  newline between body and p or the p element  -->	<firstChild var="refChild" obj="bodyElem" interface="Node"/>	<!--  replace with different whitespace  -->	<createTextNode var="blankNode" obj="doc" data="&quot;     &quot;"/>	<insertBefore var="replacedNode" obj="bodyElem" newChild="blankNode" refChild="refChild"/>	<normalizeDocument obj="doc"/>	<assertLowerSeverity obj="errorMonitor" severity="SEVERITY_ERROR" id="noErrors"/>	<getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/>	<item var="bodyElem" obj="bodyList" index="0" interface="NodeList"/>	<!--  previously inserted whitespace between body and p  -->	<firstChild var="textNode" obj="bodyElem" interface="Node"/>	<isElementContentWhitespace obj="textNode" var="isElemContentWhitespace"/>	<assertTrue actual="isElemContentWhitespace" id="isElemContentWhitespace"/></if>
            }
            // domimplementationregistry22.xml
            #[test]
            fn test_domimplementationregistry22() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#has_feature; // type: boolean // <var name="hasFeature" type="boolean"/>
                // let mut r#base_impl; // type: DOMImplementation // <var name="baseImpl" type="DOMImplementation"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // let mut r#dom_impl_list; // type: DOMImplementationList // <var name="domImplList" type="DOMImplementationList"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementationList var="domImplList" obj="domImplRegistry" features="&quot;XPath&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <length var="length" obj="domImplList" interface="DOMImplementationList"/>

                // // unimplemented: // <if>	<equals actual="length" expected="0" ignoreCase="false"/>	<implementation var="baseImpl"/>	<hasFeature var="hasFeature" feature="&quot;XPath&quot;" version="nullVersion"/>	<assertFalse actual="hasFeature" id="baseImplSupportsLS"/>	<else>		<for-each collection="domImplList" member="domImpl">			<hasFeature var="hasFeature" obj="domImpl" feature="&quot;XPath&quot;" version="nullVersion"/>			<assertTrue actual="hasFeature" id="hasCore"/>		</for-each>	</else></if>
            }
            // nodeinsertbefore02.xml
            #[test]
            fn test_nodeinsertbefore02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc_type; // type: DocumentType // <var name="newDocType" type="DocumentType"/>
                // let mut r#new_comment; // type: Comment // <var name="newComment" type="Comment"/>
                // let mut r#inserted_comment; // type: Comment // <var name="insertedComment" type="Comment"/>
                // let mut r#data; // type: DOMString // <var name="data" type="DOMString"/>
                // let mut r#new_pi; // type: ProcessingInstruction // <var name="newPI" type="ProcessingInstruction"/>
                // let mut r#inserted_pi; // type: ProcessingInstruction // <var name="insertedPI" type="ProcessingInstruction"/>
                // let mut r#target; // type: DOMString // <var name="target" type="DOMString"/>
                // let mut r#null_pub_id; // type: DOMString // <var name="nullPubId" type="DOMString" isNull="true"/>
                // let mut r#null_sys_id; // type: DOMString // <var name="nullSysId" type="DOMString" isNull="true"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocumentType var="newDocType" obj="domImpl" qualifiedName="rootName" publicId="nullPubId" systemId="nullSysId"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" qualifiedName="rootName" namespaceURI="rootNS" doctype="newDocType"/>
                // r#new_comment = r#new_doc.create_comment("Comment"); // <createComment var="newComment" obj="newDoc" data="&quot;Comment&quot;"/>
                // r#new_pi = r#new_doc
                //     .create_processing_instruction("PITarget", Some("PIData"))
                //     .unwrap(); // <createProcessingInstruction var="newPI" obj="newDoc" target="&quot;PITarget&quot;" data="&quot;PIData&quot;"/>
                // r#inserted_comment = r#new_doc
                //     .insert_before(new_comment.into(), new_doc_type.into())
                //     .unwrap()
                //     .as_comment()
                //     .unwrap(); // <insertBefore var="insertedComment" obj="newDoc" newChild="newComment" refChild="newDocType"/>
                // r#data = r#inserted_comment.data().to_string(); // <data var="data" obj="insertedComment" interface="CharacterData"/>
                // assert_eq!(r#data, "Comment"); // <assertEquals actual="data" expected="&quot;Comment&quot;" id="nodeinsertbefore02_1" ignoreCase="false"/>
                // r#inserted_pi = r#new_doc
                //     .insert_before(new_pi.into(), Some(new_comment.into()))
                //     .unwrap()
                //     .as_processing_instruction()
                //     .unwrap(); // <insertBefore var="insertedPI" obj="newDoc" newChild="newPI" refChild="newComment"/>
                // r#target = r#inserted_pi.target().to_string(); // <target var="target" obj="insertedPI" interface="ProcessingInstruction"/>
                // assert_eq!(r#target, "PITarget"); // <assertEquals actual="target" expected="&quot;PITarget&quot;" id="nodeinsertbefore02_2" ignoreCase="false"/>
            }
            // nodereplacechild02.xml
            #[test]
            fn test_nodereplacechild02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                r#replaced = r#doc
                    .replace_child(doc_type.into(), doc_type.into())
                    .unwrap(); // <replaceChild obj="doc" var="replaced" oldChild="docType" newChild="docType"/>
            }
            // nodegetbaseuri17.xml
            #[test]
            fn test_nodegetbaseuri17() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#base_uri; // type: DOMString // <var name="baseURI" type="DOMString"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                r#doc = todo!(); // barfoo_base.xml // <load var="doc" href="barfoo_base" willBeModified="true"/>
                r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" index="0" interface="NodeList"/>
                r#text_node = r#p_elem.first_child().unwrap().as_text_node().unwrap(); // <firstChild var="textNode" obj="pElem" interface="Node"/>
                r#base_uri = r#text_node.base_uri().unwrap().to_string(); // <baseURI var="baseURI" obj="textNode" interface="Node"/>

                // unimplemented: // <assertNull actual="baseURI" id="baseURI"/>
            }
            // documentrenamenode01.xml
            #[test]
            fn test_documentrenamenode01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#renamedclass; // type: Node // <var name="renamedclass" type="Node"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#child_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#element = r#child_list.item(1).unwrap(); // <item var="element" obj="childList" index="1" interface="NodeList"/>
                r#attr = r#element.get_attribute_node("class").unwrap(); // <getAttributeNode var="attr" obj="element" name="&quot;class&quot;"/>
                r#renamedclass = r#doc
                    .rename_node(
                        r#attr.into(),
                        Some("http://www.w3.org/DOM/Test"),
                        "renamedNode",
                    )
                    .unwrap(); // <renameNode var="renamedclass" obj="doc" n="attr" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;renamedNode&quot;"/>
                r#node_name = r#renamedclass.node_name().to_string(); // <nodeName var="nodeName" obj="renamedclass"/>
                r#namespace_uri = r#renamedclass.namespace_uri().unwrap().to_string(); // <namespaceURI var="namespaceURI" obj="renamedclass" interface="Node"/>
                r#node_type = r#renamedclass.node_type(); // <nodeType var="nodeType" obj="renamedclass"/>
                assert_eq!(r#node_name, "renamedNode"); // <assertEquals expected="&quot;renamedNode&quot;" actual="nodeName" id="documentrenameode01_nodeName" ignoreCase="false"/>
                assert_eq!(r#node_type as i32, 2); // <assertEquals expected="2" actual="nodeType" id="documentrenameNode01_nodeType" ignoreCase="false"/>
                assert_eq!(r#namespace_uri, "http://www.w3.org/DOM/Test"); // <assertEquals expected="&quot;http://www.w3.org/DOM/Test&quot;" actual="namespaceURI" id="documentrenamenode01_nodeValue" ignoreCase="false"/>
            }
            // nodeissamenode04.xml
            #[test]
            fn test_nodeissamenode04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element1; // type: Element // <var name="element1" type="Element"/>
                let mut r#element2; // type: Element // <var name="element2" type="Element"/>
                let mut r#is_same; // type: boolean // <var name="isSame" type="boolean"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#element1 = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "xhtml:br".as_ref())
                    .unwrap(); // <createElementNS var="element1" obj="doc" qualifiedName="&quot;xhtml:br&quot;" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>
                r#element2 = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "xhtml:br".as_ref())
                    .unwrap(); // <createElementNS var="element2" obj="doc" qualifiedName="&quot;xhtml:br&quot;" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>
                is_same = element2.is_same_node(&element1.into()); // <isSameNode var="isSame" obj="element2" other="element1"/>
                assert!(!r#is_same); // <assertFalse actual="isSame" id="nodeissamenode04"/>
            }
            // nodelookupprefix09.xml
            #[test]
            fn test_nodelookupprefix09() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                let mut r#prefix_empty; // type: DOMString // <var name="prefixEmpty" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>
                r#prefix = r#elem
                    .lookup_prefix("http://www.usa.com")
                    .unwrap()
                    .to_string(); // <lookupPrefix var="prefix" obj="elem" namespaceURI="&quot;http://www.usa.com&quot;"/>
                assert_eq!(r#prefix, "dmstc"); // <assertEquals actual="prefix" expected="&quot;dmstc&quot;" id="nodelookupprefix09" ignoreCase="false"/>
                r#prefix_empty = r#elem
                    .lookup_prefix("http://www.w3.org/1999/xhtml")
                    .unwrap()
                    .to_string(); // <lookupPrefix var="prefixEmpty" obj="elem" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>

                // unimplemented: // <assertNull actual="prefixEmpty" id="nodelookupprefixEmpty09"/>
            }
            // nodeisdefaultnamespace13.xml
            #[test]
            fn test_nodeisdefaultnamespace13() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#body_elem; // type: Element // <var name="bodyElem" type="Element"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                let mut r#is_default; // type: boolean // <var name="isDefault" type="boolean"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#body_list; // type: NodeList // <var name="bodyList" type="NodeList"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#body_list = r#doc.get_elements_by_tag_name("body"); // <getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/>
                r#body_elem = r#body_list.item(0).unwrap(); // <item var="bodyElem" obj="bodyList" index="0" interface="NodeList"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "p".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;p&quot;"/>
                r#txt = r#doc.create_text_node("Text"); // <createTextNode var="txt" obj="doc" data="&quot;Text&quot;"/>
                r#appended_child = r#elem.append_child(txt.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="txt"/>
                r#appended_child = r#body_elem.append_child(elem.into()).unwrap(); // <appendChild obj="bodyElem" var="appendedChild" newChild="elem"/>
                r#is_default = r#txt.is_default_namespace("http://www.w3.org/1999/xhtml"); // <isDefaultNamespace var="isDefault" obj="txt" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>
                assert!(r#is_default); // <assertTrue actual="isDefault" id="nodeisdefaultnamespace13"/>
            }
            // nodesettextcontent07.xml
            #[test]
            fn test_nodesettextcontent07() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>
                r#txt = r#elem.first_child().unwrap(); // <firstChild var="txt" obj="elem" interface="Node"/>
                r#txt.set_text_content("Text").unwrap(); // <textContent obj="txt" value="&quot;Text&quot;"/>
                r#text_content = r#txt.text_content().unwrap(); // <textContent var="textContent" obj="txt"/>
                assert_eq!(r#text_content, "Text"); // <assertEquals actual="textContent" expected="&quot;Text&quot;" id="nodegettextcontent10" ignoreCase="false"/>
            }
            // nodereplacechild08.xml
            #[test]
            fn test_nodereplacechild08() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc2" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#elem = r#doc2
                //     .create_element_ns(Some(r#root_ns.as_ref()), r#root_name.as_ref())
                //     .unwrap(); // <createElementNS var="elem" obj="doc2" namespaceURI="rootNS" qualifiedName="rootName"/>

                // // unimplemented: // <try>	<replaceChild obj="doc" var="replaced" oldChild="docElem" newChild="elem"/>	<fail id="throw_WRONG_DOCUMENT_OR_NOT_SUPPORTED"/>	<catch>		<DOMException code="WRONG_DOCUMENT_ERR"/>		<DOMException code="NOT_SUPPORTED_ERR"/>	</catch></try>
            }
            // nodeinsertbefore10.xml
            #[test]
            fn test_nodeinsertbefore10() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#new_elem; // type: Element // <var name="newElem" type="Element"/>
                // let mut r#inserted; // type: Node // <var name="inserted" type="Node"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_tagname; // type: DOMString // <var name="rootTagname" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_tagname = r#doc_elem.tag_name().to_string(); // <tagName var="rootTagname" obj="docElem"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(1).unwrap(); // <item var="elem" obj="elemList" index="1" interface="NodeList"/>
                // r#new_elem = r#doc
                //     .create_element_ns(Some(r#root_ns.as_ref()), r#root_tagname.as_ref())
                //     .unwrap(); // <createElementNS var="newElem" obj="doc" qualifiedName="rootTagname" namespaceURI="rootNS"/>

                // // unimplemented: // <try>   <insertBefore obj="doc" var="inserted" newChild="newElem" refChild="elem"/>   <fail id="throw_DOMException"/>   <catch>   	    <DOMException code="HIERARCHY_REQUEST_ERR"/>   	    <DOMException code="NOT_FOUND_ERR"/>   	    <DOMException code="NOT_SUPPORTED_ERR"/>   </catch></try>
            }
            // typeinfoisderivedfrom40.xml
            #[test]
            fn test_typeinfoisderivedfrom40() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "emType"); // <assertEquals actual="typeName" expected="&quot;emType&quot;" ignoreCase="false" id="typeName"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;ID&quot;" derivationMethod="4"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromID"/>
            }
            // nodeinsertbefore05.xml
            #[test]
            fn test_nodeinsertbefore05() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc_type; // type: DocumentType // <var name="newDocType" type="DocumentType"/>
                // let mut r#inserted; // type: Node // <var name="inserted" type="Node"/>
                // let mut r#null_pub_id; // type: DOMString // <var name="nullPubId" type="DOMString" isNull="true"/>
                // let mut r#null_sys_id; // type: DOMString // <var name="nullSysId" type="DOMString" isNull="true"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                // r#root_name = r#doc_type.name().to_string(); // <name var="rootName" obj="docType" interface="DocumentType"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocumentType var="newDocType" obj="domImpl" qualifiedName="rootName" publicId="nullPubId" systemId="nullSysId"/>

                // // unimplemented: // <try>	<insertBefore obj="doc" var="inserted" newChild="newDocType" refChild="docType"/> 	<fail id="throw_DOMException"/>	<catch>		<DOMException code="HIERARCHY_REQUEST_ERR"/>		<DOMException code="NOT_SUPPORTED_ERR"/>	</catch></try>
            }
            // nodereplacechild06.xml
            #[test]
            fn test_nodereplacechild06() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#replaced; // type: Element // <var name="replaced" type="Element"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#replaced_node; // type: Node // <var name="replacedNode" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#child_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#child_list.item(0).unwrap().clone(); // <item var="elem" obj="childList" index="0" interface="NodeList"/>

                // // unimplemented: // <try>	<replaceChild obj="doc" var="replacedNode" oldChild="docElem" newChild="elem"/>	<catch>		<DOMException code="NOT_SUPPORTED_ERR">			<return/>		</DOMException>	</catch></try>
                // r#replaced = r#doc.document_element().unwrap(); // <documentElement var="replaced" obj="doc"/>
                // r#node_name = r#replaced.node_name().to_string(); // <nodeName obj="replaced" var="nodeName"/>
                // assert_eq!(r#node_name, "p"); // <assertEquals actual="nodeName" expected="&quot;p&quot;" id="nodereplacechild06" ignoreCase="false"/>
            }
            // domimplementationregistry05.xml
            #[test]
            fn test_domimplementationregistry05() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#has_feature; // type: boolean // <var name="hasFeature" type="boolean"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementation var="domImpl" obj="domImplRegistry" features="&quot;+cOrE 3.0&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImpl" id="domImplNotNull"/>

                // // unimplemented: // <hasFeature var="hasFeature" obj="domImpl" feature="&quot;+Core&quot;" version="&quot;3.0&quot;"/>
                // assert!(r#has_feature); // <assertTrue actual="hasFeature" id="hasCore"/>
            }
            // domimplementationregistry11.xml
            #[test]
            fn test_domimplementationregistry11() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#has_feature; // type: boolean // <var name="hasFeature" type="boolean"/>
                // let mut r#base_impl; // type: DOMImplementation // <var name="baseImpl" type="DOMImplementation"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementation var="domImpl" obj="domImplRegistry" features="&quot;XPath&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <if>	<isNull obj="domImpl"/>	<implementation var="baseImpl"/>	<hasFeature var="hasFeature" feature="&quot;XPath&quot;" version="nullVersion"/>	<assertFalse actual="hasFeature" id="baseImplSupportsLS"/>	<else>		<hasFeature var="hasFeature" obj="domImpl" feature="&quot;XPath&quot;" version="nullVersion"/>		<assertTrue actual="hasFeature" id="hasCore"/>	</else></if>
            }
            // domimplementationregistry17.xml
            #[test]
            fn test_domimplementationregistry17() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#has_feature; // type: boolean // <var name="hasFeature" type="boolean"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // let mut r#dom_impl_list; // type: DOMImplementationList // <var name="domImplList" type="DOMImplementationList"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementationList var="domImplList" obj="domImplRegistry" features="&quot;xMl 3.0 cOrE&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <length var="length" obj="domImplList" interface="DOMImplementationList"/>

                // // unimplemented: // <assertTrue id="atLeastOne">	<greater actual="length" expected="0"/></assertTrue>

                // // unimplemented: // <for-each collection="domImplList" member="domImpl">	<hasFeature var="hasFeature" obj="domImpl" feature="&quot;XML&quot;" version="&quot;3.0&quot;"/>	<assertTrue actual="hasFeature" id="hasXML3"/>	<hasFeature var="hasFeature" obj="domImpl" feature="&quot;Core&quot;" version="nullVersion"/>	<assertTrue actual="hasFeature" id="hasCore"/></for-each>
            }
            // nodeisdefaultnamespace04.xml
            #[test]
            fn test_nodeisdefaultnamespace04() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#notations_map; // type: NamedNodeMap // <var name="notationsMap" type="NamedNodeMap"/>
                // let mut r#is_default; // type: boolean // <var name="isDefault" type="boolean"/>
                // let mut r#null_nsuri; // type: DOMString // <var name="nullNSURI" type="DOMString" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>

                // // unimplemented: // <notations var="notationsMap" obj="docType"/>
                // r#entity = r#entities_map.get_named_item("alpha".into()).unwrap(); // <getNamedItem var="entity" obj="entitiesMap" name="&quot;alpha&quot;"/>
                // r#notation = r#notations_map.get_named_item("notation1".into()).unwrap(); // <getNamedItem var="notation" obj="notationsMap" name="&quot;notation1&quot;"/>
                // r#is_default = r#entity.is_default_namespace(r#null_nsuri.as_ref()); // <isDefaultNamespace var="isDefault" obj="entity" namespaceURI="nullNSURI"/>
                // assert!(!r#is_default); // <assertFalse actual="isDefault" id="nodeisdefaultnamespace04_1"/>
                // r#is_default = r#notation.is_default_namespace(r#null_nsuri.as_ref()); // <isDefaultNamespace var="isDefault" obj="notation" namespaceURI="nullNSURI"/>
                // assert!(!r#is_default); // <assertFalse actual="isDefault" id="nodeisdefaultnamespace04_2"/>
            }
            // textreplacewholetext05.xml
            #[test]
            fn test_textreplacewholetext05() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#item_list; // type: NodeList // <var name="itemList" type="NodeList"/>
                let mut r#element_name; // type: Element // <var name="elementName" type="Element"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#cdata_node; // type: CDATASection // <var name="cdataNode" type="CDATASection"/>
                let mut r#replaced_text; // type: Text // <var name="replacedText" type="Text"/>
                let mut r#whole_text; // type: DOMString // <var name="wholeText" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#item_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="itemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#element_name = r#item_list.item(0).unwrap(); // <item var="elementName" obj="itemList" index="0" interface="NodeList"/>
                r#text_node = r#doc.create_text_node("New Text"); // <createTextNode var="textNode" obj="doc" data="&quot;New Text&quot;"/>
                r#cdata_node = r#doc.create_cdata_section("New CDATA").unwrap(); // <createCDATASection var="cdataNode" obj="doc" data="&quot;New CDATA&quot;"/>
                r#appended_child = r#element_name.append_child(text_node.into()).unwrap(); // <appendChild obj="elementName" var="appendedChild" newChild="textNode"/>
                r#appended_child = r#element_name.append_child(cdata_node.into()).unwrap(); // <appendChild obj="elementName" var="appendedChild" newChild="cdataNode"/>
                r#text_node = r#element_name
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild var="textNode" obj="elementName" interface="Node"/>
                r#replaced_text = r#text_node
                    .replace_whole_text("New Text and Cdata")
                    .unwrap()
                    .unwrap(); // <replaceWholeText obj="textNode" var="replacedText" content="&quot;New Text and Cdata&quot;"/>
                r#whole_text = r#replaced_text.whole_text().to_string(); // <wholeText var="wholeText" obj="replacedText"/>
                assert_eq!(r#whole_text, "New Text and Cdata"); // <assertEquals expected="&quot;New Text and Cdata&quot;" actual="wholeText" id="textreplacewholetext05" ignoreCase="false"/>
            }
            // domimplementationregistry10.xml
            #[test]
            fn test_domimplementationregistry10() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#has_feature; // type: boolean // <var name="hasFeature" type="boolean"/>
                // let mut r#base_impl; // type: DOMImplementation // <var name="baseImpl" type="DOMImplementation"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementation var="domImpl" obj="domImplRegistry" features="&quot;LS&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <if>	<isNull obj="domImpl"/>	<implementation var="baseImpl"/>	<hasFeature var="hasFeature" feature="&quot;LS&quot;" version="nullVersion"/>	<assertFalse actual="hasFeature" id="baseImplSupportsLS"/>	<else>		<hasFeature var="hasFeature" obj="domImpl" feature="&quot;LS&quot;" version="nullVersion"/>		<assertTrue actual="hasFeature" id="hasCore"/>	</else></if>
            }
            // domimplementationregistry25.xml
            #[test]
            fn test_domimplementationregistry25() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl_list; // type: DOMImplementationList // <var name="domImplList" type="DOMImplementationList"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementationList var="domImplList" obj="domImplRegistry" features="&quot;&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <length var="length" obj="domImplList" interface="DOMImplementationList"/>

                // // unimplemented: // <assertTrue id="atLeastOne"><greater actual="length" expected="0"/></assertTrue>
            }
            // noderemovechild26.xml
            #[test]
            fn test_noderemovechild26() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#ent4; // type: Entity // <var name="ent4" type="Entity"/>
                // let mut r#pi; // type: ProcessingInstruction // <var name="pi" type="ProcessingInstruction"/>
                // let mut r#removed; // type: Node // <var name="removed" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#ent4 = r#entities_map.get_named_item("ent4".into()).unwrap(); // <getNamedItem var="ent4" interface="NamedNodeMap" obj="entitiesMap" name="&quot;ent4&quot;"/>

                // // unimplemented: // <assertNotNull actual="ent4" id="ent4NotNull"/>
                // r#pi = r#ent4.last_child().unwrap(); // <lastChild var="pi" obj="ent4" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="pi" id="piNotNull"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">	<NO_MODIFICATION_ALLOWED_ERR>		<removeChild obj="ent4" var="removed" oldChild="pi"/>	</NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // documentadoptnode23.xml
            #[test]
            fn test_documentadoptnode23() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#adopted_node; // type: Node // <var name="adoptedNode" type="Node"/>
                // let mut r#acronym_elem; // type: Node // <var name="acronymElem" type="Node"/>
                // let mut r#acronym_elem_len; // type: int // <var name="acronymElemLen" type="int"/>
                // let mut r#adopted_len; // type: int // <var name="adoptedLen" type="int"/>
                // let mut r#acronym_elem_child; // type: NodeList // <var name="acronymElemChild" type="NodeList"/>
                // let mut r#adopted_node_child; // type: NodeList // <var name="adoptedNodeChild" type="NodeList"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#child_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#child_list.item(0).unwrap().clone(); // <item var="acronymElem" obj="childList" index="0" interface="NodeList"/>
                // r#adopted_node = r#doc.adopt_node(r#acronym_elem.into()); // <adoptNode var="adoptedNode" obj="doc" source="acronymElem"/>

                // // unimplemented: // <if><notNull obj="adoptedNode"/><childNodes var="acronymElemChild" obj="acronymElem"/><length var="acronymElemLen" obj="acronymElemChild" interface="NodeList"/><childNodes var="adoptedNodeChild" obj="adoptedNode"/><length var="adoptedLen" obj="adoptedNodeChild" interface="NodeList"/><assertEquals actual="acronymElemLen" expected="adoptedLen" id="documentadoptnode23" ignoreCase="false"/></if>
            }
            // canonicalform05.xml
            #[test]
            fn test_canonicalform05() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#new_child; // type: Element // <var name="newChild" type="Element"/>
                // let mut r#retval; // type: Element // <var name="retval" type="Element"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#errors; // type: List // <var name="errors" type="List"/>
                // let mut r#error; // type: DOMError // <var name="error" type="DOMError"/>
                // let mut r#error_count; // type: int // <var name="errorCount" type="int" value="0"/>
                // let mut r#severity; // type: int // <var name="severity" type="int"/>
                // let mut r#problem_node; // type: Node // <var name="problemNode" type="Node"/>
                // let mut r#location; // type: DOMLocator // <var name="location" type="DOMLocator"/>
                // let mut r#line_number; // type: int // <var name="lineNumber" type="int"/>
                // let mut r#column_number; // type: int // <var name="columnNumber" type="int"/>
                // let mut r#byte_offset; // type: int // <var name="byteOffset" type="int"/>
                // let mut r#utf16_offset; // type: int // <var name="utf16Offset" type="int"/>
                // let mut r#uri; // type: DOMString // <var name="uri" type="DOMString"/>
                // let mut r#type; // type: DOMString // <var name="type" type="DOMString"/>
                // let mut r#message; // type: DOMString // <var name="message" type="DOMString"/>
                // let mut r#related_exception; // type: DOMObject // <var name="relatedException" type="DOMObject"/>
                // let mut r#related_data; // type: DOMObject // <var name="relatedData" type="DOMObject"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#p_list.item(0).unwrap(); // <item var="elem" obj="pList" index="0" interface="NodeList"/>
                // r#new_child = r#doc.create_element("br".to_string()).unwrap(); // <createElement var="newChild" obj="doc" tagName="&quot;br&quot;"/>
                // r#retval = r#elem.append_child(new_child).unwrap(); // <appendChild var="retval" obj="elem" newChild="newChild"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;canonical-form&quot;" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;canonical-form&quot;" value="true"/><setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/><normalizeDocument obj="doc"/><allErrors var="errors" obj="errorMonitor"/><for-each member="error" collection="errors">	<severity var="severity" obj="error"/>	<if>		<equals actual="severity" expected="2" ignoreCase="false"/>		<!-- location should have relatedNode, everything else should be -1 or null -->		<location var="location" obj="error"/>		<relatedNode var="problemNode" obj="location" interface="DOMLocator"/>		<assertSame actual="problemNode" expected="newChild" id="relatedNodeIsL1Node"/>		<lineNumber var="lineNumber" obj="location"/>		<assertEquals actual="lineNumber" expected="-1" ignoreCase="false" id="lineNumber"/>		<columnNumber var="columnNumber" obj="location"/>		<assertEquals actual="columnNumber" expected="-1" ignoreCase="false" id="columnNumber"/>		<byteOffset var="byteOffset" obj="location"/>		<assertEquals actual="byteOffset" expected="-1" ignoreCase="false" id="byteOffset"/>		<utf16Offset var="utf16Offset" obj="location"/>		<assertEquals actual="utf16Offset" expected="-1" ignoreCase="false" id="utf16Offset"/>		<uri var="uri" obj="location" interface="DOMLocator"/>		<assertNull actual="uri" id="uri"/>		<!--  message and type should be non-empty  -->		<message var="message" obj="error"/>		<length var="length" obj="message" interface="DOMString"/>		<assertTrue id="messageNotEmpty">			<greater actual="length" expected="0"/>		</assertTrue>		<!--  can't make any assertions about type, relatedData and relatedException		          other than access should not raise exception   -->		<type var="type" obj="error" interface="DOMError"/>		<relatedData var="relatedData" obj="error"/>		<relatedException var="relatedException" obj="error"/>		<increment var="errorCount" value="1"/>		<else>			<assertEquals actual="severity" expected="1" ignoreCase="false" id="anyOthersShouldBeWarnings"/>		</else>	</if></for-each><assertEquals actual="errorCount" expected="1" ignoreCase="false" id="oneError"/>		</if>
            }
            // nodecomparedocumentposition31.xml
            #[test]
            fn test_nodecomparedocumentposition31() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#name_list; // type: NodeList // <var name="nameList" type="NodeList"/>
                let mut r#position_list; // type: NodeList // <var name="positionList" type="NodeList"/>
                let mut r#strong; // type: Element // <var name="strong" type="Element"/>
                let mut r#code; // type: Element // <var name="code" type="Element"/>
                let mut r#new_elem; // type: Element // <var name="newElem" type="Element"/>
                let mut r#name_position; // type: int // <var name="namePosition" type="int"/>
                let mut r#elem_position; // type: int // <var name="elemPosition" type="int"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#name_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="nameList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#strong = r#name_list.item(0).unwrap(); // <item var="strong" obj="nameList" index="0" interface="NodeList"/>
                r#position_list = r#doc.get_elements_by_tag_name("code"); // <getElementsByTagName var="positionList" obj="doc" tagname="&quot;code&quot;" interface="Document"/>
                r#code = r#position_list.item(1).unwrap(); // <item var="code" obj="positionList" index="1" interface="NodeList"/>
                r#new_elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "br".as_ref())
                    .unwrap(); // <createElementNS var="newElem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;br&quot;"/>
                r#appended_child = r#code.append_child(new_elem.into()).unwrap(); // <appendChild obj="code" var="appendedChild" newChild="newElem"/>
                r#name_position = r#strong.compare_document_position(&r#new_elem.into()); // <compareDocumentPosition var="namePosition" obj="strong" other="newElem"/>
                assert_eq!(u16::from(r#name_position), 4); // <assertEquals actual="namePosition" expected="4" id="nodecomparedocumentpositionFollowing31" ignoreCase="false"/>
                r#elem_position = r#new_elem.compare_document_position(&r#strong.into()); // <compareDocumentPosition var="elemPosition" obj="newElem" other="strong"/>
                assert_eq!(u16::from(r#elem_position), 2); // <assertEquals actual="elemPosition" expected="2" id="nodecomparedocumentpositionPRECEDING31" ignoreCase="false"/>
            }
            // comments01.xml
            #[test]
            fn test_comments01() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#new_comment; // type: Comment // <var name="newComment" type="Comment"/>
                // let mut r#last_child; // type: Node // <var name="lastChild" type="Node"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#p_list.item(0).unwrap(); // <item var="elem" obj="pList" index="0" interface="NodeList"/>
                // r#new_comment = r#doc.create_comment("COMMENT_NODE"); // <createComment var="newComment" obj="doc" data="&quot;COMMENT_NODE&quot;"/>
                // r#appended_child = r#elem.append_child(new_comment.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="newComment"/>

                // // unimplemented: // <domConfig interface="Document" obj="doc" var="domConfig"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;comments&quot;" value="false"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#doc.normalize(); // <normalize obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" severity="SEVERITY_ERROR" id="normalizationError"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#p_list.item(0).unwrap(); // <item var="elem" obj="pList" index="0" interface="NodeList"/>
                // r#last_child = r#elem.last_child().unwrap(); // <lastChild var="lastChild" obj="elem" interface="Node"/>
                // r#node_name = r#last_child.node_name().to_string(); // <nodeName var="nodeName" obj="lastChild"/>
                // assert_eq!(r#node_name, "#comment"); // <assertEquals actual="nodeName" expected="&quot;#comment&quot;" id="documentnormalizedocument04_true" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom73.xml
            #[test]
            fn test_typeinfoisderivedfrom73() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>

                // // unimplemented: // <implementationAttribute name="validating" value="true"/>

                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_type_info; // type: TypeInfo // <var name="elemTypeInfo" type="TypeInfo"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#ret_value; // type: boolean // <var name="retValue" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("sup"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;sup&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="elemTypeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <isDerivedFrom obj="elemTypeInfo" var="retValue" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;emType&quot;" derivationMethod="0"/>
                // assert!(r#ret_value); // <assertTrue actual="retValue" id="isDerived"/>
            }
            // nodecomparedocumentposition21.xml
            #[test]
            fn test_nodecomparedocumentposition21() {
                // unimplemented: // <implementationAttribute name="coalescing" value="false"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#elem_name1; // type: Element // <var name="elemName1" type="Element"/>
                let mut r#elem_name2; // type: Element // <var name="elemName2" type="Element"/>
                let mut r#txt1; // type: Text // <var name="txt1" type="Text"/>
                let mut r#txt2; // type: Text // <var name="txt2" type="Text"/>
                let mut r#txt1_position; // type: int // <var name="txt1Position" type="int"/>
                let mut r#txt2_position; // type: int // <var name="txt2Position" type="int"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#elem_name1 = r#elem_list.item(0).unwrap(); // <item var="elemName1" obj="elemList" index="0" interface="NodeList"/>
                r#elem_name2 = r#elem_list.item(1).unwrap(); // <item var="elemName2" obj="elemList" index="1" interface="NodeList"/>
                r#txt1 = r#elem_name1.first_child().unwrap(); // <firstChild var="txt1" obj="elemName1" interface="Node"/>
                r#txt2 = r#elem_name2.first_child().unwrap(); // <firstChild var="txt2" obj="elemName2" interface="Node"/>
                r#txt1_position = r#txt1.compare_document_position(&r#txt2); // <compareDocumentPosition var="txt1Position" obj="txt1" other="txt2"/>
                assert_eq!(u16::from(r#txt1_position), 4); // <assertEquals actual="txt1Position" expected="4" id="nodecomparedocumentpositionFollowing21" ignoreCase="false"/>
                r#txt2_position = r#txt2.compare_document_position(&r#txt1); // <compareDocumentPosition var="txt2Position" obj="txt2" other="txt1"/>
                assert_eq!(u16::from(r#txt2_position), 2); // <assertEquals actual="txt2Position" expected="2" id="nodecomparedocumentpositionPRECEDING21" ignoreCase="false"/>
            }
            // documentrenamenode20.xml
            #[test]
            fn test_documentrenamenode20() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#renamed_node; // type: Node // <var name="renamedNode" type="Node"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_tagname; // type: DOMString // <var name="rootTagname" type="DOMString"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_tagname = r#doc_elem.tag_name().to_string(); // <tagName var="rootTagname" obj="docElem"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_tagname = r#doc_elem.tag_name().to_string(); // <tagName var="rootTagname" obj="docElem"/>
                // r#element = r#doc
                //     .create_element_ns(Some(r#root_ns.as_ref()), r#root_tagname.as_ref())
                //     .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="rootNS" qualifiedName="rootTagname"/>

                // // unimplemented: // <assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><renameNode var="renamedNode" obj="doc" n="element" namespaceURI="&quot;http://www.example.com/xml&quot;" qualifiedName="&quot;xml:html&quot;"/></NAMESPACE_ERR></assertDOMException>
            }
            // typeinfoisderivedfrom30.xml
            #[test]
            fn test_typeinfoisderivedfrom30() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;pType&quot;" derivationMethod="1"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromPTypeRestriction"/>
            }
            // userdatahandler04.xml
            #[test]
            fn test_userdatahandler04() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#user_data_monitor; // type: UserDataMonitor // <var name="userDataMonitor" type="UserDataMonitor"/>
                // let mut r#old_user_data; // type: DOMUserData // <var name="oldUserData" type="DOMUserData"/>
                // let mut r#element_ns; // type: DOMString // <var name="elementNS" type="DOMString"/>
                // let mut r#new_node; // type: Node // <var name="newNode" type="Node"/>
                // let mut r#notifications; // type: List // <var name="notifications" type="List"/>
                // let mut r#notification; // type: UserDataNotification // <var name="notification" type="UserDataNotification"/>
                // let mut r#operation; // type: short // <var name="operation" type="short"/>
                // let mut r#key; // type: DOMString // <var name="key" type="DOMString"/>
                // let mut r#data; // type: DOMString // <var name="data" type="DOMString"/>
                // let mut r#src; // type: Node // <var name="src" type="Node"/>
                // let mut r#dst; // type: Node // <var name="dst" type="Node"/>
                // let mut r#greeting_count; // type: int // <var name="greetingCount" type="int" value="0"/>
                // let mut r#salutation_count; // type: int // <var name="salutationCount" type="int" value="0"/>
                // let mut r#hello; // type: DOMString // <var name="hello" type="DOMString" value="&quot;Hello&quot;"/>
                // let mut r#mister; // type: DOMString // <var name="mister" type="DOMString" value="&quot;Mr.&quot;"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" qualifiedName="rootName" namespaceURI="rootNS" doctype="docType"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#node = r#p_list.item(0).unwrap(); // <item var="node" obj="pList" index="0" interface="NodeList"/>

                // // unimplemented: // <setUserData var="oldUserData" obj="node" key="&quot;greeting&quot;" data="hello" handler="userDataMonitor"/>

                // // unimplemented: // <setUserData var="oldUserData" obj="node" key="&quot;salutation&quot;" data="mister" handler="userDataMonitor"/>
                // r#element_ns = r#node.namespace_uri().unwrap().to_string(); // <namespaceURI var="elementNS" obj="node" interface="Node"/>
                // r#new_node = r#doc.adopt_node(r#node.into()); // <adoptNode var="newNode" obj="doc" source="node"/>

                // // unimplemented: // <allNotifications var="notifications" obj="userDataMonitor"/>

                // // unimplemented: // <assertSize size="2" collection="notifications" id="twoNotifications"/>

                // // unimplemented: // <for-each member="notification" collection="notifications">	<operation var="operation" obj="notification"/>	<assertEquals actual="operation" expected="5" ignoreCase="false" id="operationIsImport"/>	<key var="key" obj="notification"/>	<data var="data" obj="notification" interface="UserDataNotification"/>	<if>		<equals actual="key" expected="&quot;greeting&quot;" ignoreCase="false"/>		<assertEquals actual="data" expected="hello" ignoreCase="false" id="greetingDataHello"/>		<increment var="greetingCount" value="1"/>		<else>			<assertEquals actual="key" expected="&quot;salutation&quot;" ignoreCase="false" id="saluationKey"/>			<assertEquals actual="data" expected="mister" ignoreCase="false" id="salutationDataMr"/>			<increment var="salutationCount" value="1"/>		</else>	</if>	<src interface="UserDataNotification" var="src" obj="notification"/>	<assertSame actual="src" expected="node" id="srcIsNode"/>	<dst var="dst" obj="notification"/>	<!--  spec says dst must be newly created   -->	<assertNull actual="dst" id="dstIsNull"/></for-each>
                // assert_eq!(r#greeting_count, 1); // <assertEquals actual="greetingCount" expected="1" ignoreCase="false" id="greetingCountIs1"/>
                // assert_eq!(r#salutation_count, 1); // <assertEquals actual="salutationCount" expected="1" ignoreCase="false" id="salutationCountIs1"/>
            }
            // nodelookupprefix03.xml
            #[test]
            fn test_nodelookupprefix03() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                // let mut r#null_nsuri; // type: DOMString // <var name="nullNSURI" type="DOMString" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                // r#prefix = r#doc_type
                //     .lookup_prefix(r#null_nsuri.as_ref())
                //     .unwrap()
                //     .to_string(); // <lookupPrefix var="prefix" obj="docType" namespaceURI="nullNSURI"/>

                // // unimplemented: // <assertNull actual="prefix" id="nodelookupprefix03"/>
            }
            // nodelookupnamespaceuri15.xml
            #[test]
            fn test_nodelookupnamespaceuri15() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                let mut r#cloned_comment; // type: Comment // <var name="clonedComment" type="Comment"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "dom3:p".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:p&quot;"/>
                r#comment = r#doc.create_comment("Text"); // <createComment var="comment" obj="doc" data="&quot;Text&quot;"/>
                r#cloned_comment = r#comment.clone_node(true); // <cloneNode var="clonedComment" obj="comment" deep="true"/>
                r#appended_child = r#elem.append_child(cloned_comment).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="clonedComment"/>
                r#appended_child = r#doc_elem.append_child(elem.into()).unwrap(); // <appendChild obj="docElem" var="appendedChild" newChild="elem"/>
                r#namespace_uri = r#cloned_comment
                    .lookup_namespace_uri("dom3")
                    .unwrap()
                    .to_string(); // <lookupNamespaceURI var="namespaceURI" obj="clonedComment" prefix="&quot;dom3&quot;" interface="Node"/>
                assert_eq!(r#namespace_uri, "http://www.w3.org/1999/xhtml"); // <assertEquals actual="namespaceURI" expected="&quot;http://www.w3.org/1999/xhtml&quot;" id="nodelookupnamespaceuri15" ignoreCase="false"/>
            }
            // nodeinsertbefore18.xml
            #[test]
            fn test_nodeinsertbefore18() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#new_elem; // type: Element // <var name="newElem" type="Element"/>
                let mut r#new_comment; // type: Comment // <var name="newComment" type="Comment"/>
                let mut r#new_pi; // type: ProcessingInstruction // <var name="newPI" type="ProcessingInstruction"/>
                let mut r#new_cdata; // type: CDATASection // <var name="newCDATA" type="CDATASection"/>
                let mut r#inserted_node; // type: Comment // <var name="insertedNode" type="Comment"/>
                let mut r#data; // type: DOMString // <var name="data" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#inserted; // type: Node // <var name="inserted" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#element = r#doc.create_element("element".to_string()).unwrap(); // <createElement var="element" obj="doc" tagName="&quot;element&quot;"/>
                r#new_elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/DOM"), "dom3:elem".as_ref())
                    .unwrap(); // <createElementNS var="newElem" obj="doc" namespaceURI="&quot;http://www.w3.org/DOM&quot;" qualifiedName="&quot;dom3:elem&quot;"/>
                r#new_comment = r#doc.create_comment("Comment"); // <createComment var="newComment" obj="doc" data="&quot;Comment&quot;"/>
                r#new_cdata = r#doc.create_cdata_section("CDATASection").unwrap(); // <createCDATASection var="newCDATA" obj="doc" data="&quot;CDATASection&quot;"/>
                r#new_pi = r#doc
                    .create_processing_instruction("target", Some("data"))
                    .unwrap(); // <createProcessingInstruction var="newPI" obj="doc" target="&quot;target&quot;" data="&quot;data&quot;"/>
                r#appended_child = r#element.append_child(new_elem.into()).unwrap(); // <appendChild obj="element" var="appendedChild" newChild="newElem"/>
                r#appended_child = r#element.append_child(new_comment.into()).unwrap(); // <appendChild obj="element" var="appendedChild" newChild="newComment"/>
                r#appended_child = r#element.append_child(new_pi.into()).unwrap(); // <appendChild obj="element" var="appendedChild" newChild="newPI"/>
                r#appended_child = r#element.append_child(new_cdata.into()).unwrap(); // <appendChild obj="element" var="appendedChild" newChild="newCDATA"/>
                r#inserted = r#element
                    .insert_before(new_comment.into(), Some(new_elem.into()))
                    .unwrap(); // <insertBefore obj="element" var="inserted" refChild="newElem" newChild="newComment"/>
                r#inserted_node = r#element.first_child().unwrap().as_comment().unwrap(); // <firstChild var="insertedNode" obj="element" interface="Node"/>
                r#data = r#inserted_node.data().to_string(); // <data var="data" obj="insertedNode" interface="CharacterData"/>
                assert_eq!(r#data, "Comment"); // <assertEquals actual="data" expected="&quot;Comment&quot;" id="nodeinsertbefore18" ignoreCase="false"/>
            }
            // nodegetfeature05.xml
            #[test]
            fn test_nodegetfeature05() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // let mut r#feature_impl; // type: Node // <var name="featureImpl" type="Node"/>
                // let mut r#is_supported; // type: boolean // <var name="isSupported" type="boolean"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#node = r#doc.document_element().unwrap(); // <documentElement var="node" obj="doc"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Core&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="coreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="cOrEUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;+cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="PlusCoreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;org.w3c.domts.bogus.feature&quot;" version="nullVersion"/>

                // // unimplemented: // <assertNull actual="featureImpl" id="unrecognizedFeature"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;2.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core20"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;3.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core30"/>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="SVGUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="HTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="EventsUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSAsyncUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XPathUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusHTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusSVGUnspecified"/></if>
            }
            // elementsetidattribute05.xml
            #[test]
            fn test_elementsetidattribute05() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#name_elem; // type: Element // <var name="nameElem" type="Element"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#name_elem = r#elem_list.item(2).unwrap(); // <item var="nameElem" obj="elemList" index="2" interface="NodeList"/>

                // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR"><NOT_FOUND_ERR><setIdAttribute obj="nameElem" name="&quot;hasMiddleName&quot;" isId="true"/></NOT_FOUND_ERR></assertDOMException>
            }
            // documentrenamenode10.xml
            #[test]
            fn test_documentrenamenode10() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#text_entry; // type: DOMString // <var name="textEntry" type="DOMString" value="&quot;hello&quot;"/>
                // let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                // let mut r#renamed_node; // type: Node // <var name="renamedNode" type="Node"/>
                // let mut r#qualified_name; // type: DOMString // <var name="qualifiedName" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#qualified_names; // type: List // <var name="qualifiedNames" type="List"><member>"_:"</member><member>":0"</member><member>":"</member><member>"a0:0"</member><member>"_:0;"</member><member>"a:::::c"</member></var>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#text_node = r#doc.create_text_node(r#text_entry); // <createTextNode var="textNode" data="textEntry" obj="doc"/>

                // // unimplemented: // <for-each collection="qualifiedNames" member="qualifiedName"><assertDOMException id="documentrenamenode10_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><renameNode var="renamedNode" obj="doc" n="textNode" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="qualifiedName"/></NOT_SUPPORTED_ERR></assertDOMException></for-each>
            }
            // elementsetidattributens04.xml
            #[test]
            fn test_elementsetidattributens04() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#strong_elem; // type: Element // <var name="strongElem" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "strong"); // <getElementsByTagNameNS var="elemList" obj="doc" localName="&quot;strong&quot;" namespaceURI="&quot;*&quot;" interface="Document"/>
                r#strong_elem = r#elem_list.item(2).unwrap(); // <item var="strongElem" obj="elemList" index="2" interface="NodeList"/>
                r#strong_elem
                    .set_attribute_ns(Some("http://www.netzero.com"), "dmstc:newAttr", "newValue")
                    .unwrap(); // <setAttributeNS obj="strongElem" qualifiedName="&quot;dmstc:newAttr&quot;" namespaceURI="&quot;http://www.netzero.com&quot;" value="&quot;newValue&quot;"/>
                r#strong_elem
                    .set_id_attribute_ns(Some("http://www.netzero.com"), "newAttr", true)
                    .unwrap(); // <setIdAttributeNS obj="strongElem" localName="&quot;newAttr&quot;" namespaceURI="&quot;http://www.netzero.com&quot;" isId="true"/>
                r#attributes_map = r#strong_elem.attributes(); // <attributes var="attributesMap" obj="strongElem"/>
                r#attr = r#attributes_map.get_named_item("dmstc:newAttr").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;dmstc:newAttr&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributensIsIdTrue04"/>
                r#elem = r#doc.get_element_by_id("newValue".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;newValue&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "strong"); // <assertEquals actual="elemName" expected="&quot;strong&quot;" id="elementsetidattributensGetElementById04" ignoreCase="false"/>
                r#strong_elem
                    .set_id_attribute_ns(Some("http://www.netzero.com"), "newAttr", false)
                    .unwrap(); // <setIdAttributeNS obj="strongElem" localName="&quot;newAttr&quot;" namespaceURI="&quot;http://www.netzero.com&quot;" isId="false"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(!r#id); // <assertFalse actual="id" id="elementsetidattributensIsIdFalse04"/>
            }
            // nodeappendchild02.xml
            #[test]
            fn test_nodeappendchild02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_elem; // type: Element // <var name="newElem" type="Element"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#tag_name; // type: DOMString // <var name="tagName" type="DOMString"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#tag_name = r#doc_elem.tag_name().to_string(); // <tagName var="tagName" obj="docElem"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#new_elem = r#doc
                //     .create_element_ns(Some(r#root_ns.as_ref()), r#tag_name.as_ref())
                //     .unwrap(); // <createElementNS var="newElem" obj="doc" qualifiedName="tagName" namespaceURI="rootNS"/>

                // // unimplemented: // <try>	<appendChild obj="doc" var="appendedChild" newChild="newElem"/>	<fail id="throw_HIERARCHY_REQUEST_OR_NOT_SUPPORTED"/>	<catch>		<DOMException code="HIERARCHY_REQUEST_ERR"/>		<DOMException code="NOT_SUPPORTED_ERR"/>	</catch></try>
            }
            // nodeisequalnode04.xml
            #[test]
            fn test_nodeisequalnode04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#owner_doc: DocumentRef; // <var name="ownerDoc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "xhtml:p".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:p&quot;"/>
                r#owner_doc = r#elem.owner_document().unwrap(); // <ownerDocument var="ownerDoc" obj="elem"/>
                r#is_equal = r#doc.is_equal_node(&r#owner_doc.into()); // <isEqualNode var="isEqual" obj="doc" arg="ownerDoc"/>
                assert!(r#is_equal); // <assertTrue actual="isEqual" id="nodeisequalnode04"/>
            }
            // nodegetbaseuri20.xml
            #[test]
            fn test_nodegetbaseuri20() {
                // unimplemented: // <implementationAttribute name="validating" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#base_uri; // type: DOMString // <var name="baseURI" type="DOMString"/>
                let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                r#doc = todo!(); // external_barfoo.xml // <load var="doc" href="external_barfoo" willBeModified="true"/>
                r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#p_elem = r#p_list.item(2).unwrap(); // <item var="pElem" obj="pList" index="2" interface="NodeList"/>
                // unimplemented: // <assertNotNull actual="pElem" id="pElemNotNull"/>
                r#base_uri = r#p_elem.base_uri().unwrap().to_string(); // <baseURI var="baseURI" obj="pElem" interface="Node"/>

                // unimplemented: // <assertURIEquals actual="baseURI" isAbsolute="true" name="&quot;external_widget&quot;" id="equalsExternalBarFoo"/>
            }
            // typeinfoisderivedfrom53.xml
            #[test]
            fn test_typeinfoisderivedfrom53() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // typeinfo.xml // <load var="doc" href="typeinfo" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anySimpleType&quot;" derivationMethod="2"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromAnySimpleExtension"/>
            }
            // elementsetidattributenode02.xml
            #[test]
            fn test_elementsetidattributenode02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>
                r#attributes_map = r#acronym_elem.attributes(); // <attributes var="attributesMap" obj="acronymElem"/>
                r#attr = r#attributes_map.get_named_item("class").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;class&quot;"/>
                r#acronym_elem.set_id_attribute_node(r#attr, true).unwrap(); // <setIdAttributeNode obj="acronymElem" idAttr="attr" isId="true"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributenodeIsIdTrue02"/>
                r#elem = r#doc.get_element_by_id("No".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;No&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "acronym"); // <assertEquals actual="elemName" expected="&quot;acronym&quot;" id="elementsetidattributenodeGetElementById02" ignoreCase="false"/>
                r#elem.set_id_attribute_node(r#attr, false).unwrap(); // <setIdAttributeNode obj="elem" idAttr="attr" isId="false"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(!r#id); // <assertFalse actual="id" id="elementsetidattributenodeIsIdFalse02"/>
            }
            // entitygetinputencoding04.xml
            #[test]
            fn test_entitygetinputencoding04() {
                // // unimplemented: // <implementationAttribute name="validating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#encoding_name; // type: DOMString // <var name="encodingName" type="DOMString"/>
                // r#doc = todo!(); // external_barfoo.xml // <load var="doc" href="external_barfoo" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#entity = r#entities_map.get_named_item("ent2".into()).unwrap(); // <getNamedItem var="entity" obj="entitiesMap" name="&quot;ent2&quot;"/>
                // r#encoding_name = r#entity.input_encoding().unwrap().to_string(); // <inputEncoding obj="entity" var="encodingName" interface="Entity"/>
                // assert_eq!(r#encoding_name, "UTF-8"); // <assertEquals id="entityIsUTF8" actual="encodingName" expected="&quot;UTF-8&quot;" ignoreCase="true"/>
                // r#encoding_name = r#doc.input_encoding().unwrap().to_string(); // <inputEncoding obj="doc" var="encodingName" interface="Document"/>
                // assert_eq!(r#encoding_name, "UTF-8"); // <assertEquals id="documentIsUTF8" actual="encodingName" expected="&quot;UTF-8&quot;" ignoreCase="true"/>
            }
            // typeinfoisderivedfrom04.xml
            #[test]
            fn test_typeinfoisderivedfrom04() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(0).unwrap(); // <item var="acronymElem" obj="elemList" index="0" interface="NodeList"/>
                // r#attr = r#acronym_elem.get_attribute_node("title").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;title&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "string"); // <assertEquals actual="typeName" expected="&quot;string&quot;" ignoreCase="false" id="nameIsString"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anyType&quot;" derivationMethod="15"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromAnyType"/>
            }
            // noderemovechild07.xml
            #[test]
            fn test_noderemovechild07() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#notations; // type: NamedNodeMap // <var name="notations" type="NamedNodeMap"/>
                // let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                // let mut r#removed_child; // type: Node // <var name="removedChild" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <notations var="notations" obj="docType"/>
                // r#notation = r#notations.get_named_item("notation1".into()).unwrap();
                // // <getNamedItem var="notation" obj="notations" name="&quot;notation1&quot;"/>

                // // unimplemented: // <assertDOMException id="NOT_FOUND_ERR_noderemovechild07_1"><NOT_FOUND_ERR><removeChild obj="doc" var="removedChild" oldChild="notation"/></NOT_FOUND_ERR></assertDOMException>

                // // unimplemented: // <try>	<removeChild obj="notation" var="removedChild" oldChild="doc"/>	<catch>		<DOMException code="NOT_FOUND_ERR"/>		<DOMException code="NO_MODIFICATION_ALLOWED_ERR"/>	</catch></try>
            }
            // canonicalform10.xml
            #[test]
            fn test_canonicalform10() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // // unimplemented: // <implementationAttribute name="validating" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#div_list; // type: NodeList // <var name="divList" type="NodeList"/>
                // let mut r#div; // type: Element // <var name="div" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // r#doc = todo!(); // canonicalform03.xml // <load var="doc" href="canonicalform03" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;canonical-form&quot;" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/><setParameter obj="domConfig" name="&quot;canonical-form&quot;" value="true"/><normalizeDocument obj="doc"/><!--  fail test if normalize had any errors or fatal errors   --><assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/><getElementsByTagName var="divList" obj="doc" tagname="&quot;div&quot;" interface="Document"/><item var="div" obj="divList" index="5" interface="NodeList"/><getAttributeNode var="node" obj="div" name="&quot;xmlns&quot;"/><assertNotNull actual="node" id="xmlnsPresent"/><getAttributeNode var="node" obj="div" name="&quot;xmlns:a&quot;"/><assertNull actual="node" id="xmlnsANotPresent"/></if>
            }
            // typeinfoisderivedfrom61.xml
            #[test]
            fn test_typeinfoisderivedfrom61() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // typeinfo.xml // <load var="doc" href="typeinfo" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;short&quot;" derivationMethod="1"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="isDerived"/>
            }
            // nodeisequalnode17.xml
            #[test]
            fn test_nodeisequalnode17() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#attr1; // type: Attr // <var name="attr1" type="Attr"/>
                // let mut r#attr2; // type: Attr // <var name="attr2" type="Attr"/>
                // let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#attr1 = r#doc.create_attribute_ns(None, "root".as_ref()).unwrap(); // <createAttributeNS var="attr1" obj="doc" namespaceURI="nullNSURI" qualifiedName="&quot;root&quot;"/>
                // r#attr2 = r#new_doc.import_node(r#attr1.into(), true).unwrap(); // <importNode var="attr2" obj="newDoc" importedNode="attr1" deep="true"/>
                // r#is_equal = r#attr1.is_equal_node(&r#attr2.into()); // <isEqualNode var="isEqual" obj="attr1" arg="attr2"/>
                // assert!(r#is_equal); // <assertTrue actual="isEqual" id="nodeisequalnode17"/>
            }
            // textreplacewholetext08.xml
            #[test]
            fn test_textreplacewholetext08() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#item_list; // type: NodeList // <var name="itemList" type="NodeList"/>
                let mut r#p; // type: Element // <var name="p" type="Element"/>
                let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                let mut r#node; // type: Node // <var name="node" type="Node"/>
                r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                r#item_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="itemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#p = r#item_list.item(0).unwrap(); // <item var="p" obj="itemList" index="0" interface="NodeList"/>
                r#ent_ref = r#doc.create_entity_reference("ent2".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent2&quot;"/>
                r#node = r#p.append_child(ent_ref.into()).unwrap(); // <appendChild obj="p" var="node" newChild="entRef"/>
                r#node = r#p.first_child().unwrap(); // <firstChild var="node" obj="p" interface="Node"/>

                // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">	<NO_MODIFICATION_ALLOWED_ERR>		<replaceWholeText obj="node" var="node" content="&quot;yo&quot;"/>	</NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // nodesetuserdata05.xml
            #[test]
            fn test_nodesetuserdata05() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                // let mut r#user_data; // type: DOMUserData // <var name="userData" type="DOMUserData"/>
                // let mut r#returned1; // type: DOMUserData // <var name="returned1" type="DOMUserData"/>
                // let mut r#returned2; // type: DOMUserData // <var name="returned2" type="DOMUserData"/>
                // let mut r#ret_user_data; // type: DOMUserData // <var name="retUserData" type="DOMUserData"/>
                // let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#null_handler; // type: UserDataHandler // <var name="nullHandler" type="UserDataHandler" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc2 = todo!(); // hc_staff.xml // <load var="doc2" href="hc_staff" willBeModified="true"/>
                // r#attr = r#doc
                //     .create_attribute_ns(
                //         Some("http://www.w3.org/XML/1998/namespace"),
                //         "lang".as_ref(),
                //     )
                //     .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;lang&quot;"/>

                // // unimplemented: // <setUserData obj="attr" var="retUserData" key="&quot;Key1&quot;" data="doc" handler="nullHandler"/>

                // // unimplemented: // <setUserData obj="attr" var="retUserData" key="&quot;Key2&quot;" data="doc2" handler="nullHandler"/>

                // // unimplemented: // <getUserData var="returned1" obj="attr" key="&quot;Key1&quot;"/>

                // // unimplemented: // <getUserData var="returned2" obj="attr" key="&quot;Key2&quot;"/>
                // r#success = r#returned1.is_equal_node(&r#returned2.into()); // <isEqualNode var="success" obj="returned1" arg="returned2"/>
                // assert!(r#success); // <assertTrue actual="success" id="nodesetuserdata05"/>
            }
            // documentadoptnode30.xml
            #[test]
            fn test_documentadoptnode30() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_text; // type: Text // <var name="newText" type="Text"/>
                // let mut r#adopted_text; // type: Text // <var name="adoptedText" type="Text"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#new_text = r#doc.create_text_node("Document.adoptNode test for a TEXT_NODE"); // <createTextNode var="newText" obj="doc" data="&quot;Document.adoptNode test for a TEXT_NODE&quot;"/>
                // r#adopted_text = r#doc.adopt_node(r#new_text.into()); // <adoptNode var="adoptedText" obj="doc" source="newText"/>

                // // unimplemented: // <if><notNull obj="adoptedText"/><nodeValue var="nodeValue" obj="adoptedText"/><assertEquals actual="nodeValue" expected="&quot;Document.adoptNode test for a TEXT_NODE&quot;" id="documentadoptnode30" ignoreCase="false"/></if>
            }
            // canonicalform01.xml
            #[test]
            fn test_canonicalform01() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#child_value; // type: DOMString // <var name="childValue" type="DOMString"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#ent2; // type: Entity // <var name="ent2" type="Entity"/>
                // let mut r#doctype; // type: DocumentType // <var name="doctype" type="DocumentType"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;canonical-form&quot;" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;canonical-form&quot;" value="true"/><setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/><!--  add an entity reference to the content of the p element  --><getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/><item var="pElem" obj="pList" interface="NodeList" index="0"/><createEntityReference var="entRef" obj="doc" name="&quot;ent1&quot;"/><appendChild var="child" obj="pElem" newChild="entRef"/><normalizeDocument obj="doc"/><!--  fail test if normalize had any errors or fatal errors   --><assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/><getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/><item var="pElem" obj="pList" interface="NodeList" index="0"/><lastChild var="child" obj="pElem" interface="Node"/><assertNotNull actual="child" id="lastChildNotNull"/><!--   this should be a Text node  --><nodeName var="childName" obj="child"/><assertEquals actual="childName" expected="&quot;#text&quot;" ignoreCase="false" id="firstChildName"/><nodeValue var="childValue" obj="child"/><assertEquals actual="childValue" expected="&quot;barfoo&quot;" ignoreCase="false" id="firstChildValue"/></if>
            }
            // documentrenamenode26.xml
            #[test]
            fn test_documentrenamenode26() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                // let mut r#renamed_node; // type: Node // <var name="renamedNode" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>

                // // unimplemented: // <assertDOMException id="documentrenamenode26_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><renameNode var="renamedNode" obj="doc" n="docFrag" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;root&quot;"/></NOT_SUPPORTED_ERR></assertDOMException>
            }
            // nodeisequalnode31.xml
            #[test]
            fn test_nodeisequalnode31() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#cdata1; // type: CDATASection // <var name="cdata1" type="CDATASection"/>
                let mut r#cdata2; // type: CDATASection // <var name="cdata2" type="CDATASection"/>
                let mut r#cdata3; // type: CDATASection // <var name="cdata3" type="CDATASection"/>
                let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#cdata1 = r#doc.create_cdata_section("cdata").unwrap(); // <createCDATASection var="cdata1" obj="doc" data="&quot;cdata&quot;"/>
                r#cdata2 = r#doc.create_cdata_section("cdata").unwrap(); // <createCDATASection var="cdata2" obj="doc" data="&quot;cdata&quot;"/>
                r#cdata3 = r#doc.create_cdata_section("#CDATASection").unwrap(); // <createCDATASection var="cdata3" obj="doc" data="&quot;#CDATASection&quot;"/>
                r#is_equal = r#cdata1.is_equal_node(&r#cdata2.into()); // <isEqualNode var="isEqual" obj="cdata1" arg="cdata2"/>
                assert!(r#is_equal); // <assertTrue actual="isEqual" id="nodeisequalnodeTrue29"/>
                r#is_equal = r#cdata1.is_equal_node(&r#cdata3.into()); // <isEqualNode var="isEqual" obj="cdata1" arg="cdata3"/>
                assert!(!r#is_equal); // <assertFalse actual="isEqual" id="nodeisequalnodeFalse29"/>
            }
            // typeinfoisderivedfrom60.xml
            #[test]
            fn test_typeinfoisderivedfrom60() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // typeinfo.xml // <load var="doc" href="typeinfo" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;IDREF&quot;" derivationMethod="8"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="isDerived"/>
            }
            // nodegetbaseuri18.xml
            #[test]
            fn test_nodegetbaseuri18() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#base_uri; // type: DOMString // <var name="baseURI" type="DOMString"/>
                let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                r#doc = todo!(); // barfoo_base.xml // <load var="doc" href="barfoo_base" willBeModified="true"/>
                r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" index="0" interface="NodeList"/>
                r#comment = r#p_elem.next_sibling().unwrap(); // <nextSibling var="comment" obj="pElem" interface="Node"/>
                r#base_uri = r#comment.base_uri().unwrap().to_string(); // <baseURI var="baseURI" obj="comment" interface="Node"/>

                // unimplemented: // <assertNull actual="baseURI" id="baseURI"/>
            }
            // documentadoptnode04.xml
            #[test]
            fn test_documentadoptnode04() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_attr; // type: Attr // <var name="newAttr" type="Attr"/>
                // let mut r#adopted_attr; // type: Attr // <var name="adoptedAttr" type="Attr"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#node_namespace_uri; // type: DOMString // <var name="nodeNamespaceURI" type="DOMString"/>
                // let mut r#node_prefix; // type: DOMString // <var name="nodePrefix" type="DOMString"/>
                // let mut r#attr_owner_elem; // type: Element // <var name="attrOwnerElem" type="Element"/>
                // let mut r#is_specified; // type: boolean // <var name="isSpecified" type="boolean"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // let mut r#xml_ns; // type: DOMString // <var name="xmlNS" type="DOMString" value="&quot;http://www.w3.org/XML/1998/namespace&quot;"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#new_attr = r#doc
                //     .create_attribute_ns(Some(r#xml_ns.as_ref()), "xml:lang".as_ref())
                //     .unwrap(); // <createAttributeNS var="newAttr" obj="doc" namespaceURI="xmlNS" qualifiedName="&quot;xml:lang&quot;"/>
                // r#adopted_attr = r#new_doc.adopt_node(r#new_attr.into()); // <adoptNode var="adoptedAttr" obj="newDoc" source="newAttr"/>

                // // unimplemented: // <if><notNull obj="adoptedAttr"/><nodeName var="nodeName" obj="adoptedAttr"/><namespaceURI var="nodeNamespaceURI" obj="adoptedAttr" interface="Node"/><prefix var="nodePrefix" obj="adoptedAttr"/><ownerElement var="attrOwnerElem" obj="adoptedAttr" interface="Attr"/><specified var="isSpecified" obj="adoptedAttr"/><assertEquals expected="&quot;xml:lang&quot;" actual="nodeName" id="documentadoptnode04_nodeName" ignoreCase="false"/><assertEquals expected="xmlNS" actual="nodeNamespaceURI" id="documentadoptnode04_namespaceURI" ignoreCase="false"/><assertEquals expected="&quot;xml&quot;" actual="nodePrefix" id="documentadoptnode04_prefix" ignoreCase="false"/><assertNull actual="attrOwnerElem" id="documentadoptnode04_ownerDoc"/><assertTrue actual="isSpecified" id="documentadoptnode04_specified"/></if>
            }
            // documentgetdocumenturi01.xml
            #[test]
            fn test_documentgetdocumenturi01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_uri; // type: DOMString // <var name="docURI" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#doc_uri = r#doc.document_uri().unwrap().to_string(); // <documentURI var="docURI" obj="doc"/>

                // unimplemented: // <assertNotNull actual="docURI" id="documentgetdocumenturi01"/>
            }
            // cdatasections01.xml
            #[test]
            fn test_cdatasections01() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#new_cdata; // type: CDATASection // <var name="newCdata" type="CDATASection"/>
                // let mut r#cdata; // type: CDATASection // <var name="cdata" type="CDATASection"/>
                // let mut r#text; // type: Node // <var name="text" type="Node"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#p_list.item(0).unwrap(); // <item var="elem" obj="pList" index="0" interface="NodeList"/>
                // r#new_cdata = r#doc.create_cdata_section("CDATA").unwrap(); // <createCDATASection var="newCdata" obj="doc" data="&quot;CDATA&quot;"/>
                // r#appended_child = r#elem.append_child(new_cdata.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="newCdata"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;cdata-sections&quot;" value="false"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#doc.normalize(); // <normalize obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" severity="SEVERITY_ERROR" id="normalizationError"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#p_list.item(0).unwrap(); // <item var="elem" obj="pList" index="0" interface="NodeList"/>
                // r#cdata = r#elem.last_child().unwrap(); // <lastChild var="cdata" obj="elem" interface="Node"/>
                // r#node_name = r#cdata.node_name().to_string(); // <nodeName var="nodeName" obj="cdata"/>
                // assert_eq!(r#node_name, "#cdata-section"); // <assertEquals actual="nodeName" expected="&quot;#cdata-section&quot;" id="documentnormalizedocument03_true" ignoreCase="false"/>
            }
            // nodelookupnamespaceuri14.xml
            #[test]
            fn test_nodelookupnamespaceuri14() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#cdata; // type: CDATASection // <var name="cdata" type="CDATASection"/>
                let mut r#lookup_namespace_uri; // type: DOMString // <var name="lookupNamespaceURI" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "dom3:p".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:p&quot;"/>
                r#cdata = r#doc.create_cdata_section("Text").unwrap(); // <createCDATASection var="cdata" obj="doc" data="&quot;Text&quot;"/>
                r#appended_child = r#elem.append_child(cdata.into()).unwrap(); // <appendChild var="appendedChild" obj="elem" newChild="cdata"/>
                r#appended_child = r#doc_elem.append_child(elem.into()).unwrap(); // <appendChild var="appendedChild" obj="docElem" newChild="elem"/>
                r#lookup_namespace_uri = r#cdata.lookup_namespace_uri("dom3").unwrap().to_string(); // <lookupNamespaceURI var="lookupNamespaceURI" obj="cdata" prefix="&quot;dom3&quot;" interface="Node"/>
                assert_eq!(r#lookup_namespace_uri, "http://www.w3.org/1999/xhtml");
                // <assertEquals actual="lookupNamespaceURI" expected="&quot;http://www.w3.org/1999/xhtml&quot;" id="nodelookupnamespaceuri14" ignoreCase="false"/>
            }
            // nodesettextcontent02.xml
            #[test]
            fn test_nodesettextcontent02() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#elem_child; // type: Element // <var name="elemChild" type="Element"/>
                // let mut r#new_elem; // type: Element // <var name="newElem" type="Element"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#document_elem; // type: Element // <var name="documentElem" type="Element"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;dom3:elem&quot;" doctype="nullDocType"/>
                // r#new_elem = r#new_doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/DOM/Test"),
                //         "dom3:childElem".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="newElem" obj="newDoc" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;dom3:childElem&quot;"/>
                // r#document_elem = r#new_doc.document_element().unwrap(); // <documentElement var="documentElem" obj="newDoc" interface="Document"/>
                // r#appended_child = r#document_elem.append_child(new_elem.into()).unwrap(); // <appendChild obj="documentElem" var="appendedChild" newChild="newElem"/>
                // r#new_doc.set_text_content("textContent").unwrap(); // <textContent value="&quot;textContent&quot;" obj="newDoc"/>
                // r#elem_list = r#new_doc.get_elements_by_tag_name_ns(Some("*"), "childElem"); // <getElementsByTagNameNS var="elemList" obj="newDoc" localName="&quot;childElem&quot;" namespaceURI="&quot;*&quot;" interface="Document"/>
                // r#elem_child = r#elem_list.item(0).unwrap(); // <item var="elemChild" obj="elemList" index="0" interface="NodeList"/>
                // r#node_name = r#elem_child.node_name().to_string(); // <nodeName var="nodeName" obj="elemChild"/>
                // assert_eq!(r#node_name, "dom3:childElem"); // <assertEquals actual="nodeName" expected="&quot;dom3:childElem&quot;" id="nodesettextcontent02" ignoreCase="false"/>
            }
            // nodecomparedocumentposition17.xml
            #[test]
            fn test_nodecomparedocumentposition17() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#pi1; // type: ProcessingInstruction // <var name="pi1" type="ProcessingInstruction"/>
                let mut r#pi2; // type: ProcessingInstruction // <var name="pi2" type="ProcessingInstruction"/>
                let mut r#pi1_position; // type: int // <var name="pi1Position" type="int"/>
                let mut r#pi2_position; // type: int // <var name="pi2Position" type="int"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#pi1 = r#doc
                    .create_processing_instruction("PI1", Some(""))
                    .unwrap(); // <createProcessingInstruction var="pi1" obj="doc" target="&quot;PI1&quot;" data="&quot;&quot;"/>
                r#pi2 = r#doc
                    .create_processing_instruction("PI2", Some(""))
                    .unwrap(); // <createProcessingInstruction var="pi2" obj="doc" target="&quot;PI2&quot;" data="&quot;&quot;"/>
                r#appended_child = r#doc.append_child(pi1.into()).unwrap(); // <appendChild obj="doc" var="appendedChild" newChild="pi1"/>
                r#appended_child = r#doc.append_child(pi2.into()).unwrap(); // <appendChild obj="doc" var="appendedChild" newChild="pi2"/>
                r#pi1_position = r#pi1.compare_document_position(&r#pi2.into()); // <compareDocumentPosition var="pi1Position" obj="pi1" other="pi2"/>
                assert_eq!(u16::from(r#pi1_position), 4); // <assertEquals actual="pi1Position" expected="4" id="nodecomparedocumentpositionFollowing17" ignoreCase="false"/>
                r#pi2_position = r#pi2.compare_document_position(&r#pi1.into()); // <compareDocumentPosition var="pi2Position" obj="pi2" other="pi1"/>
                assert_eq!(u16::from(r#pi2_position), 2); // <assertEquals actual="pi2Position" expected="2" id="nodecomparedocumentpositionPRECEDING17" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom17.xml
            #[test]
            fn test_typeinfoisderivedfrom17() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "emType"); // <assertEquals actual="typeName" expected="&quot;emType&quot;" ignoreCase="false" id="name"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;emp0001_3Type&quot;" derivationMethod="11"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="derivedFromEmp13NotUnion"/>
            }
            // documentsetstricterrorchecking03.xml
            #[test]
            fn test_documentsetstricterrorchecking03() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#strict_error_checking_value; // type: boolean // <var name="strictErrorCheckingValue" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // // unimplemented: // <strictErrorChecking obj="doc" value="false"/>

                // // unimplemented: // <strictErrorChecking var="strictErrorCheckingValue" obj="doc"/>
                // assert!(!r#strict_error_checking_value); // <assertFalse actual="strictErrorCheckingValue" id="documentsetstricterrorchecking03"/>
            }
            // elementsetidattributenode01.xml
            #[test]
            fn test_elementsetidattributenode01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#employee_elem; // type: Element // <var name="employeeElem" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#employee_elem = r#elem_list.item(2).unwrap(); // <item var="employeeElem" obj="elemList" index="2" interface="NodeList"/>
                r#attributes_map = r#employee_elem.attributes(); // <attributes var="attributesMap" obj="employeeElem"/>
                r#attr = r#attributes_map.get_named_item("xmlns:dmstc").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;xmlns:dmstc&quot;"/>
                r#employee_elem.set_id_attribute_node(r#attr, true).unwrap(); // <setIdAttributeNode obj="employeeElem" idAttr="attr" isId="true"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributenodeIsIdTrue01"/>
                r#elem = r#doc
                    .get_element_by_id("http://www.netzero.com".as_ref())
                    .unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;http://www.netzero.com&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "p"); // <assertEquals actual="elemName" expected="&quot;p&quot;" id="elementsetidattributenodeGetElementById01" ignoreCase="false"/>
                r#elem.set_id_attribute_node(r#attr, false).unwrap(); // <setIdAttributeNode obj="elem" idAttr="attr" isId="false"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(!r#id); // <assertFalse actual="id" id="elementsetidattributenodeIsIdFalse01"/>
            }
            // nodecomparedocumentposition01.xml
            #[test]
            fn test_nodecomparedocumentposition01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#document_position_doc; // type: int // <var name="documentPositionDoc" type="int"/>
                let mut r#document_position_doc_type; // type: int // <var name="documentPositionDocType" type="int"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                r#document_position_doc = r#doc.compare_document_position(&r#doc_type.into()); // <compareDocumentPosition var="documentPositionDoc" obj="doc" other="docType"/>
                assert_eq!(u16::from(r#document_position_doc), 20); // <assertEquals actual="documentPositionDoc" expected="20" id="nodecomparedocumentpositionIsContainedFollowing01" ignoreCase="false"/>
                r#document_position_doc_type = r#doc_type.compare_document_position(&r#doc.into()); // <compareDocumentPosition var="documentPositionDocType" obj="docType" other="doc"/>
                assert_eq!(u16::from(r#document_position_doc_type), 10); // <assertEquals actual="documentPositionDocType" expected="10" id="nodecomparetreepositionContainsPRECEDING01" ignoreCase="false"/>
            }
            // nodecomparedocumentposition06.xml
            #[test]
            fn test_nodecomparedocumentposition06() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#document_position_doc; // type: int // <var name="documentPositionDoc" type="int"/>
                let mut r#document_position_doc_elem; // type: int // <var name="documentPositionDocElem" type="int"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#document_position_doc = r#doc.compare_document_position(&r#doc_elem.into()); // <compareDocumentPosition var="documentPositionDoc" obj="doc" other="docElem"/>
                assert_eq!(u16::from(r#document_position_doc), 20); // <assertEquals actual="documentPositionDoc" expected="20" id="nodecomparedocumentpositionIsContainedFollowing06" ignoreCase="false"/>
                r#document_position_doc_elem = r#doc_elem.compare_document_position(&r#doc.into()); // <compareDocumentPosition var="documentPositionDocElem" obj="docElem" other="doc"/>
                assert_eq!(u16::from(r#document_position_doc_elem), 10); // <assertEquals actual="documentPositionDocElem" expected="10" id="nodecomparedocumentpotionContainsPRECEDING06" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom62.xml
            #[test]
            fn test_typeinfoisderivedfrom62() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // typeinfo.xml // <load var="doc" href="typeinfo" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;decimal&quot;" derivationMethod="1"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="isDerived"/>
            }
            // nodegetbaseuri13.xml
            #[test]
            fn test_nodegetbaseuri13() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#notations_map; // type: NamedNodeMap // <var name="notationsMap" type="NamedNodeMap"/>
                // let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                // let mut r#base_uri; // type: DOMString // <var name="baseURI" type="DOMString"/>
                // let mut r#doc_uri; // type: DOMString // <var name="docURI" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <notations var="notationsMap" obj="docType"/>
                // r#notation = r#notations_map.get_named_item("notation1".into()).unwrap(); // <getNamedItem var="notation" obj="notationsMap" name="&quot;notation1&quot;"/>
                // r#base_uri = r#notation.base_uri().unwrap().to_string(); // <baseURI var="baseURI" obj="notation" interface="Node"/>
                // r#doc_uri = r#doc.document_uri().unwrap().to_string(); // <documentURI var="docURI" obj="doc"/>
                // assert_eq!(r#base_uri, doc_uri); // <assertEquals actual="baseURI" expected="docURI" ignoreCase="false" id="sameAsDocURI"/>

                // // unimplemented: // <assertURIEquals actual="baseURI" id="entityBase" isAbsolute="true" name="&quot;hc_staff&quot;"/>
            }
            // domconfigelementcontentwhitespace1.xml
            #[test]
            fn test_domconfigelementcontentwhitespace1() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // let mut r#parameter; // type: DOMString // <var name="parameter" type="DOMString" value="&quot;eLeMent-content-whitespace&quot;"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDocType"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(r#state); // <assertTrue actual="state" id="defaultFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="true"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetTrue"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="false"/>

                // // unimplemented: // <if>  	  <isTrue value="canSet"/>  	  <setParameter obj="domConfig" name="parameter" value="false"/>  	  <getParameter var="state" obj="domConfig" name="parameter"/>  	  <assertFalse actual="state" id="setFalseEffective"/>  	  <else>  	  	  <assertDOMException id="throw_NOT_SUPPORTED_ERR">  	  	  	<NOT_SUPPORTED_ERR>  	  			<setParameter obj="domConfig" name="parameter" value="false"/>  	  		</NOT_SUPPORTED_ERR>  	  	  </assertDOMException>  	  	  <!--  should still be true after failed attempt  -->  	  	  <getParameter var="state" obj="domConfig" name="parameter"/>  	      <assertTrue actual="state" id="setFalseNotEffective"/>  	  </else>  </if>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="true"/>
            }
            // datatypenormalization05.xml
            #[test]
            fn test_datatypenormalization05() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#str; // type: DOMString // <var name="str" type="DOMString"/>
                // let mut r#can_set_normalization; // type: boolean // <var name="canSetNormalization" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#can_set_xml_schema; // type: boolean // <var name="canSetXMLSchema" type="boolean"/>
                // let mut r#xsd_ns; // type: DOMString // <var name="xsdNS" type="DOMString" value="&quot;http://www.w3.org/2001/XMLSchema&quot;"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // r#doc = todo!(); // datatype_normalization.xml // <load var="doc" href="datatype_normalization" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetNormalization" obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetValidate" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetXMLSchema" obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>

                // // unimplemented: // <if>	<and>		<isTrue value="canSetNormalization"/>		<isTrue value="canSetValidate"/>		<isTrue value="canSetXMLSchema"/>	</and>	<setParameter obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>		<normalizeDocument obj="doc"/>	<!--  fail test if normalize had any errors or fatal errors   -->	<assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>		<getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;http://www.w3.org/2001/DOM-Test-Suite/Level-3/datatype_normalization&quot;" localName="&quot;dateTime&quot;" interface="Document"/>	<item var="element" obj="elemList" interface="NodeList" index="0"/>	<getAttribute var="str" obj="element" name="&quot;value&quot;"/>	<assertEquals actual="str" expected="&quot;2004-01-21T15:30:00-05:00&quot;" ignoreCase="false" id="firstValue"/>	<getAttribute var="str" obj="element" name="&quot;union&quot;"/>	<assertEquals actual="str" expected="&quot;2004-01-21T20:30:00-05:00&quot;" ignoreCase="false" id="firstUnion"/>	<textContent var="str" obj="element"/>	<assertEquals actual="str" expected="&quot;2004-01-21T15:30:00 2004-01-21T15:30:00Z&quot;" ignoreCase="false" id="firstList"/>		<item var="element" obj="elemList" interface="NodeList" index="1"/>	<getAttribute var="str" obj="element" name="&quot;value&quot;"/>	<assertEquals actual="str" expected="&quot;2004-01-21T15:30:00.0000-05:00&quot;" ignoreCase="false" id="secondValue"/>	<getAttribute var="str" obj="element" name="&quot;union&quot;"/>	<assertEquals actual="str" expected="&quot;2004-01-21T15:30:00.0000-05:00&quot;" ignoreCase="false" id="secondUnion"/>	<textContent var="str" obj="element"/>	<assertEquals actual="str" expected="&quot;2004-01-21T15:30:00.0000&quot;" ignoreCase="false" id="secondList"/>		<item var="element" obj="elemList" interface="NodeList" index="2"/>	<getAttribute var="str" obj="element" name="&quot;value&quot;"/>	<assertEquals actual="str" expected="&quot;2004-01-21T15:30:00.0001-05:00&quot;" ignoreCase="false" id="thirdValue"/>	<getAttribute var="str" obj="element" name="&quot;union&quot;"/>	<assertEquals actual="str" expected="&quot;2004-01-21T15:30:00.0001-05:00&quot;" ignoreCase="false" id="thirdUnion"/>	<textContent var="str" obj="element"/>	<assertEquals actual="str" expected="&quot;2004-01-21T15:30:00.0001&quot;" ignoreCase="false" id="thirdList"/>	</if>
            }
            // nodegetbaseuri05.xml
            #[test]
            fn test_nodegetbaseuri05() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#base_uri; // type: DOMString // <var name="baseURI" type="DOMString"/>
                r#doc = todo!(); // barfoo_base.xml // <load var="doc" href="barfoo_base" willBeModified="false"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#base_uri = r#doc_elem.base_uri().unwrap().to_string(); // <baseURI var="baseURI" obj="docElem" interface="Node"/>
                assert_eq!(r#base_uri, "http://www.w3.org/DOM/L3Test"); // <assertEquals actual="baseURI" expected="&quot;http://www.w3.org/DOM/L3Test&quot;" id="nodegetbaseuri05" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom14.xml
            #[test]
            fn test_typeinfoisderivedfrom14() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>
                // r#attr = r#acronym_elem.get_attribute_node("class").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;class&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "classType"); // <assertEquals actual="typeName" expected="&quot;classType&quot;" ignoreCase="false" id="name"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;classType&quot;" derivationMethod="1"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromSelfRestriction"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;classType&quot;" derivationMethod="14"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="notDerivedFromSelfOther"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;classType&quot;" derivationMethod="15"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromSelfAll"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;classType&quot;" derivationMethod="0"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromSelfAny"/>
            }
            // noderemovechild02.xml
            #[test]
            fn test_noderemovechild02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#removed; // type: Node // <var name="removed" type="Node"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR_1"><NOT_FOUND_ERR><removeChild obj="doc" var="removed" oldChild="newDoc"/></NOT_FOUND_ERR></assertDOMException>

                // // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR_2"><NOT_FOUND_ERR><removeChild obj="newDoc" var="removed" oldChild="doc"/></NOT_FOUND_ERR></assertDOMException>
            }
            // typeinfoisderivedfrom02.xml
            #[test]
            fn test_typeinfoisderivedfrom02() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(0).unwrap(); // <item var="acronymElem" obj="elemList" index="0" interface="NodeList"/>
                // r#attr = r#acronym_elem.get_attribute_node("title").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;title&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;string&quot;" derivationMethod="1"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromSelfRestriction"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;string&quot;" derivationMethod="14"/>
                // assert!(!r#is_derived); // <assertFalse actual="isDerived" id="derivedFromSelfOther"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;string&quot;" derivationMethod="0"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromSelfAny"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;string&quot;" derivationMethod="15"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromSelfAll"/>
            }
            // nodesettextcontent03.xml
            #[test]
            fn test_nodesettextcontent03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>
                r#doc_type.set_text_content("textContent").unwrap(); // <textContent value="&quot;textContent&quot;" obj="docType"/>
                r#text_content = r#doc_type.text_content().unwrap(); // <textContent var="textContent" obj="docType"/>

                // unimplemented: // <assertNull actual="textContent" id="nodesettextcontent03"/>
            }
            // canonicalform06.xml
            #[test]
            fn test_canonicalform06() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#null_string; // type: DOMString // <var name="nullString" type="DOMString" isNull="true"/>
                // let mut r#null_doctype; // type: DocumentType // <var name="nullDoctype" type="DocumentType" isNull="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#errors; // type: List // <var name="errors" type="List"/>
                // let mut r#error; // type: DOMError // <var name="error" type="DOMError"/>
                // let mut r#severity; // type: int // <var name="severity" type="int"/>
                // let mut r#type; // type: DOMString // <var name="type" type="DOMString"/>
                // let mut r#locator; // type: DOMLocator // <var name="locator" type="DOMLocator"/>
                // let mut r#related_node; // type: Node // <var name="relatedNode" type="Node"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="nullString" qualifiedName="nullString" doctype="nullDoctype"/>

                // // unimplemented: // <assertDOMException id="xml10InvalidName">	<INVALID_CHARACTER_ERR>		<createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.example.org/domts/wellformed01&quot;" qualifiedName="&quot;LegalName&quot;"/>	</INVALID_CHARACTER_ERR></assertDOMException>

                // // unimplemented: // <try>	<xmlVersion obj="doc" value="&quot;1.1&quot;" interface="Document"/>	<catch>		<DOMException code="NOT_SUPPORTED_ERR">			<return/>		</DOMException>	</catch></try>
                // r#elem = r#doc
                //     .create_element_ns(
                //         Some("http://www.example.org/domts/wellformed01".as_ref()),
                //         "LegalName".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.example.org/domts/wellformed01&quot;" qualifiedName="&quot;LegalName&quot;"/>
                // r#retval = r#doc.append_child(elem.into()).unwrap(); // <appendChild var="retval" obj="doc" newChild="elem"/>
                // r#doc.set_xml_version("1.0").unwrap(); // <xmlVersion obj="doc" value="&quot;1.0&quot;" interface="Document"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;canonical-form&quot;" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;canonical-form&quot;" value="true"/><setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/><normalizeDocument obj="doc"/><allErrors var="errors" obj="errorMonitor"/><for-each member="error" collection="errors">	<severity var="severity" obj="error"/>	<assertEquals actual="severity" expected="2" ignoreCase="false" id="severity"/>	<type var="type" obj="error" interface="DOMError"/>	<assertEquals actual="type" expected="&quot;wf-invalid-character-in-node-name&quot;" ignoreCase="false" id="type"/>	<location var="locator" obj="error" interface="DOMError"/>	<relatedNode var="relatedNode" obj="locator" interface="DOMLocator"/>	<assertSame actual="relatedNode" expected="elem" id="relatedNode"/></for-each><assertSize size="1" collection="errors" id="oneError"/>		</if>
            }
            // infoset05.xml
            #[test]
            fn test_infoset05() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#xmlns_attr; // type: Attr // <var name="xmlnsAttr" type="Attr"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;infoset&quot;" value="true"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#xmlns_attr = r#doc_elem.get_attribute_node("xmlns").unwrap();
                // // <getAttributeNode var="xmlnsAttr" obj="docElem" name="&quot;xmlns&quot;"/>

                // // unimplemented: // <assertNotNull actual="xmlnsAttr" id="xmlnsAttrNotNull"/>
            }
            // elementgetschematypeinfo01.xml
            #[test]
            fn test_elementgetschematypeinfo01() {
                // // unimplemented: // <implementationAttribute name="validating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#type_ns; // type: DOMString // <var name="typeNS" type="DOMString"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>

                // // unimplemented: // <assertNull actual="typeName" id="nameIsNull"/>

                // // unimplemented: // <typeNamespace var="typeNS" obj="typeInfo"/>

                // // unimplemented: // <assertNull actual="typeNS" id="nsIsNull"/>
            }
            // canonicalform07.xml
            #[test]
            fn test_canonicalform07() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#body_list; // type: NodeList // <var name="bodyList" type="NodeList"/>
                // let mut r#body; // type: Element // <var name="body" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;canonical-form&quot;" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;canonical-form&quot;" value="true"/><setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/><!-- if we discarded whitespace on parse, add some back  --><if><implementationAttribute name="ignoringElementContentWhitespace" value="true"/>	<getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/>	<item var="body" obj="bodyList" interface="NodeList" index="0"/>	<firstChild var="child" obj="body" interface="Node"/>	<createTextNode var="text" obj="doc" data="&quot;    &quot;"/>	<insertBefore var="child" obj="body" newChild="text" refChild="child"/></if><normalizeDocument obj="doc"/><!--  fail test if normalize had any errors or fatal errors   --><assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/><getElementsByTagName var="bodyList" obj="doc" tagname="&quot;body&quot;" interface="Document"/><item var="body" obj="bodyList" interface="NodeList" index="0"/><firstChild var="child" obj="body" interface="Node"/><assertNotNull actual="child" id="firstChildNotNull"/><!--   this should be a Text node  --><nodeName var="childName" obj="child"/><assertEquals actual="childName" expected="&quot;#text&quot;" ignoreCase="false" id="firstChild"/><nextSibling var="child" obj="child" interface="Node"/><assertNotNull actual="child" id="secondChildNotNull"/><nodeName var="childName" obj="child"/><assertEquals actual="childName" expected="&quot;p&quot;" ignoreCase="false" id="secondChild"/></if>
            }
            // nodecomparedocumentposition24.xml
            #[test]
            fn test_nodecomparedocumentposition24() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#notaions_map; // type: NamedNodeMap // <var name="notaionsMap" type="NamedNodeMap"/>
                // let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                // let mut r#notation2; // type: Notation // <var name="notation2" type="Notation"/>
                // let mut r#notation_position; // type: int // <var name="notationPosition" type="int"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <notations var="notaionsMap" obj="docType"/>
                // r#notation = r#notaions_map.get_named_item("notation1".into()).unwrap(); // <getNamedItem var="notation" obj="notaionsMap" name="&quot;notation1&quot;"/>
                // r#notation2 = r#notaions_map.get_named_item("notation1".into()).unwrap(); // <getNamedItem var="notation2" obj="notaionsMap" name="&quot;notation1&quot;"/>
                // r#notation_position = r#notation.compare_document_position(&r#notation2.into()); // <compareDocumentPosition var="notationPosition" obj="notation" other="notation2"/>
                // assert_eq!(r#notation_position, 0); // <assertEquals actual="notationPosition" expected="0" id="nodecomparedocumentposition24" ignoreCase="false"/>
            }
            // nodereplacechild03.xml
            #[test]
            fn test_nodereplacechild03() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/DOM&quot;" qualifiedName="&quot;dom3:doc&quot;" doctype="nullDocType"/>

                // // unimplemented: // <try>        <replaceChild obj="doc" var="replaced" oldChild="doc" newChild="newDoc"/>        <catch>                <DOMException code="NOT_FOUND_ERR"/>		<DOMException code="HIERARCHY_REQUEST_ERR"/>                <DOMException code="WRONG_DOCUMENT_ERR"/>        </catch></try>
            }
            // nodegetfeature02.xml
            #[test]
            fn test_nodegetfeature02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // let mut r#feature_impl; // type: Node // <var name="featureImpl" type="Node"/>
                // let mut r#is_supported; // type: boolean // <var name="isSupported" type="boolean"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#node = r#doc.create_document_fragment(); // <createDocumentFragment var="node" obj="doc"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Core&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="coreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="cOrEUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;+cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="PlusCoreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;org.w3c.domts.bogus.feature&quot;" version="nullVersion"/>

                // // unimplemented: // <assertNull actual="featureImpl" id="unrecognizedFeature"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;2.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core20"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;3.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core30"/>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="SVGUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="HTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="EventsUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSAsyncUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XPathUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusHTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusSVGUnspecified"/></if>
            }
            // domimplementationregistry06.xml
            #[test]
            fn test_domimplementationregistry06() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#has_feature; // type: boolean // <var name="hasFeature" type="boolean"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementation var="domImpl" obj="domImplRegistry" features="&quot;xMl 3.0 cOrE&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImpl" id="domImplNotNull"/>

                // // unimplemented: // <hasFeature var="hasFeature" obj="domImpl" feature="&quot;XML&quot;" version="&quot;3.0&quot;"/>
                // assert!(r#has_feature); // <assertTrue actual="hasFeature" id="hasXML3"/>

                // // unimplemented: // <hasFeature var="hasFeature" obj="domImpl" feature="&quot;Core&quot;" version="nullVersion"/>
                // assert!(r#has_feature); // <assertTrue actual="hasFeature" id="hasCore"/>
            }
            // nodereplacechild20.xml
            #[test]
            fn test_nodereplacechild20() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#replaced; // type: Element // <var name="replaced" type="Element"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                // r#elem = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "dom3:p".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:p&quot;"/>
                // r#attr = r#doc
                //     .create_attribute_ns(
                //         Some("http://www.w3.org/XML/1998/namespace"),
                //         "xml:lang".as_ref(),
                //     )
                //     .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>
                // r#appended_child = r#doc_frag.append_child(elem.into()).unwrap();
                // // <appendChild obj="docFrag" var="appendedChild" newChild="elem"/>

                // // unimplemented: // <assertDOMException id="throw_HIERARCHY_REQUEST_ERR"><HIERARCHY_REQUEST_ERR><replaceChild var="replaced" obj="docFrag" oldChild="elem" newChild="attr"/></HIERARCHY_REQUEST_ERR></assertDOMException>
            }
            // nodecomparedocumentposition15.xml
            #[test]
            fn test_nodecomparedocumentposition15() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#doc_frag_child; // type: Node // <var name="docFragChild" type="Node"/>
                let mut r#attr_position; // type: int // <var name="attrPosition" type="int"/>
                let mut r#doc_frag_child_position; // type: int // <var name="docFragChildPosition" type="int"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#attr_node; // type: Node // <var name="attrNode" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#attr = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/XML/1998/namespace"),
                        "xml:lang".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>
                r#attr_node = r#doc_elem.set_attribute_node_ns(r#attr).unwrap().unwrap(); // <setAttributeNodeNS obj="docElem" var="attrNode" newAttr="attr"/>
                r#appended_child = r#doc_frag.append_child(doc_elem.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="docElem"/>
                r#doc_frag_child = r#doc_frag.first_child().unwrap(); // <firstChild var="docFragChild" obj="docFrag" interface="Node"/>
                r#doc_frag_child_position =
                    r#doc_frag_child.compare_document_position(&r#attr.into()); // <compareDocumentPosition var="docFragChildPosition" obj="docFragChild" other="attr"/>
                assert_eq!(u16::from(r#doc_frag_child_position), 20); // <assertEquals actual="docFragChildPosition" expected="20" id="nodecomparedocumentpositionIsContainedFollows15" ignoreCase="false"/>
                r#attr_position = r#attr.compare_document_position(&r#doc_frag_child); // <compareDocumentPosition var="attrPosition" obj="attr" other="docFragChild"/>
                assert_eq!(u16::from(r#attr_position), 10); // <assertEquals actual="attrPosition" expected="10" id="nodecomparedocumentpositionPRECEEDINGContains15" ignoreCase="false"/>
            }
            // checkcharacternormalization02.xml
            #[test]
            fn test_checkcharacternormalization02() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // let mut r#text_value; // type: DOMString // <var name="textValue" type="DOMString"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#errors; // type: List // <var name="errors" type="List"/>
                // let mut r#error; // type: DOMError // <var name="error" type="DOMError"/>
                // let mut r#severity; // type: int // <var name="severity" type="int"/>
                // let mut r#locator; // type: DOMLocator // <var name="locator" type="DOMLocator"/>
                // let mut r#related_node; // type: Node // <var name="relatedNode" type="Node"/>
                // let mut r#error_count; // type: int // <var name="errorCount" type="int" value="0"/>
                // let mut r#error_type; // type: DOMString // <var name="errorType" type="DOMString"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;check-character-normalization&quot;" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;check-character-normalization&quot;" value="true"/><setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/><getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/><item var="pElem" obj="pList" index="0" interface="NodeList"/><!--  character entity is expanded during code generation        code equivalent to "suc\u0327on"    --><createTextNode var="text" obj="doc" data="&quot;sucon&quot;"/><appendChild var="retval" obj="pElem" newChild="text"/><normalizeDocument obj="doc"/><allErrors var="errors" obj="errorMonitor"/><for-each member="error" collection="errors">	<severity var="severity" obj="error"/>	<if><equals actual="severity" expected="2" ignoreCase="false"/>		<increment var="errorCount" value="1"/>		<type var="errorType" obj="error" interface="DOMError"/>		<!-- type name is specified in LS spec -->		<assertEquals actual="errorType" expected="&quot;check-character-normalization-failure&quot;" ignoreCase="false" id="errorType"/>		<location var="locator" obj="error"/>		<relatedNode var="relatedNode" obj="locator" interface="DOMLocator"/>		<assertSame actual="relatedNode" expected="text" id="relatedNodeSame"/>        	</if></for-each><assertEquals actual="errorCount" expected="1" ignoreCase="false" id="oneError"/></if>
            }
            // infoset02.xml
            #[test]
            fn test_infoset02() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#child_type; // type: int // <var name="childType" type="int"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;infoset&quot;" value="true"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" interface="NodeList" index="0"/>
                // r#ent_ref = r#doc.create_entity_reference("ent3".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent3&quot;"/>
                // r#child = r#p_elem.append_child(ent_ref.into()).unwrap(); // <appendChild var="child" obj="pElem" newChild="entRef"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" interface="NodeList" index="0"/>
                // r#child = r#p_elem.last_child().unwrap(); // <lastChild var="child" obj="pElem" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="child" id="lastChildNotNull"/>
                // r#child_type = r#child.node_type(); // <nodeType var="childType" obj="child"/>
                // assert_eq!(r#child_type as i32, 5); // <assertEquals actual="childType" expected="5" ignoreCase="false" id="lastChildEntRef"/>
                // r#child_name = r#child.node_name().to_string(); // <nodeName var="childName" obj="child"/>
                // assert_eq!(r#child_name, "ent3"); // <assertEquals actual="childName" expected="&quot;ent3&quot;" ignoreCase="false" id="lastChildName"/>
            }
            // nodegetfeature06.xml
            #[test]
            fn test_nodegetfeature06() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // let mut r#feature_impl; // type: Node // <var name="featureImpl" type="Node"/>
                // let mut r#is_supported; // type: boolean // <var name="isSupported" type="boolean"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#node = r#doc.create_attribute("title".to_string()).unwrap(); // <createAttribute var="node" obj="doc" name="&quot;title&quot;"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Core&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="coreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="cOrEUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;+cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="PlusCoreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;org.w3c.domts.bogus.feature&quot;" version="nullVersion"/>

                // // unimplemented: // <assertNull actual="featureImpl" id="unrecognizedFeature"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;2.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core20"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;3.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core30"/>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="SVGUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="HTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="EventsUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSAsyncUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XPathUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusHTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusSVGUnspecified"/></if>
            }
            // typeinfoisderivedfrom42.xml
            #[test]
            fn test_typeinfoisderivedfrom42() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "strongType"); // <assertEquals actual="typeName" expected="&quot;strongType&quot;" ignoreCase="false" id="typeName"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anySimpleType&quot;" derivationMethod="8"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromAnySimpleType"/>
            }
            // domconfigurationcansetparameter04.xml
            #[test]
            fn test_domconfigurationcansetparameter04() {
                // // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>

                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#acronym_list; // type: NodeList // <var name="acronymList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Node // <var name="acronymElem" type="Node"/>
                // let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                // let mut r#first; // type: Node // <var name="first" type="Node"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#param_val; // type: boolean // <var name="paramVal" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter obj="domConfig" var="canSet" name="&quot;entities&quot;" value="false"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetFalse"/>

                // // unimplemented: // <getParameter var="paramVal" obj="domConfig" name="&quot;entities&quot;"/>
                // assert!(r#param_val); // <assertTrue actual="paramVal" id="stillTrue"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>
                // r#acronym_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="acronymList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#acronym_list[1].clone(); // <item var="acronymElem" obj="acronymList" index="1" interface="NodeList"/>
                // r#first = r#acronym_elem.first_child().unwrap(); // <firstChild var="first" obj="acronymElem" interface="Node"/>
                // r#node_type = r#first.node_type(); // <nodeType var="nodeType" obj="first" interface="Node"/>
                // assert_eq!(r#node_type as i32, 5); // <assertEquals actual="nodeType" expected="5" id="entityRefPreserved" ignoreCase="false"/>
            }
            // domconfigerrorhandler2.xml
            #[test]
            fn test_domconfigerrorhandler2() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#error_handler; // type: DOMErrorHandler // <var name="errorHandler" type="DOMErrorHandler" isNull="true"/>
                // let mut r#parameter; // type: DOMString // <var name="parameter" type="DOMString" value="&quot;error-handler&quot;"/>
                // let mut r#state; // type: DOMErrorHandler // <var name="state" type="DOMErrorHandler"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDocType"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="errorHandler"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetNull"/>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="errorHandler"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>

                // // unimplemented: // <assertNull actual="state" id="errorHandlerIsNull"/>
            }
            // documentrenamenode02.xml
            #[test]
            fn test_documentrenamenode02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#renamedclass; // type: Node // <var name="renamedclass" type="Node"/>
                let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                let mut r#node_type; // type: int // <var name="nodeType" type="int"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#child_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#element = r#child_list.item(1).unwrap(); // <item var="element" obj="childList" index="1" interface="NodeList"/>
                r#attr = r#element.get_attribute_node("class").unwrap(); // <getAttributeNode var="attr" obj="element" name="&quot;class&quot;"/>
                r#renamedclass = r#doc
                    .rename_node(
                        r#attr.into(),
                        Some("http://www.w3.org/DOM/Test"),
                        "prefi0x:renamedNode",
                    )
                    .unwrap(); // <renameNode var="renamedclass" obj="doc" n="attr" namespaceURI="&quot;http://www.w3.org/DOM/Test&quot;" qualifiedName="&quot;prefi0x:renamedNode&quot;"/>
                r#node_name = r#renamedclass.node_name().to_string(); // <nodeName var="nodeName" obj="renamedclass"/>
                r#namespace_uri = r#renamedclass.namespace_uri().unwrap().to_string(); // <namespaceURI var="namespaceURI" obj="renamedclass" interface="Node"/>
                r#node_type = r#renamedclass.node_type(); // <nodeType var="nodeType" obj="renamedclass"/>
                assert_eq!(r#node_name, "prefi0x:renamedNode"); // <assertEquals expected="&quot;prefi0x:renamedNode&quot;" actual="nodeName" id="documentrenamenode02_nodeName" ignoreCase="false"/>
                assert_eq!(r#namespace_uri, "http://www.w3.org/DOM/Test"); // <assertEquals expected="&quot;http://www.w3.org/DOM/Test&quot;" actual="namespaceURI" id="documentrenamenode02_namespaceURI" ignoreCase="false"/>
            }
            // domstringlistgetlength01.xml
            #[test]
            fn test_domstringlistgetlength01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#param_list; // type: DOMStringList // <var name="paramList" type="DOMStringList"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#list_size; // type: int // <var name="listSize" type="int"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <parameterNames obj="domConfig" var="paramList"/>

                // // unimplemented: // <assertNotNull actual="paramList" id="domstringlistgetlength01_notNull"/>

                // // unimplemented: // <length obj="paramList" var="listSize" interface="DOMStringList"/>

                // // unimplemented: // <assertNotEquals actual="listSize" expected="0" id="domstringlistgetlength01_notZero" ignoreCase="false"/>
            }
            // elementgetschematypeinfo04.xml
            #[test]
            fn test_elementgetschematypeinfo04() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#code_elem; // type: Element // <var name="codeElem" type="Element"/>
                // let mut r#elem_type_info; // type: TypeInfo // <var name="elemTypeInfo" type="TypeInfo"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // let mut r#type_namespace; // type: DOMString // <var name="typeNamespace" type="DOMString"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#doc_elem_node_name; // type: DOMString // <var name="docElemNodeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("code"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;code&quot;" interface="Document"/>
                // r#code_elem = r#elem_list.item(1).unwrap(); // <item var="codeElem" obj="elemList" index="1" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="elemTypeInfo" obj="codeElem" interface="Element"/>

                // // unimplemented: // <typeName var="typeName" obj="elemTypeInfo"/>

                // // unimplemented: // <typeNamespace var="typeNamespace" obj="elemTypeInfo"/>
                // assert_eq!(r#type_name, "code"); // <assertEquals expected="&quot;code&quot;" actual="typeName" id="elementgetschematypeinfo04_typeName" ignoreCase="false"/>
                // assert_eq!(r#type_namespace, "http://www.w3.org/1999/xhtml"); // <assertEquals expected="&quot;http://www.w3.org/1999/xhtml&quot;" actual="typeNamespace" id="elementgetschematypeinfo04_typeNamespace" ignoreCase="false"/>
            }
            // domimplementationgetfeature05.xml
            #[test]
            fn test_domimplementationgetfeature05() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#dom_impl_returned; // type: DOMImplementation // <var name="domImplReturned" type="DOMImplementation"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <implementation obj="doc" var="domImpl"/>

                // // unimplemented: // <getFeature var="domImplReturned" obj="domImpl" feature="&quot;&quot;" version="nullVersion" interface="DOMImplementation"/>

                // // unimplemented: // <assertNull actual="domImplReturned" id="domimplementationgetFeature05"/>
            }
            // documentsetxmlversion01.xml
            #[test]
            fn test_documentsetxmlversion01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#version_value; // type: DOMString // <var name="versionValue" type="DOMString"/>
                // let mut r#illegal_version; // type: List // <var name="illegalVersion" type="List"><member>"{"</member><member>"}"</member><member>"~"</member><member>"'"</member><member>"!"</member><member>"@"</member><member>"#"</member><member>"$"</member><member>"%"</member><member>"^"</member><member>"&amp;"</member><member>"*"</member><member>"("</member><member>")"</member><member>"+"</member><member>"="</member><member>"["</member><member>"]"</member><member>"\\"</member><member>"/"</member><member>";"</member><member>"`"</member><member>"&lt;"</member><member>"&gt;"</member><member>","</member><member>"a "</member><member>"\""</member><member>"---"</member></var>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // // unimplemented: // <for-each collection="illegalVersion" member="versionValue"><assertDOMException id="NOT_SUPPORTED_ERR_documentsetversion01"><NOT_SUPPORTED_ERR><xmlVersion obj="doc" value="versionValue" interface="Document"/></NOT_SUPPORTED_ERR></assertDOMException></for-each>
            }
            // documentgetinputencoding02.xml
            #[test]
            fn test_documentgetinputencoding02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#encoding_name; // type: DOMString // <var name="encodingName" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#encoding_name = r#new_doc.input_encoding().unwrap().to_string();
                // // <inputEncoding obj="newDoc" var="encodingName" interface="Document"/>

                // // unimplemented: // <assertNull actual="encodingName" id="documentgetinputencoding02"/>
            }
            // entitygetxmlversion02.xml
            #[test]
            fn test_entitygetxmlversion02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#entity_version; // type: DOMString // <var name="entityVersion" type="DOMString"/>
                // r#doc = todo!(); // barfoo_utf16.xml // <load var="doc" href="barfoo_utf16" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#entity = r#entities_map.get_named_item("ent5".into()).unwrap(); // <getNamedItem var="entity" obj="entitiesMap" name="&quot;ent5&quot;"/>
                // r#entity_version = r#entity.xml_version().unwrap().to_string(); // <xmlVersion obj="entity" var="entityVersion" interface="Entity"/>

                // // unimplemented: // <assertNull actual="entityVersion" id="entitygetxmlversion02"/>
            }
            // elementsetidattributens01.xml
            #[test]
            fn test_elementsetidattributens01() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#employee_elem; // type: Element // <var name="employeeElem" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#employee_elem = r#elem_list.item(2).unwrap(); // <item var="employeeElem" obj="elemList" index="2" interface="NodeList"/>
                r#employee_elem
                    .set_id_attribute_ns(Some("http://www.w3.org/2000/xmlns/"), "dmstc", true)
                    .unwrap(); // <setIdAttributeNS obj="employeeElem" localName="&quot;dmstc&quot;" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" isId="true"/>
                r#attributes_map = r#employee_elem.attributes(); // <attributes var="attributesMap" obj="employeeElem"/>
                r#attr = r#attributes_map.get_named_item("xmlns:dmstc").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;xmlns:dmstc&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributensIsIdTrue01"/>
                r#elem = r#doc
                    .get_element_by_id("http://www.netzero.com".as_ref())
                    .unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;http://www.netzero.com&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "p"); // <assertEquals actual="elemName" expected="&quot;p&quot;" id="elementsetidattributensGetElementById01" ignoreCase="false"/>
                r#employee_elem
                    .set_id_attribute_ns(Some("http://www.w3.org/2000/xmlns/"), "dmstc", false)
                    .unwrap(); // <setIdAttributeNS obj="employeeElem" localName="&quot;dmstc&quot;" namespaceURI="&quot;http://www.w3.org/2000/xmlns/&quot;" isId="false"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(!r#id); // <assertFalse actual="id" id="elementsetidattributensIsIdFalse01"/>
            }
            // nodecomparedocumentposition29.xml
            #[test]
            fn test_nodecomparedocumentposition29() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#ent_ref1; // type: EntityReference // <var name="entRef1" type="EntityReference"/>
                let mut r#ent_ref2; // type: EntityReference // <var name="entRef2" type="EntityReference"/>
                let mut r#ent_ref_child1; // type: Element // <var name="entRefChild1" type="Element"/>
                let mut r#ent_ref_child2; // type: ProcessingInstruction // <var name="entRefChild2" type="ProcessingInstruction"/>
                let mut r#ent_ref_child1_position; // type: int // <var name="entRefChild1Position" type="int"/>
                let mut r#ent_ref_child2_position; // type: int // <var name="entRefChild2Position" type="int"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#ent_ref1 = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference name="&quot;ent4&quot;" obj="doc" var="entRef1"/>
                r#ent_ref2 = r#doc.create_entity_reference("ent4".to_string()).unwrap(); // <createEntityReference name="&quot;ent4&quot;" obj="doc" var="entRef2"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#appended_child = r#doc_elem.append_child(ent_ref1.into()).unwrap(); // <appendChild obj="docElem" var="appendedChild" newChild="entRef1"/>
                r#appended_child = r#doc_elem.append_child(ent_ref2.into()).unwrap(); // <appendChild obj="docElem" var="appendedChild" newChild="entRef2"/>
                r#ent_ref_child1 = r#ent_ref1.first_child().unwrap(); // <firstChild obj="entRef1" var="entRefChild1" interface="Node"/>

                // unimplemented: // <assertNotNull actual="entRefChild1" id="entRefChild1NotNull"/>
                r#ent_ref_child2 = r#ent_ref2.last_child().unwrap(); // <lastChild obj="entRef2" var="entRefChild2" interface="Node"/>

                // unimplemented: // <assertNotNull actual="entRefChild2" id="entRefChild2NotNull"/>
                r#ent_ref_child1_position =
                    r#ent_ref_child1.compare_document_position(&r#ent_ref_child2); // <compareDocumentPosition var="entRefChild1Position" obj="entRefChild1" other="entRefChild2"/>
                assert_eq!(u16::from(r#ent_ref_child1_position), 4); // <assertEquals actual="entRefChild1Position" expected="4" id="nodecomparedocumentpositionFollowing29" ignoreCase="false"/>
                r#ent_ref_child2_position =
                    r#ent_ref_child2.compare_document_position(&r#ent_ref_child1); // <compareDocumentPosition var="entRefChild2Position" obj="entRefChild2" other="entRefChild1"/>
                assert_eq!(u16::from(r#ent_ref_child2_position), 2); // <assertEquals actual="entRefChild2Position" expected="2" id="nodecomparedocumentpositionPRECEDING29" ignoreCase="false"/>
            }
            // documentrenamenode12.xml
            #[test]
            fn test_documentrenamenode12() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#renamed_node; // type: Node // <var name="renamedNode" type="Node"/>
                // let mut r#text_entry; // type: DOMString // <var name="textEntry" type="DOMString" value="&quot;hello&quot;"/>
                // let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#text_node = r#doc.create_text_node(r#text_entry); // <createTextNode var="textNode" data="textEntry" obj="doc"/>

                // // unimplemented: // <assertDOMException id="documentrenamenode12_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><renameNode var="renamedNode" obj="doc" n="textNode" namespaceURI="&quot;http://www.w3.org/XML/1999/namespace&quot;" qualifiedName="&quot;xml:prefix&quot;"/></NOT_SUPPORTED_ERR></assertDOMException>
            }
            // nodeisequalnode15.xml
            #[test]
            fn test_nodeisequalnode15() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#attr1; // type: Attr // <var name="attr1" type="Attr"/>
                // let mut r#attr2; // type: Attr // <var name="attr2" type="Attr"/>
                // let mut r#addr_element; // type: Element // <var name="addrElement" type="Element"/>
                // let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                // let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#element_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName interface="Document" obj="doc" tagname="&quot;acronym&quot;" var="elementList"/>
                // r#addr_element = r#element_list.item(3).unwrap(); // <item interface="NodeList" obj="elementList" var="addrElement" index="3"/>
                // r#attr1 = r#addr_element
                //     .get_attribute_node_ns(None, "title".into())
                //     .unwrap()
                //     .unwrap(); // <getAttributeNodeNS obj="addrElement" var="attr1" namespaceURI="nullNS" localName="&quot;title&quot;"/>

                // // unimplemented: // <if><implementationAttribute name="namespaceAware" value="true"/>	<createAttributeNS var="attr2" obj="doc" namespaceURI="nullNS" qualifiedName="&quot;title&quot;"/>	<else>		<createAttribute var="attr2" obj="doc" name="&quot;title&quot;"/>	</else></if>
                // r#attr2.set_value("Yes").unwrap(); // <value obj="attr2" value="&quot;Yes&quot;"/>
                // r#is_equal = r#attr1.is_equal_node(&r#attr2.into()); // <isEqualNode var="isEqual" obj="attr1" arg="attr2"/>
                // assert!(r#is_equal); // <assertTrue actual="isEqual" id="nodeisequalnode15"/>
            }
            // documentgetxmlstandalone02.xml
            #[test]
            fn test_documentgetxmlstandalone02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#standalone; // type: boolean // <var name="standalone" type="boolean"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#standalone = r#new_doc.xml_standalone(); // <xmlStandalone var="standalone" obj="newDoc"/>
                // assert!(!r#standalone); // <assertFalse actual="standalone" id="documentgetxmlstandalone02"/>
            }
            // wellformed04.xml
            #[test]
            fn test_wellformed04() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#null_doctype; // type: DocumentType // <var name="nullDoctype" type="DocumentType" isNull="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#errors; // type: List // <var name="errors" type="List"/>
                // let mut r#error; // type: DOMError // <var name="error" type="DOMError"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDoctype"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>

                // // unimplemented: // <assertDOMException id="xml10InvalidName">	<INVALID_CHARACTER_ERR>		<createAttributeNS var="attr" obj="doc" namespaceURI="nullNS" qualifiedName="&quot;LegalName&quot;"/>	</INVALID_CHARACTER_ERR></assertDOMException>

                // // unimplemented: // <try>	<xmlVersion obj="doc" value="&quot;1.1&quot;" interface="Document"/>	<catch>		<DOMException code="NOT_SUPPORTED_ERR">			<return/>		</DOMException>	</catch></try>
                // r#doc_elem
                //     .set_attribute_ns(None, "LegalName".into(), "foo")
                //     .unwrap(); // <setAttributeNS obj="docElem" namespaceURI="nullNS" qualifiedName="&quot;LegalName&quot;" value="&quot;foo&quot;"/>
                // r#doc.set_xml_version("1.0").unwrap(); // <xmlVersion obj="doc" value="&quot;1.0&quot;" interface="Document"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;well-formed&quot;" value="false"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;well-formed&quot;" value="false"/><setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/><normalizeDocument obj="doc"/><allErrors var="errors" obj="errorMonitor"/><for-each member="error" collection="errors">	<assertNull actual="error" id="noErrorsExpected"/></for-each></if>
            }
            // elementsetidattributens02.xml
            #[test]
            fn test_elementsetidattributens02() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#address_elem; // type: Element // <var name="addressElem" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                let mut r#xsi_ns; // type: DOMString // <var name="xsiNS" type="DOMString" value="&quot;http://www.w3.org/2001/XMLSchema-instance&quot;"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "acronym"); // <getElementsByTagNameNS var="elemList" obj="doc" localName="&quot;acronym&quot;" namespaceURI="&quot;*&quot;" interface="Document"/>
                r#address_elem = r#elem_list.item(2).unwrap(); // <item var="addressElem" obj="elemList" index="2" interface="NodeList"/>
                r#address_elem
                    .set_id_attribute_ns(Some(r#xsi_ns), "noNamespaceSchemaLocation", true)
                    .unwrap(); // <setIdAttributeNS obj="addressElem" localName="&quot;noNamespaceSchemaLocation&quot;" namespaceURI="xsiNS" isId="true"/>
                r#attributes_map = r#address_elem.attributes(); // <attributes var="attributesMap" obj="addressElem"/>
                r#attr = r#attributes_map
                    .get_named_item("xsi:noNamespaceSchemaLocation")
                    .unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;xsi:noNamespaceSchemaLocation&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributensIsIdTrue02"/>
                r#elem = r#doc.get_element_by_id("Yes".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;Yes&quot;"/>

                // unimplemented: // <assertNotNull actual="elem" id="getElementByIDNotNull"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "acronym"); // <assertEquals actual="elemName" expected="&quot;acronym&quot;" id="elementsetidattributensGetElementById01" ignoreCase="false"/>
                r#address_elem
                    .set_id_attribute_ns(Some(r#xsi_ns), "noNamespaceSchemaLocation", false)
                    .unwrap(); // <setIdAttributeNS obj="addressElem" localName="&quot;noNamespaceSchemaLocation&quot;" namespaceURI="xsiNS" isId="false"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(!r#id); // <assertFalse actual="id" id="elementsetidattributensIsIdFalse02"/>
            }
            // documentrenamenode07.xml
            #[test]
            fn test_documentrenamenode07() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#renamed_node; // type: Node // <var name="renamedNode" type="Node"/>
                // let mut r#node_name; // type: DOMString // <var name="nodeName" type="DOMString"/>
                // let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#attr = r#new_doc
                //     .create_attribute_ns(
                //         Some("http://www.w3.org/XML/1998/namespace"),
                //         "xml:lang".as_ref(),
                //     )
                //     .unwrap(); // <createAttributeNS var="attr" obj="newDoc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>
                // r#renamed_node = r#new_doc
                //     .rename_node(
                //         r#attr.into(),
                //         Some("http://www.w3.org/XML/1998/namespace"),
                //         "xml:dom",
                //     )
                //     .unwrap(); // <renameNode var="renamedNode" obj="newDoc" n="attr" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:dom&quot;"/>
                // r#node_name = r#renamed_node.node_name().to_string(); // <nodeName var="nodeName" obj="renamedNode"/>
                // r#namespace_uri = r#renamed_node.namespace_uri().unwrap().to_string(); // <namespaceURI var="namespaceURI" obj="renamedNode" interface="Node"/>
                // assert_eq!(r#node_name, "xml:dom"); // <assertEquals expected="&quot;xml:dom&quot;" actual="nodeName" id="documentrenamenode07_nodeName" ignoreCase="false"/>
                // assert_eq!(r#namespace_uri, "http://www.w3.org/XML/1998/namespace");
                // // <assertEquals expected="&quot;http://www.w3.org/XML/1998/namespace&quot;" actual="namespaceURI" id="documentrenamenode07_namespaceURI" ignoreCase="false"/>
            }
            // entities02.xml
            #[test]
            fn test_entities02() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#child; // type: Node // <var name="child" type="Node"/>
                // let mut r#child_name; // type: DOMString // <var name="childName" type="DOMString"/>
                // let mut r#ent_ref; // type: EntityReference // <var name="entRef" type="EntityReference"/>
                // let mut r#child_value; // type: DOMString // <var name="childValue" type="DOMString"/>
                // let mut r#entities; // type: NamedNodeMap // <var name="entities" type="NamedNodeMap"/>
                // let mut r#ent2; // type: Entity // <var name="ent2" type="Entity"/>
                // let mut r#doctype; // type: DocumentType // <var name="doctype" type="DocumentType"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;entities&quot;" value="false"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" interface="NodeList" index="0"/>
                // r#ent_ref = r#doc.create_entity_reference("ent1".to_string()).unwrap(); // <createEntityReference var="entRef" obj="doc" name="&quot;ent1&quot;"/>
                // r#child = r#p_elem.append_child(ent_ref.into()).unwrap(); // <appendChild var="child" obj="pElem" newChild="entRef"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" interface="NodeList" index="0"/>
                // r#child = r#p_elem.last_child().unwrap(); // <lastChild var="child" obj="pElem" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="child" id="lastChildNotNull"/>
                // r#child_name = r#child.node_name().to_string(); // <nodeName var="childName" obj="child"/>
                // assert_eq!(r#child_name, "#text"); // <assertEquals actual="childName" expected="&quot;#text&quot;" ignoreCase="false" id="firstChildName"/>
                // r#child_value = r#child.node_value().unwrap().to_string(); // <nodeValue var="childValue" obj="child"/>
                // assert_eq!(r#child_value, "barfoo"); // <assertEquals actual="childValue" expected="&quot;barfoo&quot;" ignoreCase="false" id="firstChildValue"/>
                // r#doctype = r#doc.doctype().unwrap(); // <doctype var="doctype" obj="doc"/>

                // // unimplemented: // <entities var="entities" obj="doctype"/>
                // r#ent2 = r#entities.get_named_item("ent2".into()).unwrap(); // <getNamedItem var="ent2" obj="entities" name="&quot;ent2&quot;"/>

                // // unimplemented: // <assertNotNull actual="ent2" id="ent2NotNull"/>
            }
            // documentnormalizedocument09.xml
            #[test]
            fn test_documentnormalizedocument09() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#doc_elem_node_name; // type: DOMString // <var name="docElemNodeName" type="DOMString"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#error_handler; // type: DOMErrorHandler // <var name="errorHandler" type="DOMErrorHandler"/>
                // let mut r#err_handler; // type: DOMErrorHandler // <var name="errHandler" type="DOMErrorHandler">	<handleError>		<assertFalse actual="true" id="documentnormalizedocument09_Err"/>		<return value="true"/>	</handleError></var>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errHandler"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="&quot;validate-if-schema&quot;" value="true"/>

                // // unimplemented: // <if><isTrue value="canSet"/><setParameter obj="domConfig" name="&quot;validate-if-schema&quot;" value="true"/><normalizeDocument obj="doc"/><documentElement var="docElem" obj="doc"/><nodeName var="docElemNodeName" obj="docElem"/><assertEquals actual="docElemNodeName" expected="&quot;html&quot;" id="documentnormalizedocument09_True" ignoreCase="false"/></if>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;validate-if-schema&quot;" value="false"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#doc_elem_node_name = r#doc_elem.node_name().to_string(); // <nodeName var="docElemNodeName" obj="docElem"/>
                // assert_eq!(r#doc_elem_node_name, "html"); // <assertEquals actual="docElemNodeName" expected="&quot;html&quot;" id="documentnormalizedocument09_False" ignoreCase="false"/>
            }
            // domconfigschemalocation1.xml
            #[test]
            fn test_domconfigschemalocation1() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#state; // type: DOMString // <var name="state" type="DOMString"/>
                // let mut r#parameter; // type: DOMString // <var name="parameter" type="DOMString" value="&quot;sChEma-location&quot;"/>
                // let mut r#null_schema_location; // type: DOMString // <var name="nullSchemaLocation" type="DOMString" isNull="true"/>
                // let mut r#sample_schema_location; // type: DOMString // <var name="sampleSchemaLocation" type="DOMString" value="&quot;http://www.example.com/schemas/sampleschema.xsd&quot;"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDocType"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="true"/>
                // assert!(!r#can_set); // <assertFalse actual="canSet" id="canSetTrue"/>

                // // unimplemented: // <try>  	<getParameter var="state" obj="domConfig" name="parameter"/>  	<assertNull actual="state" id="defaultSchemaLocation"/>  	<catch>  		<DOMException code="NOT_FOUND_ERR">  			<return/>  		</DOMException>  	</catch>  </try>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="sampleSchemaLocation"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetURI"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="nullSchemaLocation"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetNull"/>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="sampleSchemaLocation"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert_eq!(r#state, sample_schema_location); // <assertEquals actual="state" expected="sampleSchemaLocation" ignoreCase="false" id="setURIEffective"/>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="nullSchemaLocation"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>

                // // unimplemented: // <assertNull actual="state" id="setNullEffective"/>
            }
            // attrgetschematypeinfo02.xml
            #[test]
            fn test_attrgetschematypeinfo02() {
                // // unimplemented: // <implementationAttribute name="validating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#type_ns; // type: DOMString // <var name="typeNS" type="DOMString"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>
                // r#attr = r#acronym_elem.get_attribute_node("id").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;id&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "ID"); // <assertEquals actual="typeName" expected="&quot;ID&quot;" ignoreCase="false" id="nameIsID"/>

                // // unimplemented: // <typeNamespace var="typeNS" obj="typeInfo"/>
                // assert_eq!(r#type_ns, "http://www.w3.org/TR/REC-xml"); // <assertEquals actual="typeNS" expected="&quot;http://www.w3.org/TR/REC-xml&quot;" ignoreCase="false" id="nsIsXML"/>
            }
            // nodelookupprefix19.xml
            #[test]
            fn test_nodelookupprefix19() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                r#doc = todo!(); // barfoo_nodefaultns.xml // <load var="doc" href="barfoo_nodefaultns" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("html:p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;html:p&quot;" interface="Document"/>
                r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>
                r#attributes_map = r#elem.attributes(); // <attributes var="attributesMap" obj="elem"/>
                r#attr = r#attributes_map.get_named_item("class").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;class&quot;"/>
                r#prefix = r#attr
                    .lookup_prefix("http://www.w3.org/1999/xhtml")
                    .unwrap()
                    .to_string(); // <lookupPrefix var="prefix" obj="attr" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;"/>
                assert_eq!(r#prefix, "html"); // <assertEquals actual="prefix" expected="&quot;html&quot;" id="nodelookupprefix19" ignoreCase="false"/>
            }
            // documentrenamenode21.xml
            #[test]
            fn test_documentrenamenode21() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#renamed_node; // type: Node // <var name="renamedNode" type="Node"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#attr = r#new_doc
                //     .create_attribute_ns(
                //         Some("http://www.w3.org/XML/1998/namespace"),
                //         "xml:lang".as_ref(),
                //     )
                //     .unwrap(); // <createAttributeNS var="attr" obj="newDoc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NAMESPACE_ERR"><NAMESPACE_ERR><renameNode var="renamedNode" obj="newDoc" n="attr" namespaceURI="&quot;http://www.w3.org/2000/XMLNS/&quot;" qualifiedName="&quot;xmlns:xml&quot;"/></NAMESPACE_ERR></assertDOMException>
            }
            // nodeinsertbefore07.xml
            #[test]
            fn test_nodeinsertbefore07() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_alt: DocumentRef; // <var name="docAlt" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#new_comment; // type: Comment // <var name="newComment" type="Comment"/>
                // let mut r#inserted; // type: Node // <var name="inserted" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_alt = todo!(); // hc_staff.xml // <load var="docAlt" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#new_comment = r#doc_alt.create_comment("Comment"); // <createComment var="newComment" obj="docAlt" data="&quot;Comment&quot;"/>

                // // unimplemented: // <assertDOMException id="WRONG_DOCUMENT_ERR_nodeinsertbefore07"><WRONG_DOCUMENT_ERR><insertBefore obj="doc" var="inserted" newChild="newComment" refChild="docElem"/></WRONG_DOCUMENT_ERR></assertDOMException>
            }
            // documentnormalizedocument07.xml
            #[test]
            fn test_documentnormalizedocument07() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#new_child; // type: CDATASection // <var name="newChild" type="CDATASection"/>
                // let mut r#old_child; // type: Node // <var name="oldChild" type="Node"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#errors; // type: List // <var name="errors" type="List"/>
                // let mut r#error; // type: DOMError // <var name="error" type="DOMError"/>
                // let mut r#error_count; // type: int // <var name="errorCount" type="int" value="0"/>
                // let mut r#severity; // type: int // <var name="severity" type="int"/>
                // let mut r#problem_node; // type: Node // <var name="problemNode" type="Node"/>
                // let mut r#location; // type: DOMLocator // <var name="location" type="DOMLocator"/>
                // let mut r#line_number; // type: int // <var name="lineNumber" type="int"/>
                // let mut r#column_number; // type: int // <var name="columnNumber" type="int"/>
                // let mut r#byte_offset; // type: int // <var name="byteOffset" type="int"/>
                // let mut r#utf16_offset; // type: int // <var name="utf16Offset" type="int"/>
                // let mut r#uri; // type: DOMString // <var name="uri" type="DOMString"/>
                // let mut r#type; // type: DOMString // <var name="type" type="DOMString"/>
                // let mut r#message; // type: DOMString // <var name="message" type="DOMString"/>
                // let mut r#related_exception; // type: DOMObject // <var name="relatedException" type="DOMObject"/>
                // let mut r#related_data; // type: DOMObject // <var name="relatedData" type="DOMObject"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>
                // r#old_child = r#elem.first_child().unwrap(); // <firstChild var="oldChild" obj="elem" interface="Node"/>
                // r#new_child = r#doc.create_cdata_section("this is not ]]> good").unwrap(); // <createCDATASection var="newChild" obj="doc" data="&quot;this is not ]]&gt; good&quot;"/>
                // r#retval = r#elem
                //     .replace_child(new_child.into(), old_child)
                //     .unwrap(); // <replaceChild var="retval" obj="elem" newChild="newChild" oldChild="oldChild"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;split-cdata-sections&quot;" value="false"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <allErrors var="errors" obj="errorMonitor"/>

                // // unimplemented: // <for-each member="error" collection="errors">	<severity var="severity" obj="error"/>	<if>		<equals actual="severity" expected="2" ignoreCase="false"/>		<!-- location should have relatedNode -->		<location var="location" obj="error"/>		<relatedNode var="problemNode" obj="location" interface="DOMLocator"/>		<assertSame actual="problemNode" expected="newChild" id="relatedNode"/>		<!-- 		    can't make assertions about these values		-->		<lineNumber var="lineNumber" obj="location"/>		<columnNumber var="columnNumber" obj="location"/>		<byteOffset var="byteOffset" obj="location"/>		<utf16Offset var="utf16Offset" obj="location"/>		<uri var="uri" obj="location" interface="DOMLocator"/>		<!--  message should be non-empty  -->		<message var="message" obj="error"/>		<length var="length" obj="message" interface="DOMString"/>		<assertTrue id="messageNotEmpty">			<greater actual="length" expected="0"/>		</assertTrue>		<!--  can't make any assertions about type or relatedData		          other than access should not raise exception -->		<type var="type" obj="error" interface="DOMError"/>		<relatedData var="relatedData" obj="error"/>		<relatedException var="relatedException" obj="error"/>		<increment var="errorCount" value="1"/>		<else>			<assertEquals actual="severity" expected="1" ignoreCase="false" id="anyOthersShouldBeWarnings"/>		</else>	</if></for-each>
                // assert_eq!(r#error_count, 1); // <assertEquals actual="errorCount" expected="1" ignoreCase="false" id="oneError"/>
            }
            // domconfigvalidateifschema1.xml
            #[test]
            fn test_domconfigvalidateifschema1() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // let mut r#parameter; // type: DOMString // <var name="parameter" type="DOMString" value="&quot;vAlIdate-if-schema&quot;"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDocType"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(!r#state); // <assertFalse actual="state" id="defaultFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="false"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="true"/>

                // // unimplemented: // <if>  	  <isTrue value="canSet"/>  	  <setParameter obj="domConfig" name="parameter" value="true"/>  	  <getParameter var="state" obj="domConfig" name="parameter"/>  	  <assertTrue actual="state" id="setTrueEffective"/>  	  <else>  	  	  <assertDOMException id="throw_NOT_SUPPORTED_ERR">  	  	  	<NOT_SUPPORTED_ERR>  	  			<setParameter obj="domConfig" name="parameter" value="true"/>  	  		</NOT_SUPPORTED_ERR>  	  	  </assertDOMException>  	  	  <!--  should still be false after failed attempt  -->  	  	  <getParameter var="state" obj="domConfig" name="parameter"/>  	      <assertFalse actual="state" id="setTrueNotEffective"/>  	  </else>  </if>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="false"/>
            }
            // domimplementationregistry09.xml
            #[test]
            fn test_domimplementationregistry09() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#has_feature; // type: boolean // <var name="hasFeature" type="boolean"/>
                // let mut r#base_impl; // type: DOMImplementation // <var name="baseImpl" type="DOMImplementation"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementation var="domImpl" obj="domImplRegistry" features="&quot;HTML&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <if>	<isNull obj="domImpl"/>	<implementation var="baseImpl"/>	<hasFeature var="hasFeature" feature="&quot;HTML&quot;" version="nullVersion"/>	<assertFalse actual="hasFeature" id="baseImplSupportsHTML"/>	<else>		<hasFeature var="hasFeature" obj="domImpl" feature="&quot;HTML&quot;" version="nullVersion"/>		<assertTrue actual="hasFeature" id="hasCore"/>	</else></if>
            }
            // infoset07.xml
            #[test]
            fn test_infoset07() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#null_doctype; // type: DocumentType // <var name="nullDoctype" type="DocumentType" isNull="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#errors; // type: List // <var name="errors" type="List"/>
                // let mut r#error; // type: DOMError // <var name="error" type="DOMError"/>
                // let mut r#severity; // type: int // <var name="severity" type="int"/>
                // let mut r#type; // type: DOMString // <var name="type" type="DOMString"/>
                // let mut r#locator; // type: DOMLocator // <var name="locator" type="DOMLocator"/>
                // let mut r#related_node; // type: Node // <var name="relatedNode" type="Node"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDoctype"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>

                // // unimplemented: // <assertDOMException id="xml10InvalidName">	<INVALID_CHARACTER_ERR>		<createAttribute var="attr" obj="doc" name="&quot;LegalName&quot;"/>	</INVALID_CHARACTER_ERR></assertDOMException>

                // // unimplemented: // <try>	<xmlVersion obj="doc" value="&quot;1.1&quot;" interface="Document"/>	<catch>		<DOMException code="NOT_SUPPORTED_ERR">			<return/>		</DOMException>	</catch></try>
                // r#doc_elem
                //     .set_attribute("LegalName".into(), "foo".into())
                //     .unwrap(); // <setAttribute obj="docElem" name="&quot;LegalName&quot;" value="&quot;foo&quot;"/>
                // r#attr = r#doc_elem.get_attribute_node("LegalName".into()).unwrap(); // <getAttributeNode var="attr" obj="docElem" name="&quot;LegalName&quot;"/>
                // r#doc.set_xml_version("1.0").unwrap(); // <xmlVersion obj="doc" value="&quot;1.0&quot;" interface="Document"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;infoset&quot;" value="true"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <allErrors var="errors" obj="errorMonitor"/>

                // // unimplemented: // <for-each member="error" collection="errors">	<severity var="severity" obj="error"/>	<assertEquals actual="severity" expected="2" ignoreCase="false" id="severity"/>	<type var="type" obj="error" interface="DOMError"/>	<assertEquals actual="type" expected="&quot;wf-invalid-character-in-node-name&quot;" ignoreCase="false" id="type"/>	<location var="locator" obj="error" interface="DOMError"/>	<relatedNode var="relatedNode" obj="locator" interface="DOMLocator"/>	<assertSame actual="relatedNode" expected="attr" id="relatedNode"/></for-each>

                // // unimplemented: // <assertSize size="1" collection="errors" id="oneError"/>
            }
            // nodelookupnamespaceuri07.xml
            #[test]
            fn test_nodelookupnamespaceuri07() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                r#elem = r#elem_list.item(2).unwrap(); // <item var="elem" obj="elemList" index="2" interface="NodeList"/>
                r#namespace_uri = r#elem.lookup_namespace_uri("dmstc").unwrap().to_string(); // <lookupNamespaceURI var="namespaceURI" obj="elem" prefix="&quot;dmstc&quot;" interface="Node"/>
                assert_eq!(r#namespace_uri, "http://www.netzero.com"); // <assertEquals actual="namespaceURI" expected="&quot;http://www.netzero.com&quot;" id="nodelookupnamespaceuri07" ignoreCase="false"/>
            }
            // documentsetdocumenturi01.xml
            #[test]
            fn test_documentsetdocumenturi01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_uri; // type: DOMString // <var name="docURI" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc.set_document_uri("file:///test").unwrap(); // <documentURI obj="doc" value="&quot;file:///test&quot;"/>
                // r#doc_uri = r#doc.document_uri().unwrap().to_string(); // <documentURI var="docURI" obj="doc"/>
                // assert_eq!(r#doc_uri, "file:///test"); // <assertEquals actual="docURI" expected="&quot;file:///test&quot;" id="documentsetdocumenturi01" ignoreCase="false"/>
            }
            // nodeinsertbefore23.xml
            #[test]
            fn test_nodeinsertbefore23() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#ref_node; // type: Element // <var name="refNode" type="Element"/>
                // let mut r#new_node; // type: Text // <var name="newNode" type="Text"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#inserted; // type: Node // <var name="inserted" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc2 = todo!(); // hc_staff.xml // <load var="doc2" href="hc_staff" willBeModified="true"/>
                // r#element = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "xhtml:body".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="element" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:body&quot;"/>
                // r#ref_node = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "xhtml:p".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="refNode" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;xhtml:p&quot;"/>
                // r#new_node = r#doc2.create_text_node("TextNode"); // <createTextNode var="newNode" obj="doc2" data="&quot;TextNode&quot;"/>
                // r#appended_child = r#element.append_child(ref_node.into()).unwrap();
                // // <appendChild obj="element" var="appendedChild" newChild="refNode"/>

                // // unimplemented: // <assertDOMException id="throw_WRONG_DOCUMENT_ERR"><WRONG_DOCUMENT_ERR><insertBefore obj="element" var="inserted" refChild="refNode" newChild="newNode"/></WRONG_DOCUMENT_ERR></assertDOMException>
            }
            // datatypenormalization10.xml
            #[test]
            fn test_datatypenormalization10() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#str; // type: DOMString // <var name="str" type="DOMString"/>
                // let mut r#can_set_normalization; // type: boolean // <var name="canSetNormalization" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#can_set_xml_schema; // type: boolean // <var name="canSetXMLSchema" type="boolean"/>
                // let mut r#xsd_ns; // type: DOMString // <var name="xsdNS" type="DOMString" value="&quot;http://www.w3.org/2001/XMLSchema&quot;"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // r#doc = todo!(); // datatype_normalization.xml // <load var="doc" href="datatype_normalization" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetNormalization" obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetValidate" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetXMLSchema" obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>

                // // unimplemented: // <if>	<and>		<isTrue value="canSetNormalization"/>		<isTrue value="canSetValidate"/>		<isTrue value="canSetXMLSchema"/>	</and>	<setParameter obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>	<normalizeDocument obj="doc"/>	<!--  fail test if normalize had any errors or fatal errors   -->	<assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>	<getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;http://www.w3.org/2001/DOM-Test-Suite/Level-3/datatype_normalization&quot;" localName="&quot;float&quot;" interface="Document"/>	<item var="element" obj="elemList" interface="NodeList" index="0"/>	<getAttribute var="str" obj="element" name="&quot;default&quot;"/>	<assertEquals actual="str" expected="&quot;3.1415926E0&quot;" ignoreCase="false" id="firstValue"/></if>
            }
            // nodeisdefaultnamespace02.xml
            #[test]
            fn test_nodeisdefaultnamespace02() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#is_default; // type: boolean // <var name="isDefault" type="boolean"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#null_nsuri; // type: DOMString // <var name="nullNSURI" type="DOMString" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.local_name().unwrap().to_string(); // <localName var="rootName" obj="docElem" interface="Node"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#is_default = r#new_doc.is_default_namespace(r#root_ns.as_ref()); // <isDefaultNamespace var="isDefault" obj="newDoc" namespaceURI="rootNS"/>
                // assert!(r#is_default); // <assertTrue actual="isDefault" id="nodeisdefaultnamespace02_true"/>
                // r#is_default = r#new_doc.is_default_namespace(r#null_nsuri.as_ref()); // <isDefaultNamespace var="isDefault" obj="newDoc" namespaceURI="nullNSURI"/>
                // assert!(!r#is_default); // <assertFalse actual="isDefault" id="nodeisdefaultnamespace02_false"/>
            }
            // nodeissamenode02.xml
            #[test]
            fn test_nodeissamenode02() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_type1; // type: DocumentType // <var name="docType1" type="DocumentType"/>
                let mut r#doc_type2; // type: DocumentType // <var name="docType2" type="DocumentType"/>
                let mut r#is_same; // type: boolean // <var name="isSame" type="boolean"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#doc_type1 = r#doc.doctype().unwrap(); // <doctype var="docType1" obj="doc"/>
                r#doc_type2 = r#doc.doctype().unwrap(); // <doctype var="docType2" obj="doc"/>
                is_same = doc_type1.is_same_node(&doc_type2.into()); // <isSameNode var="isSame" obj="docType1" other="docType2"/>
                assert!(r#is_same); // <assertTrue actual="isSame" id="nodeissamenode02"/>
            }
            // elementsetidattribute04.xml
            #[test]
            fn test_elementsetidattribute04() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#name_elem; // type: Element // <var name="nameElem" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#name_elem = r#elem_list.item(2).unwrap(); // <item var="nameElem" obj="elemList" index="2" interface="NodeList"/>
                r#name_elem
                    .set_attribute("hasMiddleName", "Antoine")
                    .unwrap(); // <setAttribute obj="nameElem" name="&quot;hasMiddleName&quot;" value="&quot;Antoine&quot;"/>
                r#name_elem.set_id_attribute("hasMiddleName", true).unwrap(); // <setIdAttribute obj="nameElem" name="&quot;hasMiddleName&quot;" isId="true"/>
                r#attributes_map = r#name_elem.attributes(); // <attributes var="attributesMap" obj="nameElem"/>
                r#attr = r#attributes_map.get_named_item("hasMiddleName").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;hasMiddleName&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributeIsIdTrue03"/>
                r#elem = r#doc.get_element_by_id("Antoine".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;Antoine&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "strong"); // <assertEquals actual="elemName" expected="&quot;strong&quot;" id="elementsetidattributeGetElementById03" ignoreCase="false"/>
                r#name_elem
                    .set_id_attribute("hasMiddleName", false)
                    .unwrap(); // <setIdAttribute obj="nameElem" name="&quot;hasMiddleName&quot;" isId="false"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(!r#id); // <assertFalse actual="id" id="elementsetidattributeIsIdFalse03"/>
            }
            // nodegettextcontent12.xml
            #[test]
            fn test_nodegettextcontent12() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "body".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;body&quot;"/>
                r#comment = r#doc.create_comment("Comment"); // <createComment var="comment" obj="doc" data="&quot;Comment&quot;"/>
                r#appended_child = r#elem.append_child(comment.into()).unwrap(); // <appendChild obj="elem" var="appendedChild" newChild="comment"/>
                r#text_content = r#comment.text_content().unwrap(); // <textContent var="textContent" obj="comment"/>
                assert_eq!(r#text_content, "Comment"); // <assertEquals actual="textContent" expected="&quot;Comment&quot;" id="nodegettextcontent12" ignoreCase="false"/>
            }
            // textreplacewholetext06.xml
            #[test]
            fn test_textreplacewholetext06() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>

                // unimplemented: // <implementationAttribute name="expandEntityReferences" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#item_list; // type: NodeList // <var name="itemList" type="NodeList"/>
                let mut r#element_strong; // type: Element // <var name="elementStrong" type="Element"/>
                let mut r#text_node; // type: Text // <var name="textNode" type="Text"/>
                let mut r#eref_node; // type: EntityReference // <var name="erefNode" type="EntityReference"/>
                let mut r#replaced_text; // type: Text // <var name="replacedText" type="Text"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#item_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="itemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                r#element_strong = r#item_list.item(0).unwrap(); // <item var="elementStrong" obj="itemList" index="0" interface="NodeList"/>
                r#text_node = r#doc.create_text_node("New Text"); // <createTextNode var="textNode" obj="doc" data="&quot;New Text&quot;"/>
                r#eref_node = r#doc.create_entity_reference("beta".to_string()).unwrap(); // <createEntityReference var="erefNode" obj="doc" name="&quot;beta&quot;"/>
                r#appended_child = r#element_strong.append_child(text_node.into()).unwrap(); // <appendChild obj="elementStrong" var="appendedChild" newChild="textNode"/>
                r#appended_child = r#element_strong.append_child(eref_node.into()).unwrap(); // <appendChild obj="elementStrong" var="appendedChild" newChild="erefNode"/>
                r#text_node = r#element_strong
                    .first_child()
                    .unwrap()
                    .as_text_node()
                    .unwrap(); // <firstChild var="textNode" obj="elementStrong" interface="Node"/>
                r#replaced_text = r#text_node
                    .replace_whole_text("New Text and Cdata")
                    .unwrap()
                    .unwrap(); // <replaceWholeText obj="textNode" var="replacedText" content="&quot;New Text and Cdata&quot;"/>
                r#node_value = r#text_node.node_value().unwrap().to_string(); // <nodeValue var="nodeValue" obj="textNode"/>
                assert_eq!(r#node_value, "New Text and Cdata"); // <assertEquals actual="nodeValue" expected="&quot;New Text and Cdata&quot;" id="textreplacewholetext06" ignoreCase="false"/>
            }
            // attrgetschematypeinfo05.xml
            #[test]
            fn test_attrgetschematypeinfo05() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#type_ns; // type: DOMString // <var name="typeNS" type="DOMString"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>
                // r#attr = r#acronym_elem.get_attribute_node("class").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;class&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "classType"); // <assertEquals actual="typeName" expected="&quot;classType&quot;" ignoreCase="false" id="nameIsClassType"/>

                // // unimplemented: // <typeNamespace var="typeNS" obj="typeInfo"/>
                // assert_eq!(r#type_ns, "http://www.w3.org/1999/xhtml"); // <assertEquals actual="typeNS" expected="&quot;http://www.w3.org/1999/xhtml&quot;" ignoreCase="false" id="nsIsXHTML"/>
            }
            // nodeisdefaultnamespace05.xml
            #[test]
            fn test_nodeisdefaultnamespace05() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#is_default; // type: boolean // <var name="isDefault" type="boolean"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#null_nsuri; // type: DOMString // <var name="nullNSURI" type="DOMString" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.local_name().unwrap().to_string(); // <localName var="rootName" obj="docElem" interface="Node"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#elem = r#new_doc.document_element().unwrap(); // <documentElement var="elem" obj="newDoc"/>
                // r#is_default = r#elem.is_default_namespace(r#root_ns.as_ref()); // <isDefaultNamespace var="isDefault" obj="elem" namespaceURI="rootNS"/>
                // assert!(r#is_default); // <assertTrue actual="isDefault" id="nodeisdefaultnamespace05_1"/>
                // r#is_default = r#elem.is_default_namespace(r#null_nsuri.as_ref()); // <isDefaultNamespace var="isDefault" obj="elem" namespaceURI="nullNSURI"/>
                // assert!(!r#is_default); // <assertFalse actual="isDefault" id="nodeisdefaultnamespace05_2"/>
            }
            // attrisid03.xml
            #[test]
            fn test_attrisid03() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#xml_ns; // type: DOMString // <var name="xmlNS" type="DOMString" value="&quot;http://www.w3.org/XML/1998/namespace&quot;"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>
                r#acronym_elem
                    .set_attribute_ns(Some(r#xml_ns), "xml:lang", "FR-fr")
                    .unwrap(); // <setAttributeNS obj="acronymElem" namespaceURI="xmlNS" qualifiedName="&quot;xml:lang&quot;" value="&quot;FR-fr&quot;"/>
                r#acronym_elem
                    .set_id_attribute_ns(Some(r#xml_ns), "lang", false)
                    .unwrap(); // <setIdAttributeNS obj="acronymElem" localName="&quot;lang&quot;" namespaceURI="xmlNS" isId="false"/>
                r#attr = r#acronym_elem
                    .get_attribute_node_ns(Some(r#xml_ns), "lang")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS var="attr" obj="acronymElem" namespaceURI="xmlNS" localName="&quot;lang&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(!r#id); // <assertFalse actual="id" id="AttrIsIDFalse03"/>
            }
            // nodesetuserdata04.xml
            #[test]
            fn test_nodesetuserdata04() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#user_data; // type: DOMUserData // <var name="userData" type="DOMUserData"/>
                // let mut r#returned1; // type: DOMUserData // <var name="returned1" type="DOMUserData"/>
                // let mut r#returned2; // type: DOMUserData // <var name="returned2" type="DOMUserData"/>
                // let mut r#ret_user_data; // type: DOMUserData // <var name="retUserData" type="DOMUserData"/>
                // let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#txt; // type: Text // <var name="txt" type="Text"/>
                // let mut r#null_handler; // type: UserDataHandler // <var name="nullHandler" type="UserDataHandler" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#elem = r#doc
                //     .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "p".as_ref())
                //     .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;p&quot;"/>
                // r#txt = r#doc.create_text_node("TEXT"); // <createTextNode var="txt" obj="doc" data="&quot;TEXT&quot;"/>

                // // unimplemented: // <setUserData obj="elem" var="retUserData" key="&quot;Key1&quot;" data="txt" handler="nullHandler"/>

                // // unimplemented: // <setUserData obj="elem" var="retUserData" key="&quot;Key2&quot;" data="txt" handler="nullHandler"/>

                // // unimplemented: // <getUserData var="returned1" obj="elem" key="&quot;Key1&quot;"/>

                // // unimplemented: // <getUserData var="returned2" obj="elem" key="&quot;Key2&quot;"/>
                // r#success = r#returned1.is_equal_node(&r#returned2.into()); // <isEqualNode var="success" obj="returned1" arg="returned2"/>
                // assert!(r#success); // <assertTrue actual="success" id="nodesetuserdata04"/>
            }
            // domconfignamespacedeclarations1.xml
            #[test]
            fn test_domconfignamespacedeclarations1() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // let mut r#parameter; // type: DOMString // <var name="parameter" type="DOMString" value="&quot;nAmEspace-declarations&quot;"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDocType"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(r#state); // <assertTrue actual="state" id="defaultFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="false"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="true"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetTrue"/>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="false"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(!r#state); // <assertFalse actual="state" id="setFalseEffective"/>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="true"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(r#state); // <assertTrue actual="state" id="setTrueEffective"/>
            }
            // entitygetxmlencoding04.xml
            #[test]
            fn test_entitygetxmlencoding04() {
                // // unimplemented: // <implementationAttribute name="validating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#encoding_name; // type: DOMString // <var name="encodingName" type="DOMString"/>
                // r#doc = todo!(); // external_barfoo.xml // <load var="doc" href="external_barfoo" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#entity = r#entities_map.get_named_item("ent2".into()).unwrap(); // <getNamedItem var="entity" obj="entitiesMap" name="&quot;ent2&quot;"/>
                // r#encoding_name = r#entity.xml_encoding().unwrap().to_string(); // <xmlEncoding obj="entity" var="encodingName" interface="Entity"/>

                // // unimplemented: // <assertNull actual="encodingName" id="xmlEncoding"/>
            }
            // elementsetidattributenode08.xml
            #[test]
            fn test_elementsetidattributenode08() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list1; // type: NodeList // <var name="elemList1" type="NodeList"/>
                let mut r#elem_list2; // type: NodeList // <var name="elemList2" type="NodeList"/>
                let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list1 = r#doc.get_elements_by_tag_name_ns(Some("*"), "acronym"); // <getElementsByTagNameNS var="elemList1" obj="doc" localName="&quot;acronym&quot;" namespaceURI="&quot;*&quot;" interface="Document"/>
                r#elem_list2 = r#doc.get_elements_by_tag_name_ns(Some("*"), "p"); // <getElementsByTagNameNS var="elemList2" obj="doc" localName="&quot;p&quot;" namespaceURI="&quot;*&quot;" interface="Document"/>
                r#acronym_elem = r#elem_list1.item(1).unwrap(); // <item var="acronymElem" obj="elemList1" index="1" interface="NodeList"/>
                r#p_elem = r#elem_list2.item(2).unwrap(); // <item var="pElem" obj="elemList2" index="2" interface="NodeList"/>
                r#attributes_map = r#acronym_elem.attributes(); // <attributes var="attributesMap" obj="acronymElem"/>
                r#attr = r#attributes_map.get_named_item("title").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;title&quot;"/>
                r#acronym_elem.set_id_attribute_node(r#attr, true).unwrap(); // <setIdAttributeNode obj="acronymElem" idAttr="attr" isId="true"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributenodeIsId1True08"/>
                r#attributes_map = r#p_elem.attributes(); // <attributes var="attributesMap" obj="pElem"/>
                r#attr = r#attributes_map.get_named_item("xmlns:dmstc").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;xmlns:dmstc&quot;"/>
                r#p_elem.set_id_attribute_node(r#attr, true).unwrap(); // <setIdAttributeNode obj="pElem" idAttr="attr" isId="true"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributenodeIsId2True08"/>
                r#elem = r#doc.get_element_by_id("Yes".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;Yes&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "acronym"); // <assertEquals actual="elemName" expected="&quot;acronym&quot;" id="elementsetidattributenode1GetElementById08" ignoreCase="false"/>
                r#elem = r#doc
                    .get_element_by_id("http://www.netzero.com".as_ref())
                    .unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;http://www.netzero.com&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "p"); // <assertEquals actual="elemName" expected="&quot;p&quot;" id="elementsetidattributenode2GetElementById08" ignoreCase="false"/>
            }
            // noderemovechild10.xml
            #[test]
            fn test_noderemovechild10() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#removed_elem; // type: Element // <var name="removedElem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#elem = r#doc
                    .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "dom3:br".as_ref())
                    .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:br&quot;"/>
                r#appended_child = r#doc_frag.append_child(elem.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="elem"/>
                r#removed_elem = r#doc_frag.remove_child(elem.into()).unwrap(); // <removeChild var="removedElem" obj="docFrag" oldChild="elem"/>
                r#elem_name = r#removed_elem.node_name().to_string(); // <nodeName var="elemName" obj="removedElem"/>
                assert_eq!(r#elem_name, "dom3:br"); // <assertEquals actual="elemName" expected="&quot;dom3:br&quot;" id="noderemovechild10" ignoreCase="false"/>
            }
            // nodegetbaseuri10.xml
            #[test]
            fn test_nodegetbaseuri10() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                let mut r#new_pi; // type: ProcessingInstruction // <var name="newPI" type="ProcessingInstruction"/>
                let mut r#base_uri; // type: DOMString // <var name="baseURI" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // barfoo_base.xml // <load var="doc" href="barfoo_base" willBeModified="true"/>
                r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                r#new_pi = r#doc
                    .create_processing_instruction("TARGET", Some("DATA"))
                    .unwrap(); // <createProcessingInstruction var="newPI" obj="doc" target="&quot;TARGET&quot;" data="&quot;DATA&quot;"/>
                r#appended_child = r#doc_elem.append_child(new_pi.into()).unwrap(); // <appendChild obj="docElem" var="appendedChild" newChild="newPI"/>
                r#base_uri = r#new_pi.base_uri().unwrap().to_string(); // <baseURI var="baseURI" obj="newPI" interface="Node"/>
                assert_eq!(r#base_uri, "http://www.w3.org/DOM/L3Test"); // <assertEquals actual="baseURI" expected="&quot;http://www.w3.org/DOM/L3Test&quot;" id="nodegetbaseuri10" ignoreCase="false"/>
            }
            // domstringlistitem02.xml
            #[test]
            fn test_domstringlistitem02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#param_list; // type: DOMStringList // <var name="paramList" type="DOMStringList"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#list_size; // type: int // <var name="listSize" type="int"/>
                // let mut r#ret_str; // type: DOMString // <var name="retStr" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <parameterNames obj="domConfig" var="paramList"/>
                // r#ret_str = r#param_list[0].clone(); // <item obj="paramList" var="retStr" index="0" interface="DOMStringList"/>

                // // unimplemented: // <assertNotNull actual="retStr" id="domstringlistitem02_notNull"/>
                // r#ret_str = r#param_list[100].clone(); // <item obj="paramList" var="retStr" index="100" interface="DOMStringList"/>

                // // unimplemented: // <assertNull actual="retStr" id="domstringlistitem02_null"/>
            }
            // documentgetxmlstandalone01.xml
            #[test]
            fn test_documentgetxmlstandalone01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#standalone; // type: boolean // <var name="standalone" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#standalone = r#doc.xml_standalone(); // <xmlStandalone var="standalone" obj="doc"/>
                // assert!(!r#standalone); // <assertFalse actual="standalone" id="documentgetxmlstandalone01"/>
            }
            // domconfiginfoset1.xml
            #[test]
            fn test_domconfiginfoset1() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // let mut r#parameter; // type: DOMString // <var name="parameter" type="DOMString" value="&quot;iNfOset&quot;"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDocType"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(!r#state); // <assertFalse actual="state" id="defaultFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="false"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="true"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetTrue"/>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="true"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(r#state); // <assertTrue actual="state" id="setTrueIsEffective"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="&quot;entities&quot;"/>
                // assert!(!r#state); // <assertFalse actual="state" id="entitiesSetFalse"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="&quot;cdata-sections&quot;"/>
                // assert!(!r#state); // <assertFalse actual="state" id="cdataSectionsSetFalse"/>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="false"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(r#state); // <assertTrue actual="state" id="setFalseIsNoOp"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;entities&quot;" value="true"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(!r#state); // <assertFalse actual="state" id="setEntitiesTrueInvalidatesInfoset"/>
            }
            // normalizecharacters05.xml
            #[test]
            fn test_normalizecharacters05() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // let mut r#text_value; // type: DOMString // <var name="textValue" type="DOMString"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;normalize-characters&quot;" value="false"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" index="0" interface="NodeList"/>
                // r#text = r#doc.create_text_node("sucon"); // <createTextNode var="text" obj="doc" data="&quot;sucon&quot;"/>
                // r#retval = r#p_elem.append_child(text.into()).unwrap(); // <appendChild var="retval" obj="pElem" newChild="text"/>
                // r#doc.normalize(); // <normalize obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" index="0" interface="NodeList"/>
                // r#text = r#p_elem.first_child().unwrap().as_text_node().unwrap(); // <firstChild var="text" obj="pElem" interface="Node"/>
                // r#text_value = r#text.node_value().unwrap().to_string(); // <nodeValue var="textValue" obj="text"/>
                // assert_eq!(r#text_value, "barsucon"); // <assertEquals actual="textValue" expected="&quot;barsucon&quot;" ignoreCase="false" id="noCharNormalization"/>
            }
            // normalizecharacters01.xml
            #[test]
            fn test_normalizecharacters01() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // let mut r#p_list; // type: NodeList // <var name="pList" type="NodeList"/>
                // let mut r#p_elem; // type: Element // <var name="pElem" type="Element"/>
                // let mut r#text; // type: Text // <var name="text" type="Text"/>
                // let mut r#text_value; // type: DOMString // <var name="textValue" type="DOMString"/>
                // let mut r#retval; // type: Node // <var name="retval" type="Node"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;normalize-characters&quot;" value="false"/>

                // // unimplemented: // <setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" index="0" interface="NodeList"/>
                // r#text = r#doc.create_text_node("sucon"); // <createTextNode var="text" obj="doc" data="&quot;sucon&quot;"/>
                // r#retval = r#p_elem.append_child(text.into()).unwrap(); // <appendChild var="retval" obj="pElem" newChild="text"/>
                // r#doc.normalize_document(); // <normalizeDocument obj="doc"/>

                // // unimplemented: // <assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>
                // r#p_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="pList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#p_elem = r#p_list.item(0).unwrap(); // <item var="pElem" obj="pList" index="0" interface="NodeList"/>
                // r#text = r#p_elem.first_child().unwrap().as_text_node().unwrap(); // <firstChild var="text" obj="pElem" interface="Node"/>
                // r#text_value = r#text.node_value().unwrap().to_string(); // <nodeValue var="textValue" obj="text"/>
                // assert_eq!(r#text_value, "barsucon"); // <assertEquals actual="textValue" expected="&quot;barsucon&quot;" ignoreCase="false" id="noCharNormalization"/>
            }
            // nodegetuserdata03.xml
            #[test]
            fn test_nodegetuserdata03() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#user_data; // type: DOMUserData // <var name="userData" type="DOMUserData"/>
                // let mut r#ret_user_data; // type: DOMUserData // <var name="retUserData" type="DOMUserData"/>
                // let mut r#success; // type: boolean // <var name="success" type="boolean"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#returned_user_data; // type: DOMUserData // <var name="returnedUserData" type="DOMUserData"/>
                // let mut r#null_handler; // type: UserDataHandler // <var name="nullHandler" type="UserDataHandler" isNull="true"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>
                // r#elem = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "body".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="elem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;body&quot;"/>

                // // unimplemented: // <setUserData obj="doc" var="returnedUserData" key="&quot;something&quot;" data="elem" handler="nullHandler"/>

                // // unimplemented: // <getUserData var="retUserData" obj="doc" key="&quot;something&quot;"/>
                // r#success = r#ret_user_data.is_equal_node(&r#elem.into()); // <isEqualNode var="success" obj="retUserData" arg="elem"/>
                // assert!(r#success); // <assertTrue actual="success" id="nodegetuserdata03"/>
            }
            // elementsetidattributens05.xml
            #[test]
            fn test_elementsetidattributens05() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name_ns(Some("*"), "acronym"); // <getElementsByTagNameNS var="elemList" obj="doc" localName="&quot;acronym&quot;" namespaceURI="&quot;*&quot;" interface="Document"/>
                r#acronym_elem = r#elem_list.item(2).unwrap(); // <item var="acronymElem" obj="elemList" index="2" interface="NodeList"/>
                r#acronym_elem
                    .set_attribute_ns(Some("*"), "title", "newValue")
                    .unwrap(); // <setAttributeNS obj="acronymElem" qualifiedName="&quot;title&quot;" namespaceURI="&quot;*&quot;" value="&quot;newValue&quot;"/>
                r#acronym_elem
                    .set_id_attribute_ns(Some("*"), "title", true)
                    .unwrap(); // <setIdAttributeNS obj="acronymElem" localName="&quot;title&quot;" namespaceURI="&quot;*&quot;" isId="true"/>
                r#attributes_map = r#acronym_elem.attributes(); // <attributes var="attributesMap" obj="acronymElem"/>
                r#attr = r#attributes_map.get_named_item("title").unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;title&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(r#id); // <assertTrue actual="id" id="elementsetidattributensIsIdTrue05"/>
                r#elem = r#doc.get_element_by_id("newValue".as_ref()).unwrap(); // <getElementById obj="doc" var="elem" elementId="&quot;newValue&quot;"/>
                r#elem_name = r#elem.tag_name().to_string(); // <tagName obj="elem" var="elemName"/>
                assert_eq!(r#elem_name, "acronym"); // <assertEquals actual="elemName" expected="&quot;acronym&quot;" id="elementsetidattributensGetElementById05" ignoreCase="false"/>
                r#acronym_elem
                    .set_id_attribute_ns(Some("*"), "title", false)
                    .unwrap(); // <setIdAttributeNS obj="acronymElem" localName="&quot;title&quot;" namespaceURI="&quot;*&quot;" isId="false"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(!r#id); // <assertFalse actual="id" id="elementsetidattributensIsIdFalse05"/>
            }
            // nodeisequalnode32.xml
            #[test]
            fn test_nodeisequalnode32() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#pi1; // type: ProcessingInstruction // <var name="pi1" type="ProcessingInstruction"/>
                let mut r#pi2; // type: ProcessingInstruction // <var name="pi2" type="ProcessingInstruction"/>
                let mut r#pi3; // type: ProcessingInstruction // <var name="pi3" type="ProcessingInstruction"/>
                let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#pi1 = r#doc
                    .create_processing_instruction("Target1", Some("pi"))
                    .unwrap(); // <createProcessingInstruction var="pi1" obj="doc" data="&quot;pi&quot;" target="&quot;Target1&quot;"/>
                r#pi2 = r#doc
                    .create_processing_instruction("Target1", Some("pi"))
                    .unwrap(); // <createProcessingInstruction var="pi2" obj="doc" data="&quot;pi&quot;" target="&quot;Target1&quot;"/>
                r#pi3 = r#doc
                    .create_processing_instruction("Target1", Some("#ProcessingInstruction"))
                    .unwrap(); // <createProcessingInstruction var="pi3" obj="doc" data="&quot;#ProcessingInstruction&quot;" target="&quot;Target1&quot;"/>
                r#is_equal = r#pi1.is_equal_node(&r#pi2.into()); // <isEqualNode var="isEqual" obj="pi1" arg="pi2"/>
                assert!(r#is_equal); // <assertTrue actual="isEqual" id="nodeisequalnodeTrue29"/>
                r#is_equal = r#pi1.is_equal_node(&r#pi3.into()); // <isEqualNode var="isEqual" obj="pi1" arg="pi3"/>
                assert!(!r#is_equal); // <assertFalse actual="isEqual" id="nodeisequalnodeFalse29"/>
            }
            // datatypenormalization08.xml
            #[test]
            fn test_datatypenormalization08() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#str; // type: DOMString // <var name="str" type="DOMString"/>
                // let mut r#can_set_normalization; // type: boolean // <var name="canSetNormalization" type="boolean"/>
                // let mut r#can_set_validate; // type: boolean // <var name="canSetValidate" type="boolean"/>
                // let mut r#can_set_xml_schema; // type: boolean // <var name="canSetXMLSchema" type="boolean"/>
                // let mut r#xsd_ns; // type: DOMString // <var name="xsdNS" type="DOMString" value="&quot;http://www.w3.org/2001/XMLSchema&quot;"/>
                // let mut r#error_monitor; // type: DOMErrorMonitor // <var name="errorMonitor" type="DOMErrorMonitor"/>
                // r#doc = todo!(); // datatype_normalization.xml // <load var="doc" href="datatype_normalization" willBeModified="true"/>

                // // unimplemented: // <domConfig obj="doc" var="domConfig" interface="Document"/>

                // // unimplemented: // <canSetParameter var="canSetNormalization" obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetValidate" obj="domConfig" name="&quot;validate&quot;" value="true"/>

                // // unimplemented: // <canSetParameter var="canSetXMLSchema" obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>

                // // unimplemented: // <if>	<and>		<isTrue value="canSetNormalization"/>		<isTrue value="canSetValidate"/>		<isTrue value="canSetXMLSchema"/>	</and>	<setParameter obj="domConfig" name="&quot;datatype-normalization&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;validate&quot;" value="true"/>	<setParameter obj="domConfig" name="&quot;schema-type&quot;" value="xsdNS"/>	<setParameter obj="domConfig" name="&quot;error-handler&quot;" value="errorMonitor"/>	<normalizeDocument obj="doc"/>	<!--  fail test if normalize had any errors or fatal errors   -->	<assertLowerSeverity obj="errorMonitor" id="normalizeError" severity="SEVERITY_ERROR"/>	<getElementsByTagNameNS var="elemList" obj="doc" namespaceURI="&quot;http://www.w3.org/2001/DOM-Test-Suite/Level-3/datatype_normalization&quot;" localName="&quot;decimal&quot;" interface="Document"/>	<item var="element" obj="elemList" interface="NodeList" index="0"/>	<getAttribute var="str" obj="element" name="&quot;default&quot;"/>	<assertEquals actual="str" expected="&quot;3.1415926&quot;" ignoreCase="false" id="firstValue"/></if>
            }
            // documentadoptnode20.xml
            #[test]
            fn test_documentadoptnode20() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#notation_map; // type: NamedNodeMap // <var name="notationMap" type="NamedNodeMap"/>
                // let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                // let mut r#adopted_notation; // type: Node // <var name="adoptedNotation" type="Node"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <notations var="notationMap" obj="docType"/>
                // r#notation = r#notation_map.get_named_item("notation2".into()).unwrap();
                // // <getNamedItem var="notation" obj="notationMap" name="&quot;notation2&quot;"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR"><NO_MODIFICATION_ALLOWED_ERR><adoptNode var="adoptedNotation" obj="newDoc" source="notation"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // documentadoptnode09.xml
            #[test]
            fn test_documentadoptnode09() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#adopted_doc; // type: Node // <var name="adoptedDoc" type="Node"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_SUPPORTED_ERR"><NOT_SUPPORTED_ERR><adoptNode var="adoptedDoc" obj="newDoc" source="doc"/></NOT_SUPPORTED_ERR></assertDOMException>
            }
            // domimplementationregistry01.xml
            #[test]
            fn test_domimplementationregistry01() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>
            }
            // nodeisequalnode16.xml
            #[test]
            fn test_nodeisequalnode16() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attr1; // type: Attr // <var name="attr1" type="Attr"/>
                let mut r#attr2; // type: Attr // <var name="attr2" type="Attr"/>
                let mut r#addr_element; // type: Element // <var name="addrElement" type="Element"/>
                let mut r#element_list; // type: NodeList // <var name="elementList" type="NodeList"/>
                let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                let mut r#null_nsuri; // type: DOMString // <var name="nullNSURI" type="DOMString" isNull="true"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#element_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elementList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#addr_element = r#element_list.item(3).unwrap(); // <item var="addrElement" obj="elementList" index="3" interface="NodeList"/>
                r#attr1 = r#addr_element
                    .get_attribute_node_ns(Some(r#null_nsuri), "dir")
                    .unwrap()
                    .unwrap(); // <getAttributeNodeNS obj="addrElement" var="attr1" namespaceURI="nullNSURI" localName="&quot;dir&quot;"/>
                r#attr2 = r#attr1.clone_node(true); // <cloneNode var="attr2" obj="attr1" deep="true"/>
                r#is_equal = r#attr1.is_equal_node(&r#attr2); // <isEqualNode var="isEqual" obj="attr1" arg="attr2"/>
                assert!(r#is_equal); // <assertTrue actual="isEqual" id="nodeisequalnode16"/>
            }
            // typeinfoisderivedfrom03.xml
            #[test]
            fn test_typeinfoisderivedfrom03() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#acronym_elem; // type: Element // <var name="acronymElem" type="Element"/>
                // let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_name; // type: DOMString // <var name="elemName" type="DOMString"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym_elem = r#elem_list.item(0).unwrap(); // <item var="acronymElem" obj="elemList" index="0" interface="NodeList"/>
                // r#attr = r#acronym_elem.get_attribute_node("title").unwrap(); // <getAttributeNode var="attr" obj="acronymElem" name="&quot;title&quot;"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="attr" interface="Attr"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "string"); // <assertEquals actual="typeName" expected="&quot;string&quot;" ignoreCase="false" id="nameIsString"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/2001/XMLSchema&quot;" typeNameArg="&quot;anySimpleType&quot;" derivationMethod="15"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromAnySimpleType"/>
            }
            // nodeisequalnode11.xml
            #[test]
            fn test_nodeisequalnode11() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#employee_list; // type: NodeList // <var name="employeeList" type="NodeList"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dup_doc: DocumentRef; // <var name="dupDoc" type="Document"/>
                // let mut r#elem1; // type: Element // <var name="elem1" type="Element"/>
                // let mut r#elem2; // type: Element // <var name="elem2" type="Element"/>
                // let mut r#elem3; // type: Element // <var name="elem3" type="Element"/>
                // let mut r#elem4; // type: Element // <var name="elem4" type="Element"/>
                // let mut r#is_equal; // type: boolean // <var name="isEqual" type="boolean"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#employee_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="employeeList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#elem1 = r#employee_list.item(0).unwrap(); // <item var="elem1" obj="employeeList" index="0" interface="NodeList"/>
                // r#elem2 = r#new_doc.import_node(r#elem1.into(), false).unwrap(); // <importNode var="elem2" obj="newDoc" importedNode="elem1" deep="false"/>
                // r#is_equal = r#elem1.is_equal_node(&r#elem2.into()); // <isEqualNode var="isEqual" obj="elem1" arg="elem2"/>
                // assert!(!r#is_equal); // <assertFalse actual="isEqual" id="nodeisequalnodeFalse11"/>
                // r#elem3 = r#new_doc.import_node(r#elem1.into(), true).unwrap(); // <importNode var="elem3" obj="newDoc" importedNode="elem1" deep="true"/>
                // r#is_equal = r#elem1.is_equal_node(&r#elem3.into()); // <isEqualNode var="isEqual" obj="elem1" arg="elem3"/>

                // // unimplemented: // <if><implementationAttribute name="validating" value="true"/><assertFalse actual="isEqual" id="deepImportNoDTD"/></if>
                // r#dup_doc = todo!(); // hc_staff.xml // <load var="dupDoc" href="hc_staff" willBeModified="true"/>
                // r#elem4 = r#dup_doc.import_node(r#elem1.into(), true).unwrap(); // <importNode var="elem4" obj="dupDoc" importedNode="elem1" deep="true"/>
                // r#is_equal = r#elem1.is_equal_node(&r#elem4.into()); // <isEqualNode var="isEqual" obj="elem1" arg="elem4"/>
                // assert!(r#is_equal); // <assertTrue actual="isEqual" id="deepImportSameDTD"/>
            }
            // nodeissamenode09.xml
            #[test]
            fn test_nodeissamenode09() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#entity; // type: Entity // <var name="entity" type="Entity"/>
                // let mut r#is_same; // type: boolean // <var name="isSame" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#entity = r#entities_map.get_named_item("alpha".into()).unwrap(); // <getNamedItem var="entity" obj="entitiesMap" name="&quot;alpha&quot;"/>
                // // <isSameNode var="isSame" obj="docType" other="entity"/>
                // assert!(!r#is_same); // <assertFalse actual="isSame" id="nodeissamenode09"/>
            }
            // noderemovechild19.xml
            #[test]
            fn test_noderemovechild19() {
                // // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#parent_list; // type: NodeList // <var name="parentList" type="NodeList"/>
                // let mut r#parent; // type: Element // <var name="parent" type="Element"/>
                // let mut r#child; // type: EntityReference // <var name="child" type="EntityReference"/>
                // let mut r#removed; // type: EntityReference // <var name="removed" type="EntityReference"/>
                // let mut r#removed_name; // type: DOMString // <var name="removedName" type="DOMString"/>
                // let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                // let mut r#ent_ref_child; // type: Node // <var name="entRefChild" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#parent_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="parentList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#parent = r#parent_list[1].clone(); // <item var="parent" obj="parentList" index="1" interface="NodeList"/>
                // r#child = r#parent.first_child().unwrap(); // <firstChild var="child" obj="parent" interface="Node"/>
                // r#removed = r#parent.remove_child(child.into()).unwrap(); // <removeChild var="removed" obj="parent" oldChild="child"/>
                // r#removed_name = r#removed.node_name().to_string(); // <nodeName obj="removed" var="removedName"/>
                // assert_eq!(r#removed_name, "beta"); // <assertEquals actual="removedName" expected="&quot;beta&quot;" id="noderemovechild19" ignoreCase="false"/>

                // // unimplemented: // <try>	<removeChild obj="child" var="removedNode" oldChild="parent"/>	<fail id="throw_DOMException"/>	<catch>		<DOMException code="NO_MODIFICATION_ALLOWED_ERR"/>		<DOMException code="NOT_FOUND_ERR"/>	</catch></try>
                // r#ent_ref_child = r#child.first_child().unwrap(); // <firstChild var="entRefChild" obj="child" interface="Node"/>

                // // unimplemented: // <if>    <!-- entity may not be resolved if validating is false  -->	<notNull obj="entRefChild"/>	<assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">		<NO_MODIFICATION_ALLOWED_ERR>			<removeChild obj="child" var="removedNode" oldChild="entRefChild"/>		</NO_MODIFICATION_ALLOWED_ERR>	</assertDOMException></if>
            }
            // nodegetfeature08.xml
            #[test]
            fn test_nodegetfeature08() {
                // // unimplemented: // <hasFeature feature="&quot;XML&quot;"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#node; // type: Node // <var name="node" type="Node"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>
                // let mut r#feature_impl; // type: Node // <var name="featureImpl" type="Node"/>
                // let mut r#is_supported; // type: boolean // <var name="isSupported" type="boolean"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>
                // r#node = r#doc
                //     .create_processing_instruction("test-pi", Some("foo"))
                //     .unwrap(); // <createProcessingInstruction var="node" obj="doc" target="&quot;test-pi&quot;" data="&quot;foo&quot;"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Core&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="coreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="cOrEUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;+cOrE&quot;" version="nullVersion"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="PlusCoreUnspecifiedVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;org.w3c.domts.bogus.feature&quot;" version="nullVersion"/>

                // // unimplemented: // <assertNull actual="featureImpl" id="unrecognizedFeature"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;2.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core20"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;cOrE&quot;" version="&quot;3.0&quot;"/>

                // // unimplemented: // <assertSame actual="featureImpl" expected="node" id="Core30"/>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="SVGUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="HTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;Events&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="EventsUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;LS-Async&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="LSAsyncUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;XPath&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertSame actual="featureImpl" expected="node" id="XPathUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;HTML&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusHTMLUnspecified"/></if>

                // // unimplemented: // <isSupported var="isSupported" obj="node" feature="&quot;+SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <getFeature interface="Node" var="featureImpl" obj="node" feature="&quot;SVG&quot;" version="nullVersion"/>

                // // unimplemented: // <if><isTrue value="isSupported"/><assertNotNull actual="featureImpl" id="PlusSVGUnspecified"/></if>
            }
            // nodegetbaseuri01.xml
            #[test]
            fn test_nodegetbaseuri01() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#base_uri; // type: DOMString // <var name="baseURI" type="DOMString"/>
                let mut r#document_uri; // type: DOMString // <var name="documentURI" type="DOMString"/>
                r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>
                r#base_uri = r#doc.base_uri().unwrap().to_string(); // <baseURI var="baseURI" obj="doc" interface="Node"/>

                // unimplemented: // <assertURIEquals actual="baseURI" name="&quot;barfoo&quot;" isAbsolute="true" id="notNull"/>
                r#document_uri = r#doc.document_uri().unwrap().to_string(); // <documentURI var="documentURI" obj="doc"/>
                assert_eq!(r#base_uri, document_uri); // <assertEquals actual="baseURI" expected="documentURI" ignoreCase="false" id="sameAsDocumentURI"/>
            }
            // nodereplacechild28.xml
            #[test]
            fn test_nodereplacechild28() {
                // // unimplemented: // <implementationAttribute name="expandEntityReferences" value="false"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#acronym; // type: Element // <var name="acronym" type="Element"/>
                // let mut r#beta_ref; // type: EntityReference // <var name="betaRef" type="EntityReference"/>
                // let mut r#dallas; // type: Text // <var name="dallas" type="Text"/>
                // let mut r#beta_text; // type: Node // <var name="betaText" type="Node"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#replaced_child; // type: Node // <var name="replacedChild" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#child_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                // r#acronym = r#child_list.item(1).unwrap().clone(); // <item var="acronym" obj="childList" index="1" interface="NodeList"/>
                // r#beta_ref = r#acronym.first_child().unwrap(); // <firstChild var="betaRef" obj="acronym" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="betaRef" id="betaRefNotNull"/>
                // r#beta_text = r#beta_ref.first_child().unwrap(); // <firstChild var="betaText" obj="betaRef" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="betaText" id="betaTextNotNull"/>
                // r#dallas = r#beta_ref.next_sibling().unwrap(); // <nextSibling var="dallas" obj="betaRef" interface="Node"/>

                // // unimplemented: // <assertNotNull actual="dallas" id="dallasNotNull"/>

                // // unimplemented: // <assertDOMException id="throw_NO_MODIFICATION_ALLOWED_ERR">	<NO_MODIFICATION_ALLOWED_ERR>		<replaceChild obj="acronym" var="replacedChild" oldChild="dallas" newChild="betaText"/>	</NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // typeinfoisderivedfrom72.xml
            #[test]
            fn test_typeinfoisderivedfrom72() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>

                // // unimplemented: // <implementationAttribute name="validating" value="true"/>

                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_type_info; // type: TypeInfo // <var name="elemTypeInfo" type="TypeInfo"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#ret_value; // type: boolean // <var name="retValue" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("code"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;code&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="elemTypeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <isDerivedFrom obj="elemTypeInfo" var="retValue" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;field&quot;" derivationMethod="12"/>
                // assert!(!r#ret_value); // <assertFalse actual="retValue" id="isDerived"/>
            }
            // noderemovechild01.xml
            #[test]
            fn test_noderemovechild01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#removed; // type: Node // <var name="removed" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>

                // // unimplemented: // <assertDOMException id="NOT_FOUND_ERR_noderemovechild01"><NOT_FOUND_ERR><removeChild obj="doc" var="removed" oldChild="doc"/></NOT_FOUND_ERR></assertDOMException>
            }
            // nodereplacechild37.xml
            #[test]
            fn test_nodereplacechild37() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc2: DocumentRef; // <var name="doc2" type="Document"/>
                // let mut r#parent; // type: Attr // <var name="parent" type="Attr"/>
                // let mut r#old_child; // type: Text // <var name="oldChild" type="Text"/>
                // let mut r#new_child; // type: EntityReference // <var name="newChild" type="EntityReference"/>
                // let mut r#node_value; // type: DOMString // <var name="nodeValue" type="DOMString"/>
                // let mut r#replaced; // type: Node // <var name="replaced" type="Node"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc2 = todo!(); // hc_staff.xml // <load var="doc2" href="hc_staff" willBeModified="true"/>
                // r#parent = r#doc
                //     .create_attribute_ns(
                //         Some("http://www.w3.org/XML/1998/namespace"),
                //         "xml:lang".as_ref(),
                //     )
                //     .unwrap(); // <createAttributeNS var="parent" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>
                // r#old_child = r#doc.create_text_node("Text"); // <createTextNode var="oldChild" obj="doc" data="&quot;Text&quot;"/>
                // r#new_child = r#doc2.create_entity_reference("delta".to_string()).unwrap(); // <createEntityReference var="newChild" obj="doc2" name="&quot;delta&quot;"/>
                // r#appended_child = r#parent.append_child(old_child.into()).unwrap();
                // // <appendChild obj="parent" var="appendedChild" newChild="oldChild"/>

                // // unimplemented: // <assertDOMException id="throw_WRONG_DOCUMENT_ERR"><WRONG_DOCUMENT_ERR><replaceChild obj="parent" var="replaced" oldChild="oldChild" newChild="newChild"/></WRONG_DOCUMENT_ERR></assertDOMException>
            }
            // nodelookupnamespaceuri06.xml
            #[test]
            fn test_nodelookupnamespaceuri06() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#namespace_uri; // type: DOMString // <var name="namespaceURI" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#elem = r#elem_list.item(2).unwrap(); // <item var="elem" obj="elemList" index="2" interface="NodeList"/>
                r#namespace_uri = r#elem.lookup_namespace_uri("dmstc").unwrap().to_string(); // <lookupNamespaceURI var="namespaceURI" obj="elem" prefix="&quot;dmstc&quot;" interface="Node"/>
                assert_eq!(r#namespace_uri, "http://www.netzero.com"); // <assertEquals actual="namespaceURI" expected="&quot;http://www.netzero.com&quot;" id="nodelookupnamespaceuri06" ignoreCase="false"/>
            }
            // domimplementationregistry07.xml
            #[test]
            fn test_domimplementationregistry07() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#has_feature; // type: boolean // <var name="hasFeature" type="boolean"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementation var="domImpl" obj="domImplRegistry" features="&quot;http://www.example.com/bogus-feature 99.0&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <assertNull actual="domImpl" id="domImplNull"/>
            }
            // noderemovechild20.xml
            #[test]
            fn test_noderemovechild20() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#parent_list; // type: NodeList // <var name="parentList" type="NodeList"/>
                // let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                // let mut r#parent; // type: Element // <var name="parent" type="Element"/>
                // let mut r#child; // type: Element // <var name="child" type="Element"/>
                // let mut r#cloned_child; // type: Element // <var name="clonedChild" type="Element"/>
                // let mut r#removed; // type: Element // <var name="removed" type="Element"/>
                // let mut r#removed_name; // type: DOMString // <var name="removedName" type="DOMString"/>
                // let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                // let mut r#removed_node; // type: Node // <var name="removedNode" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#parent_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="parentList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                // r#parent = r#parent_list[0].clone(); // <item var="parent" obj="parentList" index="0" interface="NodeList"/>
                // r#child = r#doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "dom3:br".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="child" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;dom3:br&quot;"/>
                // r#appended_child = r#parent.append_child(child.into()).unwrap(); // <appendChild obj="parent" var="appendedChild" newChild="child"/>
                // r#removed = r#parent.remove_child(child.into()).unwrap(); // <removeChild var="removed" obj="parent" oldChild="child"/>
                // r#removed_name = r#removed.node_name().to_string(); // <nodeName obj="removed" var="removedName"/>
                // assert_eq!(r#removed_name, "dom3:br"); // <assertEquals actual="removedName" expected="&quot;dom3:br&quot;" id="noderemovechild20" ignoreCase="false"/>
                // r#cloned_child = r#child.clone_node(true); // <cloneNode var="clonedChild" obj="child" deep="true"/>

                // // unimplemented: // <assertDOMException id="throw_NOT_FOUND_ERR">	<NOT_FOUND_ERR>		<removeChild obj="parent" var="removedNode" oldChild="clonedChild"/>	</NOT_FOUND_ERR>	</assertDOMException>
            }
            // nodelookupprefix17.xml
            #[test]
            fn test_nodelookupprefix17() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#attributes_map; // type: NamedNodeMap // <var name="attributesMap" type="NamedNodeMap"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#prefix; // type: DOMString // <var name="prefix" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#elem = r#elem_list.item(2).unwrap(); // <item var="elem" obj="elemList" index="2" interface="NodeList"/>
                r#attributes_map = r#elem.attributes(); // <attributes var="attributesMap" obj="elem"/>
                r#attr = r#attributes_map
                    .get_named_item("xsi:noNamespaceSchemaLocation")
                    .unwrap(); // <getNamedItem var="attr" obj="attributesMap" name="&quot;xsi:noNamespaceSchemaLocation&quot;"/>
                r#prefix = r#attr
                    .lookup_prefix("http://www.netzero.com")
                    .unwrap()
                    .to_string(); // <lookupPrefix var="prefix" obj="attr" namespaceURI="&quot;http://www.netzero.com&quot;"/>
                assert_eq!(r#prefix, "dmstc"); // <assertEquals actual="prefix" expected="&quot;dmstc&quot;" id="nodelookupprefix17" ignoreCase="false"/>
            }
            // domimplementationregistry14.xml
            #[test]
            fn test_domimplementationregistry14() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#has_feature; // type: boolean // <var name="hasFeature" type="boolean"/>
                // let mut r#dom_impl_list; // type: DOMImplementationList // <var name="domImplList" type="DOMImplementationList"/>
                // let mut r#length; // type: int // <var name="length" type="int"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementationList var="domImplList" obj="domImplRegistry" features="&quot;cOrE 3.0&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <length var="length" obj="domImplList" interface="DOMImplementationList"/>

                // // unimplemented: // <assertTrue id="atLeastOne">	<greater actual="length" expected="0"/></assertTrue>

                // // unimplemented: // <for-each collection="domImplList" member="domImpl">	<hasFeature var="hasFeature" obj="domImpl" feature="&quot;Core&quot;" version="&quot;3.0&quot;"/>	<assertTrue actual="hasFeature" id="hasCore"/></for-each>
            }
            // elementgetschematypeinfo06.xml
            #[test]
            fn test_elementgetschematypeinfo06() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#strong_elem; // type: Element // <var name="strongElem" type="Element"/>
                // let mut r#elem_type_info; // type: TypeInfo // <var name="elemTypeInfo" type="TypeInfo"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // let mut r#type_namespace; // type: DOMString // <var name="typeNamespace" type="DOMString"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#doc_elem_node_name; // type: DOMString // <var name="docElemNodeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("strong"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;strong&quot;" interface="Document"/>
                // r#strong_elem = r#elem_list.item(1).unwrap(); // <item var="strongElem" obj="elemList" index="1" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="elemTypeInfo" obj="strongElem" interface="Element"/>

                // // unimplemented: // <typeName var="typeName" obj="elemTypeInfo"/>

                // // unimplemented: // <typeNamespace var="typeNamespace" obj="elemTypeInfo"/>
                // assert_eq!(r#type_name, "strongType"); // <assertEquals expected="&quot;strongType&quot;" actual="typeName" id="elementgetschematypeinfo06_typeName" ignoreCase="false"/>
                // assert_eq!(r#type_namespace, "http://www.w3.org/1999/xhtml"); // <assertEquals expected="&quot;http://www.w3.org/1999/xhtml&quot;" actual="typeNamespace" id="elementgetschematypeinfo06_typeNamespace" ignoreCase="false"/>
            }
            // noderemovechild27.xml
            #[test]
            fn test_noderemovechild27() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#notations_map; // type: NamedNodeMap // <var name="notationsMap" type="NamedNodeMap"/>
                // let mut r#child; // type: Entity // <var name="child" type="Entity"/>
                // let mut r#parent; // type: Notation // <var name="parent" type="Notation"/>
                // let mut r#removed; // type: Node // <var name="removed" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>

                // // unimplemented: // <notations var="notationsMap" obj="docType"/>
                // r#child = r#entities_map.get_named_item("ent1".into()).unwrap(); // <getNamedItem var="child" interface="NamedNodeMap" obj="entitiesMap" name="&quot;ent1&quot;"/>
                // r#parent = r#notations_map.get_named_item("notation1".into()).unwrap();
                // // <getNamedItem var="parent" interface="NamedNodeMap" obj="notationsMap" name="&quot;notation1&quot;"/>

                // // unimplemented: // <try>        <removeChild obj="parent" var="removed" oldChild="child"/>        <catch>                <DOMException code="NOT_FOUND_ERR"/>                <DOMException code="NO_MODIFICATION_ALLOWED_ERR"/>        </catch></try>
            }
            // typeinfoisderivedfrom16.xml
            #[test]
            fn test_typeinfoisderivedfrom16() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#type_info; // type: TypeInfo // <var name="typeInfo" type="TypeInfo"/>
                // let mut r#is_derived; // type: boolean // <var name="isDerived" type="boolean"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("em"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;em&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="typeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <assertNotNull actual="typeInfo" id="typeInfoNotNull"/>

                // // unimplemented: // <typeName var="typeName" obj="typeInfo"/>
                // assert_eq!(r#type_name, "emType"); // <assertEquals actual="typeName" expected="&quot;emType&quot;" ignoreCase="false" id="name"/>

                // // unimplemented: // <isDerivedFrom var="isDerived" obj="typeInfo" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;emp0001_3Type&quot;" derivationMethod="4"/>
                // assert!(r#is_derived); // <assertTrue actual="isDerived" id="derivedFromEmp13Union"/>
            }
            // documentadoptnode25.xml
            #[test]
            fn test_documentadoptnode25() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_elem; // type: Element // <var name="newElem" type="Element"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#adopted_node; // type: Node // <var name="adoptedNode" type="Node"/>
                // let mut r#adopted_name; // type: DOMString // <var name="adoptedName" type="DOMString"/>
                // let mut r#adopted_ns; // type: DOMString // <var name="adoptedNS" type="DOMString"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>
                // r#new_elem = r#doc
                //     .create_element_ns(Some("http://www.w3.org/1999/xhtml"), "th".as_ref())
                //     .unwrap(); // <createElementNS var="newElem" obj="doc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;th&quot;"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#adopted_node = r#new_doc.adopt_node(r#new_elem.into()); // <adoptNode var="adoptedNode" obj="newDoc" source="newElem"/>

                // // unimplemented: // <if><notNull obj="adoptedNode"/><nodeName var="adoptedName" obj="adoptedNode"/><namespaceURI var="adoptedNS" obj="adoptedNode" interface="Node"/><assertEquals actual="adoptedName" expected="&quot;th&quot;" id="documentadoptnode25_1" ignoreCase="false"/><assertEquals actual="adoptedNS" expected="&quot;http://www.w3.org/1999/xhtml&quot;" id="documentadoptnode25_2" ignoreCase="false"/></if>
            }
            // documentrenamenode18.xml
            #[test]
            fn test_documentrenamenode18() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#element; // type: Element // <var name="element" type="Element"/>
                // let mut r#renamed_node; // type: Node // <var name="renamedNode" type="Node"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_tagname; // type: DOMString // <var name="rootTagname" type="DOMString"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="true"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_tagname = r#doc_elem.tag_name().to_string(); // <tagName var="rootTagname" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootTagname" doctype="nullDocType"/>
                // r#element = r#new_doc
                //     .create_element_ns(
                //         Some("http://www.w3.org/1999/xhtml"),
                //         "body".as_ref(),
                //     )
                //     .unwrap(); // <createElementNS var="element" obj="newDoc" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;body&quot;"/>

                // // unimplemented: // <assertDOMException id="documentrenamenode18_WRONG_DOCUMENT_ERR"><WRONG_DOCUMENT_ERR><renameNode var="renamedNode" obj="doc" n="element" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;head&quot;"/></WRONG_DOCUMENT_ERR></assertDOMException>
            }
            // nodecomparedocumentposition39.xml
            #[test]
            fn test_nodecomparedocumentposition39() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#attr1; // type: Attr // <var name="attr1" type="Attr"/>
                let mut r#attr2; // type: Attr // <var name="attr2" type="Attr"/>
                let mut r#attr_position; // type: int // <var name="attrPosition" type="int"/>
                let mut r#swapped_position; // type: int // <var name="swappedPosition" type="int"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#elem_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#elem = r#elem_list.item(3).unwrap(); // <item var="elem" obj="elemList" index="3" interface="NodeList"/>
                r#attr1 = r#elem.get_attribute_node("class").unwrap(); // <getAttributeNode var="attr1" obj="elem" name="&quot;class&quot;"/>
                r#attr2 = r#elem
                    .get_attribute_node("xsi:noNamespaceSchemaLocation")
                    .unwrap(); // <getAttributeNode var="attr2" obj="elem" name="&quot;xsi:noNamespaceSchemaLocation&quot;"/>
                r#attr_position = r#attr1.compare_document_position(&r#attr2.into()); // <compareDocumentPosition var="attrPosition" obj="attr1" other="attr2"/>
                assert_eq!(u16::from(r#attr_position), 32); // <assertEquals actual="attrPosition" expected="32" bitmask="32" id="isImplementationSpecific" ignoreCase="false"/>
                assert_eq!(u16::from(r#attr_position), 0); // <assertEquals actual="attrPosition" expected="0" bitmask="25" id="otherBitsZero" ignoreCase="false"/>

                // unimplemented: // <assertNotEquals actual="attrPosition" expected="0" bitmask="6" id="eitherFollowingOrPreceding" ignoreCase="false"/>
                r#swapped_position = r#attr2.compare_document_position(&r#attr1.into());
                // <compareDocumentPosition var="swappedPosition" obj="attr2" other="attr1"/>

                // unimplemented: // <assertNotEquals actual="attrPosition" expected="swappedPosition" bitmask="2" id="onlyOnePreceding" ignoreCase="false"/>

                // unimplemented: // <assertNotEquals actual="attrPosition" expected="swappedPosition" bitmask="4" id="onlyOneFollowing" ignoreCase="false"/>
            }
            // domimplementationregistry02.xml
            #[test]
            fn test_domimplementationregistry02() {
                // let mut r#dom_impl_registry; // type: DOMImplementationRegistry // <var name="domImplRegistry" type="DOMImplementationRegistry"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#has_feature; // type: boolean // <var name="hasFeature" type="boolean"/>
                // let mut r#null_version; // type: DOMString // <var name="nullVersion" type="DOMString" isNull="true"/>

                // // unimplemented: // <DOMImplementationRegistry.newInstance var="domImplRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImplRegistry" id="domImplRegistryNotNull"/>

                // // unimplemented: // <getDOMImplementation var="domImpl" obj="domImplRegistry" features="&quot;cOrE&quot;" interface="DOMImplementationRegistry"/>

                // // unimplemented: // <assertNotNull actual="domImpl" id="domImplNotNull"/>

                // // unimplemented: // <hasFeature var="hasFeature" obj="domImpl" feature="&quot;Core&quot;" version="nullVersion"/>
                // assert!(r#has_feature); // <assertTrue actual="hasFeature" id="hasCore"/>
            }
            // documentgetdocumenturi02.xml
            #[test]
            fn test_documentgetdocumenturi02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#doc_uri; // type: DOMString // <var name="docURI" type="DOMString"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#doc_uri = r#new_doc.document_uri().unwrap().to_string(); // <documentURI var="docURI" obj="newDoc"/>

                // // unimplemented: // <assertNull actual="docURI" id="documentgetdocumenturi02"/>
            }
            // nodegetbaseuri02.xml
            #[test]
            fn test_nodegetbaseuri02() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#new_doc: DocumentRef; // <var name="newDoc" type="Document"/>
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#base_uri; // type: DOMString // <var name="baseURI" type="DOMString"/>
                // let mut r#root_ns; // type: DOMString // <var name="rootNS" type="DOMString"/>
                // let mut r#root_name; // type: DOMString // <var name="rootName" type="DOMString"/>
                // let mut r#doc_elem; // type: Element // <var name="docElem" type="Element"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // r#doc = todo!(); // barfoo.xml // <load var="doc" href="barfoo" willBeModified="false"/>
                // r#doc_elem = r#doc.document_element().unwrap(); // <documentElement var="docElem" obj="doc"/>
                // r#root_ns = r#doc_elem.namespace_uri().unwrap().to_string(); // <namespaceURI var="rootNS" obj="docElem" interface="Node"/>
                // r#root_name = r#doc_elem.tag_name().to_string(); // <tagName var="rootName" obj="docElem"/>

                // // unimplemented: // <implementation var="domImpl" obj="doc"/>

                // // unimplemented: // <createDocument var="newDoc" obj="domImpl" namespaceURI="rootNS" qualifiedName="rootName" doctype="nullDocType"/>
                // r#base_uri = r#new_doc.base_uri().unwrap().to_string(); // <baseURI var="baseURI" obj="newDoc" interface="Node"/>

                // // unimplemented: // <assertNull actual="baseURI" id="baseURIIsNull"/>
                // r#new_doc
                //     .set_document_uri("http://www.example.com/sample.xml")
                //     .unwrap(); // <documentURI obj="newDoc" value="&quot;http://www.example.com/sample.xml&quot;"/>
                // r#base_uri = r#new_doc.base_uri().unwrap().to_string(); // <baseURI var="baseURI" obj="newDoc" interface="Node"/>
                // assert_eq!(r#base_uri, "http://www.example.com/sample.xml"); // <assertEquals expected="&quot;http://www.example.com/sample.xml&quot;" actual="baseURI" ignoreCase="true" id="baseURISameAsDocURI"/>
            }
            // nodeissamenode06.xml
            #[test]
            fn test_nodeissamenode06() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#element; // type: Element // <var name="element" type="Element"/>
                let mut r#element1; // type: Element // <var name="element1" type="Element"/>
                let mut r#attr1; // type: Attr // <var name="attr1" type="Attr"/>
                let mut r#attr2; // type: Attr // <var name="attr2" type="Attr"/>
                let mut r#child_list; // type: NodeList // <var name="childList" type="NodeList"/>
                let mut r#is_same; // type: boolean // <var name="isSame" type="boolean"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#child_list = r#doc.get_elements_by_tag_name("acronym"); // <getElementsByTagName var="childList" obj="doc" tagname="&quot;acronym&quot;" interface="Document"/>
                r#element = r#child_list.item(2).unwrap(); // <item var="element" obj="childList" index="2" interface="NodeList"/>
                r#element1 = r#child_list.item(2).unwrap(); // <item var="element1" obj="childList" index="2" interface="NodeList"/>
                r#attr1 = r#element.get_attribute_node("class").unwrap(); // <getAttributeNode var="attr1" obj="element" name="&quot;class&quot;"/>
                r#attr2 = r#element1.get_attribute_node("class").unwrap(); // <getAttributeNode var="attr2" obj="element1" name="&quot;class&quot;"/>
                is_same = attr1.is_same_node(&attr2.into()); // <isSameNode var="isSame" obj="attr1" other="attr2"/>
                assert!(r#is_same); // <assertTrue actual="isSame" id="nodeissamenode06"/>
            }
            // nodereplacechild21.xml
            #[test]
            fn test_nodereplacechild21() {
                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#doc_type; // type: DocumentType // <var name="docType" type="DocumentType"/>
                // let mut r#entities_map; // type: NamedNodeMap // <var name="entitiesMap" type="NamedNodeMap"/>
                // let mut r#ent; // type: Entity // <var name="ent" type="Entity"/>
                // let mut r#doc1: DocumentRef; // <var name="doc1" type="Document"/>
                // let mut r#doc_type1; // type: DocumentType // <var name="docType1" type="DocumentType"/>
                // let mut r#notations_map; // type: NamedNodeMap // <var name="notationsMap" type="NamedNodeMap"/>
                // let mut r#notation; // type: Notation // <var name="notation" type="Notation"/>
                // let mut r#replaced_child; // type: Node // <var name="replacedChild" type="Node"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#doc_type = r#doc.doctype().unwrap(); // <doctype var="docType" obj="doc"/>

                // // unimplemented: // <entities var="entitiesMap" obj="docType"/>
                // r#ent = r#entities_map.get_named_item("alpha".into()).unwrap(); // <getNamedItem var="ent" obj="entitiesMap" name="&quot;alpha&quot;"/>
                // r#doc1 = todo!(); // hc_staff.xml // <load var="doc1" href="hc_staff" willBeModified="false"/>
                // r#doc_type1 = r#doc1.doctype().unwrap(); // <doctype var="docType1" obj="doc1"/>

                // // unimplemented: // <notations var="notationsMap" obj="docType1"/>
                // r#notation = r#notations_map.get_named_item("notation1".into()).unwrap();
                // // <getNamedItem var="notation" obj="notationsMap" name="&quot;notation1&quot;"/>

                // // unimplemented: // <assertDOMException id="NO_MODIFICATION_ALLOWED_ERR1_nodereplacechild21"><NO_MODIFICATION_ALLOWED_ERR><replaceChild obj="docType" var="replacedChild" oldChild="ent" newChild="notation"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>

                // // unimplemented: // <assertDOMException id="NO_MODIFICATION_ALLOWED_ERR2_nodereplacechild21"><NO_MODIFICATION_ALLOWED_ERR><replaceChild obj="docType" var="replacedChild" oldChild="docType" newChild="ent"/></NO_MODIFICATION_ALLOWED_ERR></assertDOMException>
            }
            // domconfigvalidate1.xml
            #[test]
            fn test_domconfigvalidate1() {
                // let mut r#dom_impl; // type: DOMImplementation // <var name="domImpl" type="DOMImplementation"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#dom_config; // type: DOMConfiguration // <var name="domConfig" type="DOMConfiguration"/>
                // let mut r#null_doc_type; // type: DocumentType // <var name="nullDocType" type="DocumentType" isNull="true"/>
                // let mut r#can_set; // type: boolean // <var name="canSet" type="boolean"/>
                // let mut r#state; // type: boolean // <var name="state" type="boolean"/>
                // let mut r#parameter; // type: DOMString // <var name="parameter" type="DOMString" value="&quot;vAlIdate&quot;"/>

                // // unimplemented: // <implementation var="domImpl"/>

                // // unimplemented: // <createDocument var="doc" obj="domImpl" namespaceURI="&quot;http://www.w3.org/1999/xhtml&quot;" qualifiedName="&quot;html&quot;" doctype="nullDocType"/>

                // // unimplemented: // <domConfig var="domConfig" obj="doc" interface="Document"/>

                // // unimplemented: // <getParameter var="state" obj="domConfig" name="parameter"/>
                // assert!(!r#state); // <assertFalse actual="state" id="defaultFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="false"/>
                // assert!(r#can_set); // <assertTrue actual="canSet" id="canSetFalse"/>

                // // unimplemented: // <canSetParameter var="canSet" obj="domConfig" name="parameter" value="true"/>

                // // unimplemented: // <if>  	  <isTrue value="canSet"/>  	  <setParameter obj="domConfig" name="parameter" value="true"/>  	  <getParameter var="state" obj="domConfig" name="parameter"/>  	  <assertTrue actual="state" id="setTrueEffective"/>  	  <else>  	  	  <assertDOMException id="throw_NOT_SUPPORTED_ERR">  	  	  	<NOT_SUPPORTED_ERR>  	  			<setParameter obj="domConfig" name="parameter" value="true"/>  	  		</NOT_SUPPORTED_ERR>  	  	  </assertDOMException>  	  	  <!--  should still be false after failed attempt  -->  	  	  <getParameter var="state" obj="domConfig" name="parameter"/>  	      <assertFalse actual="state" id="setTrueNotEffective"/>  	  </else>  </if>

                // // unimplemented: // <setParameter obj="domConfig" name="parameter" value="false"/>
            }
            // nodesettextcontent05.xml
            #[test]
            fn test_nodesettextcontent05() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#text_content; // type: DOMString // <var name="textContent" type="DOMString"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="true"/>
                r#elem_list = r#doc.get_elements_by_tag_name("p"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;p&quot;" interface="Document"/>
                r#elem = r#elem_list.item(3).unwrap(); // <item var="elem" obj="elemList" index="3" interface="NodeList"/>
                r#attr = r#elem.get_attribute_node("dir").unwrap(); // <getAttributeNode var="attr" obj="elem" name="&quot;dir&quot;"/>
                r#attr.set_text_content("NA").unwrap(); // <textContent obj="attr" value="&quot;NA&quot;"/>
                r#text_content = r#attr.text_content().unwrap(); // <textContent var="textContent" obj="attr"/>
                assert_eq!(r#text_content, "NA"); // <assertEquals actual="textContent" expected="&quot;NA&quot;" id="nodesettextcontent05" ignoreCase="false"/>
            }
            // attrisid06.xml
            #[test]
            fn test_attrisid06() {
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#attr; // type: Attr // <var name="attr" type="Attr"/>
                let mut r#id; // type: boolean // <var name="id" type="boolean" value="false"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#attr = r#doc
                    .create_attribute_ns(
                        Some("http://www.w3.org/XML/1998/namespace"),
                        "xml:lang".as_ref(),
                    )
                    .unwrap(); // <createAttributeNS var="attr" obj="doc" namespaceURI="&quot;http://www.w3.org/XML/1998/namespace&quot;" qualifiedName="&quot;xml:lang&quot;"/>
                r#id = r#attr.is_id(); // <isId var="id" obj="attr"/>
                assert!(!r#id); // <assertFalse actual="id" id="AttrIsIDFalse06"/>
            }
            // nodeinsertbefore09.xml
            #[test]
            fn test_nodeinsertbefore09() {
                // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                let mut r#doc_frag; // type: DocumentFragment // <var name="docFrag" type="DocumentFragment"/>
                let mut r#new_comment; // type: Comment // <var name="newComment" type="Comment"/>
                let mut r#insert_comment; // type: Comment // <var name="insertComment" type="Comment"/>
                let mut r#comment; // type: Comment // <var name="comment" type="Comment"/>
                let mut r#inserted; // type: DocumentFragment // <var name="inserted" type="DocumentFragment"/>
                let mut r#data; // type: DOMString // <var name="data" type="DOMString"/>
                let mut r#appended_child; // type: Node // <var name="appendedChild" type="Node"/>
                r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                r#new_comment = r#doc.create_comment("Comment"); // <createComment var="newComment" obj="doc" data="&quot;Comment&quot;"/>
                r#appended_child = r#doc.append_child(new_comment.into()).unwrap(); // <appendChild obj="doc" var="appendedChild" newChild="newComment"/>
                r#doc_frag = r#doc.create_document_fragment(); // <createDocumentFragment var="docFrag" obj="doc"/>
                r#insert_comment = r#doc.create_comment("insertComment"); // <createComment var="insertComment" obj="doc" data="&quot;insertComment&quot;"/>
                r#appended_child = r#doc_frag.append_child(insert_comment.into()).unwrap(); // <appendChild obj="docFrag" var="appendedChild" newChild="insertComment"/>
                r#inserted = r#doc
                    .insert_before(doc_frag.into(), Some(new_comment.into()))
                    .unwrap(); // <insertBefore var="inserted" obj="doc" newChild="docFrag" refChild="newComment"/>
                r#comment = r#new_comment
                    .previous_sibling()
                    .unwrap()
                    .as_comment()
                    .unwrap(); // <previousSibling var="comment" obj="newComment" interface="Node"/>
                r#data = r#comment.data().to_string(); // <data var="data" obj="comment" interface="CharacterData"/>
                assert_eq!(r#data, "insertComment"); // <assertEquals actual="data" expected="&quot;insertComment&quot;" id="nodeinsertbefore09" ignoreCase="false"/>
            }
            // typeinfoisderivedfrom67.xml
            #[test]
            fn test_typeinfoisderivedfrom67() {
                // // unimplemented: // <implementationAttribute name="schemaValidating" value="true"/>

                // // unimplemented: // <implementationAttribute name="validating" value="true"/>

                // // unimplemented: // <implementationAttribute name="namespaceAware" value="true"/>
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#elem; // type: Element // <var name="elem" type="Element"/>
                // let mut r#elem_type_info; // type: TypeInfo // <var name="elemTypeInfo" type="TypeInfo"/>
                // let mut r#type_name; // type: DOMString // <var name="typeName" type="DOMString"/>
                // let mut r#elem_list; // type: NodeList // <var name="elemList" type="NodeList"/>
                // let mut r#ret_value; // type: boolean // <var name="retValue" type="boolean"/>
                // r#doc = todo!(); // hc_staff.xml // <load var="doc" href="hc_staff" willBeModified="false"/>
                // r#elem_list = r#doc.get_elements_by_tag_name("sup"); // <getElementsByTagName var="elemList" obj="doc" tagname="&quot;sup&quot;" interface="Document"/>
                // r#elem = r#elem_list.item(0).unwrap(); // <item var="elem" obj="elemList" index="0" interface="NodeList"/>

                // // unimplemented: // <schemaTypeInfo var="elemTypeInfo" obj="elem" interface="Element"/>

                // // unimplemented: // <isDerivedFrom obj="elemTypeInfo" var="retValue" typeNamespaceArg="&quot;http://www.w3.org/1999/xhtml&quot;" typeNameArg="&quot;emp0004_5Type&quot;" derivationMethod="4"/>
                // assert!(r#ret_value); // <assertTrue actual="retValue" id="isDerived"/>
            }
            // documentgetxmlencoding01.xml
            #[test]
            fn test_documentgetxmlencoding01() {
                // let mut r#doc: DocumentRef; // <var name="doc" type="Document"/>
                // let mut r#encoding_name; // type: DOMString // <var name="encodingName" type="DOMString"/>
                // r#doc = todo!(); // barfoo_utf8.xml // <load var="doc" href="barfoo_utf8" willBeModified="false"/>
                // r#encoding_name = r#doc.xml_encoding().unwrap().to_string(); // <xmlEncoding obj="doc" var="encodingName" interface="Document"/>
                // assert_eq!(r#encoding_name, "uTf-8"); // <assertEquals expected="&quot;uTf-8&quot;" actual="encodingName" id="documentgetxmlencoding01" ignoreCase="false"/>
            }
        }
    }
}
