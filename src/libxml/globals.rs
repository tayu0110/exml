//! Provide methods and data structures for global variables.  
//! This module is based on `libxml/globals.h`, `globals.c`, and so on in `libxml2-v2.11.8`.
//!
//! Please refer to original libxml2 documents also.

// Copyright of the original code is the following.
// --------
// Summary: interface for all global variables of the library
// Description: all the global variables and thread handling for
//              those variables is handled by this module.
//
// The bottom of this file is automatically generated by build_glob.py
// based on the description file global.data
//
// Copy: See Copyright for the status of this software.
//
// Author: Gary Pennington <Gary.Pennington@uk.sun.com>, Daniel Veillard
// --------
// globals.c: definition and handling of the set of global variables of the library
//
// The bottom of this file is automatically generated by build_glob.py
// based on the description file global.data
//
// See Copyright for the status of this software.
//
// Gary Pennington <Gary.Pennington@uk.sun.com>
// daniel@veillard.com

use std::ffi::c_void;

use libc::{free, malloc, realloc};

use crate::{
    error::XmlError,
    libxml::xmlmemory::{XmlFreeFunc, XmlMallocFunc, XmlReallocFunc, XmlStrdupFunc},
};

use super::{
    threads::xml_get_global_state,
    xmlstring::{XmlChar, xml_char_strdup},
};

pub type XmlGlobalStatePtr = *mut XmlGlobalState;
pub struct XmlGlobalState {
    // pub(crate) xml_parser_version: *const c_char,
    // pub(crate) xml_default_sax_locator: XmlSAXLocator,
    pub(crate) xml_free: Option<XmlFreeFunc>,
    pub(crate) xml_malloc: Option<XmlMallocFunc>,
    pub(crate) xml_mem_strdup: Option<XmlStrdupFunc>,
    pub(crate) xml_realloc: Option<XmlReallocFunc>,

    // pub(crate) old_xml_wd_compatibility: i32,

    // pub(crate) xml_buffer_alloc_scheme: XmlBufferAllocationScheme,
    // pub(crate) xml_default_buffer_size: i32,

    // pub(crate) xml_substitute_entities_default_value: i32,
    // pub(crate) xml_do_validity_checking_default_value: i32,
    // pub(crate) xml_get_warnings_default_value: i32,
    // pub(crate) xml_keep_blanks_default_value: i32,
    // pub(crate) xml_line_numbers_default_value: i32,
    // pub(crate) xml_load_ext_dtd_default_value: i32,
    // pub(crate) xml_parser_debug_entities: i32,
    // pub(crate) xml_pedantic_parser_default_value: i32,

    // pub(crate) xml_indent_tree_output: i32,
    // pub(crate) xml_malloc_atomic: Option<XmlMallocFunc>,
    pub(crate) xml_last_error: XmlError,
    // pub(crate) xml_structured_error_context: AtomicPtr<c_void>,
}

/// The variable holding the libxml malloc() implementation
///
/// Returns a pointer to the newly allocated block or NULL in case of error
#[doc(alias = "xmlMalloc")]
pub(in crate::libxml) static mut _XML_MALLOC: Option<XmlMallocFunc> = Some(malloc);
pub unsafe extern "C" fn xml_malloc(size: usize) -> *mut c_void {
    unsafe { _XML_MALLOC.expect("Failed to allocate memory : _XML_MALLOC is None")(size) }
}

pub fn set_xml_malloc(malloc: Option<XmlMallocFunc>) {
    unsafe {
        _XML_MALLOC = malloc;
        (*xml_get_global_state()).xml_malloc = malloc;
    }
}
/// The variable holding the libxml malloc() implementation for atomic
/// data (i.e. blocks not containing pointers), useful when using a
/// garbage collecting allocator.
///
/// Returns a pointer to the newly allocated block or NULL in case of error
#[doc(alias = "xmlMallocAtomic")]
pub(in crate::libxml) static mut _XML_MALLOC_ATOMIC: XmlMallocFunc = malloc;
pub unsafe extern "C" fn xml_malloc_atomic(size: usize) -> *mut c_void {
    unsafe { _XML_MALLOC_ATOMIC(size) }
}
/// The variable holding the libxml realloc() implementation
///
/// Returns a pointer to the newly reallocated block or NULL in case of error
#[doc(alias = "xmlRealloc")]
pub(in crate::libxml) static mut _XML_REALLOC: Option<XmlReallocFunc> = Some(realloc);
pub unsafe extern "C" fn xml_realloc(mem: *mut c_void, size: usize) -> *mut c_void {
    unsafe { _XML_REALLOC.expect("Failed to reallocate memory : _XML_REALLOC is None")(mem, size) }
}
pub fn set_xml_realloc(realloc: Option<XmlReallocFunc>) {
    unsafe {
        _XML_REALLOC = realloc;
        (*xml_get_global_state()).xml_realloc = realloc;
    }
}
/// The variable holding the libxml free() implementation
#[doc(alias = "xmlFree")]
pub(in crate::libxml) static mut _XML_FREE: Option<XmlFreeFunc> = Some(free);
pub unsafe extern "C" fn xml_free(mem: *mut c_void) {
    unsafe {
        _XML_FREE.expect("Failed to deallocate memory : _XML_FREE is None")(mem);
    }
}
pub fn set_xml_free(free: Option<XmlFreeFunc>) {
    unsafe {
        _XML_FREE = free;
        (*xml_get_global_state()).xml_free = free;
    }
}

/// a strdup implementation with a type signature matching POSIX
///
/// Returns a new xmlChar * or NULL
#[doc(alias = "xmlPosixStrdup")]
unsafe extern "C" fn xml_posix_strdup(cur: *const XmlChar) -> *mut XmlChar {
    unsafe { xml_char_strdup(cur as _) as _ }
}
/// The variable holding the libxml strdup() implementation
///
/// Returns the copy of the string or NULL in case of error
#[doc(alias = "xmlMemStrdup")]
pub(in crate::libxml) static mut _XML_MEM_STRDUP: Option<XmlStrdupFunc> = Some(xml_posix_strdup);
pub unsafe extern "C" fn xml_mem_strdup(str: *const XmlChar) -> *mut XmlChar {
    unsafe {
        _XML_MEM_STRDUP.expect("Failed to duplicate xml string : _XML_MEM_STRDUP is None")(str)
    }
}
pub fn set_xml_mem_strdup(mem_strdup: Option<XmlStrdupFunc>) {
    unsafe {
        _XML_MEM_STRDUP = mem_strdup;
        (*xml_get_global_state()).xml_mem_strdup = mem_strdup;
    }
}
