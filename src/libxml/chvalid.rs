//! Provide methods and data structures for handling Unicode characters and strings.  
//! This module is based on `libxml/chvalid.h`, `chvalid.c`, and so on in `libxml2-v2.11.8`.
//!
//! Please refer to original libxml2 documents also.

use std::ops::RangeInclusive;

/*
 * Define our typedefs and structures
 *
 */
pub(crate) type XmlChSRangePtr = *mut XmlChSRange;
pub(crate) struct XmlChSRange {
    pub(crate) range: RangeInclusive<u16>,
}

pub(crate) type XmlChLRangePtr = *mut XmlChLRange;
pub(crate) struct XmlChLRange {
    pub(crate) range: RangeInclusive<u32>,
}

pub(crate) type XmlChRangeGroupPtr = *mut XmlChRangeGroup;
pub struct XmlChRangeGroup {
    pub(crate) short_range: &'static [XmlChSRange], /* points to an array of ranges */
    pub(crate) long_range: &'static [XmlChLRange],
}

/// Check if the character ranges that `rptr` points contain `val`.  
/// Return `true` if so, otherwise return `false`.
///
/// Please refer to the document of `xmlCharInRange` for original libxml2.
pub fn xml_char_in_range(val: u32, rptr: &XmlChRangeGroup) -> bool {
    /* is val in 'short' or 'long'  array? */
    if val < 0x10000 {
        if rptr.short_range.is_empty() {
            return false;
        }
        let sptr = rptr.short_range;
        let (mut low, mut high) = (0, sptr.len());
        while high - low > 1 {
            let mid = (high + low) / 2;
            if val < *sptr[mid].range.start() as u32 {
                high = mid;
            } else if val > *sptr[mid].range.end() as u32 {
                low = mid;
            } else {
                return true;
            }
        }
        sptr[low].range.contains(&(val as u16))
    } else {
        if rptr.long_range.is_empty() {
            return false;
        }
        let lptr = rptr.long_range;
        let (mut low, mut high) = (0, lptr.len());
        while high - low > 1 {
            let mid = (high + low) / 2;
            if val < *lptr[mid].range.start() {
                high = mid;
            } else if val > *lptr[mid].range.end() {
                low = mid;
            } else {
                return true;
            }
        }
        lptr[low].range.contains(&val)
    }
}

/**
 * XmlIsBaseCharCh:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
fn xml_is_base_char_ch(c: u8) -> bool {
    (0x41..=0x5a).contains(&c)
        || (0x61..=0x7a).contains(&c)
        || (0xc0..=0xd6).contains(&c)
        || (0xd8..=0xf6).contains(&c)
        || 0xf8 <= c
}

pub(crate) const XML_IS_BASE_CHAR_GROUP: XmlChRangeGroup = XmlChRangeGroup {
    short_range: XML_IS_BASE_CHAR_SRNG,
    long_range: &[],
};

#[doc(alias = "xmlIsBaseCharQ")]
pub(crate) fn xml_is_base_char(c: u32) -> bool {
    if c < 0x100 {
        xml_is_base_char_ch(c as u8)
    } else {
        xml_char_in_range(c, &XML_IS_BASE_CHAR_GROUP)
    }
}

const XML_IS_CHAR_SRNG: &[XmlChSRange] = &[
    XmlChSRange {
        range: 0x100..=0xd7ff,
    },
    XmlChSRange {
        range: 0xe000..=0xfffd,
    },
];
const XML_IS_CHAR_LRNG: &[XmlChLRange] = &[XmlChLRange {
    range: 0x10000..=0x10ffff,
}];

#[doc(alias = "XmlIsBlankCh")]
fn xml_is_blank_ch(c: u8) -> bool {
    c == 0x20 || (0x9..=0xa).contains(&c) || c == 0xd
}

#[doc(alias = "xmlIsBlankQ")]
pub(crate) fn xml_is_blank_char(c: u32) -> bool {
    c < 0x100 && xml_is_blank_ch(c as u8)
}

/**
 * xml_is_char_ch:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#[macro_export]
macro_rules! xml_is_char_ch {
    ( $c:expr ) => {
        (0x9..=0xa).contains(&$c) || $c == 0xd || 0x20 <= $c
    };
}

/**
 * xmlIsCharQ:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#[macro_export]
macro_rules! xml_is_char_q {
    ( $c:expr ) => {
        if $c < 0x100 {
            $crate::xml_is_char_ch!($c)
        } else {
            (0x100..=0xd7ff).contains(&$c)
                || (0xe000..=0xfffd).contains(&$c)
                || (0x10000..=0x10ffff).contains(&$c)
        }
    };
}

pub(crate) const XML_IS_CHAR_GROUP: XmlChRangeGroup = XmlChRangeGroup {
    short_range: XML_IS_CHAR_SRNG,
    long_range: XML_IS_CHAR_LRNG,
};

/**
 * xmlIsCombiningQ:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#[macro_export]
macro_rules! xml_is_combining_q {
    ( $c:expr ) => {
        if $c < 0x100 {
            false
        } else {
            $crate::libxml::chvalid::xml_char_in_range(
                $c,
                &$crate::libxml::chvalid::XML_IS_COMBINING_GROUP,
            )
        }
    };
}

const XML_IS_COMBINING_SRNG: &[XmlChSRange] = &[
    XmlChSRange {
        range: 0x300..=0x345,
    },
    XmlChSRange {
        range: 0x360..=0x361,
    },
    XmlChSRange {
        range: 0x483..=0x486,
    },
    XmlChSRange {
        range: 0x591..=0x5a1,
    },
    XmlChSRange {
        range: 0x5a3..=0x5b9,
    },
    XmlChSRange {
        range: 0x5bb..=0x5bd,
    },
    XmlChSRange {
        range: 0x5bf..=0x5bf,
    },
    XmlChSRange {
        range: 0x5c1..=0x5c2,
    },
    XmlChSRange {
        range: 0x5c4..=0x5c4,
    },
    XmlChSRange {
        range: 0x64b..=0x652,
    },
    XmlChSRange {
        range: 0x670..=0x670,
    },
    XmlChSRange {
        range: 0x6d6..=0x6dc,
    },
    XmlChSRange {
        range: 0x6dd..=0x6df,
    },
    XmlChSRange {
        range: 0x6e0..=0x6e4,
    },
    XmlChSRange {
        range: 0x6e7..=0x6e8,
    },
    XmlChSRange {
        range: 0x6ea..=0x6ed,
    },
    XmlChSRange {
        range: 0x901..=0x903,
    },
    XmlChSRange {
        range: 0x93c..=0x93c,
    },
    XmlChSRange {
        range: 0x93e..=0x94c,
    },
    XmlChSRange {
        range: 0x94d..=0x94d,
    },
    XmlChSRange {
        range: 0x951..=0x954,
    },
    XmlChSRange {
        range: 0x962..=0x963,
    },
    XmlChSRange {
        range: 0x981..=0x983,
    },
    XmlChSRange {
        range: 0x9bc..=0x9bc,
    },
    XmlChSRange {
        range: 0x9be..=0x9be,
    },
    XmlChSRange {
        range: 0x9bf..=0x9bf,
    },
    XmlChSRange {
        range: 0x9c0..=0x9c4,
    },
    XmlChSRange {
        range: 0x9c7..=0x9c8,
    },
    XmlChSRange {
        range: 0x9cb..=0x9cd,
    },
    XmlChSRange {
        range: 0x9d7..=0x9d7,
    },
    XmlChSRange {
        range: 0x9e2..=0x9e3,
    },
    XmlChSRange {
        range: 0xa02..=0xa02,
    },
    XmlChSRange {
        range: 0xa3c..=0xa3c,
    },
    XmlChSRange {
        range: 0xa3e..=0xa3e,
    },
    XmlChSRange {
        range: 0xa3f..=0xa3f,
    },
    XmlChSRange {
        range: 0xa40..=0xa42,
    },
    XmlChSRange {
        range: 0xa47..=0xa48,
    },
    XmlChSRange {
        range: 0xa4b..=0xa4d,
    },
    XmlChSRange {
        range: 0xa70..=0xa71,
    },
    XmlChSRange {
        range: 0xa81..=0xa83,
    },
    XmlChSRange {
        range: 0xabc..=0xabc,
    },
    XmlChSRange {
        range: 0xabe..=0xac5,
    },
    XmlChSRange {
        range: 0xac7..=0xac9,
    },
    XmlChSRange {
        range: 0xacb..=0xacd,
    },
    XmlChSRange {
        range: 0xb01..=0xb03,
    },
    XmlChSRange {
        range: 0xb3c..=0xb3c,
    },
    XmlChSRange {
        range: 0xb3e..=0xb43,
    },
    XmlChSRange {
        range: 0xb47..=0xb48,
    },
    XmlChSRange {
        range: 0xb4b..=0xb4d,
    },
    XmlChSRange {
        range: 0xb56..=0xb57,
    },
    XmlChSRange {
        range: 0xb82..=0xb83,
    },
    XmlChSRange {
        range: 0xbbe..=0xbc2,
    },
    XmlChSRange {
        range: 0xbc6..=0xbc8,
    },
    XmlChSRange {
        range: 0xbca..=0xbcd,
    },
    XmlChSRange {
        range: 0xbd7..=0xbd7,
    },
    XmlChSRange {
        range: 0xc01..=0xc03,
    },
    XmlChSRange {
        range: 0xc3e..=0xc44,
    },
    XmlChSRange {
        range: 0xc46..=0xc48,
    },
    XmlChSRange {
        range: 0xc4a..=0xc4d,
    },
    XmlChSRange {
        range: 0xc55..=0xc56,
    },
    XmlChSRange {
        range: 0xc82..=0xc83,
    },
    XmlChSRange {
        range: 0xcbe..=0xcc4,
    },
    XmlChSRange {
        range: 0xcc6..=0xcc8,
    },
    XmlChSRange {
        range: 0xcca..=0xccd,
    },
    XmlChSRange {
        range: 0xcd5..=0xcd6,
    },
    XmlChSRange {
        range: 0xd02..=0xd03,
    },
    XmlChSRange {
        range: 0xd3e..=0xd43,
    },
    XmlChSRange {
        range: 0xd46..=0xd48,
    },
    XmlChSRange {
        range: 0xd4a..=0xd4d,
    },
    XmlChSRange {
        range: 0xd57..=0xd57,
    },
    XmlChSRange {
        range: 0xe31..=0xe31,
    },
    XmlChSRange {
        range: 0xe34..=0xe3a,
    },
    XmlChSRange {
        range: 0xe47..=0xe4e,
    },
    XmlChSRange {
        range: 0xeb1..=0xeb1,
    },
    XmlChSRange {
        range: 0xeb4..=0xeb9,
    },
    XmlChSRange {
        range: 0xebb..=0xebc,
    },
    XmlChSRange {
        range: 0xec8..=0xecd,
    },
    XmlChSRange {
        range: 0xf18..=0xf19,
    },
    XmlChSRange {
        range: 0xf35..=0xf35,
    },
    XmlChSRange {
        range: 0xf37..=0xf37,
    },
    XmlChSRange {
        range: 0xf39..=0xf39,
    },
    XmlChSRange {
        range: 0xf3e..=0xf3e,
    },
    XmlChSRange {
        range: 0xf3f..=0xf3f,
    },
    XmlChSRange {
        range: 0xf71..=0xf84,
    },
    XmlChSRange {
        range: 0xf86..=0xf8b,
    },
    XmlChSRange {
        range: 0xf90..=0xf95,
    },
    XmlChSRange {
        range: 0xf97..=0xf97,
    },
    XmlChSRange {
        range: 0xf99..=0xfad,
    },
    XmlChSRange {
        range: 0xfb1..=0xfb7,
    },
    XmlChSRange {
        range: 0xfb9..=0xfb9,
    },
    XmlChSRange {
        range: 0x20d0..=0x20dc,
    },
    XmlChSRange {
        range: 0x20e1..=0x20e1,
    },
    XmlChSRange {
        range: 0x302a..=0x302f,
    },
    XmlChSRange {
        range: 0x3099..=0x3099,
    },
    XmlChSRange {
        range: 0x309a..=0x309a,
    },
];

pub(crate) const XML_IS_COMBINING_GROUP: XmlChRangeGroup = XmlChRangeGroup {
    short_range: XML_IS_COMBINING_SRNG,
    long_range: &[],
};

/**
 * xmlIsDigit_ch:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#[macro_export]
macro_rules! xml_is_digit_ch {
    ( $c:expr ) => {
        (0x30..=0x39).contains(&$c)
    };
}

/**
 * xmlIsDigitQ:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#[macro_export]
macro_rules! xml_is_digit_q {
    ( $c:expr ) => {
        if $c < 0x100 {
            $crate::xml_is_digit_ch!($c)
        } else {
            $crate::libxml::chvalid::xml_char_in_range(
                $c,
                &$crate::libxml::chvalid::XML_IS_DIGIT_GROUP as _,
            )
        }
    };
}

const XML_IS_DIGIT_SRNG: &[XmlChSRange] = &[
    XmlChSRange {
        range: 0x660..=0x669,
    },
    XmlChSRange {
        range: 0x6f0..=0x6f9,
    },
    XmlChSRange {
        range: 0x966..=0x96f,
    },
    XmlChSRange {
        range: 0x9e6..=0x9ef,
    },
    XmlChSRange {
        range: 0xa66..=0xa6f,
    },
    XmlChSRange {
        range: 0xae6..=0xaef,
    },
    XmlChSRange {
        range: 0xb66..=0xb6f,
    },
    XmlChSRange {
        range: 0xbe7..=0xbef,
    },
    XmlChSRange {
        range: 0xc66..=0xc6f,
    },
    XmlChSRange {
        range: 0xce6..=0xcef,
    },
    XmlChSRange {
        range: 0xd66..=0xd6f,
    },
    XmlChSRange {
        range: 0xe50..=0xe59,
    },
    XmlChSRange {
        range: 0xed0..=0xed9,
    },
    XmlChSRange {
        range: 0xf20..=0xf29,
    },
];
pub(crate) const XML_IS_DIGIT_GROUP: XmlChRangeGroup = XmlChRangeGroup {
    short_range: XML_IS_DIGIT_SRNG,
    long_range: &[],
};

/**
 * xmlIsExtender_ch:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#[macro_export]
macro_rules! xml_is_extender_ch {
    ( $c:expr ) => {
        $c == 0xb7
    };
}

/**
 * xmlIsExtenderQ:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#[macro_export]
macro_rules! xml_is_extender_q {
    ( $c:expr ) => {
        if $c < 0x100 {
            $crate::xml_is_extender_ch!($c)
        } else {
            $crate::libxml::chvalid::xml_char_in_range(
                $c,
                &$crate::libxml::chvalid::XML_IS_EXTENDER_GROUP,
            )
        }
    };
}

const XML_IS_EXTENDER_SRNG: &[XmlChSRange] = &[
    XmlChSRange {
        range: 0x2d0..=0x2d0,
    },
    XmlChSRange {
        range: 0x2d1..=0x2d1,
    },
    XmlChSRange {
        range: 0x387..=0x387,
    },
    XmlChSRange {
        range: 0x640..=0x640,
    },
    XmlChSRange {
        range: 0xe46..=0xe46,
    },
    XmlChSRange {
        range: 0xec6..=0xec6,
    },
    XmlChSRange {
        range: 0x3005..=0x3005,
    },
    XmlChSRange {
        range: 0x3031..=0x3035,
    },
    XmlChSRange {
        range: 0x309d..=0x309e,
    },
    XmlChSRange {
        range: 0x30fc..=0x30fe,
    },
];
pub(crate) const XML_IS_EXTENDER_GROUP: XmlChRangeGroup = XmlChRangeGroup {
    short_range: XML_IS_EXTENDER_SRNG,
    long_range: &[],
};

/**
 * xmlIsIdeographicQ:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#[macro_export]
macro_rules! xml_is_ideographic_q {
    ( $c:expr ) => {
        if $c < 0x100 {
            false
        } else {
            (0x4e00..=0x9fa5).contains(&$c) || $c == 0x3007 || (0x3021..=0x3029).contains(&$c)
        }
    };
}

const XML_IS_IDEOGRAPHIC_SRNG: &[XmlChSRange] = &[
    XmlChSRange {
        range: 0x3007..=0x3007,
    },
    XmlChSRange {
        range: 0x3021..=0x3029,
    },
    XmlChSRange {
        range: 0x4e00..=0x9fa5,
    },
];
pub(crate) const XML_IS_IDEOGRAPHIC_GROUP: XmlChRangeGroup = XmlChRangeGroup {
    short_range: XML_IS_IDEOGRAPHIC_SRNG,
    long_range: &[],
};

pub const XML_IS_PUBID_CHAR_TAB: [bool; 256] = [
    false, false, false, false, false, false, false, false, false, false, true, false, false, true,
    false, false, false, false, false, false, false, false, false, false, false, false, false,
    false, false, false, false, false, true, true, false, true, true, true, false, true, true,
    true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true,
    true, true, true, false, true, false, true, true, true, true, true, true, true, true, true,
    true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true,
    true, true, true, false, false, false, false, true, false, true, true, true, true, true, true,
    true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true,
    true, true, true, true, false, false, false, false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false, false, false, false, false, false,
    false, false, false, false, false, false, false, false, false, false, false, false, false,
    false, false, false, false, false, false,
];

const XML_IS_BASE_CHAR_SRNG: &[XmlChSRange] = &[
    XmlChSRange {
        range: 0x100..=0x131,
    },
    XmlChSRange {
        range: 0x134..=0x13e,
    },
    XmlChSRange {
        range: 0x141..=0x148,
    },
    XmlChSRange {
        range: 0x14a..=0x17e,
    },
    XmlChSRange {
        range: 0x180..=0x1c3,
    },
    XmlChSRange {
        range: 0x1cd..=0x1f0,
    },
    XmlChSRange {
        range: 0x1f4..=0x1f5,
    },
    XmlChSRange {
        range: 0x1fa..=0x217,
    },
    XmlChSRange {
        range: 0x250..=0x2a8,
    },
    XmlChSRange {
        range: 0x2bb..=0x2c1,
    },
    XmlChSRange {
        range: 0x386..=0x386,
    },
    XmlChSRange {
        range: 0x388..=0x38a,
    },
    XmlChSRange {
        range: 0x38c..=0x38c,
    },
    XmlChSRange {
        range: 0x38e..=0x3a1,
    },
    XmlChSRange {
        range: 0x3a3..=0x3ce,
    },
    XmlChSRange {
        range: 0x3d0..=0x3d6,
    },
    XmlChSRange {
        range: 0x3da..=0x3da,
    },
    XmlChSRange {
        range: 0x3dc..=0x3dc,
    },
    XmlChSRange {
        range: 0x3de..=0x3de,
    },
    XmlChSRange {
        range: 0x3e0..=0x3e0,
    },
    XmlChSRange {
        range: 0x3e2..=0x3f3,
    },
    XmlChSRange {
        range: 0x401..=0x40c,
    },
    XmlChSRange {
        range: 0x40e..=0x44f,
    },
    XmlChSRange {
        range: 0x451..=0x45c,
    },
    XmlChSRange {
        range: 0x45e..=0x481,
    },
    XmlChSRange {
        range: 0x490..=0x4c4,
    },
    XmlChSRange {
        range: 0x4c7..=0x4c8,
    },
    XmlChSRange {
        range: 0x4cb..=0x4cc,
    },
    XmlChSRange {
        range: 0x4d0..=0x4eb,
    },
    XmlChSRange {
        range: 0x4ee..=0x4f5,
    },
    XmlChSRange {
        range: 0x4f8..=0x4f9,
    },
    XmlChSRange {
        range: 0x531..=0x556,
    },
    XmlChSRange {
        range: 0x559..=0x559,
    },
    XmlChSRange {
        range: 0x561..=0x586,
    },
    XmlChSRange {
        range: 0x5d0..=0x5ea,
    },
    XmlChSRange {
        range: 0x5f0..=0x5f2,
    },
    XmlChSRange {
        range: 0x621..=0x63a,
    },
    XmlChSRange {
        range: 0x641..=0x64a,
    },
    XmlChSRange {
        range: 0x671..=0x6b7,
    },
    XmlChSRange {
        range: 0x6ba..=0x6be,
    },
    XmlChSRange {
        range: 0x6c0..=0x6ce,
    },
    XmlChSRange {
        range: 0x6d0..=0x6d3,
    },
    XmlChSRange {
        range: 0x6d5..=0x6d5,
    },
    XmlChSRange {
        range: 0x6e5..=0x6e6,
    },
    XmlChSRange {
        range: 0x905..=0x939,
    },
    XmlChSRange {
        range: 0x93d..=0x93d,
    },
    XmlChSRange {
        range: 0x958..=0x961,
    },
    XmlChSRange {
        range: 0x985..=0x98c,
    },
    XmlChSRange {
        range: 0x98f..=0x990,
    },
    XmlChSRange {
        range: 0x993..=0x9a8,
    },
    XmlChSRange {
        range: 0x9aa..=0x9b0,
    },
    XmlChSRange {
        range: 0x9b2..=0x9b2,
    },
    XmlChSRange {
        range: 0x9b6..=0x9b9,
    },
    XmlChSRange {
        range: 0x9dc..=0x9dd,
    },
    XmlChSRange {
        range: 0x9df..=0x9e1,
    },
    XmlChSRange {
        range: 0x9f0..=0x9f1,
    },
    XmlChSRange {
        range: 0xa05..=0xa0a,
    },
    XmlChSRange {
        range: 0xa0f..=0xa10,
    },
    XmlChSRange {
        range: 0xa13..=0xa28,
    },
    XmlChSRange {
        range: 0xa2a..=0xa30,
    },
    XmlChSRange {
        range: 0xa32..=0xa33,
    },
    XmlChSRange {
        range: 0xa35..=0xa36,
    },
    XmlChSRange {
        range: 0xa38..=0xa39,
    },
    XmlChSRange {
        range: 0xa59..=0xa5c,
    },
    XmlChSRange {
        range: 0xa5e..=0xa5e,
    },
    XmlChSRange {
        range: 0xa72..=0xa74,
    },
    XmlChSRange {
        range: 0xa85..=0xa8b,
    },
    XmlChSRange {
        range: 0xa8d..=0xa8d,
    },
    XmlChSRange {
        range: 0xa8f..=0xa91,
    },
    XmlChSRange {
        range: 0xa93..=0xaa8,
    },
    XmlChSRange {
        range: 0xaaa..=0xab0,
    },
    XmlChSRange {
        range: 0xab2..=0xab3,
    },
    XmlChSRange {
        range: 0xab5..=0xab9,
    },
    XmlChSRange {
        range: 0xabd..=0xabd,
    },
    XmlChSRange {
        range: 0xae0..=0xae0,
    },
    XmlChSRange {
        range: 0xb05..=0xb0c,
    },
    XmlChSRange {
        range: 0xb0f..=0xb10,
    },
    XmlChSRange {
        range: 0xb13..=0xb28,
    },
    XmlChSRange {
        range: 0xb2a..=0xb30,
    },
    XmlChSRange {
        range: 0xb32..=0xb33,
    },
    XmlChSRange {
        range: 0xb36..=0xb39,
    },
    XmlChSRange {
        range: 0xb3d..=0xb3d,
    },
    XmlChSRange {
        range: 0xb5c..=0xb5d,
    },
    XmlChSRange {
        range: 0xb5f..=0xb61,
    },
    XmlChSRange {
        range: 0xb85..=0xb8a,
    },
    XmlChSRange {
        range: 0xb8e..=0xb90,
    },
    XmlChSRange {
        range: 0xb92..=0xb95,
    },
    XmlChSRange {
        range: 0xb99..=0xb9a,
    },
    XmlChSRange {
        range: 0xb9c..=0xb9c,
    },
    XmlChSRange {
        range: 0xb9e..=0xb9f,
    },
    XmlChSRange {
        range: 0xba3..=0xba4,
    },
    XmlChSRange {
        range: 0xba8..=0xbaa,
    },
    XmlChSRange {
        range: 0xbae..=0xbb5,
    },
    XmlChSRange {
        range: 0xbb7..=0xbb9,
    },
    XmlChSRange {
        range: 0xc05..=0xc0c,
    },
    XmlChSRange {
        range: 0xc0e..=0xc10,
    },
    XmlChSRange {
        range: 0xc12..=0xc28,
    },
    XmlChSRange {
        range: 0xc2a..=0xc33,
    },
    XmlChSRange {
        range: 0xc35..=0xc39,
    },
    XmlChSRange {
        range: 0xc60..=0xc61,
    },
    XmlChSRange {
        range: 0xc85..=0xc8c,
    },
    XmlChSRange {
        range: 0xc8e..=0xc90,
    },
    XmlChSRange {
        range: 0xc92..=0xca8,
    },
    XmlChSRange {
        range: 0xcaa..=0xcb3,
    },
    XmlChSRange {
        range: 0xcb5..=0xcb9,
    },
    XmlChSRange {
        range: 0xcde..=0xcde,
    },
    XmlChSRange {
        range: 0xce0..=0xce1,
    },
    XmlChSRange {
        range: 0xd05..=0xd0c,
    },
    XmlChSRange {
        range: 0xd0e..=0xd10,
    },
    XmlChSRange {
        range: 0xd12..=0xd28,
    },
    XmlChSRange {
        range: 0xd2a..=0xd39,
    },
    XmlChSRange {
        range: 0xd60..=0xd61,
    },
    XmlChSRange {
        range: 0xe01..=0xe2e,
    },
    XmlChSRange {
        range: 0xe30..=0xe30,
    },
    XmlChSRange {
        range: 0xe32..=0xe33,
    },
    XmlChSRange {
        range: 0xe40..=0xe45,
    },
    XmlChSRange {
        range: 0xe81..=0xe82,
    },
    XmlChSRange {
        range: 0xe84..=0xe84,
    },
    XmlChSRange {
        range: 0xe87..=0xe88,
    },
    XmlChSRange {
        range: 0xe8a..=0xe8a,
    },
    XmlChSRange {
        range: 0xe8d..=0xe8d,
    },
    XmlChSRange {
        range: 0xe94..=0xe97,
    },
    XmlChSRange {
        range: 0xe99..=0xe9f,
    },
    XmlChSRange {
        range: 0xea1..=0xea3,
    },
    XmlChSRange {
        range: 0xea5..=0xea5,
    },
    XmlChSRange {
        range: 0xea7..=0xea7,
    },
    XmlChSRange {
        range: 0xeaa..=0xeab,
    },
    XmlChSRange {
        range: 0xead..=0xeae,
    },
    XmlChSRange {
        range: 0xeb0..=0xeb0,
    },
    XmlChSRange {
        range: 0xeb2..=0xeb3,
    },
    XmlChSRange {
        range: 0xebd..=0xebd,
    },
    XmlChSRange {
        range: 0xec0..=0xec4,
    },
    XmlChSRange {
        range: 0xf40..=0xf47,
    },
    XmlChSRange {
        range: 0xf49..=0xf69,
    },
    XmlChSRange {
        range: 0x10a0..=0x10c5,
    },
    XmlChSRange {
        range: 0x10d0..=0x10f6,
    },
    XmlChSRange {
        range: 0x1100..=0x1100,
    },
    XmlChSRange {
        range: 0x1102..=0x1103,
    },
    XmlChSRange {
        range: 0x1105..=0x1107,
    },
    XmlChSRange {
        range: 0x1109..=0x1109,
    },
    XmlChSRange {
        range: 0x110b..=0x110c,
    },
    XmlChSRange {
        range: 0x110e..=0x1112,
    },
    XmlChSRange {
        range: 0x113c..=0x113c,
    },
    XmlChSRange {
        range: 0x113e..=0x113e,
    },
    XmlChSRange {
        range: 0x1140..=0x1140,
    },
    XmlChSRange {
        range: 0x114c..=0x114c,
    },
    XmlChSRange {
        range: 0x114e..=0x114e,
    },
    XmlChSRange {
        range: 0x1150..=0x1150,
    },
    XmlChSRange {
        range: 0x1154..=0x1155,
    },
    XmlChSRange {
        range: 0x1159..=0x1159,
    },
    XmlChSRange {
        range: 0x115f..=0x1161,
    },
    XmlChSRange {
        range: 0x1163..=0x1163,
    },
    XmlChSRange {
        range: 0x1165..=0x1165,
    },
    XmlChSRange {
        range: 0x1167..=0x1167,
    },
    XmlChSRange {
        range: 0x1169..=0x1169,
    },
    XmlChSRange {
        range: 0x116d..=0x116e,
    },
    XmlChSRange {
        range: 0x1172..=0x1173,
    },
    XmlChSRange {
        range: 0x1175..=0x1175,
    },
    XmlChSRange {
        range: 0x119e..=0x119e,
    },
    XmlChSRange {
        range: 0x11a8..=0x11a8,
    },
    XmlChSRange {
        range: 0x11ab..=0x11ab,
    },
    XmlChSRange {
        range: 0x11ae..=0x11af,
    },
    XmlChSRange {
        range: 0x11b7..=0x11b8,
    },
    XmlChSRange {
        range: 0x11ba..=0x11ba,
    },
    XmlChSRange {
        range: 0x11bc..=0x11c2,
    },
    XmlChSRange {
        range: 0x11eb..=0x11eb,
    },
    XmlChSRange {
        range: 0x11f0..=0x11f0,
    },
    XmlChSRange {
        range: 0x11f9..=0x11f9,
    },
    XmlChSRange {
        range: 0x1e00..=0x1e9b,
    },
    XmlChSRange {
        range: 0x1ea0..=0x1ef9,
    },
    XmlChSRange {
        range: 0x1f00..=0x1f15,
    },
    XmlChSRange {
        range: 0x1f18..=0x1f1d,
    },
    XmlChSRange {
        range: 0x1f20..=0x1f45,
    },
    XmlChSRange {
        range: 0x1f48..=0x1f4d,
    },
    XmlChSRange {
        range: 0x1f50..=0x1f57,
    },
    XmlChSRange {
        range: 0x1f59..=0x1f59,
    },
    XmlChSRange {
        range: 0x1f5b..=0x1f5b,
    },
    XmlChSRange {
        range: 0x1f5d..=0x1f5d,
    },
    XmlChSRange {
        range: 0x1f5f..=0x1f7d,
    },
    XmlChSRange {
        range: 0x1f80..=0x1fb4,
    },
    XmlChSRange {
        range: 0x1fb6..=0x1fbc,
    },
    XmlChSRange {
        range: 0x1fbe..=0x1fbe,
    },
    XmlChSRange {
        range: 0x1fc2..=0x1fc4,
    },
    XmlChSRange {
        range: 0x1fc6..=0x1fcc,
    },
    XmlChSRange {
        range: 0x1fd0..=0x1fd3,
    },
    XmlChSRange {
        range: 0x1fd6..=0x1fdb,
    },
    XmlChSRange {
        range: 0x1fe0..=0x1fec,
    },
    XmlChSRange {
        range: 0x1ff2..=0x1ff4,
    },
    XmlChSRange {
        range: 0x1ff6..=0x1ffc,
    },
    XmlChSRange {
        range: 0x2126..=0x2126,
    },
    XmlChSRange {
        range: 0x212a..=0x212b,
    },
    XmlChSRange {
        range: 0x212e..=0x212e,
    },
    XmlChSRange {
        range: 0x2180..=0x2182,
    },
    XmlChSRange {
        range: 0x3041..=0x3094,
    },
    XmlChSRange {
        range: 0x30a1..=0x30fa,
    },
    XmlChSRange {
        range: 0x3105..=0x312c,
    },
    XmlChSRange {
        range: 0xac00..=0xd7a3,
    },
];

/**
 * xmlIsPubidChar_ch:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
#[macro_export]
macro_rules! xml_is_pubid_char_ch {
    ( $c:expr ) => {
        $crate::libxml::chvalid::XML_IS_PUBID_CHAR_TAB[$c as usize]
    };
}

/**
 * xmlIsPubidCharQ:
 * @c: char to validate
 *
 * Automatically generated by genChRanges.py
 */
macro_rules! xml_is_pubid_char_q {
    ( $c:expr ) => {
        if $c < 0x100 {
            xml_is_pubid_char_ch!($c)
        } else {
            false
        }
    };
}

/**
 * xmlIsChar:
 * @ch:  character to validate
 *
 * This function is DEPRECATED.
 * Use xml_is_char_ch or xmlIsCharQ instead
 *
 * Returns true if argument valid, false otherwise
 */
pub fn xml_is_char(ch: u32) -> bool {
    xml_is_char_q!(ch)
}

/**
 * xmlIsCombining:
 * @ch:  character to validate
 *
 * This function is DEPRECATED.
 * Use xmlIsCombiningQ instead
 *
 * Returns true if argument valid, false otherwise
 */
pub fn xml_is_combining(ch: u32) -> bool {
    xml_is_combining_q!(ch)
}

/**
 * xmlIsDigit:
 * @ch:  character to validate
 *
 * This function is DEPRECATED.
 * Use xmlIsDigit_ch or xmlIsDigitQ instead
 *
 * Returns true if argument valid, false otherwise
 */
pub fn xml_is_digit(ch: u32) -> bool {
    xml_is_digit_q!(ch)
}

/**
 * xmlIsExtender:
 * @ch:  character to validate
 *
 * This function is DEPRECATED.
 * Use xmlIsExtender_ch or xmlIsExtenderQ instead
 *
 * Returns true if argument valid, false otherwise
 */
pub fn xml_is_extender(ch: u32) -> bool {
    xml_is_extender_q!(ch)
}

/**
 * xmlIsIdeographic:
 * @ch:  character to validate
 *
 * This function is DEPRECATED.
 * Use xmlIsIdeographicQ instead
 *
 * Returns true if argument valid, false otherwise
 */
pub fn xml_is_ideographic(ch: u32) -> bool {
    xml_is_ideographic_q!(ch)
}

/**
 * xmlIsPubidChar:
 * @ch:  character to validate
 *
 * This function is DEPRECATED.
 * Use xmlIsPubidChar_ch or xmlIsPubidCharQ instead
 *
 * Returns true if argument valid, false otherwise
 */
pub fn xml_is_pubid_char(ch: u32) -> bool {
    xml_is_pubid_char_q!(ch)
}

#[cfg(test)]
mod tests {
    use crate::{globals::reset_last_error, libxml::xmlmemory::xml_mem_blocks, test_util::*};

    use super::*;

    #[test]
    fn test_xml_is_blank() {
        let mut leaks = 0;

        unsafe {
            for n_ch in 0..GEN_NB_UNSIGNED_INT {
                let mem_base = xml_mem_blocks();
                let ch = gen_unsigned_int(n_ch, 0);

                let ret_val = xml_is_blank_char(ch) as i32;
                desret_int(ret_val);
                des_unsigned_int(n_ch, ch, 0);
                reset_last_error();
                if mem_base != xml_mem_blocks() {
                    leaks += 1;
                    eprint!(
                        "Leak of {} blocks found in xmlIsBlank",
                        xml_mem_blocks() - mem_base
                    );
                    eprintln!(" {}", n_ch);
                }
            }
            assert!(leaks == 0, "{leaks} Leaks are found in xmlIsBlank()");
        }
    }

    #[test]
    fn test_xml_is_char() {
        let mut leaks = 0;

        unsafe {
            for n_ch in 0..GEN_NB_UNSIGNED_INT {
                let mem_base = xml_mem_blocks();
                let ch = gen_unsigned_int(n_ch, 0);

                let ret_val = xml_is_char(ch) as i32;
                desret_int(ret_val);
                des_unsigned_int(n_ch, ch, 0);
                reset_last_error();
                if mem_base != xml_mem_blocks() {
                    leaks += 1;
                    eprint!(
                        "Leak of {} blocks found in xmlIsChar",
                        xml_mem_blocks() - mem_base
                    );
                    eprintln!(" {}", n_ch);
                }
            }
            assert!(leaks == 0, "{leaks} Leaks are found in xmlIsChar()");
        }
    }

    #[test]
    fn test_xml_is_combining() {
        let mut leaks = 0;

        unsafe {
            for n_ch in 0..GEN_NB_UNSIGNED_INT {
                let mem_base = xml_mem_blocks();
                let ch = gen_unsigned_int(n_ch, 0);

                let ret_val = xml_is_combining(ch) as i32;
                desret_int(ret_val);
                des_unsigned_int(n_ch, ch, 0);
                reset_last_error();
                if mem_base != xml_mem_blocks() {
                    leaks += 1;
                    eprint!(
                        "Leak of {} blocks found in xmlIsCombining",
                        xml_mem_blocks() - mem_base
                    );
                    eprintln!(" {}", n_ch);
                }
            }
            assert!(leaks == 0, "{leaks} Leaks are found in xmlIsCombining()");
        }
    }

    #[test]
    fn test_xml_is_digit() {
        let mut leaks = 0;

        unsafe {
            for n_ch in 0..GEN_NB_UNSIGNED_INT {
                let mem_base = xml_mem_blocks();
                let ch = gen_unsigned_int(n_ch, 0);

                let ret_val = xml_is_digit(ch) as i32;
                desret_int(ret_val);
                des_unsigned_int(n_ch, ch, 0);
                reset_last_error();
                if mem_base != xml_mem_blocks() {
                    leaks += 1;
                    eprint!(
                        "Leak of {} blocks found in xmlIsDigit",
                        xml_mem_blocks() - mem_base
                    );
                    eprintln!(" {}", n_ch);
                }
            }
            assert!(leaks == 0, "{leaks} Leaks are found in xmlIsDigit()");
        }
    }

    #[test]
    fn test_xml_is_extender() {
        let mut leaks = 0;

        unsafe {
            for n_ch in 0..GEN_NB_UNSIGNED_INT {
                let mem_base = xml_mem_blocks();
                let ch = gen_unsigned_int(n_ch, 0);

                let ret_val = xml_is_extender(ch) as i32;
                desret_int(ret_val);
                des_unsigned_int(n_ch, ch, 0);
                reset_last_error();
                if mem_base != xml_mem_blocks() {
                    leaks += 1;
                    eprint!(
                        "Leak of {} blocks found in xmlIsExtender",
                        xml_mem_blocks() - mem_base
                    );
                    eprintln!(" {}", n_ch);
                }
            }
            assert!(leaks == 0, "{leaks} Leaks are found in xmlIsExtender()");
        }
    }

    #[test]
    fn test_xml_is_ideographic() {
        let mut leaks = 0;

        unsafe {
            for n_ch in 0..GEN_NB_UNSIGNED_INT {
                let mem_base = xml_mem_blocks();
                let ch = gen_unsigned_int(n_ch, 0);

                let ret_val = xml_is_ideographic(ch) as i32;
                desret_int(ret_val);
                des_unsigned_int(n_ch, ch, 0);
                reset_last_error();
                if mem_base != xml_mem_blocks() {
                    leaks += 1;
                    eprint!(
                        "Leak of {} blocks found in xmlIsIdeographic",
                        xml_mem_blocks() - mem_base
                    );
                    eprintln!(" {}", n_ch);
                }
            }
            assert!(leaks == 0, "{leaks} Leaks are found in xmlIsIdeographic()");
        }
    }

    #[test]
    fn test_xml_is_pubid_char() {
        let mut leaks = 0;

        unsafe {
            for n_ch in 0..GEN_NB_UNSIGNED_INT {
                let mem_base = xml_mem_blocks();
                let ch = gen_unsigned_int(n_ch, 0);

                let ret_val = xml_is_pubid_char(ch) as i32;
                desret_int(ret_val);
                des_unsigned_int(n_ch, ch, 0);
                reset_last_error();
                if mem_base != xml_mem_blocks() {
                    leaks += 1;
                    eprint!(
                        "Leak of {} blocks found in xmlIsPubidChar",
                        xml_mem_blocks() - mem_base
                    );
                    eprintln!(" {}", n_ch);
                }
            }
            assert!(leaks == 0, "{leaks} Leaks are found in xmlIsPubidChar()");
        }
    }
}
